exports.builtins = {
  _http_agent: function (e, t, o, s, n, i) {
    "use strict";
    const {
        ArrayPrototypeIncludes: r,
        ArrayPrototypeIndexOf: c,
        ArrayPrototypePop: l,
        ArrayPrototypePush: a,
        ArrayPrototypeShift: h,
        ArrayPrototypeSome: k,
        ArrayPrototypeSplice: u,
        FunctionPrototypeCall: p,
        ObjectCreate: f,
        ObjectKeys: m,
        ObjectSetPrototypeOf: g,
        ObjectValues: S,
        StringPrototypeIndexOf: y,
        StringPrototypeSplit: d,
        StringPrototypeStartsWith: v,
        StringPrototypeSubstr: A,
        Symbol: R,
      } = i,
      _ = t("net"),
      b = t("events");
    let P = t("internal/util/debuglog").debuglog("http", (e) => {
      P = e;
    });
    const { AsyncResource: q } = t("async_hooks"),
      { async_id_symbol: C } = t("internal/async_hooks").symbols,
      { kEmptyObject: x, once: T } = t("internal/util"),
      {
        validateNumber: L,
        validateOneOf: E,
        validateString: N,
      } = t("internal/validators"),
      O = R("onkeylog"),
      w = R("requestOptions"),
      I = R("requestAsyncResource");
    class ReusedHandle {
      constructor(e, t) {
        (this.type = e), (this.handle = t);
      }
    }
    function freeSocketErrorListener(e) {
      P("SOCKET ERROR on FREE socket:", e.message, e.stack),
        this.destroy(),
        this.emit("agentRemove");
    }
    function Agent(e) {
      if (!(this instanceof Agent)) return new Agent(e);
      p(b, this),
        (this.defaultPort = 80),
        (this.protocol = "http:"),
        (this.options = { __proto__: null, ...e }),
        void 0 === this.options.noDelay && (this.options.noDelay = !0),
        (this.options.path = null),
        (this.requests = f(null)),
        (this.sockets = f(null)),
        (this.freeSockets = f(null)),
        (this.keepAliveMsecs = this.options.keepAliveMsecs || 1e3),
        (this.keepAlive = this.options.keepAlive || !1),
        (this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets),
        (this.maxFreeSockets = this.options.maxFreeSockets || 256),
        (this.scheduling = this.options.scheduling || "lifo"),
        (this.maxTotalSockets = this.options.maxTotalSockets),
        (this.totalSocketCount = 0),
        E(this.scheduling, "scheduling", ["fifo", "lifo"]),
        void 0 !== this.maxTotalSockets
          ? L(this.maxTotalSockets, "maxTotalSockets", 1)
          : (this.maxTotalSockets = 1 / 0),
        this.on("free", (e, t) => {
          const o = this.getName(t);
          if ((P("agent.on(free)", o), !e.writable)) return void e.destroy();
          const s = this.requests[o];
          if (s && s.length) {
            const t = h(s),
              n = t[I];
            return (
              n
                ? (n.runInAsyncScope(() => {
                    asyncResetHandle(e), setRequestSocket(this, t, e);
                  }),
                  (t[I] = null))
                : setRequestSocket(this, t, e),
              void (0 === s.length && delete this.requests[o])
            );
          }
          const n = e._httpMessage;
          if (!n || !n.shouldKeepAlive || !this.keepAlive)
            return void e.destroy();
          const i = this.freeSockets[o] || [],
            r = i.length;
          let c = r;
          this.sockets[o] && (c += this.sockets[o].length),
            this.totalSocketCount > this.maxTotalSockets ||
            c > this.maxSockets ||
            r >= this.maxFreeSockets ||
            !this.keepSocketAlive(e)
              ? e.destroy()
              : ((this.freeSockets[o] = i),
                (e[C] = -1),
                (e._httpMessage = null),
                this.removeSocket(e, t),
                e.once("error", freeSocketErrorListener),
                a(i, e));
        }),
        this.on("newListener", maybeEnableKeylog);
    }
    function maybeEnableKeylog(e) {
      if ("keylog" === e) {
        this.removeListener("newListener", maybeEnableKeylog);
        const e = this;
        this[O] = function onkeylog(t) {
          e.emit("keylog", t, this);
        };
        const t = S(this.sockets);
        for (let e = 0; e < t.length; e++) t[e].on("keylog", this[O]);
      }
    }
    function calculateServerName(e, t) {
      let o = e.host;
      const s = t.getHeader("host");
      if (s)
        if ((N(s, "options.headers.host"), v(s, "["))) {
          const e = y(s, "]");
          o = -1 === e ? s : A(s, 1, e - 1);
        } else o = d(s, ":", 1)[0];
      return _.isIP(o) && (o = ""), o;
    }
    function setRequestSocket(e, t, o) {
      t.onSocket(o);
      const s = e.options.timeout || 0;
      void 0 !== t.timeout && t.timeout !== s && o.setTimeout(t.timeout);
    }
    function asyncResetHandle(e) {
      const t = e._handle;
      t &&
        "function" == typeof t.asyncReset &&
        (t.asyncReset(new ReusedHandle(t.getProviderType(), t)),
        (e[C] = t.getAsyncId()));
    }
    g(Agent.prototype, b.prototype),
      g(Agent, b),
      (Agent.defaultMaxSockets = 1 / 0),
      (Agent.prototype.createConnection = _.createConnection),
      (Agent.prototype.getName = function getName(e = x) {
        let t = e.host || "localhost";
        return (
          (t += ":"),
          e.port && (t += e.port),
          (t += ":"),
          e.localAddress && (t += e.localAddress),
          (4 !== e.family && 6 !== e.family) || (t += `:${e.family}`),
          e.socketPath && (t += `:${e.socketPath}`),
          t
        );
      }),
      (Agent.prototype.addRequest = function addRequest(e, t, o, s) {
        "string" == typeof t &&
          (t = { __proto__: null, host: t, port: o, localAddress: s }),
          (t = { __proto__: null, ...t, ...this.options }).socketPath &&
            (t.path = t.socketPath),
          t.servername ||
            "" === t.servername ||
            (t.servername = calculateServerName(t, e));
        const n = this.getName(t);
        this.sockets[n] || (this.sockets[n] = []);
        const i = this.freeSockets[n];
        let r;
        if (i) {
          for (; i.length && i[0].destroyed; ) h(i);
          (r = "fifo" === this.scheduling ? h(i) : l(i)),
            i.length || delete this.freeSockets[n];
        }
        const c = i ? i.length : 0,
          k = c + this.sockets[n].length;
        r
          ? (asyncResetHandle(r),
            this.reuseSocket(r, e),
            setRequestSocket(this, e, r),
            a(this.sockets[n], r))
          : k < this.maxSockets && this.totalSocketCount < this.maxTotalSockets
          ? (P("call onSocket", k, c),
            this.createSocket(e, t, (t, o) => {
              t ? e.onSocket(o, t) : setRequestSocket(this, e, o);
            }))
          : (P("wait for socket"),
            this.requests[n] || (this.requests[n] = []),
            (e[w] = t),
            (e[I] = new q("QueuedRequest")),
            a(this.requests[n], e));
      }),
      (Agent.prototype.createSocket = function createSocket(e, t, o) {
        (t = { __proto__: null, ...t, ...this.options }).socketPath &&
          (t.path = t.socketPath),
          t.servername ||
            "" === t.servername ||
            (t.servername = calculateServerName(t, e));
        const s = this.getName(t);
        (t._agentKey = s), P("createConnection", s, t), (t.encoding = null);
        const n = T((e, n) => {
          if (e) return o(e);
          this.sockets[s] || (this.sockets[s] = []),
            a(this.sockets[s], n),
            this.totalSocketCount++,
            P("sockets", s, this.sockets[s].length, this.totalSocketCount),
            (function installListeners(e, t, o) {
              function onFree() {
                P("CLIENT socket onFree"), e.emit("free", t, o);
              }
              function onClose(s) {
                P("CLIENT socket onClose"),
                  e.totalSocketCount--,
                  e.removeSocket(t, o);
              }
              function onTimeout() {
                P("CLIENT socket onTimeout");
                const o = e.freeSockets;
                if (k(m(o), (e) => r(o[e], t))) return t.destroy();
              }
              function onRemove() {
                P("CLIENT socket onRemove"),
                  e.totalSocketCount--,
                  e.removeSocket(t, o),
                  t.removeListener("close", onClose),
                  t.removeListener("free", onFree),
                  t.removeListener("timeout", onTimeout),
                  t.removeListener("agentRemove", onRemove);
              }
              t.on("free", onFree),
                t.on("close", onClose),
                t.on("timeout", onTimeout),
                t.on("agentRemove", onRemove),
                e[O] && t.on("keylog", e[O]);
            })(this, n, t),
            o(null, n);
        });
        this.keepAlive &&
          ((t.keepAlive = this.keepAlive),
          (t.keepAliveInitialDelay = this.keepAliveMsecs));
        const i = this.createConnection(t, n);
        i && n(null, i);
      }),
      (Agent.prototype.removeSocket = function removeSocket(e, t) {
        const o = this.getName(t);
        P("removeSocket", o, "writable:", e.writable);
        const s = [this.sockets];
        e.writable || a(s, this.freeSockets);
        for (let t = 0; t < s.length; t++) {
          const n = s[t];
          if (n[o]) {
            const t = c(n[o], e);
            -1 !== t && (u(n[o], t, 1), 0 === n[o].length && delete n[o]);
          }
        }
        let n;
        if (this.requests[o] && this.requests[o].length)
          P("removeSocket, have a request, make a socket"),
            (n = this.requests[o][0]);
        else {
          const e = m(this.requests);
          for (let o = 0; o < e.length; o++) {
            const s = e[o];
            if (this.sockets[s] && this.sockets[s].length) break;
            P(
              "removeSocket, have a request with different origin, make a socket"
            ),
              (n = this.requests[s][0]),
              (t = n[w]);
            break;
          }
        }
        n &&
          t &&
          ((n[w] = void 0),
          this.createSocket(n, t, (e, t) => {
            e ? n.onSocket(t, e) : t.emit("free");
          }));
      }),
      (Agent.prototype.keepSocketAlive = function keepSocketAlive(e) {
        e.setKeepAlive(!0, this.keepAliveMsecs), e.unref();
        const t = this.options.timeout || 0;
        return e.timeout !== t && e.setTimeout(t), !0;
      }),
      (Agent.prototype.reuseSocket = function reuseSocket(e, t) {
        P("have free socket"),
          e.removeListener("error", freeSocketErrorListener),
          (t.reusedSocket = !0),
          e.ref();
      }),
      (Agent.prototype.destroy = function destroy() {
        const e = [this.freeSockets, this.sockets];
        for (let t = 0; t < e.length; t++) {
          const o = e[t],
            s = m(o);
          for (let e = 0; e < s.length; e++) {
            const t = o[s[e]];
            for (let e = 0; e < t.length; e++) t[e].destroy();
          }
        }
      }),
      (o.exports = { Agent: Agent, globalAgent: new Agent() });
  },
  _http_client: function (e, t, s, o, n, i) {
    "use strict";
    const {
        ArrayIsArray: r,
        Boolean: a,
        Error: c,
        FunctionPrototypeCall: h,
        NumberIsFinite: u,
        ObjectAssign: d,
        ObjectKeys: l,
        ObjectSetPrototypeOf: p,
        ReflectApply: m,
        RegExpPrototypeExec: f,
        String: T,
        StringPrototypeCharCodeAt: g,
        StringPrototypeIncludes: k,
        StringPrototypeIndexOf: _,
        StringPrototypeToUpperCase: C,
        Symbol: E,
        TypedArrayPrototypeSlice: y,
      } = i,
      H = t("net"),
      R = t("internal/assert"),
      { kEmptyObject: v, once: O } = t("internal/util"),
      {
        _checkIsHttpToken: S,
        freeParser: b,
        parsers: A,
        HTTPParser: P,
        isLenient: L,
        prepareError: q,
      } = t("_http_common"),
      {
        kUniqueHeaders: N,
        parseUniqueHeadersOption: I,
        OutgoingMessage: D,
      } = t("_http_outgoing"),
      w = t("_http_agent"),
      { Buffer: M } = t("buffer"),
      { defaultTriggerAsyncIdScope: x } = t("internal/async_hooks"),
      { URL: K, urlToHttpOptions: j, isURL: F } = t("internal/url"),
      {
        kOutHeaders: V,
        kNeedDrain: G,
        isTraceHTTPEnabled: U,
        traceBegin: z,
        traceEnd: B,
        getNextTraceEventId: $,
      } = t("internal/http"),
      { connResetException: Q, codes: Y } = t("internal/errors"),
      {
        ERR_HTTP_HEADERS_SENT: J,
        ERR_INVALID_ARG_TYPE: W,
        ERR_INVALID_HTTP_TOKEN: X,
        ERR_INVALID_PROTOCOL: Z,
        ERR_UNESCAPED_CHARACTERS: ee,
      } = Y,
      { validateInteger: te, validateBoolean: se } = t("internal/validators"),
      { getTimerDuration: oe } = t("internal/timers"),
      { DTRACE_HTTP_CLIENT_REQUEST: ne, DTRACE_HTTP_CLIENT_RESPONSE: ie } =
        t("internal/dtrace"),
      {
        hasObserver: re,
        startPerf: ae,
        stopPerf: ce,
      } = t("internal/perf/observe"),
      he = E("ClientRequestStatistics"),
      ue = t("diagnostics_channel"),
      de = ue.channel("http.client.request.start"),
      le = ue.channel("http.client.response.finish"),
      { addAbortSignal: pe, finished: me } = t("stream");
    let fe = t("internal/util/debuglog").debuglog("http", (e) => {
      fe = e;
    });
    const Te = /[^\u0021-\u00ff]/,
      ge = E("kError"),
      ke = 0 | P.kLenientAll,
      _e = 0 | P.kLenientNone,
      Ce = "http.client.request";
    function validateHost(e, t) {
      if (null != e && "string" != typeof e)
        throw new W(`options.${t}`, ["string", "undefined", "null"], e);
      return e;
    }
    class HTTPClientAsyncResource {
      constructor(e, t) {
        (this.type = e), (this.req = t);
      }
    }
    function ClientRequest(e, t, s) {
      if ((h(D, this), "string" == typeof e)) {
        e = j(new K(e));
      } else F(e) ? (e = j(e)) : ((s = t), (t = e), (e = null));
      "function" == typeof t ? ((s = t), (t = e || v)) : (t = d(e || {}, t));
      let n = t.agent;
      const i = t._defaultAgent || w.globalAgent;
      if (!1 === n) n = new i.constructor();
      else if (null == n) "function" != typeof t.createConnection && (n = i);
      else if ("function" != typeof n.addRequest)
        throw new W(
          "options.agent",
          ["Agent-like Object", "undefined", "false"],
          n
        );
      this.agent = n;
      const c = t.protocol || i.protocol;
      let p = i.protocol;
      if (
        (this.agent && this.agent.protocol && (p = this.agent.protocol), t.path)
      ) {
        const e = T(t.path);
        if (null !== f(Te, e))
          throw (
            (fe('Path contains unescaped characters: "%s"', e),
            new ee("Request path"))
          );
      }
      if (c !== p) throw new Z(c, p);
      const m = t.defaultPort || (this.agent && this.agent.defaultPort),
        E = (t.port = t.port || m || 80),
        y = (t.host =
          validateHost(t.hostname, "hostname") ||
          validateHost(t.host, "host") ||
          "localhost"),
        R = void 0 === t.setHost || a(t.setHost);
      (this.socketPath = t.socketPath),
        void 0 !== t.timeout && (this.timeout = oe(t.timeout, "timeout"));
      const b = t.signal;
      b && pe(b, this);
      let A = t.method;
      const P = "string" == typeof A;
      if (null != A && !P) throw new W("options.method", "string", A);
      if (P && A) {
        if (!S(A)) throw new X("Method", A);
        A = this.method = C(A);
      } else A = this.method = "GET";
      const L = t.maxHeaderSize;
      void 0 !== L && te(L, "maxHeaderSize", 0), (this.maxHeaderSize = L);
      const q = t.insecureHTTPParser;
      void 0 !== q && se(q, "options.insecureHTTPParser"),
        (this.insecureHTTPParser = q),
        void 0 !== t.joinDuplicateHeaders &&
          se(t.joinDuplicateHeaders, "options.joinDuplicateHeaders"),
        (this.joinDuplicateHeaders = t.joinDuplicateHeaders),
        (this.path = t.path || "/"),
        s && this.once("response", s),
        (this.useChunkedEncodingByDefault =
          "GET" !== A &&
          "HEAD" !== A &&
          "DELETE" !== A &&
          "OPTIONS" !== A &&
          "TRACE" !== A &&
          "CONNECT" !== A),
        (this._ended = !1),
        (this.res = null),
        (this.aborted = !1),
        (this.timeoutCb = null),
        (this.upgradeOrConnect = !1),
        (this.parser = null),
        (this.maxHeadersCount = null),
        (this.reusedSocket = !1),
        (this.host = y),
        (this.protocol = c),
        this.agent &&
          (this.agent.keepAlive || u(this.agent.maxSockets)
            ? ((this._last = !1), (this.shouldKeepAlive = !0))
            : ((this._last = !0), (this.shouldKeepAlive = !1)));
      if (r(t.headers))
        this._storeHeader(
          this.method + " " + this.path + " HTTP/1.1\r\n",
          t.headers
        );
      else {
        if (t.headers) {
          const e = l(t.headers);
          for (let s = 0; s < e.length; s++) {
            const o = e[s];
            this.setHeader(o, t.headers[o]);
          }
        }
        if (y && !this.getHeader("host") && R) {
          let e = y;
          const t = _(e, ":");
          -1 !== t && k(e, ":", t + 1) && 91 !== g(e, 0) && (e = `[${e}]`),
            E && +E !== m && (e += ":" + E),
            this.setHeader("Host", e);
        }
        if (
          (t.auth &&
            !this.getHeader("Authorization") &&
            this.setHeader(
              "Authorization",
              "Basic " + M.from(t.auth).toString("base64")
            ),
          this.getHeader("expect"))
        ) {
          if (this._header) throw new J("render");
          this._storeHeader(
            this.method + " " + this.path + " HTTP/1.1\r\n",
            this[V]
          );
        }
      }
      this[N] = I(t.uniqueHeaders);
      let x = t;
      if ((x.signal && ((x = d({}, t)), delete x.signal), this.agent))
        this.agent.addRequest(this, x);
      else if (
        ((this._last = !0),
        (this.shouldKeepAlive = !1),
        "function" == typeof x.createConnection)
      ) {
        const e = O((e, t) => {
          e ? o.nextTick(() => this.emit("error", e)) : this.onSocket(t);
        });
        try {
          const t = x.createConnection(x, e);
          t && e(null, t);
        } catch (t) {
          e(t);
        }
      } else
        fe("CLIENT use net.createConnection", x),
          this.onSocket(H.createConnection(x));
    }
    function emitAbortNT(e) {
      e.emit("abort");
    }
    function ondrain() {
      const e = this._httpMessage;
      e && !e.finished && e[G] && ((e[G] = !1), e.emit("drain"));
    }
    function socketCloseListener() {
      const e = this,
        t = e._httpMessage;
      fe("HTTP socket close");
      const s = e.parser,
        o = t.res;
      (t.destroyed = !0),
        o
          ? (o.complete || o.destroy(Q("aborted")),
            (t._closed = !0),
            t.emit("close"),
            !o.aborted && o.readable && o.push(null))
          : (t.socket._hadError ||
              ((t.socket._hadError = !0), t.emit("error", Q("socket hang up"))),
            (t._closed = !0),
            t.emit("close")),
        t.outputData && (t.outputData.length = 0),
        s && (s.finish(), b(s, t, e));
    }
    function socketErrorListener(e) {
      const t = this,
        s = t._httpMessage;
      fe("SOCKET ERROR:", e.message, e.stack),
        s && ((s.socket._hadError = !0), s.emit("error", e));
      const o = t.parser;
      o && (o.finish(), b(o, s, t)),
        t.removeListener("data", socketOnData),
        t.removeListener("end", socketOnEnd),
        t.destroy();
    }
    function socketOnEnd() {
      const e = this,
        t = this._httpMessage,
        s = this.parser;
      t.res ||
        t.socket._hadError ||
        ((t.socket._hadError = !0), t.emit("error", Q("socket hang up"))),
        s && (s.finish(), b(s, t, e)),
        e.destroy();
    }
    function socketOnData(e) {
      const t = this,
        s = this._httpMessage,
        o = this.parser;
      R(o && o.socket === t);
      const n = o.execute(e);
      if (n instanceof c)
        q(n, o, e),
          fe("parse error", n),
          b(o, s, t),
          t.removeListener("data", socketOnData),
          t.removeListener("end", socketOnEnd),
          t.destroy(),
          (s.socket._hadError = !0),
          s.emit("error", n);
      else if (o.incoming && o.incoming.upgrade) {
        const i = n,
          r = o.incoming;
        (s.res = r),
          t.removeListener("data", socketOnData),
          t.removeListener("end", socketOnEnd),
          t.removeListener("drain", ondrain),
          s.timeoutCb && t.removeListener("timeout", s.timeoutCb),
          t.removeListener("timeout", responseOnTimeout),
          o.finish(),
          b(o, s, t);
        const a = y(e, i, e.length),
          c = "CONNECT" === s.method ? "connect" : "upgrade";
        s.listenerCount(c) > 0
          ? ((s.upgradeOrConnect = !0),
            t.emit("agentRemove"),
            t.removeListener("close", socketCloseListener),
            t.removeListener("error", socketErrorListener),
            (t._httpMessage = null),
            (t.readableFlowing = null),
            s.emit(c, r, t, a),
            (s.destroyed = !0),
            (s._closed = !0),
            s.emit("close"))
          : t.destroy();
      } else
        o.incoming &&
          o.incoming.complete &&
          !statusIsInformational(o.incoming.statusCode) &&
          (t.removeListener("data", socketOnData),
          t.removeListener("end", socketOnEnd),
          t.removeListener("drain", ondrain),
          b(o, s, t));
    }
    function statusIsInformational(e) {
      return e < 200 && e >= 100 && 101 !== e;
    }
    function parserOnIncomingClient(e, t) {
      const s = this.socket,
        o = s._httpMessage;
      if ((fe("AGENT incoming response!"), o.res)) return s.destroy(), 0;
      if (((o.res = e), e.upgrade)) return 2;
      const n = o.method;
      return "CONNECT" === n
        ? ((e.upgrade = !0), 2)
        : statusIsInformational(e.statusCode)
        ? ((o.res = null),
          100 === e.statusCode && o.emit("continue"),
          o.emit("information", {
            statusCode: e.statusCode,
            statusMessage: e.statusMessage,
            httpVersion: e.httpVersion,
            httpVersionMajor: e.httpVersionMajor,
            httpVersionMinor: e.httpVersionMinor,
            headers: e.headers,
            rawHeaders: e.rawHeaders,
          }),
          1)
        : (!o.shouldKeepAlive ||
            t ||
            o.upgradeOrConnect ||
            (o.shouldKeepAlive = !1),
          ie(s, o),
          o[he] &&
            re("http") &&
            ce(o, he, {
              detail: {
                res: {
                  statusCode: e.statusCode,
                  statusMessage: e.statusMessage,
                  headers: e.headers,
                },
              },
            }),
          le.hasSubscribers && le.publish({ request: o, response: e }),
          U() &&
            "number" == typeof o._traceEventId &&
            B(Ce, o._traceEventId, { path: o.path, statusCode: e.statusCode }),
          (o.res = e),
          (e.req = o),
          e.on("end", responseOnEnd),
          o.on("finish", requestOnFinish),
          s.on("timeout", responseOnTimeout),
          (!o.aborted && o.emit("response", e)) || e._dump(),
          "HEAD" === n ? 1 : 304 === e.statusCode ? ((e.complete = !0), 1) : 0);
    }
    function responseKeepAlive(e) {
      const t = e.socket;
      fe("AGENT socket keep-alive"),
        e.timeoutCb && (t.setTimeout(0, e.timeoutCb), (e.timeoutCb = null)),
        t.removeListener("close", socketCloseListener),
        t.removeListener("error", socketErrorListener),
        t.removeListener("data", socketOnData),
        t.removeListener("end", socketOnEnd);
      const s = t._handle ? t._handle.getAsyncId() : void 0;
      x(s, o.nextTick, emitFreeNT, e),
        (e.destroyed = !0),
        e.res && (e.res.socket = null);
    }
    function responseOnEnd() {
      const e = this.req,
        t = e.socket;
      t &&
        (e.timeoutCb && t.removeListener("timeout", emitRequestTimeout),
        t.removeListener("timeout", responseOnTimeout)),
        (e._ended = !0),
        e.shouldKeepAlive
          ? e.writableFinished &&
            !this.aborted &&
            (R(e.finished), responseKeepAlive(e))
          : (t.writable &&
              (fe("AGENT socket.destroySoon()"),
              "function" == typeof t.destroySoon ? t.destroySoon() : t.end()),
            R(!t.writable));
    }
    function responseOnTimeout() {
      const e = this._httpMessage;
      if (!e) return;
      const t = e.res;
      t && t.emit("timeout");
    }
    function requestOnFinish() {
      const e = this;
      e.shouldKeepAlive && e._ended && responseKeepAlive(e);
    }
    function emitFreeNT(e) {
      (e._closed = !0), e.emit("close"), e.socket && e.socket.emit("free");
    }
    function emitRequestTimeout() {
      const e = this._httpMessage;
      e && e.emit("timeout");
    }
    function listenSocketTimeout(e) {
      e.timeoutCb ||
        ((e.timeoutCb = emitRequestTimeout),
        e.socket
          ? e.socket.once("timeout", emitRequestTimeout)
          : e.on("socket", (e) => {
              e.once("timeout", emitRequestTimeout);
            }));
    }
    function onSocketNT(e, t, s) {
      if (e.destroyed || s) {
        let _destroy = function (e, t) {
          e.aborted || t || (t = Q("socket hang up")),
            t && e.emit("error", t),
            (e._closed = !0),
            e.emit("close");
        };
        if (((e.destroyed = !0), t)) {
          if (s || !e.agent || t.destroyed)
            return void me(t.destroy(s || e[ge]), (t) => {
              "ERR_STREAM_PREMATURE_CLOSE" === t?.code && (t = null),
                _destroy(e, t || s);
            });
          t.emit("free");
        }
        _destroy(e, s || e[ge]);
      } else
        !(function tickOnSocket(e, t) {
          const s = A.alloc();
          e.socket = t;
          const o =
            void 0 === e.insecureHTTPParser ? L() : e.insecureHTTPParser;
          s.initialize(
            P.RESPONSE,
            new HTTPClientAsyncResource("HTTPINCOMINGMESSAGE", e),
            e.maxHeaderSize || 0,
            o ? ke : _e
          ),
            (s.socket = t),
            (s.outgoing = e),
            (e.parser = s),
            (t.parser = s),
            (t._httpMessage = e),
            "number" == typeof e.maxHeadersCount &&
              (s.maxHeaderPairs = e.maxHeadersCount << 1),
            (s.joinDuplicateHeaders = e.joinDuplicateHeaders),
            (s.onIncoming = parserOnIncomingClient),
            t.on("error", socketErrorListener),
            t.on("data", socketOnData),
            t.on("end", socketOnEnd),
            t.on("close", socketCloseListener),
            t.on("drain", ondrain),
            (void 0 !== e.timeout ||
              (e.agent && e.agent.options && e.agent.options.timeout)) &&
              listenSocketTimeout(e),
            e.emit("socket", t);
        })(e, t),
          e._flush();
    }
    function setSocketTimeout(e, t) {
      e.connecting
        ? e.once("connect", function () {
            e.setTimeout(t);
          })
        : e.setTimeout(t);
    }
    p(ClientRequest.prototype, D.prototype),
      p(ClientRequest, D),
      (ClientRequest.prototype._finish = function _finish() {
        ne(this, this.socket),
          h(D.prototype._finish, this),
          re("http") &&
            ae(this, he, {
              type: "http",
              name: "HttpClient",
              detail: {
                req: {
                  method: this.method,
                  url: `${this.protocol}//${this.host}${this.path}`,
                  headers:
                    "function" == typeof this.getHeaders
                      ? this.getHeaders()
                      : {},
                },
              },
            }),
          de.hasSubscribers && de.publish({ request: this }),
          U() && ((this._traceEventId = $()), z(Ce, this._traceEventId));
      }),
      (ClientRequest.prototype._implicitHeader = function _implicitHeader() {
        if (this._header) throw new J("render");
        this._storeHeader(
          this.method + " " + this.path + " HTTP/1.1\r\n",
          this[V]
        );
      }),
      (ClientRequest.prototype.abort = function abort() {
        this.aborted ||
          ((this.aborted = !0), o.nextTick(emitAbortNT, this), this.destroy());
      }),
      (ClientRequest.prototype.destroy = function destroy(e) {
        return (
          this.destroyed ||
            ((this.destroyed = !0),
            this.res && this.res._dump(),
            (this[ge] = e),
            this.socket?.destroy(e)),
          this
        );
      }),
      (ClientRequest.prototype.onSocket = function onSocket(e, t) {
        o.nextTick(onSocketNT, this, e, t);
      }),
      (ClientRequest.prototype._deferToConnect = function _deferToConnect(
        e,
        t
      ) {
        const callSocketMethod = () => {
            e && m(this.socket[e], this.socket, t);
          },
          onSocket = () => {
            this.socket.writable
              ? callSocketMethod()
              : this.socket.once("connect", callSocketMethod);
          };
        this.socket ? onSocket() : this.once("socket", onSocket);
      }),
      (ClientRequest.prototype.setTimeout = function setTimeout(e, t) {
        return (
          this._ended ||
            (listenSocketTimeout(this),
            (e = oe(e, "msecs")),
            t && this.once("timeout", t),
            this.socket
              ? setSocketTimeout(this.socket, e)
              : this.once("socket", (t) => setSocketTimeout(t, e))),
          this
        );
      }),
      (ClientRequest.prototype.setNoDelay = function setNoDelay(e) {
        this._deferToConnect("setNoDelay", [e]);
      }),
      (ClientRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive(
        e,
        t
      ) {
        this._deferToConnect("setKeepAlive", [e, t]);
      }),
      (ClientRequest.prototype.clearTimeout = function clearTimeout(e) {
        this.setTimeout(0, e);
      }),
      (s.exports = { ClientRequest: ClientRequest });
  },
  _http_common: function (e, n, r, s, t, a) {
    "use strict";
    const { MathMin: o, Symbol: i, RegExpPrototypeExec: c } = a,
      { setImmediate: u } = n("timers"),
      { methods: l, HTTPParser: p } = t("http_parser"),
      { getOptionValue: d } = n("internal/options"),
      h = d("--insecure-http-parser"),
      m = n("internal/freelist"),
      g = n("_http_incoming"),
      { IncomingMessage: f, readStart: _, readStop: H } = g,
      k = i("IncomingMessage"),
      P = 0 | p.kOnMessageBegin,
      O = 0 | p.kOnHeaders,
      x = 0 | p.kOnHeadersComplete,
      I = 0 | p.kOnBody,
      C = 0 | p.kOnMessageComplete,
      M = 0 | p.kOnExecute,
      T = 0 | p.kOnTimeout,
      v = 2e3;
    function parserOnHeaders(e, n) {
      (this.maxHeaderPairs <= 0 ||
        this._headers.length < this.maxHeaderPairs) &&
        this._headers.push(...e),
        (this._url += n);
    }
    function parserOnHeadersComplete(e, n, r, s, t, a, i, c, u) {
      const p = this,
        { socket: d } = p;
      void 0 === r && ((r = p._headers), (p._headers = [])),
        void 0 === t && ((t = p._url), (p._url = ""));
      const h = (d && d.server && d.server[k]) || f,
        m = (p.incoming = new h(d));
      (m.httpVersionMajor = e),
        (m.httpVersionMinor = n),
        (m.httpVersion = `${e}.${n}`),
        (m.joinDuplicateHeaders =
          d?.server?.joinDuplicateHeaders || p.joinDuplicateHeaders),
        (m.url = t),
        (m.upgrade = c);
      let g = r.length;
      return (
        p.maxHeaderPairs > 0 && (g = o(g, p.maxHeaderPairs)),
        m._addHeaderLines(r, g),
        "number" == typeof s
          ? (m.method = l[s])
          : ((m.statusCode = a), (m.statusMessage = i)),
        p.onIncoming(m, u)
      );
    }
    function parserOnBody(e) {
      const n = this.incoming;
      if (null !== n && !n._dumped) {
        n.push(e) || H(this.socket);
      }
    }
    function parserOnMessageComplete() {
      const e = this,
        n = e.incoming;
      if (null !== n) {
        n.complete = !0;
        const r = e._headers;
        r.length &&
          (n._addHeaderLines(r, r.length), (e._headers = []), (e._url = "")),
          n.push(null);
      }
      _(e.socket);
    }
    const E = new m("parsers", 1e3, function parsersCb() {
      const e = new p();
      return (
        cleanParser(e),
        (e[O] = parserOnHeaders),
        (e[x] = parserOnHeadersComplete),
        (e[I] = parserOnBody),
        (e[C] = parserOnMessageComplete),
        e
      );
    });
    function closeParserInstance(e) {
      e.close();
    }
    const y = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    const $ = /[^\t\x20-\x7e\x80-\xff]/;
    function cleanParser(e) {
      (e._headers = []),
        (e._url = ""),
        (e.socket = null),
        (e.incoming = null),
        (e.outgoing = null),
        (e.maxHeaderPairs = v),
        (e[P] = null),
        (e[M] = null),
        (e[T] = null),
        (e._consumed = !1),
        (e.onIncoming = null),
        (e.joinDuplicateHeaders = null);
    }
    let j = !1;
    r.exports = {
      _checkInvalidHeaderChar: function checkInvalidHeaderChar(e) {
        return null !== c($, e);
      },
      _checkIsHttpToken: function checkIsHttpToken(e) {
        return null !== c(y, e);
      },
      chunkExpression: /(?:^|\W)chunked(?:$|\W)/i,
      continueExpression: /(?:^|\W)100-continue(?:$|\W)/i,
      CRLF: "\r\n",
      freeParser: function freeParser(e, n, r) {
        e &&
          (e._consumed && e.unconsume(),
          cleanParser(e),
          e.remove(),
          !1 === E.free(e) ? u(closeParserInstance, e) : e.free()),
          n && (n.parser = null),
          r && (r.parser = null);
      },
      methods: l,
      parsers: E,
      kIncomingMessage: k,
      HTTPParser: p,
      isLenient: function isLenient() {
        return (
          h && !j && ((j = !0), s.emitWarning("Using insecure HTTP parsing")), h
        );
      },
      prepareError: function prepareError(e, n, r) {
        (e.rawPacket = r || n.getCurrentBuffer()),
          "string" == typeof e.reason &&
            (e.message = `Parse Error: ${e.reason}`);
      },
    };
  },
  _http_incoming: function (e, t, r, i, n, o) {
    "use strict";
    const {
        ObjectDefineProperty: s,
        ObjectSetPrototypeOf: a,
        StringPrototypeCharCodeAt: c,
        StringPrototypeSlice: d,
        StringPrototypeToLowerCase: h,
        Symbol: u,
      } = o,
      { Readable: f, finished: g } = t("stream"),
      p = u("kHeaders"),
      l = u("kHeadersDistinct"),
      m = u("kHeadersCount"),
      _ = u("kTrailers"),
      k = u("kTrailersDistinct"),
      y = u("kTrailersCount");
    function readStart(e) {
      e && !e._paused && e.readable && e.resume();
    }
    function IncomingMessage(e) {
      let t;
      e && (t = { highWaterMark: e.readableHighWaterMark }),
        f.call(this, t),
        (this._readableState.readingMore = !0),
        (this.socket = e),
        (this.httpVersionMajor = null),
        (this.httpVersionMinor = null),
        (this.httpVersion = null),
        (this.complete = !1),
        (this[p] = null),
        (this[m] = 0),
        (this.rawHeaders = []),
        (this[_] = null),
        (this[y] = 0),
        (this.rawTrailers = []),
        (this.joinDuplicateHeaders = !1),
        (this.aborted = !1),
        (this.upgrade = null),
        (this.url = ""),
        (this.method = null),
        (this.statusCode = null),
        (this.statusMessage = null),
        (this.client = e),
        (this._consuming = !1),
        (this._dumped = !1);
    }
    function matchKnownFields(e, t) {
      switch (e.length) {
        case 3:
          if ("Age" === e || "age" === e) return "age";
          break;
        case 4:
          if ("Host" === e || "host" === e) return "host";
          if ("From" === e || "from" === e) return "from";
          if ("ETag" === e || "etag" === e) return "etag";
          if ("Date" === e || "date" === e) return "\0date";
          if ("Vary" === e || "vary" === e) return "\0vary";
          break;
        case 6:
          if ("Server" === e || "server" === e) return "server";
          if ("Cookie" === e || "cookie" === e) return "cookie";
          if ("Origin" === e || "origin" === e) return "\0origin";
          if ("Expect" === e || "expect" === e) return "\0expect";
          if ("Accept" === e || "accept" === e) return "\0accept";
          break;
        case 7:
          if ("Referer" === e || "referer" === e) return "referer";
          if ("Expires" === e || "expires" === e) return "expires";
          if ("Upgrade" === e || "upgrade" === e) return "\0upgrade";
          break;
        case 8:
          if ("Location" === e || "location" === e) return "location";
          if ("If-Match" === e || "if-match" === e) return "\0if-match";
          break;
        case 10:
          if ("User-Agent" === e || "user-agent" === e) return "user-agent";
          if ("Set-Cookie" === e || "set-cookie" === e) return "";
          if ("Connection" === e || "connection" === e) return "\0connection";
          break;
        case 11:
          if ("Retry-After" === e || "retry-after" === e) return "retry-after";
          break;
        case 12:
          if ("Content-Type" === e || "content-type" === e)
            return "content-type";
          if ("Max-Forwards" === e || "max-forwards" === e)
            return "max-forwards";
          break;
        case 13:
          if ("Authorization" === e || "authorization" === e)
            return "authorization";
          if ("Last-Modified" === e || "last-modified" === e)
            return "last-modified";
          if ("Cache-Control" === e || "cache-control" === e)
            return "\0cache-control";
          if ("If-None-Match" === e || "if-none-match" === e)
            return "\0if-none-match";
          break;
        case 14:
          if ("Content-Length" === e || "content-length" === e)
            return "content-length";
          break;
        case 15:
          if ("Accept-Encoding" === e || "accept-encoding" === e)
            return "\0accept-encoding";
          if ("Accept-Language" === e || "accept-language" === e)
            return "\0accept-language";
          if ("X-Forwarded-For" === e || "x-forwarded-for" === e)
            return "\0x-forwarded-for";
          break;
        case 16:
          if ("Content-Encoding" === e || "content-encoding" === e)
            return "\0content-encoding";
          if ("X-Forwarded-Host" === e || "x-forwarded-host" === e)
            return "\0x-forwarded-host";
          break;
        case 17:
          if ("If-Modified-Since" === e || "if-modified-since" === e)
            return "if-modified-since";
          if ("Transfer-Encoding" === e || "transfer-encoding" === e)
            return "\0transfer-encoding";
          if ("X-Forwarded-Proto" === e || "x-forwarded-proto" === e)
            return "\0x-forwarded-proto";
          break;
        case 19:
          if ("Proxy-Authorization" === e || "proxy-authorization" === e)
            return "proxy-authorization";
          if ("If-Unmodified-Since" === e || "if-unmodified-since" === e)
            return "if-unmodified-since";
      }
      return t ? "\0" + e : matchKnownFields(h(e), !0);
    }
    function onError(e, t, r) {
      0 === e.listenerCount("error") ? r() : r(t);
    }
    a(IncomingMessage.prototype, f.prototype),
      a(IncomingMessage, f),
      s(IncomingMessage.prototype, "connection", {
        __proto__: null,
        get: function () {
          return this.socket;
        },
        set: function (e) {
          this.socket = e;
        },
      }),
      s(IncomingMessage.prototype, "headers", {
        __proto__: null,
        get: function () {
          if (!this[p]) {
            this[p] = {};
            const e = this.rawHeaders,
              t = this[p];
            for (let r = 0; r < this[m]; r += 2)
              this._addHeaderLine(e[r + 0], e[r + 1], t);
          }
          return this[p];
        },
        set: function (e) {
          this[p] = e;
        },
      }),
      s(IncomingMessage.prototype, "headersDistinct", {
        __proto__: null,
        get: function () {
          if (!this[l]) {
            this[l] = {};
            const e = this.rawHeaders,
              t = this[l];
            for (let r = 0; r < this[m]; r += 2)
              this._addHeaderLineDistinct(e[r + 0], e[r + 1], t);
          }
          return this[l];
        },
        set: function (e) {
          this[l] = e;
        },
      }),
      s(IncomingMessage.prototype, "trailers", {
        __proto__: null,
        get: function () {
          if (!this[_]) {
            this[_] = {};
            const e = this.rawTrailers,
              t = this[_];
            for (let r = 0; r < this[y]; r += 2)
              this._addHeaderLine(e[r + 0], e[r + 1], t);
          }
          return this[_];
        },
        set: function (e) {
          this[_] = e;
        },
      }),
      s(IncomingMessage.prototype, "trailersDistinct", {
        __proto__: null,
        get: function () {
          if (!this[k]) {
            this[k] = {};
            const e = this.rawTrailers,
              t = this[k];
            for (let r = 0; r < this[y]; r += 2)
              this._addHeaderLineDistinct(e[r + 0], e[r + 1], t);
          }
          return this[k];
        },
        set: function (e) {
          this[k] = e;
        },
      }),
      (IncomingMessage.prototype.setTimeout = function setTimeout(e, t) {
        return t && this.on("timeout", t), this.socket.setTimeout(e), this;
      }),
      (IncomingMessage.prototype._read = function _read(e) {
        this._consuming ||
          ((this._readableState.readingMore = !1), (this._consuming = !0)),
          this.socket.readable && readStart(this.socket);
      }),
      (IncomingMessage.prototype._destroy = function _destroy(e, t) {
        if (
          ((this.readableEnded && this.complete) ||
            ((this.aborted = !0), this.emit("aborted")),
          this.socket && !this.socket.destroyed && this.aborted)
        ) {
          this.socket.destroy(e);
          const r = g(this.socket, (n) => {
            "ERR_STREAM_PREMATURE_CLOSE" === n?.code && (n = null),
              r(),
              i.nextTick(onError, this, n || e, t);
          });
        } else i.nextTick(onError, this, e, t);
      }),
      (IncomingMessage.prototype._addHeaderLines = function _addHeaderLines(
        e,
        t
      ) {
        if (e && e.length) {
          let r;
          if (
            (this.complete
              ? ((this.rawTrailers = e), (this[y] = t), (r = this[_]))
              : ((this.rawHeaders = e), (this[m] = t), (r = this[p])),
            r)
          )
            for (let i = 0; i < t; i += 2)
              this._addHeaderLine(e[i], e[i + 1], r);
        }
      }),
      (IncomingMessage.prototype._addHeaderLine = function _addHeaderLine(
        e,
        t,
        r
      ) {
        e = matchKnownFields(e);
        const i = c(e, 0);
        0 === i || 2 === i
          ? "string" == typeof r[(e = d(e, 1))]
            ? (r[e] += (0 === i ? ", " : "; ") + t)
            : (r[e] = t)
          : 1 === i
          ? void 0 !== r["set-cookie"]
            ? r["set-cookie"].push(t)
            : (r["set-cookie"] = [t])
          : this.joinDuplicateHeaders
          ? void 0 === r[e]
            ? (r[e] = t)
            : (r[e] += ", " + t)
          : void 0 === r[e] && (r[e] = t);
      }),
      (IncomingMessage.prototype._addHeaderLineDistinct =
        function _addHeaderLineDistinct(e, t, r) {
          (e = h(e)), r[e] ? r[e].push(t) : (r[e] = [t]);
        }),
      (IncomingMessage.prototype._dump = function _dump() {
        this._dumped ||
          ((this._dumped = !0), this.removeAllListeners("data"), this.resume());
      }),
      (r.exports = {
        IncomingMessage: IncomingMessage,
        readStart: readStart,
        readStop: function readStop(e) {
          e && e.pause();
        },
      });
  },
  _http_outgoing: function (t, e, n, i, s, o) {
    "use strict";
    const {
        Array: r,
        ArrayIsArray: h,
        ArrayPrototypeJoin: a,
        MathFloor: c,
        NumberPrototypeToString: u,
        ObjectCreate: l,
        ObjectDefineProperty: g,
        ObjectKeys: d,
        ObjectValues: _,
        ObjectPrototypeHasOwnProperty: p,
        ObjectSetPrototypeOf: f,
        RegExpPrototypeExec: k,
        SafeSet: y,
        StringPrototypeToLowerCase: w,
        Symbol: E,
      } = o,
      { getDefaultHighWaterMark: O } = e("internal/streams/state"),
      m = e("internal/assert"),
      H = e("events"),
      M = e("stream"),
      T = e("internal/util"),
      { kOutHeaders: R, utcDate: L, kNeedDrain: b } = e("internal/http"),
      { Buffer: D } = e("buffer"),
      {
        _checkIsHttpToken: A,
        _checkInvalidHeaderChar: v,
        chunkExpression: C,
      } = e("_http_common"),
      {
        defaultTriggerAsyncIdScope: S,
        symbols: { async_id_symbol: N },
      } = e("internal/async_hooks"),
      {
        codes: {
          ERR_HTTP_CONTENT_LENGTH_MISMATCH: P,
          ERR_HTTP_HEADERS_SENT: I,
          ERR_HTTP_INVALID_HEADER_VALUE: x,
          ERR_HTTP_TRAILER_INVALID: B,
          ERR_HTTP_BODY_NOT_ALLOWED: W,
          ERR_INVALID_HTTP_TOKEN: j,
          ERR_INVALID_ARG_TYPE: F,
          ERR_INVALID_ARG_VALUE: K,
          ERR_INVALID_CHAR: U,
          ERR_METHOD_NOT_IMPLEMENTED: V,
          ERR_STREAM_CANNOT_PIPE: q,
          ERR_STREAM_ALREADY_FINISHED: z,
          ERR_STREAM_WRITE_AFTER_END: Y,
          ERR_STREAM_NULL_VALUES: $,
          ERR_STREAM_DESTROYED: G,
        },
        hideStackFrames: J,
      } = e("internal/errors"),
      { validateString: Q } = e("internal/validators"),
      { isUint8Array: X } = e("internal/util/types");
    let Z = e("internal/util/debuglog").debuglog("http", (t) => {
      Z = t;
    });
    const tt = E("corked"),
      et = E("kUniqueHeaders"),
      nt = E("kBytesWritten"),
      it = E("errored"),
      st = E("kHighWaterMark"),
      ot = E("kRejectNonStandardBodyWrites"),
      nop = () => {},
      rt = /(?:^|\W)close(?:$|\W)/i;
    function OutgoingMessage(t) {
      M.call(this),
        (this.outputData = []),
        (this.outputSize = 0),
        (this.writable = !0),
        (this.destroyed = !1),
        (this._last = !1),
        (this.chunkedEncoding = !1),
        (this.shouldKeepAlive = !0),
        (this.maxRequestsOnConnectionReached = !1),
        (this._defaultKeepAlive = !0),
        (this.useChunkedEncodingByDefault = !0),
        (this.sendDate = !1),
        (this._removedConnection = !1),
        (this._removedContLen = !1),
        (this._removedTE = !1),
        (this.strictContentLength = !1),
        (this[nt] = 0),
        (this._contentLength = null),
        (this._hasBody = !0),
        (this._trailer = ""),
        (this[b] = !1),
        (this.finished = !1),
        (this._headerSent = !1),
        (this[tt] = 0),
        (this._closed = !1),
        (this.socket = null),
        (this._header = null),
        (this[R] = null),
        (this._keepAliveTimeout = 0),
        (this._onPendingData = nop),
        (this[it] = null),
        (this[st] = t?.highWaterMark ?? O()),
        (this[ot] = t?.rejectNonStandardBodyWrites ?? !1);
    }
    function processHeader(t, e, n, i, s) {
      if (
        (s && ht(n),
        (function isContentDispositionField(t) {
          return 19 === t.length && "content-disposition" === w(t);
        })(n) &&
          t._contentLength &&
          (i = D.from(i, "latin1")),
        h(i))
      ) {
        if (
          !(
            (!(i.length < 2) &&
              (function isCookieField(t) {
                return 6 === t.length && "cookie" === w(t);
              })(n)) ||
            (t[et] && t[et].has(w(n)))
          )
        ) {
          for (let o = 0; o < i.length; o++) storeHeader(t, e, n, i[o], s);
          return;
        }
        i = a(i, "; ");
      }
      storeHeader(t, e, n, i, s);
    }
    function storeHeader(t, e, n, i, s) {
      s && at(n, i),
        (e.header += n + ": " + i + "\r\n"),
        (function matchHeader(t, e, n, i) {
          if (n.length < 4 || n.length > 17) return;
          switch ((n = w(n))) {
            case "connection":
              (e.connection = !0),
                (t._removedConnection = !1),
                null !== k(rt, i) ? (t._last = !0) : (t.shouldKeepAlive = !0);
              break;
            case "transfer-encoding":
              (e.te = !0),
                (t._removedTE = !1),
                null !== k(C, i) && (t.chunkedEncoding = !0);
              break;
            case "content-length":
              (e.contLen = !0),
                (t._contentLength = i),
                (t._removedContLen = !1);
              break;
            case "date":
            case "expect":
            case "trailer":
              e[n] = !0;
              break;
            case "keep-alive":
              t._defaultKeepAlive = !1;
          }
        })(t, e, n, i);
    }
    f(OutgoingMessage.prototype, M.prototype),
      f(OutgoingMessage, M),
      g(OutgoingMessage.prototype, "errored", {
        __proto__: null,
        get() {
          return this[it];
        },
      }),
      g(OutgoingMessage.prototype, "closed", {
        __proto__: null,
        get() {
          return this._closed;
        },
      }),
      g(OutgoingMessage.prototype, "writableFinished", {
        __proto__: null,
        get() {
          return (
            this.finished &&
            0 === this.outputSize &&
            (!this.socket || 0 === this.socket.writableLength)
          );
        },
      }),
      g(OutgoingMessage.prototype, "writableObjectMode", {
        __proto__: null,
        get: () => !1,
      }),
      g(OutgoingMessage.prototype, "writableLength", {
        __proto__: null,
        get() {
          return (
            this.outputSize + (this.socket ? this.socket.writableLength : 0)
          );
        },
      }),
      g(OutgoingMessage.prototype, "writableHighWaterMark", {
        __proto__: null,
        get() {
          return this.socket ? this.socket.writableHighWaterMark : this[st];
        },
      }),
      g(OutgoingMessage.prototype, "writableCorked", {
        __proto__: null,
        get() {
          return (this.socket ? this.socket.writableCorked : 0) + this[tt];
        },
      }),
      g(OutgoingMessage.prototype, "_headers", {
        __proto__: null,
        get: T.deprecate(
          function () {
            return this.getHeaders();
          },
          "OutgoingMessage.prototype._headers is deprecated",
          "DEP0066"
        ),
        set: T.deprecate(
          function (t) {
            if (null == t) this[R] = null;
            else if ("object" == typeof t) {
              const e = (this[R] = l(null)),
                n = d(t);
              for (let i = 0; i < n.length; ++i) {
                const s = n[i];
                e[w(s)] = [s, t[s]];
              }
            }
          },
          "OutgoingMessage.prototype._headers is deprecated",
          "DEP0066"
        ),
      }),
      g(OutgoingMessage.prototype, "connection", {
        __proto__: null,
        get: function () {
          return this.socket;
        },
        set: function (t) {
          this.socket = t;
        },
      }),
      g(OutgoingMessage.prototype, "_headerNames", {
        __proto__: null,
        get: T.deprecate(
          function () {
            const t = this[R];
            if (null !== t) {
              const e = l(null),
                n = d(t);
              for (let i = 0; i < n.length; ++i) {
                const s = n[i],
                  o = t[s][0];
                e[s] = o;
              }
              return e;
            }
            return null;
          },
          "OutgoingMessage.prototype._headerNames is deprecated",
          "DEP0066"
        ),
        set: T.deprecate(
          function (t) {
            if ("object" == typeof t && null !== t) {
              const e = this[R];
              if (!e) return;
              const n = d(t);
              for (let i = 0; i < n.length; ++i) {
                const s = e[n[i]];
                s && (s[0] = t[n[i]]);
              }
            }
          },
          "OutgoingMessage.prototype._headerNames is deprecated",
          "DEP0066"
        ),
      }),
      (OutgoingMessage.prototype._renderHeaders = function _renderHeaders() {
        if (this._header) throw new I("render");
        const t = this[R],
          e = {};
        if (null !== t) {
          const n = d(t);
          for (let i = 0, s = n.length; i < s; i++) {
            const s = n[i];
            e[t[s][0]] = t[s][1];
          }
        }
        return e;
      }),
      (OutgoingMessage.prototype.cork = function () {
        this.socket ? this.socket.cork() : this[tt]++;
      }),
      (OutgoingMessage.prototype.uncork = function () {
        this.socket ? this.socket.uncork() : this[tt] && this[tt]--;
      }),
      (OutgoingMessage.prototype.setTimeout = function setTimeout(t, e) {
        return (
          e && this.on("timeout", e),
          this.socket
            ? this.socket.setTimeout(t)
            : this.once("socket", function socketSetTimeoutOnConnect(e) {
                e.setTimeout(t);
              }),
          this
        );
      }),
      (OutgoingMessage.prototype.destroy = function destroy(t) {
        return (
          this.destroyed ||
            ((this.destroyed = !0),
            (this[it] = t),
            this.socket
              ? this.socket.destroy(t)
              : this.once("socket", function socketDestroyOnConnect(e) {
                  e.destroy(t);
                })),
          this
        );
      }),
      (OutgoingMessage.prototype._send = function _send(t, e, n, i) {
        if (!this._headerSent && null !== this._header) {
          if ("string" != typeof t || ("utf8" !== e && "latin1" !== e && e)) {
            const t = this._header;
            this.outputData.unshift({
              data: t,
              encoding: "latin1",
              callback: null,
            }),
              (this.outputSize += t.length),
              this._onPendingData(t.length);
          } else t = this._header + t;
          this._headerSent = !0;
        }
        return this._writeRaw(t, e, n, i);
      }),
      (OutgoingMessage.prototype._writeRaw = function _writeRaw(t, e, n, i) {
        const s = this.socket;
        if (s && s.destroyed) return !1;
        "function" == typeof e && ((n = e), (e = null));
        if (s && s._httpMessage === this && s.writable)
          return (
            this.outputData.length && this._flushOutput(s), s.write(t, e, n)
          );
        return (
          this.outputData.push({ data: t, encoding: e, callback: n }),
          (this.outputSize += t.length),
          this._onPendingData(t.length),
          this.outputSize < this[st]
        );
      }),
      (OutgoingMessage.prototype._storeHeader = function _storeHeader(t, e) {
        const n = {
          connection: !1,
          contLen: !1,
          te: !1,
          date: !1,
          expect: !1,
          trailer: !1,
          header: t,
        };
        if (e)
          if (e === this[R])
            for (const t in e) {
              const i = e[t];
              processHeader(this, n, i[0], i[1], !1);
            }
          else if (h(e))
            if (e.length && h(e[0]))
              for (let t = 0; t < e.length; t++) {
                const i = e[t];
                processHeader(this, n, i[0], i[1], !0);
              }
            else {
              if (e.length % 2 != 0) throw new K("headers", e);
              for (let t = 0; t < e.length; t += 2)
                processHeader(this, n, e[t + 0], e[t + 1], !0);
            }
          else
            for (const t in e) p(e, t) && processHeader(this, n, t, e[t], !0);
        let { header: i } = n;
        this.sendDate && !n.date && (i += "Date: " + L() + "\r\n");
        !this.chunkedEncoding ||
          (204 !== this.statusCode && 304 !== this.statusCode) ||
          (Z(
            this.statusCode +
              " response should not use chunked encoding, closing connection."
          ),
          (this.chunkedEncoding = !1),
          (this.shouldKeepAlive = !1));
        if (this._removedConnection)
          (this._last = !0), (this.shouldKeepAlive = !1);
        else if (!n.connection) {
          const t =
            this.shouldKeepAlive &&
            (n.contLen || this.useChunkedEncodingByDefault || this.agent);
          if (t && this.maxRequestsOnConnectionReached)
            i += "Connection: close\r\n";
          else if (t) {
            if (
              ((i += "Connection: keep-alive\r\n"),
              this._keepAliveTimeout && this._defaultKeepAlive)
            ) {
              const t = c(this._keepAliveTimeout / 1e3);
              let e = "";
              ~~this._maxRequestsPerSocket > 0 &&
                (e = `, max=${this._maxRequestsPerSocket}`),
                (i += `Keep-Alive: timeout=${t}${e}\r\n`);
            }
          } else (this._last = !0), (i += "Connection: close\r\n");
        }
        n.contLen ||
          n.te ||
          (this._hasBody
            ? this.useChunkedEncodingByDefault
              ? n.trailer ||
                this._removedContLen ||
                "number" != typeof this._contentLength
                ? this._removedTE
                  ? Z("Both Content-Length and Transfer-Encoding are removed")
                  : ((i += "Transfer-Encoding: chunked\r\n"),
                    (this.chunkedEncoding = !0))
                : (i += "Content-Length: " + this._contentLength + "\r\n")
              : (this._last = !0)
            : (this.chunkedEncoding = !1));
        if (!0 !== this.chunkedEncoding && n.trailer) throw new B();
        (this._header = i + "\r\n"),
          (this._headerSent = !1),
          n.expect && this._send("");
      });
    const ht = J((t, e) => {
        if ("string" != typeof t || !t || !A(t))
          throw new j(e || "Header name", t);
      }),
      at = J((t, e) => {
        if (void 0 === e) throw new x(e, t);
        if (v(e))
          throw (
            (Z('Header "%s" contains invalid characters', t),
            new U("header content", t))
          );
      });
    (OutgoingMessage.prototype.setHeader = function setHeader(t, e) {
      if (this._header) throw new I("set");
      ht(t), at(t, e);
      let n = this[R];
      return null === n && (this[R] = n = l(null)), (n[w(t)] = [t, e]), this;
    }),
      (OutgoingMessage.prototype.setHeaders = function setHeaders(t) {
        if (this._header) throw new I("set");
        if (
          !t ||
          h(t) ||
          "function" != typeof t.keys ||
          "function" != typeof t.get
        )
          throw new F("headers", ["Headers", "Map"], t);
        for (const e of t.keys()) this.setHeader(e, t.get(e));
        return this;
      }),
      (OutgoingMessage.prototype.appendHeader = function appendHeader(t, e) {
        if (this._header) throw new I("append");
        ht(t), at(t, e);
        const n = w(t),
          i = this[R];
        if (null === i || !i[n]) return this.setHeader(t, e);
        h(i[n][1]) || (i[n][1] = [i[n][1]]);
        const s = i[n][1];
        if (h(e)) for (let t = 0, n = e.length; t < n; t++) s.push(e[t]);
        else s.push(e);
        return this;
      }),
      (OutgoingMessage.prototype.getHeader = function getHeader(t) {
        Q(t, "name");
        const e = this[R];
        if (null === e) return;
        const n = e[w(t)];
        return n && n[1];
      }),
      (OutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {
        return null !== this[R] ? d(this[R]) : [];
      }),
      (OutgoingMessage.prototype.getRawHeaderNames =
        function getRawHeaderNames() {
          const t = this[R];
          if (null === t) return [];
          const e = _(t),
            n = r(e.length);
          for (let t = 0, i = e.length; t < i; t++) n[t] = e[t][0];
          return n;
        }),
      (OutgoingMessage.prototype.getHeaders = function getHeaders() {
        const t = this[R],
          e = l(null);
        if (t) {
          const n = d(t);
          for (let i = 0; i < n.length; ++i) {
            const s = n[i],
              o = t[s][1];
            e[s] = o;
          }
        }
        return e;
      }),
      (OutgoingMessage.prototype.hasHeader = function hasHeader(t) {
        return Q(t, "name"), null !== this[R] && !!this[R][w(t)];
      }),
      (OutgoingMessage.prototype.removeHeader = function removeHeader(t) {
        if ((Q(t, "name"), this._header)) throw new I("remove");
        const e = w(t);
        switch (e) {
          case "connection":
            this._removedConnection = !0;
            break;
          case "content-length":
            this._removedContLen = !0;
            break;
          case "transfer-encoding":
            this._removedTE = !0;
            break;
          case "date":
            this.sendDate = !1;
        }
        null !== this[R] && delete this[R][e];
      }),
      (OutgoingMessage.prototype._implicitHeader = function _implicitHeader() {
        throw new V("_implicitHeader()");
      }),
      g(OutgoingMessage.prototype, "headersSent", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: function () {
          return !!this._header;
        },
      }),
      g(OutgoingMessage.prototype, "writableEnded", {
        __proto__: null,
        get: function () {
          return this.finished;
        },
      }),
      g(OutgoingMessage.prototype, "writableNeedDrain", {
        __proto__: null,
        get: function () {
          return !this.destroyed && !this.finished && this[b];
        },
      });
    const ct = D.from("\r\n");
    function onError(t, e, n) {
      const s = t.socket ? t.socket[N] : void 0;
      S(s, i.nextTick, emitErrorNt, t, e, n);
    }
    function emitErrorNt(t, e, n) {
      n(e), "function" != typeof t.emit || t._closed || t.emit("error", e);
    }
    function strictContentLength(t) {
      return (
        t.strictContentLength &&
        null != t._contentLength &&
        t._hasBody &&
        !t._removedContLen &&
        !t.chunkedEncoding &&
        !t.hasHeader("transfer-encoding")
      );
    }
    function write_(t, e, n, s, o) {
      if (("function" != typeof s && (s = nop), null === e)) throw new $();
      if ("string" != typeof e && !X(e))
        throw new F("chunk", ["string", "Buffer", "Uint8Array"], e);
      let r, h, a;
      if ((t.finished ? (r = new Y()) : t.destroyed && (r = new G("write")), r))
        return t.destroyed ? i.nextTick(s, r) : onError(t, r, s), !1;
      if (t.strictContentLength) {
        if (
          ((h ??= "string" == typeof e ? D.byteLength(e, n) : e.byteLength),
          strictContentLength(t) &&
            (o ? t[nt] + h !== t._contentLength : t[nt] + h > t._contentLength))
        )
          throw new P(h + t[nt], t._contentLength);
        t[nt] += h;
      }
      if (
        (t._header ||
          (o &&
            ((h ??= "string" == typeof e ? D.byteLength(e, n) : e.byteLength),
            (t._contentLength = h)),
          t._implicitHeader()),
        !t._hasBody)
      ) {
        if (t[ot]) throw new W();
        return (
          Z(
            "This type of response MUST NOT have a body. Ignoring write() calls."
          ),
          i.nextTick(s),
          !0
        );
      }
      return (
        o ||
          !t.socket ||
          t.socket.writableCorked ||
          (t.socket.cork(), i.nextTick(connectionCorkNT, t.socket)),
        t.chunkedEncoding && 0 !== e.length
          ? ((h ??= "string" == typeof e ? D.byteLength(e, n) : e.byteLength),
            t._send(u(h, 16), "latin1", null),
            t._send(ct, null, null),
            t._send(e, n, null, h),
            (a = t._send(ct, null, s)))
          : (a = t._send(e, n, s, h)),
        Z("write ret = " + a),
        a
      );
    }
    function connectionCorkNT(t) {
      t.uncork();
    }
    function onFinish(t) {
      (t && t.socket && t.socket._hadError) || t.emit("finish");
    }
    (OutgoingMessage.prototype.write = function write(t, e, n) {
      "function" == typeof e && ((n = e), (e = null));
      const i = write_(this, t, e, n, !1);
      return i || (this[b] = !0), i;
    }),
      (OutgoingMessage.prototype.addTrailers = function addTrailers(t) {
        this._trailer = "";
        const e = d(t),
          n = h(t);
        for (let i = 0, s = e.length; i < s; i++) {
          let s, o;
          const r = e[i];
          n ? ((s = t[r][0]), (o = t[r][1])) : ((s = r), (o = t[r])),
            ht(s, "Trailer name");
          const c = h(o);
          if (!(c && o.length > 1) || (this[et] && this[et].has(w(s)))) {
            if ((c && (o = a(o, "; ")), v(o)))
              throw (
                (Z('Trailer "%s" contains invalid characters', s),
                new U("trailer content", s))
              );
            this._trailer += s + ": " + o + "\r\n";
          } else
            for (let t = 0, e = o.length; t < e; t++) {
              if (v(o[t]))
                throw (
                  (Z('Trailer "%s"[%d] contains invalid characters', s, t),
                  new U("trailer content", s))
                );
              this._trailer += s + ": " + o[t] + "\r\n";
            }
        }
      }),
      (OutgoingMessage.prototype.end = function end(t, e, n) {
        if (
          ("function" == typeof t
            ? ((n = t), (t = null), (e = null))
            : "function" == typeof e && ((n = e), (e = null)),
          t)
        ) {
          if (this.finished)
            return (
              onError(this, new Y(), "function" != typeof n ? nop : n), this
            );
          this.socket && this.socket.cork(), write_(this, t, e, null, !0);
        } else {
          if (this.finished)
            return (
              "function" == typeof n &&
                (this.writableFinished
                  ? n(new z("end"))
                  : this.on("finish", n)),
              this
            );
          this._header ||
            (this.socket && this.socket.cork(),
            (this._contentLength = 0),
            this._implicitHeader());
        }
        if (
          ("function" == typeof n && this.once("finish", n),
          strictContentLength(this) && this[nt] !== this._contentLength)
        )
          throw new P(this[nt], this._contentLength);
        const s = onFinish.bind(void 0, this);
        return (
          this._hasBody && this.chunkedEncoding
            ? this._send("0\r\n" + this._trailer + "\r\n", "latin1", s)
            : !this._headerSent || this.writableLength || t
            ? this._send("", "latin1", s)
            : i.nextTick(s),
          this.socket &&
            ((this.socket._writableState.corked = 1), this.socket.uncork()),
          (this[tt] = 0),
          (this.finished = !0),
          Z("outgoing message end."),
          0 === this.outputData.length &&
            this.socket &&
            this.socket._httpMessage === this &&
            this._finish(),
          this
        );
      }),
      (OutgoingMessage.prototype._finish = function _finish() {
        m(this.socket), this.emit("prefinish");
      }),
      (OutgoingMessage.prototype._flush = function _flush() {
        const t = this.socket;
        if (t && t.writable) {
          const e = this._flushOutput(t);
          this.finished
            ? this._finish()
            : e && this[b] && ((this[b] = !1), this.emit("drain"));
        }
      }),
      (OutgoingMessage.prototype._flushOutput = function _flushOutput(t) {
        for (; this[tt]; ) this[tt]--, t.cork();
        const e = this.outputData.length;
        if (e <= 0) return;
        const n = this.outputData;
        let i;
        t.cork();
        for (let s = 0; s < e; s++) {
          const { data: e, encoding: o, callback: r } = n[s];
          i = t.write(e, o, r);
        }
        return (
          t.uncork(),
          (this.outputData = []),
          this._onPendingData(-this.outputSize),
          (this.outputSize = 0),
          i
        );
      }),
      (OutgoingMessage.prototype.flushHeaders = function flushHeaders() {
        this._header || this._implicitHeader(), this._send("");
      }),
      (OutgoingMessage.prototype.pipe = function pipe() {
        this.emit("error", new q());
      }),
      (OutgoingMessage.prototype[H.captureRejectionSymbol] = function (t, e) {
        this.destroy(t);
      }),
      (n.exports = {
        kHighWaterMark: st,
        kUniqueHeaders: et,
        parseUniqueHeadersOption: function parseUniqueHeadersOption(t) {
          if (!h(t)) return null;
          const e = new y(),
            n = t.length;
          for (let i = 0; i < n; i++) e.add(w(t[i]));
          return e;
        },
        validateHeaderName: ht,
        validateHeaderValue: at,
        OutgoingMessage: OutgoingMessage,
      });
  },
  _http_server: function (e, t, n, o, s, i) {
    "use strict";
    const {
        ArrayIsArray: r,
        Error: a,
        MathMin: c,
        ObjectKeys: u,
        ObjectSetPrototypeOf: d,
        RegExpPrototypeExec: h,
        ReflectApply: l,
        Symbol: p,
        SymbolFor: m,
      } = i,
      g = t("net"),
      S = t("events"),
      T = t("internal/assert"),
      {
        parsers: f,
        freeParser: v,
        continueExpression: k,
        chunkExpression: _,
        kIncomingMessage: R,
        HTTPParser: E,
        isLenient: y,
        _checkInvalidHeaderChar: C,
        prepareError: P,
      } = t("_http_common"),
      { ConnectionsList: H } = s("http_parser"),
      {
        kUniqueHeaders: w,
        parseUniqueHeadersOption: O,
        OutgoingMessage: I,
      } = t("_http_outgoing"),
      {
        kOutHeaders: A,
        kNeedDrain: b,
        isTraceHTTPEnabled: M,
        traceBegin: q,
        traceEnd: D,
        getNextTraceEventId: L,
      } = t("internal/http"),
      { defaultTriggerAsyncIdScope: x, getOrSetAsyncId: N } = t(
        "internal/async_hooks"
      ),
      { IncomingMessage: U } = t("_http_incoming"),
      { connResetException: V, codes: W } = t("internal/errors"),
      {
        ERR_HTTP_REQUEST_TIMEOUT: j,
        ERR_HTTP_HEADERS_SENT: B,
        ERR_HTTP_INVALID_STATUS_CODE: F,
        ERR_HTTP_SOCKET_ENCODING: G,
        ERR_INVALID_ARG_TYPE: K,
        ERR_HTTP_SOCKET_ASSIGNED: z,
        ERR_INVALID_ARG_VALUE: $,
        ERR_INVALID_CHAR: Q,
      } = W,
      {
        validateInteger: X,
        validateBoolean: Y,
        validateLinkHeaderValue: J,
        validateObject: Z,
      } = t("internal/validators"),
      ee = t("buffer").Buffer,
      { DTRACE_HTTP_SERVER_REQUEST: te, DTRACE_HTTP_SERVER_RESPONSE: ne } =
        t("internal/dtrace"),
      { setInterval: oe, clearInterval: se } = t("timers");
    let ie = t("internal/util/debuglog").debuglog("http", (e) => {
      ie = e;
    });
    const re = t("diagnostics_channel"),
      ae = re.channel("http.server.request.start"),
      ce = re.channel("http.server.response.finish"),
      ue = p("ServerResponse"),
      de = p("ServerResponseStatistics"),
      {
        hasObserver: he,
        startPerf: le,
        stopPerf: pe,
      } = t("internal/perf/observe"),
      me = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        103: "Early Hints",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        208: "Already Reported",
        226: "IM Used",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        308: "Permanent Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a Teapot",
        421: "Misdirected Request",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Too Early",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required",
      },
      ge = 0 | E.kOnExecute,
      Se = 0 | E.kOnTimeout,
      Te = 0 | E.kLenientAll,
      fe = 0 | E.kLenientNone,
      ve = p("http.server.connections"),
      ke = p("http.server.connectionsCheckingInterval"),
      _e = "http.server.request";
    class HTTPServerAsyncResource {
      constructor(e, t) {
        (this.type = e), (this.socket = t);
      }
    }
    function ServerResponse(e, t) {
      I.call(this, t),
        "HEAD" === e.method && (this._hasBody = !1),
        (this.req = e),
        (this.sendDate = !0),
        (this._sent100 = !1),
        (this._expect_continue = !1),
        (e.httpVersionMajor < 1 || e.httpVersionMinor < 1) &&
          ((this.useChunkedEncodingByDefault = null !== h(_, e.headers.te)),
          (this.shouldKeepAlive = !1)),
        he("http") &&
          le(this, de, {
            type: "http",
            name: "HttpRequest",
            detail: {
              req: { method: e.method, url: e.url, headers: e.headers },
            },
          }),
        M() && ((this._traceEventId = L()), q(_e, this._traceEventId));
    }
    function onServerResponseClose() {
      this._httpMessage && emitCloseNT(this._httpMessage);
    }
    function storeHTTPOptions(e) {
      (this[R] = e.IncomingMessage || U),
        (this[ue] = e.ServerResponse || ServerResponse);
      const t = e.maxHeaderSize;
      void 0 !== t && X(t, "maxHeaderSize", 0), (this.maxHeaderSize = t);
      const n = e.insecureHTTPParser;
      void 0 !== n && Y(n, "options.insecureHTTPParser"),
        (this.insecureHTTPParser = n),
        void 0 === e.noDelay && (e.noDelay = !0);
      const o = e.requestTimeout;
      void 0 !== o
        ? (X(o, "requestTimeout", 0), (this.requestTimeout = o))
        : (this.requestTimeout = 3e5);
      const s = e.headersTimeout;
      if (
        (void 0 !== s
          ? (X(s, "headersTimeout", 0), (this.headersTimeout = s))
          : (this.headersTimeout = c(6e4, this.requestTimeout)),
        this.requestTimeout > 0 &&
          this.headersTimeout > 0 &&
          this.headersTimeout > this.requestTimeout)
      )
        throw new W.ERR_OUT_OF_RANGE("headersTimeout", "<= requestTimeout", s);
      const i = e.keepAliveTimeout;
      void 0 !== i
        ? (X(i, "keepAliveTimeout", 0), (this.keepAliveTimeout = i))
        : (this.keepAliveTimeout = 5e3);
      const r = e.connectionsCheckingInterval;
      void 0 !== r
        ? (X(r, "connectionsCheckingInterval", 0),
          (this.connectionsCheckingInterval = r))
        : (this.connectionsCheckingInterval = 3e4);
      const a = e.joinDuplicateHeaders;
      void 0 !== a && Y(a, "options.joinDuplicateHeaders"),
        (this.joinDuplicateHeaders = a);
      const u = e.rejectNonStandardBodyWrites;
      void 0 !== u
        ? (Y(u, "options.rejectNonStandardBodyWrites"),
          (this.rejectNonStandardBodyWrites = u))
        : (this.rejectNonStandardBodyWrites = !1);
    }
    function setupConnectionsTracking() {
      this[ve] || (this[ve] = new H()),
        (this[ke] = oe(
          checkConnections.bind(this),
          this.connectionsCheckingInterval
        ).unref());
    }
    function httpServerPreClose(e) {
      se(e[ke]);
    }
    function Server(e, t) {
      if (!(this instanceof Server)) return new Server(e, t);
      if ("function" == typeof e) (t = e), (e = {});
      else {
        if (null != e && "object" != typeof e)
          throw new K("options", "object", e);
        e = { ...e };
      }
      storeHTTPOptions.call(this, e),
        g.Server.call(this, {
          allowHalfOpen: !0,
          noDelay: e.noDelay,
          keepAlive: e.keepAlive,
          keepAliveInitialDelay: e.keepAliveInitialDelay,
          highWaterMark: e.highWaterMark,
        }),
        t && this.on("request", t),
        (this.httpAllowHalfOpen = !1),
        this.on("connection", connectionListener),
        this.on("listening", setupConnectionsTracking),
        (this.timeout = 0),
        (this.maxHeadersCount = null),
        (this.maxRequestsPerSocket = 0),
        (this[w] = O(e.uniqueHeaders));
    }
    function checkConnections() {
      if (0 === this.headersTimeout && 0 === this.requestTimeout) return;
      const e = this[ve].expired(this.headersTimeout, this.requestTimeout);
      for (let t = 0; t < e.length; t++) {
        const n = e[t].socket;
        n && onRequestTimeout(n);
      }
    }
    function connectionListener(e) {
      x(N(e), connectionListenerInternal, this, e);
    }
    function connectionListenerInternal(e, t) {
      ie("SERVER new http connection"),
        (t.server = e),
        e.timeout &&
          "function" == typeof t.setTimeout &&
          t.setTimeout(e.timeout),
        t.on("timeout", socketOnTimeout);
      const n = f.alloc(),
        o = void 0 === e.insecureHTTPParser ? y() : e.insecureHTTPParser;
      n.initialize(
        E.REQUEST,
        new HTTPServerAsyncResource("HTTPINCOMINGMESSAGE", t),
        e.maxHeaderSize || 0,
        o ? Te : fe,
        e[ve]
      ),
        (n.socket = t),
        (t.parser = n),
        "number" == typeof e.maxHeadersCount &&
          (n.maxHeaderPairs = e.maxHeadersCount << 1);
      const s = {
        onData: null,
        onEnd: null,
        onClose: null,
        onDrain: null,
        outgoing: [],
        incoming: [],
        outgoingData: 0,
        requestsCount: 0,
        keepAliveTimeoutSet: !1,
      };
      (s.onData = socketOnData.bind(void 0, e, t, n, s)),
        (s.onEnd = socketOnEnd.bind(void 0, e, t, n, s)),
        (s.onClose = socketOnClose.bind(void 0, t, s)),
        (s.onDrain = socketOnDrain.bind(void 0, t, s)),
        t.on("data", s.onData),
        t.on("error", socketOnError),
        t.on("end", s.onEnd),
        t.on("close", s.onClose),
        t.on("drain", s.onDrain),
        (n.onIncoming = parserOnIncoming.bind(void 0, e, t, s)),
        t.on("resume", onSocketResume),
        t.on("pause", onSocketPause),
        (t.on = generateSocketListenerWrapper("on")),
        (t.addListener = generateSocketListenerWrapper("addListener")),
        (t.prependListener = generateSocketListenerWrapper("prependListener")),
        (t.setEncoding = socketSetEncoding),
        t._handle &&
          t._handle.isStreamBase &&
          !t._handle._consumed &&
          ((n._consumed = !0),
          (t._handle._consumed = !0),
          n.consume(t._handle)),
        (n[ge] = onParserExecute.bind(void 0, e, t, n, s)),
        (n[Se] = onParserTimeout.bind(void 0, e, t)),
        (t._paused = !1);
    }
    function socketSetEncoding() {
      throw new G();
    }
    function updateOutgoingData(e, t, n) {
      (t.outgoingData += n), socketOnDrain(e, t);
    }
    function socketOnDrain(e, t) {
      const n = t.outgoingData > e.writableHighWaterMark;
      e._paused &&
        !n &&
        ((e._paused = !1), e.parser && e.parser.resume(), e.resume());
      const o = e._httpMessage;
      o && !o.finished && o[b] && ((o[b] = !1), o.emit("drain"));
    }
    function socketOnTimeout() {
      const e = this.parser && this.parser.incoming,
        t = e && !e.complete && e.emit("timeout", this),
        n = this._httpMessage,
        o = n && n.emit("timeout", this),
        s = this.server.emit("timeout", this);
      t || o || s || this.destroy();
    }
    function socketOnClose(e, t) {
      ie("server socket close"),
        v(e.parser, null, e),
        (function abortIncoming(e) {
          for (; e.length; ) {
            e.shift().destroy(V("aborted"));
          }
        })(t.incoming);
    }
    function socketOnEnd(e, t, n, o) {
      const s = n.finish();
      s instanceof a
        ? (ie("parse error"), socketOnError.call(t, s))
        : e.httpAllowHalfOpen
        ? o.outgoing.length
          ? (o.outgoing[o.outgoing.length - 1]._last = !0)
          : t._httpMessage
          ? (t._httpMessage._last = !0)
          : t.end()
        : t.end();
    }
    function socketOnData(e, t, n, o, s) {
      T(!t._paused), ie("SERVER socketOnData %d", s.length);
      const i = n.execute(s);
      onParserExecuteCommon(e, t, n, o, i, s);
    }
    function onRequestTimeout(e) {
      socketOnError.call(e, new j());
    }
    function onParserExecute(e, t, n, o, s) {
      t._unrefTimer(),
        ie("SERVER socketOnParserExecute %d", s),
        onParserExecuteCommon(e, t, n, o, s, void 0);
    }
    function onParserTimeout(e, t) {
      e.emit("timeout", t) || t.destroy();
    }
    d(ServerResponse.prototype, I.prototype),
      d(ServerResponse, I),
      (ServerResponse.prototype._finish = function _finish() {
        if (
          (ne(this.socket),
          this[de] &&
            he("http") &&
            pe(this, de, {
              detail: {
                res: {
                  statusCode: this.statusCode,
                  statusMessage: this.statusMessage,
                  headers:
                    "function" == typeof this.getHeaders
                      ? this.getHeaders()
                      : {},
                },
              },
            }),
          I.prototype._finish.call(this),
          M() && "number" == typeof this._traceEventId)
        ) {
          const e = { url: this.req?.url, statusCode: this.statusCode };
          D(_e, this._traceEventId, e);
        }
      }),
      (ServerResponse.prototype.statusCode = 200),
      (ServerResponse.prototype.statusMessage = void 0),
      (ServerResponse.prototype.assignSocket = function assignSocket(e) {
        if (e._httpMessage) throw new z();
        (e._httpMessage = this),
          e.on("close", onServerResponseClose),
          (this.socket = e),
          this.emit("socket", e),
          this._flush();
      }),
      (ServerResponse.prototype.detachSocket = function detachSocket(e) {
        T(e._httpMessage === this),
          e.removeListener("close", onServerResponseClose),
          (e._httpMessage = null),
          (this.socket = null);
      }),
      (ServerResponse.prototype.writeContinue = function writeContinue(e) {
        this._writeRaw("HTTP/1.1 100 Continue\r\n\r\n", "ascii", e),
          (this._sent100 = !0);
      }),
      (ServerResponse.prototype.writeProcessing = function writeProcessing(e) {
        this._writeRaw("HTTP/1.1 102 Processing\r\n\r\n", "ascii", e);
      }),
      (ServerResponse.prototype.writeEarlyHints = function writeEarlyHints(
        e,
        t
      ) {
        let n = "HTTP/1.1 103 Early Hints\r\n";
        if ((Z(e, "hints"), null === e.link || void 0 === e.link)) return;
        const o = J(e.link);
        if (0 !== o.length) {
          n += "Link: " + o + "\r\n";
          for (const t of u(e)) "link" !== t && (n += t + ": " + e[t] + "\r\n");
          (n += "\r\n"), this._writeRaw(n, "ascii", t);
        }
      }),
      (ServerResponse.prototype._implicitHeader = function _implicitHeader() {
        this.writeHead(this.statusCode);
      }),
      (ServerResponse.prototype.writeHead = function writeHead(e, t, n) {
        const o = e;
        if ((e |= 0) < 100 || e > 999) throw new F(o);
        "string" == typeof t
          ? (this.statusMessage = t)
          : (this.statusMessage || (this.statusMessage = me[e] || "unknown"),
            (n ??= t));
        let s;
        if (((this.statusCode = e), this[A])) {
          let e;
          if (r(n)) {
            if (n.length % 2 != 0) throw new $("headers", n);
            for (let t = 0; t < n.length; t += 2)
              (e = n[t + 0]), e && this.setHeader(e, n[t + 1]);
          } else if (n) {
            const t = u(n);
            for (let o = 0; o < t.length; o++)
              (e = t[o]), e && this.setHeader(e, n[e]);
          }
          if (void 0 === e && this._header) throw new B("render");
          s = this[A];
        } else s = n;
        if (C(this.statusMessage)) throw new Q("statusMessage");
        const i = `HTTP/1.1 ${e} ${this.statusMessage}\r\n`;
        (204 === e || 304 === e || (e >= 100 && e <= 199)) &&
          (this._hasBody = !1);
        this._expect_continue && !this._sent100 && (this.shouldKeepAlive = !1);
        return this._storeHeader(i, s), this;
      }),
      (ServerResponse.prototype.writeHeader =
        ServerResponse.prototype.writeHead),
      d(Server.prototype, g.Server.prototype),
      d(Server, g.Server),
      (Server.prototype.close = function () {
        httpServerPreClose(this), l(g.Server.prototype.close, this, arguments);
      }),
      (Server.prototype.closeAllConnections = function () {
        if (!this[ve]) return;
        const e = this[ve].all();
        for (let t = 0, n = e.length; t < n; t++) e[t].socket.destroy();
      }),
      (Server.prototype.closeIdleConnections = function () {
        if (!this[ve]) return;
        const e = this[ve].idle();
        for (let t = 0, n = e.length; t < n; t++)
          (e[t].socket._httpMessage && !e[t].socket._httpMessage.finished) ||
            e[t].socket.destroy();
      }),
      (Server.prototype.setTimeout = function setTimeout(e, t) {
        return (this.timeout = e), t && this.on("timeout", t), this;
      }),
      (Server.prototype[S.captureRejectionSymbol] = function (e, t, ...n) {
        switch (t) {
          case "request": {
            const { 1: e } = n;
            if (e.headersSent || e.writableEnded) e.destroy();
            else {
              const t = e.getHeaderNames();
              for (let n = 0; n < t.length; n++) e.removeHeader(t[n]);
              (e.statusCode = 500), e.end(me[500]);
            }
            break;
          }
          default:
            g.Server.prototype[m("nodejs.rejection")].apply(this, arguments);
        }
      });
    const noop = () => {},
      Re = ee.from(
        `HTTP/1.1 400 ${me[400]}\r\nConnection: close\r\n\r\n`,
        "ascii"
      ),
      Ee = ee.from(
        `HTTP/1.1 408 ${me[408]}\r\nConnection: close\r\n\r\n`,
        "ascii"
      ),
      ye = ee.from(
        `HTTP/1.1 431 ${me[431]}\r\nConnection: close\r\n\r\n`,
        "ascii"
      ),
      Ce = ee.from(
        `HTTP/1.1 413 ${me[413]}\r\nConnection: close\r\n\r\n`,
        "ascii"
      );
    function warnUnclosedSocket() {
      warnUnclosedSocket.emitted ||
        ((warnUnclosedSocket.emitted = !0),
        o.emitWarning(
          "An error event has already been emitted on the socket. Please use the destroy method on the socket while handling a 'clientError' event."
        ));
    }
    function socketOnError(e) {
      if (
        (this.removeListener("error", socketOnError),
        0 === this.listenerCount("error", noop)
          ? this.on("error", noop)
          : warnUnclosedSocket(),
        !this.server.emit("clientError", e, this))
      ) {
        if (
          this.writable &&
          (!this._httpMessage || !this._httpMessage._headerSent)
        ) {
          let t;
          switch (e.code) {
            case "HPE_HEADER_OVERFLOW":
              t = ye;
              break;
            case "HPE_CHUNK_EXTENSIONS_OVERFLOW":
              t = Ce;
              break;
            case "ERR_HTTP_REQUEST_TIMEOUT":
              t = Ee;
              break;
            default:
              t = Re;
          }
          this.write(t);
        }
        this.destroy(e);
      }
    }
    function onParserExecuteCommon(e, t, n, o, s, i) {
      if ((resetSocketTimeout(e, t, o), s instanceof a))
        P(s, n, i), ie("parse error", s), socketOnError.call(t, s);
      else if (n.incoming && n.incoming.upgrade) {
        const r = n.incoming;
        ie("SERVER upgrade or connect", r.method),
          i || (i = n.getCurrentBuffer()),
          t.removeListener("data", o.onData),
          t.removeListener("end", o.onEnd),
          t.removeListener("close", o.onClose),
          t.removeListener("drain", o.onDrain),
          t.removeListener("error", socketOnError),
          t.removeListener("timeout", socketOnTimeout),
          unconsume(n, t),
          n.finish(),
          v(n, r, t),
          (n = null);
        const a = "CONNECT" === r.method ? "connect" : "upgrade";
        if ("upgrade" === a || e.listenerCount(a) > 0) {
          ie("SERVER have listener for %s", a);
          const n = i.slice(s, i.length);
          (t.readableFlowing = null), e.emit(a, r, t, n);
        } else t.destroy();
      } else
        n.incoming &&
          "PRI" === n.incoming.method &&
          (ie("SERVER got PRI request"), t.destroy());
      t._paused && t.parser && (ie("pause parser"), t.parser.pause());
    }
    function clearIncoming(e) {
      const t = (e = e || this).socket && e.socket.parser;
      t &&
        t.incoming === e &&
        (e.readableEnded ? (t.incoming = null) : e.on("end", clearIncoming));
    }
    function resOnFinish(e, t, n, s, i) {
      if (
        (ce.hasSubscribers &&
          ce.publish({ request: e, response: t, socket: n, server: i }),
        T(0 === s.incoming.length || s.incoming[0] === e),
        s.incoming.shift(),
        e._consuming || e._readableState.resumeScheduled || e._dump(),
        t.detachSocket(n),
        clearIncoming(e),
        o.nextTick(emitCloseNT, t),
        t._last)
      )
        "function" == typeof n.destroySoon ? n.destroySoon() : n.end();
      else if (0 === s.outgoing.length)
        i.keepAliveTimeout &&
          "function" == typeof n.setTimeout &&
          (n.setTimeout(i.keepAliveTimeout), (s.keepAliveTimeoutSet = !0));
      else {
        const e = s.outgoing.shift();
        e && e.assignSocket(n);
      }
    }
    function emitCloseNT(e) {
      e._closed || ((e.destroyed = !0), (e._closed = !0), e.emit("close"));
    }
    function parserOnIncoming(e, t, n, o, s) {
      if (
        (resetSocketTimeout(e, t, n),
        o.upgrade &&
          ((o.upgrade =
            "CONNECT" === o.method || e.listenerCount("upgrade") > 0),
          o.upgrade))
      )
        return 2;
      if ((n.incoming.push(o), !t._paused)) {
        (t._writableState.needDrain ||
          n.outgoingData >= t.writableHighWaterMark) &&
          ((t._paused = !0), t.pause());
      }
      const i = new e[ue](o, {
        highWaterMark: t.writableHighWaterMark,
        rejectNonStandardBodyWrites: e.rejectNonStandardBodyWrites,
      });
      (i._keepAliveTimeout = e.keepAliveTimeout),
        (i._maxRequestsPerSocket = e.maxRequestsPerSocket),
        (i._onPendingData = updateOutgoingData.bind(void 0, t, n)),
        (i.shouldKeepAlive = s),
        (i[w] = e[w]),
        te(o, t),
        ae.hasSubscribers &&
          ae.publish({ request: o, response: i, socket: t, server: e }),
        t._httpMessage ? n.outgoing.push(i) : i.assignSocket(t),
        i.on("finish", resOnFinish.bind(void 0, o, i, t, n, e));
      let r = !1;
      if (1 === o.httpVersionMajor && 1 === o.httpVersionMinor) {
        const s =
          "number" == typeof e.maxRequestsPerSocket &&
          e.maxRequestsPerSocket > 0;
        s &&
          (n.requestsCount++,
          (i.maxRequestsOnConnectionReached =
            e.maxRequestsPerSocket <= n.requestsCount)),
          s && e.maxRequestsPerSocket < n.requestsCount
            ? ((r = !0), e.emit("dropRequest", o, t), i.writeHead(503), i.end())
            : void 0 !== o.headers.expect &&
              ((r = !0),
              null !== h(k, o.headers.expect)
                ? ((i._expect_continue = !0),
                  e.listenerCount("checkContinue") > 0
                    ? e.emit("checkContinue", o, i)
                    : (i.writeContinue(), e.emit("request", o, i)))
                : e.listenerCount("checkExpectation") > 0
                ? e.emit("checkExpectation", o, i)
                : (i.writeHead(417), i.end()));
      }
      return r || e.emit("request", o, i), 0;
    }
    function resetSocketTimeout(e, t, n) {
      n.keepAliveTimeoutSet &&
        (t.setTimeout(e.timeout || 0), (n.keepAliveTimeoutSet = !1));
    }
    function onSocketResume() {
      this._paused
        ? this.pause()
        : this._handle &&
          !this._handle.reading &&
          ((this._handle.reading = !0), this._handle.readStart());
    }
    function onSocketPause() {
      this._handle &&
        this._handle.reading &&
        ((this._handle.reading = !1), this._handle.readStop());
    }
    function unconsume(e, t) {
      t._handle &&
        (e._consumed && e.unconsume(),
        (e._consumed = !1),
        t.removeListener("pause", onSocketPause),
        t.removeListener("resume", onSocketResume));
    }
    function generateSocketListenerWrapper(e) {
      return function socketListenerWrap(t, n) {
        const o = g.Socket.prototype[e].call(this, t, n);
        return this.parser
          ? (("data" !== t && "readable" !== t) || unconsume(this.parser, this),
            o)
          : ((this.on = g.Socket.prototype.on),
            (this.addListener = g.Socket.prototype.addListener),
            (this.prependListener = g.Socket.prototype.prependListener),
            o);
      };
    }
    n.exports = {
      STATUS_CODES: me,
      Server: Server,
      ServerResponse: ServerResponse,
      setupConnectionsTracking: setupConnectionsTracking,
      storeHTTPOptions: storeHTTPOptions,
      _connectionListener: connectionListener,
      kServerResponse: ue,
      httpServerPreClose: httpServerPreClose,
      kConnectionsCheckingInterval: ke,
    };
  },
  _stream_duplex: function (t, e, s, r, u, _) {
    "use strict";
    s.exports = e("stream").Duplex;
  },
  _stream_passthrough: function (s, t, r, e, o, u) {
    "use strict";
    r.exports = t("stream").PassThrough;
  },
  _stream_readable: function (e, t, s, a, r, _) {
    "use strict";
    s.exports = t("stream").Readable;
  },
  _stream_transform: function (r, s, t, e, n, o) {
    "use strict";
    t.exports = s("stream").Transform;
  },
  _stream_wrap: function (e, t, r, n, a, i) {
    "use strict";
    (r.exports = t("internal/js_stream_socket")),
      n.emitWarning(
        "The _stream_wrap module is deprecated.",
        "DeprecationWarning",
        "DEP0125"
      );
  },
  _stream_writable: function (t, e, r, s, i, _) {
    "use strict";
    r.exports = e("stream").Writable;
  },
  _tls_common: function (e, t, n, r, i, c) {
    "use strict";
    const o = t("tls"),
      {
        ArrayPrototypePush: s,
        JSONParse: u,
        ObjectCreate: S,
        RegExpPrototypeSymbolReplace: a,
      } = c,
      {
        codes: {
          ERR_TLS_INVALID_PROTOCOL_VERSION: f,
          ERR_TLS_PROTOCOL_VERSION_CONFLICT: l,
        },
      } = t("internal/errors"),
      {
        crypto: {
          SSL_OP_CIPHER_SERVER_PREFERENCE: C,
          TLS1_VERSION: _,
          TLS1_1_VERSION: O,
          TLS1_2_VERSION: E,
          TLS1_3_VERSION: R,
        },
      } = i("constants"),
      { kEmptyObject: x } = t("internal/util"),
      { validateInteger: L } = t("internal/validators"),
      { configSecureContext: I } = t("internal/tls/secure-context");
    function toV(e, t, n) {
      if ((null == t && (t = n), "TLSv1" === t)) return _;
      if ("TLSv1.1" === t) return O;
      if ("TLSv1.2" === t) return E;
      if ("TLSv1.3" === t) return R;
      throw new f(t, e);
    }
    const { SecureContext: T } = i("crypto");
    function SecureContext(e, t, n, r) {
      if (!(this instanceof SecureContext))
        return new SecureContext(e, t, n, r);
      if (e) {
        if (null != n) throw new l(n, e);
        if (null != r) throw new l(r, e);
      }
      (this.context = new T()),
        this.context.init(
          e,
          toV("minimum", n, o.DEFAULT_MIN_VERSION),
          toV("maximum", r, o.DEFAULT_MAX_VERSION)
        ),
        t && (L(t, "secureOptions"), this.context.setOptions(t));
    }
    n.exports = {
      SecureContext: SecureContext,
      createSecureContext: function createSecureContext(e) {
        e || (e = x);
        const {
          honorCipherOrder: t,
          minVersion: n,
          maxVersion: r,
          secureProtocol: i,
        } = e;
        let { secureOptions: c } = e;
        t && (c |= C);
        const o = new SecureContext(i, c, n, r);
        return I(o.context, e), o;
      },
      translatePeerCertificate: function translatePeerCertificate(e) {
        if (!e) return null;
        if (
          (null != e.issuerCertificate &&
            e.issuerCertificate !== e &&
            (e.issuerCertificate = translatePeerCertificate(
              e.issuerCertificate
            )),
          null != e.infoAccess)
        ) {
          const t = e.infoAccess;
          (e.infoAccess = S(null)),
            a(/([^\n:]*):([^\n]*)(?:\n|$)/g, t, (t, n, r) => {
              34 === r.charCodeAt(0) && (r = u(r)),
                n in e.infoAccess
                  ? s(e.infoAccess[n], r)
                  : (e.infoAccess[n] = [r]);
            });
        }
        return e;
      },
    };
  },
  _tls_wrap: function (e, t, s, n, i, r) {
    "use strict";
    const {
        ArrayPrototypeForEach: o,
        ArrayPrototypeJoin: a,
        ArrayPrototypePush: c,
        FunctionPrototype: h,
        ObjectAssign: l,
        ObjectDefineProperty: d,
        ObjectSetPrototypeOf: u,
        ReflectApply: p,
        RegExp: S,
        RegExpPrototypeExec: _,
        RegExpPrototypeSymbolReplace: k,
        StringPrototypeReplaceAll: y,
        StringPrototypeSlice: C,
        Symbol: f,
        SymbolFor: v,
      } = r,
      { assertCrypto: g, deprecate: m, kEmptyObject: L } = t("internal/util");
    g();
    const { setImmediate: P } = t("timers"),
      b = t("internal/assert"),
      T = t("crypto"),
      E = t("events"),
      w = t("net"),
      x = t("tls"),
      O = t("_tls_common"),
      { kReinitializeHandle: I } = t("internal/net"),
      A = t("internal/js_stream_socket"),
      { Buffer: N } = t("buffer");
    let R = t("internal/util/debuglog").debuglog("tls", (e) => {
      R = e;
    });
    const { TCP: K, constants: z } = i("tcp_wrap"),
      H = i("tls_wrap"),
      { Pipe: j, constants: D } = i("pipe_wrap"),
      { owner_symbol: q } = t("internal/async_hooks").symbols,
      { isArrayBufferView: U } = t("internal/util/types"),
      { SecureContext: V } = i("crypto"),
      { connResetException: M, codes: W } = t("internal/errors"),
      {
        ERR_INVALID_ARG_TYPE: F,
        ERR_INVALID_ARG_VALUE: B,
        ERR_MULTIPLE_CALLBACK: $,
        ERR_SOCKET_CLOSED: X,
        ERR_TLS_ALPN_CALLBACK_INVALID_RESULT: G,
        ERR_TLS_ALPN_CALLBACK_WITH_PROTOCOLS: J,
        ERR_TLS_DH_PARAM_SIZE: Q,
        ERR_TLS_HANDSHAKE_TIMEOUT: Y,
        ERR_TLS_INVALID_CONTEXT: Z,
        ERR_TLS_RENEGOTIATION_DISABLED: ee,
        ERR_TLS_REQUIRED_SERVER_NAME: te,
        ERR_TLS_SESSION_ATTACK: se,
        ERR_TLS_SNI_FROM_SERVER: ne,
        ERR_TLS_INVALID_STATE: ie,
      } = W,
      { onpskexchange: re } = i("symbols"),
      { getOptionValue: oe, getAllowUnauthorized: ae } = t("internal/options"),
      {
        validateBoolean: ce,
        validateBuffer: he,
        validateFunction: le,
        validateInt32: de,
        validateNumber: ue,
        validateObject: pe,
        validateString: Se,
        validateUint32: _e,
      } = t("internal/validators"),
      { InternalX509Certificate: ke } = t("internal/crypto/x509"),
      ye = oe("--trace-tls"),
      Ce = oe("--tls-keylog"),
      { appendFile: fe } = t("fs"),
      ve = f("connect-options"),
      ge = f("disable-renegotiation"),
      me = f("error-emitted"),
      Le = f("handshake-timeout"),
      Pe = f("res"),
      be = f("snicallback"),
      Te = f("alpncallback"),
      Ee = f("enableTrace"),
      we = f("pskcallback"),
      xe = f("pskidentityhint"),
      Oe = f("pendingSession"),
      Ie = f("verified"),
      Ae = h;
    let Ne = !1,
      Re = !1;
    function onhandshakestart(e) {
      R("server onhandshakestart");
      const { lastHandshakeTime: t } = this;
      if (
        (b(e >= t, `now (${e}) < lastHandshakeTime (${t})`),
        (this.lastHandshakeTime = e),
        0 === t)
      )
        return;
      e - t >= 1e3 * x.CLIENT_RENEG_WINDOW
        ? (this.handshakes = 1)
        : this.handshakes++;
      const s = this[q];
      b(s._tlsOptions.isServer),
        this.handshakes > x.CLIENT_RENEG_LIMIT
          ? s._emitTLSError(new se())
          : s[ge] && s._emitTLSError(new ee());
    }
    function onhandshakedone() {
      R("server onhandshakedone");
      const e = this[q];
      b(e._tlsOptions.isServer),
        e._newSessionPending ? (e._securePending = !0) : e._finishInit();
    }
    function loadSession(e) {
      R(
        "server onclienthello",
        "sessionid.len",
        e.sessionId.length,
        "ticket?",
        e.tlsTicket
      );
      const t = this[q];
      let s = !1;
      (e.sessionId.length <= 0 ||
        e.tlsTicket ||
        (t.server &&
          !t.server.emit(
            "resumeSession",
            e.sessionId,
            function onSession(e, n) {
              return (
                R("server resumeSession callback(err %j, sess? %s)", e, !!n),
                s
                  ? t.destroy(new $())
                  : ((s = !0),
                    e
                      ? t.destroy(e)
                      : null === t._handle
                      ? t.destroy(new X())
                      : (t._handle.loadSession(n), void t._handle.endParser()))
              );
            }
          ))) &&
        t._handle.endParser();
    }
    function loadSNI(e) {
      const t = this[q],
        s = e.servername;
      if (!s || !t._SNICallback) return requestOCSP(t, e);
      let n = !1;
      t._SNICallback(s, (s, i) =>
        n
          ? t.destroy(new $())
          : ((n = !0),
            s
              ? t.destroy(s)
              : null === t._handle
              ? t.destroy(new X())
              : (i && (t._handle.sni_context = i.context || i),
                void requestOCSP(t, e)))
      );
    }
    function callALPNCallback(e) {
      const t = this[q],
        s = this.getServername(),
        n = [];
      let i = 0;
      for (; i < e.length; ) {
        const t = e[i];
        i += 1;
        const s = e.slice(i, i + t);
        (i += t), n.push(s.toString("ascii"));
      }
      const r = t[Te]({ servername: s, protocols: n });
      if (void 0 === r) return;
      const o = n.indexOf(r);
      if (-1 === o) throw new G(r, n);
      let a = 0;
      for (let e = 0; e < o; e++) a += 1 + n[e].length;
      return a;
    }
    function requestOCSP(e, t) {
      if (!t.OCSPRequest || !e.server) return requestOCSPDone(e);
      let s = e._handle.sni_context;
      if (!s && ((s = e.server._sharedCreds), !s)) return requestOCSPDone(e);
      if (
        (s.context && (s = s.context),
        0 === e.server.listenerCount("OCSPRequest"))
      )
        return requestOCSPDone(e);
      let n = !1;
      R("server oncertcb emit OCSPRequest"),
        e.server.emit(
          "OCSPRequest",
          s.getCertificate(),
          s.getIssuer(),
          (t, s) => (
            R(
              "server OCSPRequest done",
              "handle?",
              !!e._handle,
              "once?",
              n,
              "response?",
              !!s,
              "err?",
              t
            ),
            n
              ? e.destroy(new $())
              : ((n = !0),
                t
                  ? e.destroy(t)
                  : null === e._handle
                  ? e.destroy(new X())
                  : (s && e._handle.setOCSPResponse(s),
                    void requestOCSPDone(e)))
          )
        );
    }
    function requestOCSPDone(e) {
      R("server certcb done");
      try {
        e._handle.certCbDone();
      } catch (t) {
        R("server certcb done errored", t), e.destroy(t);
      }
    }
    function onnewsessionclient(e, t) {
      R("client emit session");
      const s = this[q];
      s[Ie] ? s.emit("session", t) : (s[Oe] = t);
    }
    function onnewsession(e, t) {
      R("onnewsession");
      const s = this[q];
      if (!s.server) return;
      let n = !1;
      const done = () => {
        if ((R("onnewsession done"), !n)) {
          if (((n = !0), null === s._handle)) return s.destroy(new X());
          this.newSessionDone(),
            (s._newSessionPending = !1),
            s._securePending && s._finishInit(),
            (s._securePending = !1);
        }
      };
      (s._newSessionPending = !0),
        s.server.emit("newSession", e, t, done) || done();
    }
    function onPskServerCallback(e, t) {
      const s = this[q],
        n = s[we](s, e);
      if (null == n) return;
      let i;
      if (U(n)) i = n;
      else {
        if ("object" != typeof n)
          throw new F("ret", ["Object", "Buffer", "TypedArray", "DataView"], n);
        (i = n.psk), he(i, "psk");
      }
      if (i.length > t)
        throw new B("psk", i, `Pre-shared key exceeds ${t} bytes`);
      return i;
    }
    function onPskClientCallback(e, t, s) {
      const n = this[q][we](e);
      if (null != n) {
        if ((pe(n, "ret"), he(n.psk, "psk"), n.psk.length > t))
          throw new B("psk", n.psk, `Pre-shared key exceeds ${t} bytes`);
        if ((Se(n.identity, "identity"), N.byteLength(n.identity) > s))
          throw new B(
            "identity",
            n.identity,
            `PSK identity exceeds ${s} bytes`
          );
        return { psk: n.psk, identity: n.identity };
      }
    }
    function onkeylog(e) {
      R("onkeylog"), this[q].emit("keylog", e);
    }
    function onocspresponse(e) {
      R("client onocspresponse"), this[q].emit("OCSPResponse", e);
    }
    function onerror(e) {
      const t = this[q];
      R(
        "%s onerror %s had? %j",
        "object" == typeof t._tlsOptions && null !== t._tlsOptions
          ? t._tlsOptions.isServer
            ? "server"
            : "client"
          : "unknown",
        e,
        t._hadError
      ),
        t._hadError ||
          ((t._hadError = !0),
          t._secureEstablished
            ? t._tlsOptions?.isServer &&
              t._rejectUnauthorized &&
              null !== _(/peer did not return a certificate/, e.message)
              ? t.destroy()
              : t._emitTLSError(e)
            : ((t._closeAfterHandlingError = !0), t.destroy(e)));
    }
    function initRead(e, t) {
      if (
        (R(
          "%s initRead",
          e._tlsOptions.isServer ? "server" : "client",
          "handle?",
          !!e._handle,
          "buffered?",
          !!t && t.readableLength
        ),
        e._handle)
      ) {
        if (t && t.readableLength) {
          let s;
          for (; null !== (s = t.read()); ) e._handle.receive(s);
        }
        e.read(0);
      }
    }
    function TLSSocket(e, t) {
      const s = { ...t };
      let i,
        r,
        o,
        a = s.enableTrace;
      null == a
        ? ((a = ye),
          a &&
            !Re &&
            ((Re = !0),
            n.emitWarning(
              "Enabling --trace-tls can expose sensitive data in the resulting log."
            )))
        : ce(a, "options.enableTrace"),
        s.ALPNProtocols && x.convertALPNProtocols(s.ALPNProtocols, s),
        (this._tlsOptions = s),
        (this._secureEstablished = !1),
        (this._securePending = !1),
        (this._newSessionPending = !1),
        (this._controlReleased = !1),
        (this.secureConnecting = !0),
        (this._SNICallback = null),
        (this[Te] = null),
        (this.servername = null),
        (this.alpnProtocol = null),
        (this.authorized = !1),
        (this.authorizationError = null),
        (this[Pe] = null),
        (this[Ie] = !1),
        (this[Oe] = null),
        e
          ? ((i = e instanceof w.Socket && e._handle ? e : new A(e)),
            (r = i._handle),
            (o = i.writableLength > 0))
          : ((i = null), (o = !1)),
        (this.encrypted = !0),
        p(w.Socket, this, [
          {
            handle: this._wrapHandle(i, r, o),
            allowHalfOpen: e ? e.allowHalfOpen : s.allowHalfOpen,
            pauseOnCreate: s.pauseOnConnect,
            manualStart: !0,
            highWaterMark: s.highWaterMark,
            onread: e ? null : s.onread,
            signal: s.signal,
          },
        ]),
        (this.ssl = this._handle),
        this.on("error", this._tlsError),
        this._init(e, i),
        a && this._handle && this._handle.enableTrace(),
        o &&
          i.write("", (e) => {
            if (e)
              return (
                R(
                  "error got before writing any tls data to the underlying stream"
                ),
                void this.destroy(e)
              );
            this._handle.writesIssuedByPrevListenerDone();
          }),
        n.nextTick(initRead, this, e);
    }
    u(TLSSocket.prototype, w.Socket.prototype),
      u(TLSSocket, w.Socket),
      (e.TLSSocket = TLSSocket);
    const Ke = [
      "ref",
      "unref",
      "open",
      "bind",
      "listen",
      "connect",
      "bind6",
      "connect6",
      "getsockname",
      "getpeername",
      "setNoDelay",
      "setKeepAlive",
      "setSimultaneousAccepts",
      "setBlocking",
      "setPendingInstances",
    ];
    function makeMethodProxy(e) {
      return function methodProxy(...t) {
        if (this._parent[e]) return p(this._parent[e], this._parent, t);
      };
    }
    for (const e of Ke) H.TLSWrap.prototype[e] = makeMethodProxy(e);
    function onSocketCloseDestroySSL() {
      P(destroySSL, this), (this[Pe] = null);
    }
    function destroySSL(e) {
      e._destroySSL();
    }
    function keylogNewListener(e) {
      "keylog" === e &&
        this._handle &&
        (this._handle.enableKeylogCallback(),
        this.removeListener("newListener", keylogNewListener));
    }
    function newListener(e) {
      "session" === e &&
        this._handle &&
        (this._handle.enableSessionCallbacks(),
        this.removeListener("newListener", newListener));
    }
    (H.TLSWrap.prototype.close = function close(e) {
      let t;
      this[q] && ((t = this[q].ssl), (this[q].ssl = null));
      const done = () => {
        t &&
          (t.destroySSL(),
          t._secureContext.singleUse &&
            (t._secureContext.context.close(),
            (t._secureContext.context = null))),
          e && e();
      };
      return this._parentWrap && this._parentWrap._handle === this._parent
        ? (this._parentWrap.once("close", done), this._parentWrap.destroy())
        : this._parent.close(done);
    }),
      (TLSSocket.prototype.disableRenegotiation =
        function disableRenegotiation() {
          this[ge] = !0;
        }),
      (TLSSocket.prototype._wrapHandle = function (e, t, s) {
        const n = this._tlsOptions;
        t || ((t = n.pipe ? new j(D.SOCKET) : new K(z.SOCKET))[q] = this);
        const i = n.secureContext || n.credentials || x.createSecureContext(n);
        if (
          (b(t.isStreamBase, "handle must be a StreamBase"),
          !(i.context instanceof V))
        )
          throw new Z("context");
        const r = H.wrap(t, i.context, !!n.isServer, s);
        return (
          (r._parent = t),
          (r._parentWrap = e),
          (r._secureContext = i),
          (r.reading = t.reading),
          (this[Pe] = r),
          (function defineHandleReading(e, t) {
            d(t, "reading", {
              __proto__: null,
              get: () => e[Pe].reading,
              set: (t) => {
                e[Pe].reading = t;
              },
            });
          })(this, t),
          this.on("close", onSocketCloseDestroySSL),
          r
        );
      }),
      (TLSSocket.prototype[I] = function reinitializeHandle(e) {
        const t = this.ssl ? this._handle.getServername() : null,
          s = this.ssl ? this._handle.getSession() : null;
        (this.handle = this._wrapHandle(null, e, !1)),
          (this.ssl = this._handle),
          w.Socket.prototype[I].call(this, this.handle),
          this._init(),
          this._tlsOptions.enableTrace && this._handle.enableTrace(),
          s && this.setSession(s),
          t && this.setServername(t);
      }),
      (TLSSocket.prototype._destroySSL = function _destroySSL() {
        this.ssl &&
          (this.ssl.destroySSL(),
          this.ssl._secureContext.singleUse &&
            (this.ssl._secureContext.context.close(),
            (this.ssl._secureContext.context = null)),
          (this.ssl = null),
          (this[Oe] = null),
          (this[Ie] = !1));
      });
    let ze = !0,
      He = !0;
    function onServerSocketSecure() {
      if (this._requestCert) {
        const e = this._handle.verifyError();
        e
          ? ((this.authorizationError = e.code),
            this._rejectUnauthorized && this.destroy())
          : (this.authorized = !0);
      }
      !this.destroyed &&
        this._releaseControl() &&
        (R("server emit secureConnection"),
        (this.secureConnecting = !1),
        this._tlsOptions.server.emit("secureConnection", this));
    }
    function onSocketTLSError(e) {
      this._controlReleased ||
        this[me] ||
        ((this[me] = !0),
        R("server emit tlsClientError:", e),
        this._tlsOptions.server.emit("tlsClientError", e, this));
    }
    function onSocketKeylog(e) {
      this._tlsOptions.server.emit("keylog", e, this);
    }
    function onSocketClose(e) {
      if (!e && !this._controlReleased && !this[me]) {
        this[me] = !0;
        const e = M("socket hang up");
        this._tlsOptions.server.emit("tlsClientError", e, this);
      }
    }
    function tlsConnectionListener(e) {
      R("net.Server.on(connection): new TLSSocket");
      const t = new TLSSocket(e, {
        secureContext: this._sharedCreds,
        isServer: !0,
        server: this,
        requestCert: this.requestCert,
        rejectUnauthorized: this.rejectUnauthorized,
        handshakeTimeout: this[Le],
        ALPNProtocols: this.ALPNProtocols,
        ALPNCallback: this.ALPNCallback,
        SNICallback: this[be] || SNICallback,
        enableTrace: this[Ee],
        pauseOnConnect: this.pauseOnConnect,
        pskCallback: this[we],
        pskIdentityHint: this[xe],
      });
      t.on("secure", onServerSocketSecure),
        this.listenerCount("keylog") > 0 && t.on("keylog", onSocketKeylog),
        (t[me] = !1),
        t.on("close", onSocketClose),
        t.on("_tlsError", onSocketTLSError);
    }
    function Server(e, t) {
      if (!(this instanceof Server)) return new Server(e, t);
      if ("function" == typeof e) (t = e), (e = L);
      else {
        if (null != e && "object" != typeof e)
          throw new F("options", "Object", e);
        e = e ?? L;
      }
      if (
        ((this._contexts = []),
        (this.requestCert = !0 === e.requestCert),
        (this.rejectUnauthorized = !1 !== e.rejectUnauthorized),
        (this.ALPNCallback = e.ALPNCallback),
        this.ALPNCallback && e.ALPNProtocols)
      )
        throw new J();
      e.sessionTimeout && (this.sessionTimeout = e.sessionTimeout),
        e.ticketKeys && (this.ticketKeys = e.ticketKeys),
        e.ALPNProtocols && x.convertALPNProtocols(e.ALPNProtocols, this),
        this.setSecureContext(e),
        (this[Le] = e.handshakeTimeout || 12e4),
        (this[be] = e.SNICallback),
        (this[we] = e.pskCallback),
        (this[xe] = e.pskIdentityHint),
        ue(this[Le], "options.handshakeTimeout"),
        this[be] && le(this[be], "options.SNICallback"),
        this[we] && le(this[we], "options.pskCallback"),
        this[xe] && Se(this[xe], "options.pskIdentityHint"),
        p(w.Server, this, [e, tlsConnectionListener]),
        t && this.on("secureConnection", t),
        (this[Ee] = e.enableTrace);
    }
    function SNICallback(e, t) {
      const s = this.server._contexts;
      for (let n = s.length - 1; n >= 0; --n) {
        const i = s[n];
        if (null !== _(i[0], e)) return void t(null, i[1]);
      }
      t(null, void 0);
    }
    function onConnectSecure() {
      const e = this[ve],
        t = this.getEphemeralKeyInfo();
      if ("DH" === t.type && t.size < e.minDHSize) {
        const e = new Q(t.size);
        return R("client emit:", e), this.emit("error", e), void this.destroy();
      }
      let s = this._handle.verifyError();
      if (!s && !this.isSessionReused()) {
        const t =
            e.servername ||
            e.host ||
            (e.socket && e.socket._host) ||
            "localhost",
          n = this.getPeerCertificate(!0);
        s = e.checkServerIdentity(t, n);
      }
      if (s) {
        if (
          ((this.authorized = !1),
          (this.authorizationError = s.code || s.message),
          !1 !== e.rejectUnauthorized)
        )
          return void this.destroy(s);
        R(
          "client emit secureConnect. rejectUnauthorized: %s, authorizationError: %s",
          e.rejectUnauthorized,
          this.authorizationError
        ),
          (this.secureConnecting = !1),
          this.emit("secureConnect");
      } else
        (this.authorized = !0),
          R("client emit secureConnect. authorized:", this.authorized),
          (this.secureConnecting = !1),
          this.emit("secureConnect");
      this[Ie] = !0;
      const n = this[Oe];
      (this[Oe] = null),
        n && this.emit("session", n),
        this.removeListener("end", onConnectEnd);
    }
    function onConnectEnd() {
      if (!this._hadError) {
        const e = this[ve];
        this._hadError = !0;
        const t = M(
          "Client network socket disconnected before secure TLS connection was established"
        );
        (t.path = e.path),
          (t.host = e.host),
          (t.port = e.port),
          (t.localAddress = e.localAddress),
          this.destroy(t);
      }
    }
    (TLSSocket.prototype._init = function (e, t) {
      const s = this._tlsOptions,
        i = this._handle;
      (this.server = s.server),
        R("%s _init", s.isServer ? "server" : "client", "handle?", !!i);
      const r = !!s.requestCert || !s.isServer,
        o = !!s.rejectUnauthorized;
      if (
        ((this._requestCert = r),
        (this._rejectUnauthorized = o),
        (r || o) && i.setVerifyMode(r, o),
        (i.onkeylog = onkeylog),
        0 === this.listenerCount("newListener", keylogNewListener) &&
          this.on("newListener", keylogNewListener),
        s.isServer)
      ) {
        if (
          ((i.onhandshakestart = onhandshakestart),
          (i.onhandshakedone = onhandshakedone),
          (i.onclienthello = loadSession),
          (i.oncertcb = loadSNI),
          (i.onnewsession = onnewsession),
          (i.lastHandshakeTime = 0),
          (i.handshakes = 0),
          s.ALPNCallback)
        ) {
          if ("function" != typeof s.ALPNCallback)
            throw new F("options.ALPNCallback", "Function", s.ALPNCallback);
          b("function" == typeof s.ALPNCallback),
            (this[Te] = s.ALPNCallback),
            (i.ALPNCallback = callALPNCallback),
            i.enableALPNCb();
        }
        this.server &&
          ((this.server.listenerCount("resumeSession") > 0 ||
            this.server.listenerCount("newSession") > 0) &&
            i.enableSessionCallbacks(),
          this.server.listenerCount("OCSPRequest") > 0 && i.enableCertCb());
      } else
        (i.onhandshakestart = Ae),
          (i.onhandshakedone = () => {
            R("client onhandshakedone"), this._finishInit();
          }),
          (i.onocspresponse = onocspresponse),
          s.session && i.setSession(s.session),
          (i.onnewsession = onnewsessionclient),
          0 === this.listenerCount("newListener", newListener) &&
            this.on("newListener", newListener);
      Ce &&
        (ze &&
          ((ze = !1),
          n.emitWarning(
            "Using --tls-keylog makes TLS connections insecure by writing secret key material to file " +
              Ce
          )),
        this.on("keylog", (e) => {
          fe(Ce, e, { mode: 384 }, (e) => {
            e &&
              He &&
              ((He = !1),
              n.emitWarning(
                "Failed to write TLS keylog (this warning will not be repeated): " +
                  e
              ));
          });
        })),
        (i.onerror = onerror),
        s.isServer &&
          s.SNICallback &&
          (s.SNICallback !== SNICallback ||
            (s.server && s.server._contexts.length)) &&
          (b("function" == typeof s.SNICallback),
          (this._SNICallback = s.SNICallback),
          i.enableCertCb()),
        s.ALPNProtocols && i.setALPNProtocols(s.ALPNProtocols),
        s.pskCallback &&
          i.enablePskCallback &&
          (le(s.pskCallback, "pskCallback"),
          (i[re] = s.isServer ? onPskServerCallback : onPskClientCallback),
          (this[we] = s.pskCallback),
          i.enablePskCallback(),
          s.pskIdentityHint &&
            (Se(s.pskIdentityHint, "options.pskIdentityHint"),
            i.setPskIdentityHint(s.pskIdentityHint)));
      const a = this[ve];
      !s.isServer && a && a.servername && this.setServername(a.servername),
        s.handshakeTimeout > 0 &&
          this.setTimeout(s.handshakeTimeout, this._handleTimeout),
        e instanceof w.Socket &&
          ((this._parent = e),
          (this.connecting = e.connecting || !e._handle),
          e.once("connect", () => {
            (this.connecting = !1), this.emit("connect");
          })),
        t
          ? t.on("error", (e) => this._emitTLSError(e))
          : (b(!e), (this.connecting = !0));
    }),
      (TLSSocket.prototype.renegotiate = function (e, t) {
        if (
          (pe(e, "options"),
          void 0 !== t && le(t, "callback"),
          R(
            "%s renegotiate()",
            this._tlsOptions.isServer ? "server" : "client",
            "destroyed?",
            this.destroyed
          ),
          this.destroyed)
        )
          return;
        let s = !!this._requestCert,
          i = !!this._rejectUnauthorized;
        void 0 !== e.requestCert && (s = !!e.requestCert),
          void 0 !== e.rejectUnauthorized && (i = !!e.rejectUnauthorized),
          (s === this._requestCert && i === this._rejectUnauthorized) ||
            (this._handle.setVerifyMode(s, i),
            (this._requestCert = s),
            (this._rejectUnauthorized = i)),
          this.write("");
        try {
          this._handle.renegotiate();
        } catch (e) {
          return t && n.nextTick(t, e), !1;
        }
        return this.write(""), t && this.once("secure", () => t(null)), !0;
      }),
      (TLSSocket.prototype.exportKeyingMaterial = function (e, t, s) {
        if (
          (_e(e, "length", !0),
          Se(t, "label"),
          void 0 !== s && he(s, "context"),
          !this._secureEstablished)
        )
          throw new ie();
        return this._handle.exportKeyingMaterial(e, t, s);
      }),
      (TLSSocket.prototype.setMaxSendFragment = function setMaxSendFragment(e) {
        return de(e, "size"), 1 === this._handle.setMaxSendFragment(e);
      }),
      (TLSSocket.prototype._handleTimeout = function () {
        this._emitTLSError(new Y());
      }),
      (TLSSocket.prototype._emitTLSError = function (e) {
        const t = this._tlsError(e);
        t && this.emit("error", t);
      }),
      (TLSSocket.prototype._tlsError = function (e) {
        return this.emit("_tlsError", e), this._controlReleased ? e : null;
      }),
      (TLSSocket.prototype._releaseControl = function () {
        return (
          !this._controlReleased &&
          ((this._controlReleased = !0),
          this.removeListener("error", this._tlsError),
          !0)
        );
      }),
      (TLSSocket.prototype._finishInit = function () {
        this._handle &&
          ((this.alpnProtocol = this._handle.getALPNNegotiatedProtocol()),
          null === this.servername &&
            (this.servername = this._handle.getServername()),
          R(
            "%s _finishInit",
            this._tlsOptions.isServer ? "server" : "client",
            "handle?",
            !!this._handle,
            "alpn",
            this.alpnProtocol,
            "servername",
            this.servername
          ),
          (this._secureEstablished = !0),
          this._tlsOptions.handshakeTimeout > 0 &&
            this.setTimeout(0, this._handleTimeout),
          this.emit("secure"));
      }),
      (TLSSocket.prototype._start = function () {
        R(
          "%s _start",
          this._tlsOptions.isServer ? "server" : "client",
          "handle?",
          !!this._handle,
          "connecting?",
          this.connecting,
          "requestOCSP?",
          !!this._tlsOptions.requestOCSP
        ),
          this.connecting
            ? this.once("connect", this._start)
            : this._handle &&
              (this._tlsOptions.requestOCSP && this._handle.requestOCSP(),
              this._handle.start());
      }),
      (TLSSocket.prototype.setServername = function (e) {
        if ((Se(e, "name"), this._tlsOptions.isServer)) throw new ne();
        this._handle.setServername(e);
      }),
      (TLSSocket.prototype.setSession = function (e) {
        "string" == typeof e && (e = N.from(e, "latin1")),
          this._handle.setSession(e);
      }),
      (TLSSocket.prototype.getPeerCertificate = function (e) {
        return this._handle
          ? O.translatePeerCertificate(this._handle.getPeerCertificate(e)) || {}
          : null;
      }),
      (TLSSocket.prototype.getCertificate = function () {
        return this._handle
          ? O.translatePeerCertificate(this._handle.getCertificate()) || {}
          : null;
      }),
      (TLSSocket.prototype.getPeerX509Certificate = function (e) {
        const t = this._handle?.getPeerX509Certificate();
        return t ? new ke(t) : void 0;
      }),
      (TLSSocket.prototype.getX509Certificate = function () {
        const e = this._handle?.getX509Certificate();
        return e ? new ke(e) : void 0;
      }),
      o(
        [
          "getCipher",
          "getSharedSigalgs",
          "getEphemeralKeyInfo",
          "getFinished",
          "getPeerFinished",
          "getProtocol",
          "getSession",
          "getTLSTicket",
          "isSessionReused",
          "enableTrace",
        ],
        (e) => {
          TLSSocket.prototype[e] = (function makeSocketMethodProxy(e) {
            return function socketMethodProxy(...t) {
              return this._handle ? p(this._handle[e], this._handle, t) : null;
            };
          })(e);
        }
      ),
      u(Server.prototype, w.Server.prototype),
      u(Server, w.Server),
      (e.Server = Server),
      (e.createServer = function createServer(e, t) {
        return new Server(e, t);
      }),
      (Server.prototype.setSecureContext = function (e) {
        pe(e, "options"),
          e.pfx ? (this.pfx = e.pfx) : (this.pfx = void 0),
          e.key ? (this.key = e.key) : (this.key = void 0),
          e.passphrase
            ? (this.passphrase = e.passphrase)
            : (this.passphrase = void 0),
          e.cert ? (this.cert = e.cert) : (this.cert = void 0),
          e.clientCertEngine
            ? (this.clientCertEngine = e.clientCertEngine)
            : (this.clientCertEngine = void 0),
          e.ca ? (this.ca = e.ca) : (this.ca = void 0),
          e.minVersion
            ? (this.minVersion = e.minVersion)
            : (this.minVersion = void 0),
          e.maxVersion
            ? (this.maxVersion = e.maxVersion)
            : (this.maxVersion = void 0),
          e.secureProtocol
            ? (this.secureProtocol = e.secureProtocol)
            : (this.secureProtocol = void 0),
          e.crl ? (this.crl = e.crl) : (this.crl = void 0),
          (this.sigalgs = e.sigalgs),
          e.ciphers ? (this.ciphers = e.ciphers) : (this.ciphers = void 0),
          (this.ecdhCurve = e.ecdhCurve),
          e.dhparam ? (this.dhparam = e.dhparam) : (this.dhparam = void 0),
          void 0 !== e.honorCipherOrder
            ? (this.honorCipherOrder = !!e.honorCipherOrder)
            : (this.honorCipherOrder = !0);
        const t = e.secureOptions || 0;
        (this.secureOptions = t || void 0),
          e.sessionIdContext
            ? (this.sessionIdContext = e.sessionIdContext)
            : (this.sessionIdContext = C(
                T.createHash("sha1").update(a(n.argv, " ")).digest("hex"),
                0,
                32
              )),
          e.sessionTimeout && (this.sessionTimeout = e.sessionTimeout),
          e.ticketKeys && (this.ticketKeys = e.ticketKeys),
          (this.privateKeyIdentifier = e.privateKeyIdentifier),
          (this.privateKeyEngine = e.privateKeyEngine),
          (this._sharedCreds = x.createSecureContext({
            pfx: this.pfx,
            key: this.key,
            passphrase: this.passphrase,
            cert: this.cert,
            clientCertEngine: this.clientCertEngine,
            ca: this.ca,
            ciphers: this.ciphers,
            sigalgs: this.sigalgs,
            ecdhCurve: this.ecdhCurve,
            dhparam: this.dhparam,
            minVersion: this.minVersion,
            maxVersion: this.maxVersion,
            secureProtocol: this.secureProtocol,
            secureOptions: this.secureOptions,
            honorCipherOrder: this.honorCipherOrder,
            crl: this.crl,
            sessionIdContext: this.sessionIdContext,
            ticketKeys: this.ticketKeys,
            sessionTimeout: this.sessionTimeout,
            privateKeyIdentifier: this.privateKeyIdentifier,
            privateKeyEngine: this.privateKeyEngine,
          }));
      }),
      (Server.prototype._getServerData = function () {
        return { ticketKeys: this.getTicketKeys().toString("hex") };
      }),
      (Server.prototype._setServerData = function (e) {
        this.setTicketKeys(N.from(e.ticketKeys, "hex"));
      }),
      (Server.prototype.getTicketKeys = function getTicketKeys() {
        return this._sharedCreds.context.getTicketKeys();
      }),
      (Server.prototype.setTicketKeys = function setTicketKeys(e) {
        he(e),
          b(
            48 === e.byteLength,
            "Session ticket keys must be a 48-byte buffer"
          ),
          this._sharedCreds.context.setTicketKeys(e);
      }),
      (Server.prototype.setOptions = m(
        function (e) {
          (this.requestCert = !0 === e.requestCert),
            (this.rejectUnauthorized = !1 !== e.rejectUnauthorized),
            e.pfx && (this.pfx = e.pfx),
            e.key && (this.key = e.key),
            e.passphrase && (this.passphrase = e.passphrase),
            e.cert && (this.cert = e.cert),
            e.clientCertEngine && (this.clientCertEngine = e.clientCertEngine),
            e.ca && (this.ca = e.ca),
            e.minVersion && (this.minVersion = e.minVersion),
            e.maxVersion && (this.maxVersion = e.maxVersion),
            e.secureProtocol && (this.secureProtocol = e.secureProtocol),
            e.crl && (this.crl = e.crl),
            e.ciphers && (this.ciphers = e.ciphers),
            void 0 !== e.ecdhCurve && (this.ecdhCurve = e.ecdhCurve),
            e.dhparam && (this.dhparam = e.dhparam),
            e.sessionTimeout && (this.sessionTimeout = e.sessionTimeout),
            e.ticketKeys && (this.ticketKeys = e.ticketKeys);
          const t = e.secureOptions || 0;
          void 0 !== e.honorCipherOrder
            ? (this.honorCipherOrder = !!e.honorCipherOrder)
            : (this.honorCipherOrder = !0),
            t && (this.secureOptions = t),
            e.ALPNProtocols && x.convertALPNProtocols(e.ALPNProtocols, this),
            e.sessionIdContext
              ? (this.sessionIdContext = e.sessionIdContext)
              : (this.sessionIdContext = C(
                  T.createHash("sha1").update(a(n.argv, " ")).digest("hex"),
                  0,
                  32
                )),
            e.pskCallback && (this[we] = e.pskCallback),
            e.pskIdentityHint && (this[xe] = e.pskIdentityHint),
            e.sigalgs && (this.sigalgs = e.sigalgs),
            void 0 !== e.privateKeyIdentifier &&
              (this.privateKeyIdentifier = e.privateKeyIdentifier),
            void 0 !== e.privateKeyEngine &&
              (this.privateKeyEngine = e.privateKeyEngine);
        },
        "Server.prototype.setOptions() is deprecated",
        "DEP0122"
      )),
      (Server.prototype.addContext = function (e, t) {
        if (!e) throw new te();
        const s = new S(
            "^" + y(k(/([.^$+?\-\\[\]{}])/g, e, "\\$1"), "*", "[^.]*") + "$"
          ),
          n = t instanceof O.SecureContext ? t : x.createSecureContext(t);
        c(this._contexts, [s, n.context]);
      }),
      (Server.prototype[E.captureRejectionSymbol] = function (e, t, s) {
        if ("secureConnection" === t) s.destroy(e);
        else p(w.Server.prototype[v("nodejs.rejection")], this, [e, t, s]);
      }),
      (e.connect = function connect(...e) {
        e = (function normalizeConnectArgs(e) {
          const t = w._normalizeArgs(e),
            s = t[0],
            n = t[1];
          return (
            null !== e[1] && "object" == typeof e[1]
              ? l(s, e[1])
              : null !== e[2] && "object" == typeof e[2] && l(s, e[2]),
            n ? [s, n] : [s]
          );
        })(e);
        let t = e[0];
        const s = e[1];
        (t = {
          rejectUnauthorized: !ae(),
          ciphers: x.DEFAULT_CIPHERS,
          checkServerIdentity: x.checkServerIdentity,
          minDHSize: 1024,
          ...t,
        }),
          t.keepAlive || (t.singleUse = !0),
          b("function" == typeof t.checkServerIdentity),
          b(
            "number" == typeof t.minDHSize,
            "options.minDHSize is not a number: " + t.minDHSize
          ),
          b(
            t.minDHSize > 0,
            "options.minDHSize is not a positive number: " + t.minDHSize
          );
        const i = t.secureContext || x.createSecureContext(t),
          r = new TLSSocket(t.socket, {
            allowHalfOpen: t.allowHalfOpen,
            pipe: !!t.path,
            secureContext: i,
            isServer: !1,
            requestCert: !0,
            rejectUnauthorized: !1 !== t.rejectUnauthorized,
            session: t.session,
            ALPNProtocols: t.ALPNProtocols,
            requestOCSP: t.requestOCSP,
            enableTrace: t.enableTrace,
            pskCallback: t.pskCallback,
            highWaterMark: t.highWaterMark,
            onread: t.onread,
            signal: t.signal,
          });
        return (
          (t.rejectUnauthorized = !1 !== t.rejectUnauthorized),
          (r[ve] = t),
          s && r.once("secureConnect", s),
          t.socket ||
            (t.timeout && r.setTimeout(t.timeout), r.connect(t, r._start)),
          r._releaseControl(),
          t.session && r.setSession(t.session),
          t.servername &&
            (!Ne &&
              w.isIP(t.servername) &&
              (n.emitWarning(
                "Setting the TLS ServerName to an IP address is not permitted by RFC 6066. This will be ignored in a future version.",
                "DeprecationWarning",
                "DEP0123"
              ),
              (Ne = !0)),
            r.setServername(t.servername)),
          t.socket && r._start(),
          r.on("secure", onConnectSecure),
          r.prependListener("end", onConnectEnd),
          r
        );
      });
  },
  assert: function (e, t, n, r, o, a) {
    "use strict";
    const {
        ArrayPrototypeIndexOf: i,
        ArrayPrototypeJoin: c,
        ArrayPrototypePush: s,
        ArrayPrototypeShift: l,
        ArrayPrototypeSlice: u,
        Error: p,
        ErrorCaptureStackTrace: f,
        FunctionPrototypeBind: d,
        NumberIsNaN: g,
        ObjectAssign: m,
        ObjectIs: h,
        ObjectKeys: E,
        ObjectPrototypeIsPrototypeOf: w,
        ReflectApply: y,
        RegExpPrototypeExec: x,
        RegExpPrototypeSymbolReplace: S,
        SafeMap: k,
        String: F,
        StringPrototypeCharCodeAt: q,
        StringPrototypeIncludes: R,
        StringPrototypeIndexOf: $,
        StringPrototypeReplace: b,
        StringPrototypeSlice: v,
        StringPrototypeSplit: A,
        StringPrototypeStartsWith: N,
      } = a,
      { Buffer: P } = t("buffer"),
      {
        codes: {
          ERR_AMBIGUOUS_ARGUMENT: C,
          ERR_INVALID_ARG_TYPE: T,
          ERR_INVALID_ARG_VALUE: j,
          ERR_INVALID_RETURN_VALUE: I,
          ERR_MISSING_ARGS: D,
        },
        isErrorStackTraceLimitWritable: L,
        overrideStackTrace: M,
      } = t("internal/errors"),
      _ = t("internal/assert/assertion_error"),
      { openSync: O, closeSync: U, readSync: z } = t("fs"),
      { inspect: G } = t("internal/util/inspect"),
      { isPromise: V, isRegExp: B } = t("internal/util/types"),
      { EOL: W } = t("internal/constants"),
      { BuiltinModule: K } = t("internal/bootstrap/realm"),
      { isError: J } = t("internal/util"),
      Y = new k(),
      H = t("internal/assert/calltracker"),
      { validateFunction: Q } = t("internal/validators");
    let X, Z, ee, te, ne, re;
    function lazyLoadComparison() {
      const e = t("internal/util/comparisons");
      (X = e.isDeepEqual), (Z = e.isDeepStrictEqual);
    }
    const oe = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g,
      ae = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "",
        "",
        "\\u000b",
        "\\f",
        "",
        "\\u000e",
        "\\u000f",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001a",
        "\\u001b",
        "\\u001c",
        "\\u001d",
        "\\u001e",
        "\\u001f",
      ],
      escapeFn = (e) => ae[q(e, 0)];
    let ie = !1;
    const ce = (n.exports = ok),
      se = {};
    function innerFail(e) {
      if (e.message instanceof p) throw e.message;
      throw new _(e);
    }
    function findColumn(e, t, n) {
      if (n.length > t + 100)
        try {
          return parseCode(n, t);
        } catch {
          if (n.length - t > 2500) throw null;
        }
      const r = t - n.length + 2500,
        o = P.allocUnsafe(r),
        a = z(e, o, 0, r);
      return (
        (n += re.write(o.slice(0, a))),
        a < r ? parseCode(n, t) : findColumn(e, t, n)
      );
    }
    function parseCode(e, n) {
      if (void 0 === ee) {
        const e = t("internal/deps/acorn/acorn/dist/acorn").Parser;
        ({ findNodeAround: te } = t(
          "internal/deps/acorn/acorn-walk/dist/walk"
        )),
          (ee = d(e.parseExpressionAt, e)),
          (ne = d(e.tokenizer, e));
      }
      let r, o;
      for (const t of ne(e, { ecmaVersion: "latest" })) {
        if (((o = t.start), o > n)) break;
        try {
          if (
            ((r = ee(e, o, { ecmaVersion: "latest" })),
            (r = te(r, n, "CallExpression")),
            r?.node.end >= n)
          )
            return [
              r.node.start,
              b(v(e, r.node.start, r.node.end), oe, escapeFn),
            ];
        } catch (e) {
          continue;
        }
      }
      throw null;
    }
    function getErrMessage(e, n) {
      const r = p.stackTraceLimit,
        o = L();
      o && (p.stackTraceLimit = 1);
      const a = {};
      f(a, n), o && (p.stackTraceLimit = r), M.set(a, (e, t) => t);
      const i = a.stack[0],
        c = i.getFileName(),
        s = i.getLineNumber() - 1;
      let u,
        d,
        g,
        m = i.getColumnNumber() - 1;
      if (!c) return e;
      if (((u = `${c}${s}${m}`), N(c, "node:") && K.exists(v(c, 5))))
        Y.set(u, void 0);
      else {
        if (Y.has(u)) return Y.get(u);
        try {
          if ((o && (p.stackTraceLimit = 0), c)) {
            if (void 0 === re) {
              const { StringDecoder: e } = t("string_decoder");
              re = new e("utf8");
            }
            (g = O(c, "r", 438)),
              ({ 0: m, 1: e } = (function getCode(e, t, n) {
                let r = 0;
                if (0 === t) return findColumn(e, n, "");
                let o = 0,
                  a = 32;
                const i = 16384;
                let c = P.allocUnsafe(i);
                for (; 0 != a--; ) {
                  (c = o < t ? c : P.allocUnsafe(i)), (r = z(e, c, 0, i));
                  for (let a = 0; a < r; a++)
                    if (10 === c[a] && ++o === t)
                      return r < i
                        ? parseCode(c.toString("utf8", a + 1, r), n)
                        : findColumn(e, n, re.write(c.slice(a + 1, r)));
                }
              })(g, s, m)),
              re.end();
          } else {
            for (let e = 0; e < s; e++) d = v(d, $(d, "\n") + 1);
            ({ 0: m, 1: e } = parseCode(d, m));
          }
          if (R(e, "\n")) {
            "\r\n" === W && (e = S(/\r\n/g, e, "\n"));
            const t = A(e, "\n");
            e = l(t);
            for (const n of t) {
              let t = 0;
              for (; t < m && (" " === n[t] || "\t" === n[t]); ) t++;
              e += `\n  ${v(n, t)}`;
            }
          }
          return (
            (e = `The expression evaluated to a falsy value:\n\n  ${e}\n`),
            Y.set(u, e),
            e
          );
        } catch {
          Y.set(u, void 0);
        } finally {
          o && (p.stackTraceLimit = r), void 0 !== g && U(g);
        }
      }
    }
    function innerOk(e, t, n, r) {
      if (!n) {
        let o = !1;
        if (0 === t)
          (o = !0), (r = "No value argument passed to `assert.ok()`");
        else if (null == r) (o = !0), (r = getErrMessage(r, e));
        else if (r instanceof p) throw r;
        const a = new _({
          actual: n,
          expected: !0,
          message: r,
          operator: "==",
          stackStartFn: e,
        });
        throw ((a.generatedMessage = o), a);
      }
    }
    function ok(...e) {
      innerOk(ok, e.length, ...e);
    }
    (ce.fail = function fail(e, t, n, o, a) {
      const i = arguments.length;
      let c = !1;
      if (
        (null == e && i <= 1
          ? ((c = !0), (n = "Failed"))
          : 1 === i
          ? ((n = e), (e = void 0))
          : (!1 === ie &&
              ((ie = !0),
              r.emitWarning(
                "assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.",
                "DeprecationWarning",
                "DEP0094"
              )),
            2 === i && (o = "!=")),
        n instanceof p)
      )
        throw n;
      const s = new _({
        actual: e,
        expected: t,
        operator: void 0 === o ? "fail" : o,
        stackStartFn: a || fail,
        message: n,
      });
      throw (c && (s.generatedMessage = !0), s);
    }),
      (ce.AssertionError = _),
      (ce.ok = ok),
      (ce.equal = function equal(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        e == t ||
          (g(e) && g(t)) ||
          innerFail({
            actual: e,
            expected: t,
            message: n,
            operator: "==",
            stackStartFn: equal,
          });
      }),
      (ce.notEqual = function notEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        (e == t || (g(e) && g(t))) &&
          innerFail({
            actual: e,
            expected: t,
            message: n,
            operator: "!=",
            stackStartFn: notEqual,
          });
      }),
      (ce.deepEqual = function deepEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        void 0 === X && lazyLoadComparison(),
          X(e, t) ||
            innerFail({
              actual: e,
              expected: t,
              message: n,
              operator: "deepEqual",
              stackStartFn: deepEqual,
            });
      }),
      (ce.notDeepEqual = function notDeepEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        void 0 === X && lazyLoadComparison(),
          X(e, t) &&
            innerFail({
              actual: e,
              expected: t,
              message: n,
              operator: "notDeepEqual",
              stackStartFn: notDeepEqual,
            });
      }),
      (ce.deepStrictEqual = function deepStrictEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        void 0 === X && lazyLoadComparison(),
          Z(e, t) ||
            innerFail({
              actual: e,
              expected: t,
              message: n,
              operator: "deepStrictEqual",
              stackStartFn: deepStrictEqual,
            });
      }),
      (ce.notDeepStrictEqual = function notDeepStrictEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        void 0 === X && lazyLoadComparison();
        Z(e, t) &&
          innerFail({
            actual: e,
            expected: t,
            message: n,
            operator: "notDeepStrictEqual",
            stackStartFn: notDeepStrictEqual,
          });
      }),
      (ce.strictEqual = function strictEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        h(e, t) ||
          innerFail({
            actual: e,
            expected: t,
            message: n,
            operator: "strictEqual",
            stackStartFn: strictEqual,
          });
      }),
      (ce.notStrictEqual = function notStrictEqual(e, t, n) {
        if (arguments.length < 2) throw new D("actual", "expected");
        h(e, t) &&
          innerFail({
            actual: e,
            expected: t,
            message: n,
            operator: "notStrictEqual",
            stackStartFn: notStrictEqual,
          });
      });
    class Comparison {
      constructor(e, t, n) {
        for (const r of t)
          r in e &&
            (void 0 !== n &&
            "string" == typeof n[r] &&
            B(e[r]) &&
            null !== x(e[r], n[r])
              ? (this[r] = n[r])
              : (this[r] = e[r]));
      }
    }
    function compareExceptionKey(e, t, n, r, o, a) {
      if (!(n in e) || !Z(e[n], t[n])) {
        if (!r) {
          const n = new Comparison(e, o),
            r = new Comparison(t, o, e),
            i = new _({
              actual: n,
              expected: r,
              operator: "deepStrictEqual",
              stackStartFn: a,
            });
          throw ((i.actual = e), (i.expected = t), (i.operator = a.name), i);
        }
        innerFail({
          actual: e,
          expected: t,
          message: r,
          operator: a.name,
          stackStartFn: a,
        });
      }
    }
    function getActual(e) {
      Q(e, "fn");
      try {
        e();
      } catch (e) {
        return e;
      }
      return se;
    }
    function checkIsPromise(e) {
      return (
        V(e) ||
        (null !== e &&
          "object" == typeof e &&
          "function" == typeof e.then &&
          "function" == typeof e.catch)
      );
    }
    async function waitForActual(e) {
      let t;
      if ("function" == typeof e) {
        if (((t = e()), !checkIsPromise(t)))
          throw new I("instance of Promise", "promiseFn", t);
      } else {
        if (!checkIsPromise(e))
          throw new T("promiseFn", ["Function", "Promise"], e);
        t = e;
      }
      try {
        await t;
      } catch (e) {
        return e;
      }
      return se;
    }
    function expectsError(e, t, n, r) {
      if ("string" == typeof n) {
        if (4 === arguments.length)
          throw new T("error", ["Object", "Error", "Function", "RegExp"], n);
        if ("object" == typeof t && null !== t) {
          if (t.message === n)
            throw new C(
              "error/message",
              `The error message "${t.message}" is identical to the message.`
            );
        } else if (t === n)
          throw new C(
            "error/message",
            `The error "${t}" is identical to the message.`
          );
        (r = n), (n = void 0);
      } else if (null != n && "object" != typeof n && "function" != typeof n)
        throw new T("error", ["Object", "Error", "Function", "RegExp"], n);
      if (t === se) {
        let t = "";
        n && n.name && (t += ` (${n.name})`), (t += r ? `: ${r}` : ".");
        const o = e === ce.rejects ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: n,
          operator: e.name,
          message: `Missing expected ${o}${t}`,
          stackStartFn: e,
        });
      }
      n &&
        (function expectedException(e, t, n, r) {
          let o = !1,
            a = !1;
          if ("function" != typeof t) {
            if (!B(t)) {
              if ("object" != typeof e || null === e) {
                const o = new _({
                  actual: e,
                  expected: t,
                  message: n,
                  operator: "deepStrictEqual",
                  stackStartFn: r,
                });
                throw ((o.operator = r.name), o);
              }
              {
                const o = E(t);
                if (t instanceof p) s(o, "name", "message");
                else if (0 === o.length)
                  throw new j("error", t, "may not be an empty object");
                void 0 === X && lazyLoadComparison();
                for (const a of o)
                  ("string" == typeof e[a] &&
                    B(t[a]) &&
                    null !== x(t[a], e[a])) ||
                    compareExceptionKey(e, t, a, n, o, r);
                return;
              }
            }
            {
              const r = F(e);
              if (null !== x(t, r)) return;
              n ||
                ((o = !0),
                (n = `The input did not match the regular expression ${G(
                  t
                )}. Input:\n\n${G(r)}\n`)),
                (a = !0);
            }
          } else {
            if (void 0 !== t.prototype && e instanceof t) return;
            if (w(p, t)) {
              if (!n)
                if (
                  ((o = !0),
                  (n = `The error is expected to be an instance of "${t.name}". Received `),
                  J(e))
                ) {
                  const r = (e.constructor && e.constructor.name) || e.name;
                  t.name === r
                    ? (n +=
                        "an error with identical name but a different prototype.")
                    : (n += `"${r}"`),
                    e.message && (n += `\n\nError message:\n\n${e.message}`);
                } else n += `"${G(e, { depth: -1 })}"`;
              a = !0;
            } else {
              const r = y(t, {}, [e]);
              !0 !== r &&
                (n ||
                  ((o = !0),
                  (n = `The ${
                    t.name ? `"${t.name}" ` : ""
                  }validation function is expected to return "true". Received ${G(
                    r
                  )}`),
                  J(e) && (n += `\n\nCaught error:\n\n${e}`)),
                (a = !0));
            }
          }
          if (a) {
            const a = new _({
              actual: e,
              expected: t,
              message: n,
              operator: r.name,
              stackStartFn: r,
            });
            throw ((a.generatedMessage = o), a);
          }
        })(t, n, r, e);
    }
    function expectsNoError(e, t, n, r) {
      if (t !== se) {
        if (
          ("string" == typeof n && ((r = n), (n = void 0)),
          !n ||
            (function hasMatchingError(e, t) {
              if ("function" != typeof t) {
                if (B(t)) {
                  const n = F(e);
                  return null !== x(t, n);
                }
                throw new T("expected", ["Function", "RegExp"], t);
              }
              return (
                (void 0 !== t.prototype && e instanceof t) ||
                (!w(p, t) && !0 === y(t, {}, [e]))
              );
            })(t, n))
        ) {
          const o = r ? `: ${r}` : ".",
            a = e === ce.doesNotReject ? "rejection" : "exception";
          innerFail({
            actual: t,
            expected: n,
            operator: e.name,
            message: `Got unwanted ${a}${o}\nActual message: "${
              t && t.message
            }"`,
            stackStartFn: e,
          });
        }
        throw t;
      }
    }
    function internalMatch(e, t, n, r) {
      if (!B(t)) throw new T("regexp", "RegExp", t);
      const o = r === ce.match;
      if ("string" != typeof e || (null !== x(t, e)) !== o) {
        if (n instanceof p) throw n;
        const a = !n;
        n =
          n ||
          ("string" != typeof e
            ? `The "string" argument must be of type string. Received type ${typeof e} (${G(
                e
              )})`
            : (o
                ? "The input did not match the regular expression "
                : "The input was expected to not match the regular expression ") +
              `${G(t)}. Input:\n\n${G(e)}\n`);
        const i = new _({
          actual: e,
          expected: t,
          message: n,
          operator: r.name,
          stackStartFn: r,
        });
        throw ((i.generatedMessage = a), i);
      }
    }
    (ce.throws = function throws(e, ...t) {
      expectsError(throws, getActual(e), ...t);
    }),
      (ce.rejects = async function rejects(e, ...t) {
        expectsError(rejects, await waitForActual(e), ...t);
      }),
      (ce.doesNotThrow = function doesNotThrow(e, ...t) {
        expectsNoError(doesNotThrow, getActual(e), ...t);
      }),
      (ce.doesNotReject = async function doesNotReject(e, ...t) {
        expectsNoError(doesNotReject, await waitForActual(e), ...t);
      }),
      (ce.ifError = function ifError(e) {
        if (null != e) {
          let t = "ifError got unwanted exception: ";
          "object" == typeof e && "string" == typeof e.message
            ? 0 === e.message.length && e.constructor
              ? (t += e.constructor.name)
              : (t += e.message)
            : (t += G(e));
          const n = new _({
              actual: e,
              expected: null,
              operator: "ifError",
              message: t,
              stackStartFn: ifError,
            }),
            r = e.stack;
          if ("string" == typeof r) {
            const e = $(r, "\n    at");
            if (-1 !== e) {
              const t = A(v(r, e + 1), "\n");
              let o = A(n.stack, "\n");
              for (const e of t) {
                const t = i(o, e);
                if (-1 !== t) {
                  o = u(o, 0, t);
                  break;
                }
              }
              const a = c(o, "\n"),
                s = c(t, "\n");
              n.stack = `${a}\n${s}`;
            }
          }
          throw n;
        }
      }),
      (ce.match = function match(e, t, n) {
        internalMatch(e, t, n, match);
      }),
      (ce.doesNotMatch = function doesNotMatch(e, t, n) {
        internalMatch(e, t, n, doesNotMatch);
      }),
      (ce.CallTracker = H),
      (ce.strict = m(
        function strict(...e) {
          innerOk(strict, e.length, ...e);
        },
        ce,
        {
          equal: ce.strictEqual,
          deepEqual: ce.deepStrictEqual,
          notEqual: ce.notStrictEqual,
          notDeepEqual: ce.notDeepStrictEqual,
        }
      )),
      (ce.strict.strict = ce.strict);
  },
  "assert/strict": function (t, s, r, c, e, i) {
    "use strict";
    r.exports = s("assert").strict;
  },
  async_hooks: function (e, t, s, o, r, n) {
    "use strict";
    const {
        ArrayPrototypeIncludes: i,
        ArrayPrototypeIndexOf: c,
        ArrayPrototypePush: a,
        ArrayPrototypeSplice: l,
        ArrayPrototypeUnshift: h,
        FunctionPrototypeBind: y,
        NumberIsSafeInteger: u,
        ObjectDefineProperties: d,
        ObjectIs: f,
        ReflectApply: b,
        Symbol: A,
        ObjectFreeze: _,
      } = n,
      {
        ERR_ASYNC_CALLBACK: k,
        ERR_ASYNC_TYPE: g,
        ERR_INVALID_ASYNC_ID: p,
      } = t("internal/errors").codes,
      { kEmptyObject: R } = t("internal/util"),
      { validateFunction: m, validateString: I } = t("internal/validators"),
      S = t("internal/async_hooks"),
      { registerDestroyHook: v } = S,
      {
        asyncWrap: w,
        executionAsyncId: H,
        triggerAsyncId: P,
        hasAsyncIdStack: x,
        getHookArrays: D,
        enableHooks: E,
        disableHooks: L,
        updatePromiseHookMode: N,
        executionAsyncResource: C,
        newAsyncId: O,
        getDefaultTriggerAsyncId: j,
        emitInit: B,
        emitBefore: F,
        emitAfter: Y,
        emitDestroy: T,
        enabledHooksExist: W,
        initHooksExist: M,
        destroyHooksExist: q,
      } = S,
      {
        async_id_symbol: z,
        trigger_async_id_symbol: K,
        init_symbol: U,
        before_symbol: V,
        after_symbol: G,
        destroy_symbol: J,
        promise_resolve_symbol: Q,
      } = S.symbols,
      {
        kInit: X,
        kBefore: Z,
        kAfter: $,
        kDestroy: ee,
        kTotals: te,
        kPromiseResolve: se,
      } = S.constants;
    class AsyncHook {
      constructor({
        init: e,
        before: t,
        after: s,
        destroy: o,
        promiseResolve: r,
      }) {
        if (void 0 !== e && "function" != typeof e) throw new k("hook.init");
        if (void 0 !== t && "function" != typeof t) throw new k("hook.before");
        if (void 0 !== s && "function" != typeof s) throw new k("hook.after");
        if (void 0 !== o && "function" != typeof o) throw new k("hook.destroy");
        if (void 0 !== r && "function" != typeof r)
          throw new k("hook.promiseResolve");
        (this[U] = e),
          (this[V] = t),
          (this[G] = s),
          (this[J] = o),
          (this[Q] = r);
      }
      enable() {
        const { 0: e, 1: t } = D();
        if (i(e, this)) return this;
        const s = t[te];
        return (
          (t[te] = t[X] += +!!this[U]),
          (t[te] += t[Z] += +!!this[V]),
          (t[te] += t[$] += +!!this[G]),
          (t[te] += t[ee] += +!!this[J]),
          (t[te] += t[se] += +!!this[Q]),
          a(e, this),
          0 === s && t[te] > 0 && E(),
          N(),
          this
        );
      }
      disable() {
        const { 0: e, 1: t } = D(),
          s = c(e, this);
        if (-1 === s) return this;
        const o = t[te];
        return (
          (t[te] = t[X] -= +!!this[U]),
          (t[te] += t[Z] -= +!!this[V]),
          (t[te] += t[$] -= +!!this[G]),
          (t[te] += t[ee] -= +!!this[J]),
          (t[te] += t[se] -= +!!this[Q]),
          l(e, s, 1),
          o > 0 && 0 === t[te] && L(),
          this
        );
      }
    }
    function createHook(e) {
      return new AsyncHook(e);
    }
    const oe = A("destroyed");
    class AsyncResource {
      constructor(e, t = R) {
        I(e, "type");
        let s = t,
          o = !1;
        if (
          ("number" != typeof t &&
            ((s = void 0 === t.triggerAsyncId ? j() : t.triggerAsyncId),
            (o = !!t.requireManualDestroy)),
          !u(s) || s < -1)
        )
          throw new p("triggerAsyncId", s);
        const r = O();
        if (((this[z] = r), (this[K] = s), M())) {
          if (W() && 0 === e.length) throw new g(e);
          B(r, e, s, this);
        }
        if (!o && q()) {
          const e = { destroyed: !1 };
          (this[oe] = e), v(this, r, e);
        }
      }
      runInAsyncScope(e, t, ...s) {
        const o = this[z];
        F(o, this[K], this);
        try {
          return b(e, t, s);
        } finally {
          x() && Y(o);
        }
      }
      emitDestroy() {
        return (
          void 0 !== this[oe] && (this[oe].destroyed = !0), T(this[z]), this
        );
      }
      asyncId() {
        return this[z];
      }
      triggerAsyncId() {
        return this[K];
      }
      bind(e, t) {
        let s;
        if ((m(e, "fn"), void 0 === t)) {
          const t = this;
          s = function (...s) {
            return h(s, e, this), b(t.runInAsyncScope, t, s);
          };
        } else s = y(this.runInAsyncScope, this, e, t);
        return (
          d(s, {
            length: {
              __proto__: null,
              configurable: !0,
              enumerable: !1,
              value: e.length,
              writable: !1,
            },
            asyncResource: {
              __proto__: null,
              configurable: !0,
              enumerable: !0,
              value: this,
              writable: !0,
            },
          }),
          s
        );
      }
      static bind(e, t, s) {
        return (
          (t = t || e.name),
          new AsyncResource(t || "bound-anonymous-fn").bind(e, s)
        );
      }
    }
    const re = [],
      ne = createHook({
        init(e, t, s, o) {
          const r = C();
          for (let e = 0; e < re.length; ++e) re[e]._propagate(o, r, t);
        },
      });
    class AsyncLocalStorage {
      constructor() {
        (this.kResourceStore = A("kResourceStore")), (this.enabled = !1);
      }
      static bind(e) {
        return AsyncResource.bind(e);
      }
      static snapshot() {
        return AsyncLocalStorage.bind((e, ...t) => e(...t));
      }
      disable() {
        this.enabled &&
          ((this.enabled = !1),
          l(re, c(re, this), 1),
          0 === re.length && ne.disable());
      }
      _enable() {
        this.enabled || ((this.enabled = !0), a(re, this), ne.enable());
      }
      _propagate(e, t, s) {
        const o = t[this.kResourceStore];
        this.enabled && (e[this.kResourceStore] = o);
      }
      enterWith(e) {
        this._enable();
        C()[this.kResourceStore] = e;
      }
      run(e, t, ...s) {
        if (f(e, this.getStore())) return b(t, null, s);
        this._enable();
        const o = C(),
          r = o[this.kResourceStore];
        o[this.kResourceStore] = e;
        try {
          return b(t, null, s);
        } finally {
          o[this.kResourceStore] = r;
        }
      }
      exit(e, ...t) {
        if (!this.enabled) return b(e, null, t);
        this.disable();
        try {
          return b(e, null, t);
        } finally {
          this._enable();
        }
      }
      getStore() {
        if (this.enabled) {
          return C()[this.kResourceStore];
        }
      }
    }
    s.exports = {
      AsyncLocalStorage: AsyncLocalStorage,
      createHook: createHook,
      executionAsyncId: H,
      triggerAsyncId: P,
      executionAsyncResource: C,
      asyncWrapProviders: _({ __proto__: null, ...w.Providers }),
      AsyncResource: AsyncResource,
    };
  },
  buffer: function (e, t, r, n, i, f) {
    "use strict";
    const {
        Array: o,
        ArrayFrom: u,
        ArrayIsArray: s,
        ArrayPrototypeForEach: l,
        ArrayPrototypeIndexOf: a,
        MathFloor: c,
        MathMin: h,
        MathTrunc: g,
        NumberIsNaN: p,
        NumberMAX_SAFE_INTEGER: y,
        NumberMIN_SAFE_INTEGER: d,
        ObjectCreate: w,
        ObjectDefineProperties: b,
        ObjectDefineProperty: B,
        ObjectSetPrototypeOf: S,
        RegExpPrototypeSymbolReplace: _,
        StringPrototypeCharCodeAt: A,
        StringPrototypeSlice: m,
        StringPrototypeToLowerCase: v,
        StringPrototypeTrim: O,
        SymbolSpecies: E,
        SymbolToPrimitive: L,
        TypedArrayPrototypeGetBuffer: I,
        TypedArrayPrototypeGetByteLength: x,
        TypedArrayPrototypeGetByteOffset: P,
        TypedArrayPrototypeFill: N,
        TypedArrayPrototypeGetLength: U,
        TypedArrayPrototypeSet: R,
        TypedArrayPrototypeSlice: T,
        Uint8Array: F,
        Uint8ArrayPrototype: k,
      } = f,
      {
        byteLengthUtf8: M,
        compare: V,
        compareOffset: G,
        createFromString: C,
        fill: W,
        isAscii: j,
        isUtf8: D,
        indexOfBuffer: z,
        indexOfNumber: $,
        indexOfString: X,
        swap16: H,
        swap32: Y,
        swap64: q,
        kMaxLength: J,
        kStringMaxLength: K,
      } = i("buffer"),
      {
        constants: { ALL_PROPERTIES: Z, ONLY_ENUMERABLE: Q },
        getOwnNonIndexProperties: ee,
      } = i("util"),
      {
        customInspectSymbol: te,
        isInsideNodeModules: re,
        lazyDOMException: ne,
        normalizeEncoding: ie,
        kIsEncodingSymbol: fe,
        defineLazyProperties: oe,
      } = t("internal/util"),
      {
        isAnyArrayBuffer: ue,
        isArrayBufferView: se,
        isUint8Array: le,
        isTypedArray: ae,
      } = t("internal/util/types"),
      { inspect: ce } = t("internal/util/inspect"),
      { encodings: he } = i("string_decoder"),
      {
        codes: {
          ERR_BUFFER_OUT_OF_BOUNDS: ge,
          ERR_INVALID_ARG_TYPE: pe,
          ERR_INVALID_ARG_VALUE: ye,
          ERR_INVALID_BUFFER_SIZE: de,
          ERR_OUT_OF_RANGE: we,
          ERR_MISSING_ARGS: be,
          ERR_UNKNOWN_ENCODING: Be,
        },
        genericNodeError: Se,
        hideStackFrames: _e,
      } = t("internal/errors"),
      {
        validateArray: Ae,
        validateBuffer: me,
        validateNumber: ve,
        validateInteger: Oe,
        validateString: Ee,
      } = t("internal/validators"),
      validateOffset = (e, t, r = 0, n = J) => Oe(e, t, r, n),
      {
        FastBuffer: Le,
        markAsUntransferable: Ie,
        addBufferPrototypeMethods: xe,
        createUnsafeBuffer: Pe,
      } = t("internal/buffer");
    (Le.prototype.constructor = Buffer),
      (Buffer.prototype = Le.prototype),
      xe(Buffer.prototype);
    const Ne = b(
      {},
      {
        MAX_LENGTH: { __proto__: null, value: J, writable: !1, enumerable: !0 },
        MAX_STRING_LENGTH: {
          __proto__: null,
          value: K,
          writable: !1,
          enumerable: !0,
        },
      }
    );
    let Ue, Re, Te;
    Buffer.poolSize = 8192;
    const Fe = w(null);
    for (let e = 0; e < he.length; ++e) Fe[he[e]] = e;
    function createPool() {
      (Ue = Buffer.poolSize), (Te = Pe(Ue).buffer), Ie(Te), (Re = 0);
    }
    function alignPool() {
      7 & Re && ((Re |= 7), Re++);
    }
    createPool();
    let ke = !1,
      Me = 0;
    const Ve =
      "Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.";
    function toInteger(e, t) {
      return !p((e = +e)) && e >= d && e <= y ? (e % 1 == 0 ? e : c(e)) : t;
    }
    function _copyActual(e, t, r, n, i) {
      i - n > t.length - r && (i = n + t.length - r);
      let f = i - n;
      const o = e.length - n;
      return (
        f > o && (f = o),
        (0 !== n || i < e.length) && (e = new F(e.buffer, e.byteOffset + n, f)),
        R(t, e, r),
        f
      );
    }
    function Buffer(e, r, i) {
      if (
        ((function showFlaggedDeprecation() {
          ke ||
            ++Me > 1e4 ||
            (!t("internal/options").getOptionValue("--pending-deprecation") &&
              re()) ||
            (n.emitWarning(Ve, "DeprecationWarning", "DEP0005"), (ke = !0));
        })(),
        "number" == typeof e)
      ) {
        if ("string" == typeof r) throw new pe("string", "string", e);
        return Buffer.alloc(e);
      }
      return Buffer.from(e, r, i);
    }
    B(Buffer, E, {
      __proto__: null,
      enumerable: !1,
      configurable: !0,
      get: () => Le,
    }),
      (Buffer.from = function from(e, t, r) {
        if ("string" == typeof e) return fromString(e, t);
        if ("object" == typeof e && null !== e) {
          if (ue(e))
            return (function fromArrayBuffer(e, t, r) {
              (void 0 === t || p((t = +t))) && (t = 0);
              const n = e.byteLength - t;
              if (n < 0) throw new ge("offset");
              if (void 0 === r) r = n;
              else if ((r = +r) > 0) {
                if (r > n) throw new ge("length");
              } else r = 0;
              return new Le(e, t, r);
            })(e, t, r);
          const n = e.valueOf && e.valueOf();
          if (
            null != n &&
            n !== e &&
            ("string" == typeof n || "object" == typeof n)
          )
            return from(n, t, r);
          const i = (function fromObject(e) {
            if (void 0 !== e.length || ue(e.buffer))
              return "number" != typeof e.length ? new Le() : fromArrayLike(e);
            if ("Buffer" === e.type && s(e.data)) return fromArrayLike(e.data);
          })(e);
          if (i) return i;
          if ("function" == typeof e[L]) {
            const r = e[L]("string");
            if ("string" == typeof r) return fromString(r, t);
          }
        }
        throw new pe(
          "first argument",
          ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"],
          e
        );
      }),
      (Buffer.copyBytesFrom = function copyBytesFrom(e, t, r) {
        if (!ae(e)) throw new pe("view", ["TypedArray"], e);
        const n = U(e);
        if (0 === n) return Buffer.alloc(0);
        if (void 0 !== t || void 0 !== r) {
          if (void 0 !== t) {
            if ((Oe(t, "offset", 0), t >= n)) return Buffer.alloc(0);
          } else t = 0;
          let i;
          void 0 !== r ? (Oe(r, "length", 0), (i = t + r)) : (i = n),
            (e = T(e, t, i));
        }
        return fromArrayLike(new F(I(e), P(e), x(e)));
      });
    (Buffer.of = (...e) => {
      const t = Pe(e.length);
      for (let r = 0; r < e.length; r++) t[r] = e[r];
      return t;
    }),
      S(Buffer, F);
    const Ge = _e((e) => {
      if ((ve(e, "size"), !(e >= 0 && e <= J)))
        throw new ye.RangeError("size", e);
    });
    function SlowBuffer(e) {
      return Ge(e), Pe(e);
    }
    function fromStringFast(e, t) {
      const r = t.byteLength(e);
      if (r >= Buffer.poolSize >>> 1) return C(e, t.encodingVal);
      r > Ue - Re && createPool();
      let n = new Le(Te, Re, r);
      const i = t.write(n, e, 0, r);
      return i !== r && (n = new Le(Te, Re, i)), (Re += i), alignPool(), n;
    }
    function fromString(e, t) {
      let r;
      if ("string" != typeof t || 0 === t.length) {
        if (0 === e.length) return new Le();
        (r = Ce.utf8), (t = void 0);
      } else {
        if (((r = getEncodingOps(t)), void 0 === r)) throw new Be(t);
        if (0 === e.length) return new Le();
      }
      return fromStringFast(e, r);
    }
    function fromArrayLike(e) {
      if (e.length <= 0) return new Le();
      if (e.length < Buffer.poolSize >>> 1) {
        e.length > Ue - Re && createPool();
        const t = new Le(Te, Re, e.length);
        return R(t, e, 0), (Re += e.length), alignPool(), t;
      }
      return new Le(e);
    }
    function base64ByteLength(e, t) {
      return (
        61 === A(e, t - 1) && t--,
        t > 1 && 61 === A(e, t - 1) && t--,
        (3 * t) >>> 2
      );
    }
    (Buffer.alloc = function alloc(e, t, r) {
      if ((Ge(e), void 0 !== t && 0 !== t && e > 0)) {
        const n = Pe(e);
        return _fill(n, t, 0, n.length, r);
      }
      return new Le(e);
    }),
      (Buffer.allocUnsafe = function allocUnsafe(e) {
        return (
          Ge(e),
          (function allocate(e) {
            if (e <= 0) return new Le();
            if (e < Buffer.poolSize >>> 1) {
              e > Ue - Re && createPool();
              const t = new Le(Te, Re, e);
              return (Re += e), alignPool(), t;
            }
            return Pe(e);
          })(e)
        );
      }),
      (Buffer.allocUnsafeSlow = function allocUnsafeSlow(e) {
        return Ge(e), Pe(e);
      }),
      S(SlowBuffer.prototype, k),
      S(SlowBuffer, F),
      (Buffer.isBuffer = function isBuffer(e) {
        return e instanceof Buffer;
      }),
      (Buffer.compare = function compare(e, t) {
        if (!le(e)) throw new pe("buf1", ["Buffer", "Uint8Array"], e);
        if (!le(t)) throw new pe("buf2", ["Buffer", "Uint8Array"], t);
        return e === t ? 0 : V(e, t);
      }),
      (Buffer.isEncoding = function isEncoding(e) {
        return "string" == typeof e && 0 !== e.length && void 0 !== ie(e);
      }),
      (Buffer[fe] = Buffer.isEncoding),
      (Buffer.concat = function concat(e, t) {
        if ((Ae(e, "list"), 0 === e.length)) return new Le();
        if (void 0 === t) {
          t = 0;
          for (let r = 0; r < e.length; r++) e[r].length && (t += e[r].length);
        } else validateOffset(t, "length");
        const r = Buffer.allocUnsafe(t);
        let n = 0;
        for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (!le(i))
            throw new pe(`list[${t}]`, ["Buffer", "Uint8Array"], e[t]);
          n += _copyActual(i, r, n, 0, i.length);
        }
        return n < t && N(r, 0, n, t), r;
      });
    const Ce = {
      utf8: {
        encoding: "utf8",
        encodingVal: Fe.utf8,
        byteLength: M,
        write: (e, t, r, n) => e.utf8Write(t, r, n),
        slice: (e, t, r) => e.utf8Slice(t, r),
        indexOf: (e, t, r, n) => X(e, t, r, Fe.utf8, n),
      },
      ucs2: {
        encoding: "ucs2",
        encodingVal: Fe.utf16le,
        byteLength: (e) => 2 * e.length,
        write: (e, t, r, n) => e.ucs2Write(t, r, n),
        slice: (e, t, r) => e.ucs2Slice(t, r),
        indexOf: (e, t, r, n) => X(e, t, r, Fe.utf16le, n),
      },
      utf16le: {
        encoding: "utf16le",
        encodingVal: Fe.utf16le,
        byteLength: (e) => 2 * e.length,
        write: (e, t, r, n) => e.ucs2Write(t, r, n),
        slice: (e, t, r) => e.ucs2Slice(t, r),
        indexOf: (e, t, r, n) => X(e, t, r, Fe.utf16le, n),
      },
      latin1: {
        encoding: "latin1",
        encodingVal: Fe.latin1,
        byteLength: (e) => e.length,
        write: (e, t, r, n) => e.latin1Write(t, r, n),
        slice: (e, t, r) => e.latin1Slice(t, r),
        indexOf: (e, t, r, n) => X(e, t, r, Fe.latin1, n),
      },
      ascii: {
        encoding: "ascii",
        encodingVal: Fe.ascii,
        byteLength: (e) => e.length,
        write: (e, t, r, n) => e.asciiWrite(t, r, n),
        slice: (e, t, r) => e.asciiSlice(t, r),
        indexOf: (e, t, r, n) =>
          z(e, fromStringFast(t, Ce.ascii), r, Fe.ascii, n),
      },
      base64: {
        encoding: "base64",
        encodingVal: Fe.base64,
        byteLength: (e) => base64ByteLength(e, e.length),
        write: (e, t, r, n) => e.base64Write(t, r, n),
        slice: (e, t, r) => e.base64Slice(t, r),
        indexOf: (e, t, r, n) =>
          z(e, fromStringFast(t, Ce.base64), r, Fe.base64, n),
      },
      base64url: {
        encoding: "base64url",
        encodingVal: Fe.base64url,
        byteLength: (e) => base64ByteLength(e, e.length),
        write: (e, t, r, n) => e.base64urlWrite(t, r, n),
        slice: (e, t, r) => e.base64urlSlice(t, r),
        indexOf: (e, t, r, n) =>
          z(e, fromStringFast(t, Ce.base64url), r, Fe.base64url, n),
      },
      hex: {
        encoding: "hex",
        encodingVal: Fe.hex,
        byteLength: (e) => e.length >>> 1,
        write: (e, t, r, n) => e.hexWrite(t, r, n),
        slice: (e, t, r) => e.hexSlice(t, r),
        indexOf: (e, t, r, n) => z(e, fromStringFast(t, Ce.hex), r, Fe.hex, n),
      },
    };
    function getEncodingOps(e) {
      switch ((e += "").length) {
        case 4:
          if ("utf8" === e) return Ce.utf8;
          if ("ucs2" === e) return Ce.ucs2;
          if ("utf8" === (e = v(e))) return Ce.utf8;
          if ("ucs2" === e) return Ce.ucs2;
          break;
        case 5:
          if ("utf-8" === e) return Ce.utf8;
          if ("ascii" === e) return Ce.ascii;
          if ("ucs-2" === e) return Ce.ucs2;
          if ("utf-8" === (e = v(e))) return Ce.utf8;
          if ("ascii" === e) return Ce.ascii;
          if ("ucs-2" === e) return Ce.ucs2;
          break;
        case 7:
          if ("utf16le" === e || "utf16le" === v(e)) return Ce.utf16le;
          break;
        case 8:
          if ("utf-16le" === e || "utf-16le" === v(e)) return Ce.utf16le;
          break;
        case 6:
          if ("latin1" === e || "binary" === e) return Ce.latin1;
          if ("base64" === e) return Ce.base64;
          if ("latin1" === (e = v(e)) || "binary" === e) return Ce.latin1;
          if ("base64" === e) return Ce.base64;
          break;
        case 3:
          if ("hex" === e || "hex" === v(e)) return Ce.hex;
          break;
        case 9:
          if ("base64url" === e || "base64url" === v(e)) return Ce.base64url;
      }
    }
    (Buffer.byteLength = function byteLength(e, t) {
      if ("string" != typeof e) {
        if (se(e) || ue(e)) return e.byteLength;
        throw new pe("string", ["string", "Buffer", "ArrayBuffer"], e);
      }
      if (0 === e.length) return 0;
      if (t) {
        const r = getEncodingOps(t);
        if (r) return r.byteLength(e);
      }
      return M(e);
    }),
      B(Buffer.prototype, "parent", {
        __proto__: null,
        enumerable: !0,
        get() {
          if (this instanceof Buffer) return this.buffer;
        },
      }),
      B(Buffer.prototype, "offset", {
        __proto__: null,
        enumerable: !0,
        get() {
          if (this instanceof Buffer) return this.byteOffset;
        },
      }),
      (Buffer.prototype.copy = function copy(e, t, r, n) {
        return (function _copy(e, t, r, n, i) {
          if (!le(e)) throw new pe("source", ["Buffer", "Uint8Array"], e);
          if (!le(t)) throw new pe("target", ["Buffer", "Uint8Array"], t);
          if (void 0 === r) r = 0;
          else if ((r = toInteger(r, 0)) < 0)
            throw new we("targetStart", ">= 0", r);
          if (void 0 === n) n = 0;
          else if ((n = toInteger(n, 0)) < 0 || n > e.length)
            throw new we("sourceStart", `>= 0 && <= ${e.length}`, n);
          if (void 0 === i) i = e.length;
          else if ((i = toInteger(i, 0)) < 0)
            throw new we("sourceEnd", ">= 0", i);
          return r >= t.length || n >= i ? 0 : _copyActual(e, t, r, n, i);
        })(this, e, t, r, n);
      }),
      (Buffer.prototype.toString = function toString(e, t, r) {
        if (0 === arguments.length) return this.utf8Slice(0, this.length);
        const n = this.length;
        if (t <= 0) t = 0;
        else {
          if (t >= n) return "";
          t |= 0;
        }
        if ((void 0 === r || r > n ? (r = n) : (r |= 0), r <= t)) return "";
        if (void 0 === e) return this.utf8Slice(t, r);
        const i = getEncodingOps(e);
        if (void 0 === i) throw new Be(e);
        return i.slice(this, t, r);
      }),
      (Buffer.prototype.equals = function equals(e) {
        if (!le(e)) throw new pe("otherBuffer", ["Buffer", "Uint8Array"], e);
        return (
          this === e ||
          (this.byteLength === e.byteLength &&
            (0 === this.byteLength || 0 === V(this, e)))
        );
      });
    let We,
      je = 50;
    function bidirectionalIndexOf(e, t, r, n, i) {
      if (
        (me(e),
        "string" == typeof r
          ? ((n = r), (r = void 0))
          : r > 2147483647
          ? (r = 2147483647)
          : r < -2147483648 && (r = -2147483648),
        p((r = +r)) && (r = i ? 0 : e.length || e.byteLength),
        (i = !!i),
        "number" == typeof t)
      )
        return $(e, t >>> 0, r, i);
      let f;
      if (
        ((f = void 0 === n ? Ce.utf8 : getEncodingOps(n)), "string" == typeof t)
      ) {
        if (void 0 === f) throw new Be(n);
        return f.indexOf(e, t, r, i);
      }
      if (le(t)) {
        const n = void 0 === f ? Fe.utf8 : f.encodingVal;
        return z(e, t, r, n, i);
      }
      throw new pe("value", ["number", "string", "Buffer", "Uint8Array"], t);
    }
    function _fill(e, t, r, n, i) {
      if ("string" == typeof t) {
        void 0 === r || "string" == typeof r
          ? ((i = r), (r = 0), (n = e.length))
          : "string" == typeof n && ((i = n), (n = e.length));
        const f = ie(i);
        if (void 0 === f) throw (Ee(i, "encoding"), new Be(i));
        if (0 === t.length) t = 0;
        else if (1 === t.length)
          if ("utf8" === f) {
            const e = A(t, 0);
            e < 128 && (t = e);
          } else "latin1" === f && (t = A(t, 0));
      } else i = void 0;
      if (void 0 === r) (r = 0), (n = e.length);
      else if (
        (validateOffset(r, "offset"),
        void 0 === n ? (n = e.length) : validateOffset(n, "end", 0, e.length),
        r >= n)
      )
        return e;
      if ("number" == typeof t) {
        const i = x(e);
        if (r > n || n - r + r > i) throw new ge();
        N(e, t, r, n);
      } else {
        const f = W(e, t, r, n, i);
        if (f < 0) {
          if (-1 === f) throw new ye("value", t);
          throw new ge();
        }
      }
      return e;
    }
    function adjustOffset(e, t) {
      return 0 === (e = g(e))
        ? 0
        : e < 0
        ? (e += t) > 0
          ? e
          : 0
        : e < t
        ? e
        : p(e)
        ? 0
        : t;
    }
    function swap(e, t, r) {
      const n = e[t];
      (e[t] = e[r]), (e[r] = n);
    }
    if (
      ((Buffer.prototype[te] = function inspect(e, t) {
        const r = je,
          n = h(r, this.length),
          i = this.length - r;
        let f = O(_(/(.{2})/g, this.hexSlice(0, n), "$1 "));
        if ((i > 0 && (f += ` ... ${i} more byte${i > 1 ? "s" : ""}`), t)) {
          let e = !1;
          const r = t.showHidden ? Z : Q,
            n = w(null);
          l(ee(this, r), (t) => {
            (e = !0), (n[t] = this[t]);
          }),
            e &&
              (0 !== this.length && (f += ", "),
              (f += m(
                ce(n, { ...t, breakLength: 1 / 0, compact: !0 }),
                27,
                -2
              )));
        }
        return `<${this.constructor.name} ${f}>`;
      }),
      (Buffer.prototype.inspect = Buffer.prototype[te]),
      (Buffer.prototype.compare = function compare(e, t, r, n, i) {
        if (!le(e)) throw new pe("target", ["Buffer", "Uint8Array"], e);
        return 1 === arguments.length
          ? V(this, e)
          : (void 0 === t ? (t = 0) : validateOffset(t, "targetStart"),
            void 0 === r
              ? (r = e.length)
              : validateOffset(r, "targetEnd", 0, e.length),
            void 0 === n ? (n = 0) : validateOffset(n, "sourceStart"),
            void 0 === i
              ? (i = this.length)
              : validateOffset(i, "sourceEnd", 0, this.length),
            n >= i ? (t >= r ? 0 : -1) : t >= r ? 1 : G(this, e, t, n, r, i));
      }),
      (Buffer.prototype.indexOf = function indexOf(e, t, r) {
        return bidirectionalIndexOf(this, e, t, r, !0);
      }),
      (Buffer.prototype.lastIndexOf = function lastIndexOf(e, t, r) {
        return bidirectionalIndexOf(this, e, t, r, !1);
      }),
      (Buffer.prototype.includes = function includes(e, t, r) {
        return -1 !== this.indexOf(e, t, r);
      }),
      (Buffer.prototype.fill = function fill(e, t, r, n) {
        return _fill(this, e, t, r, n);
      }),
      (Buffer.prototype.write = function write(e, t, r, n) {
        if (void 0 === t) return this.utf8Write(e, 0, this.length);
        if (void 0 === r && "string" == typeof t)
          (n = t), (r = this.length), (t = 0);
        else {
          validateOffset(t, "offset", 0, this.length);
          const e = this.length - t;
          void 0 === r
            ? (r = e)
            : "string" == typeof r
            ? ((n = r), (r = e))
            : (validateOffset(r, "length", 0, this.length), r > e && (r = e));
        }
        if (!n) return this.utf8Write(e, t, r);
        const i = getEncodingOps(n);
        if (void 0 === i) throw new Be(n);
        return i.write(this, e, t, r);
      }),
      (Buffer.prototype.toJSON = function toJSON() {
        if (this.length > 0) {
          const e = new o(this.length);
          for (let t = 0; t < this.length; ++t) e[t] = this[t];
          return { type: "Buffer", data: e };
        }
        return { type: "Buffer", data: [] };
      }),
      (Buffer.prototype.subarray = function subarray(e, t) {
        const r = this.length;
        e = adjustOffset(e, r);
        const n = (t = void 0 !== t ? adjustOffset(t, r) : r) > e ? t - e : 0;
        return new Le(this.buffer, this.byteOffset + e, n);
      }),
      (Buffer.prototype.slice = function slice(e, t) {
        return this.subarray(e, t);
      }),
      (Buffer.prototype.swap16 = function swap16() {
        const e = this.length;
        if (e % 2 != 0) throw new de("16-bits");
        if (e < 128) {
          for (let t = 0; t < e; t += 2) swap(this, t, t + 1);
          return this;
        }
        return H(this);
      }),
      (Buffer.prototype.swap32 = function swap32() {
        const e = this.length;
        if (e % 4 != 0) throw new de("32-bits");
        if (e < 192) {
          for (let t = 0; t < e; t += 4)
            swap(this, t, t + 3), swap(this, t + 1, t + 2);
          return this;
        }
        return Y(this);
      }),
      (Buffer.prototype.swap64 = function swap64() {
        const e = this.length;
        if (e % 8 != 0) throw new de("64-bits");
        if (e < 192) {
          for (let t = 0; t < e; t += 8)
            swap(this, t, t + 7),
              swap(this, t + 1, t + 6),
              swap(this, t + 2, t + 5),
              swap(this, t + 3, t + 4);
          return this;
        }
        return q(this);
      }),
      (Buffer.prototype.toLocaleString = Buffer.prototype.toString),
      i("config").hasIntl)
    ) {
      const { icuErrName: e, transcode: t } = i("icu");
      We = function transcode2(r, n, i) {
        if (!le(r)) throw new pe("source", ["Buffer", "Uint8Array"], r);
        if (0 === r.length) return Buffer.alloc(0);
        (n = ie(n) || n), (i = ie(i) || i);
        const f = t(r, n, i);
        if ("number" != typeof f) return f;
        const o = e(f);
        throw Se(`Unable to transcode Buffer [${o}]`, { code: o, errno: f });
      };
    }
    const De = [
        9,
        10,
        12,
        13,
        32,
        ...u({ length: 26 }, (e, t) => A("A") + t),
        ...u({ length: 26 }, (e, t) => A("a") + t),
        ...u({ length: 10 }, (e, t) => A("0") + t),
        43,
        47,
        61,
      ],
      ze = a(De, 61);
    (r.exports = {
      Buffer: Buffer,
      SlowBuffer: SlowBuffer,
      transcode: We,
      isUtf8: function isUtf8(e) {
        if (ae(e) || ue(e)) return D(e);
        throw new pe("input", ["TypedArray", "Buffer"], e);
      },
      isAscii: function isAscii(e) {
        if (ae(e) || ue(e)) return j(e);
        throw new pe("input", ["ArrayBuffer", "Buffer", "TypedArray"], e);
      },
      kMaxLength: J,
      kStringMaxLength: K,
      btoa: function btoa(e) {
        if (0 === arguments.length) throw new be("input");
        e = `${e}`;
        for (let t = 0; t < e.length; t++)
          if (e[t].charCodeAt(0) > 255)
            throw ne("Invalid character", "InvalidCharacterError");
        return Buffer.from(e, "latin1").toString("base64");
      },
      atob: function atob(e) {
        if (0 === arguments.length) throw new be("input");
        e = `${e}`;
        let t = 0,
          r = 0;
        for (let n = 0; n < e.length; n++) {
          const i = a(De, A(e, n));
          if (i > 4) {
            if ((t++, i === ze)) r++;
            else if (r) throw ne("Invalid character", "InvalidCharacterError");
            if (r > 2) throw ne("Invalid character", "InvalidCharacterError");
          } else if (-1 === i)
            throw ne("Invalid character", "InvalidCharacterError");
        }
        let n = t % 4;
        if (n) {
          if (r) throw ne("Invalid character", "InvalidCharacterError");
        } else n = (t - r) % 4;
        if (1 === n)
          throw ne(
            "The string to be decoded is not correctly encoded.",
            "InvalidCharacterError"
          );
        return Buffer.from(e, "base64").toString("latin1");
      },
    }),
      b(r.exports, {
        constants: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: Ne,
        },
        INSPECT_MAX_BYTES: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get: () => je,
          set(e) {
            je = e;
          },
        },
      }),
      oe(r.exports, "internal/blob", ["Blob", "resolveObjectURL"]),
      oe(r.exports, "internal/file", ["File"]);
  },
  child_process: function (e, t, n, o, i, r) {
    "use strict";
    const {
        ArrayIsArray: l,
        ArrayPrototypeFilter: s,
        ArrayPrototypeIncludes: a,
        ArrayPrototypeJoin: c,
        ArrayPrototypeLastIndexOf: u,
        ArrayPrototypePush: d,
        ArrayPrototypeSlice: f,
        ArrayPrototypeSort: p,
        ArrayPrototypeSplice: g,
        ArrayPrototypeUnshift: m,
        ArrayPrototypePushApply: v,
        NumberIsInteger: h,
        ObjectAssign: y,
        ObjectDefineProperty: w,
        ObjectPrototypeHasOwnProperty: _,
        RegExpPrototypeExec: E,
        SafeSet: A,
        StringPrototypeIncludes: x,
        StringPrototypeSlice: S,
        StringPrototypeToUpperCase: P,
        SymbolDispose: b,
      } = r,
      {
        convertToValidSignal: k,
        createDeferredPromise: C,
        getSystemErrorName: T,
        kEmptyObject: R,
        promisify: I,
      } = t("internal/util"),
      { isArrayBufferView: N } = t("internal/util/types");
    let B = t("internal/util/debuglog").debuglog("child_process", (e) => {
      B = e;
    });
    const { Buffer: D } = t("buffer"),
      { Pipe: F, constants: L } = i("pipe_wrap"),
      { AbortError: O, codes: V, genericNodeError: z } = t("internal/errors"),
      {
        ERR_INVALID_ARG_VALUE: $,
        ERR_CHILD_PROCESS_IPC_REQUIRED: H,
        ERR_CHILD_PROCESS_STDIO_MAXBUFFER: j,
        ERR_INVALID_ARG_TYPE: U,
        ERR_OUT_OF_RANGE: G,
      } = V,
      { clearTimeout: K, setTimeout: M } = t("timers"),
      { getValidatedPath: X } = t("internal/fs/utils"),
      {
        isInt32: J,
        validateAbortSignal: Q,
        validateArray: Y,
        validateBoolean: q,
        validateFunction: W,
        validateObject: Z,
        validateString: ee,
      } = t("internal/validators"),
      te = t("internal/child_process"),
      {
        getValidStdio: ne,
        setupChannel: oe,
        ChildProcess: ie,
        stdioStringToArray: re,
      } = te,
      le = 1048576,
      se = "os390" === o.platform;
    let ae;
    function normalizeExecArgs(e, t, n) {
      return (
        ee(e, "command"),
        validateArgumentNullCheck(e, "command"),
        "function" == typeof t && ((n = t), (t = void 0)),
        ((t = { __proto__: null, ...t }).shell =
          "string" != typeof t.shell || t.shell),
        { file: e, options: t, callback: n }
      );
    }
    function exec(e, t, o) {
      const i = normalizeExecArgs(e, t, o);
      return n.exports.execFile(i.file, i.options, i.callback);
    }
    const customPromiseExecFunction =
      (e) =>
      (...t) => {
        const { promise: n, resolve: o, reject: i } = C();
        return (
          (n.child = e(...t, (e, t, n) => {
            null !== e
              ? ((e.stdout = t), (e.stderr = n), i(e))
              : o({ stdout: t, stderr: n });
          })),
          n
        );
      };
    function normalizeExecFileArgs(e, t, n, o) {
      return (
        l(t)
          ? (t = f(t))
          : null != t && "object" == typeof t
          ? ((o = n), (n = t), (t = null))
          : "function" == typeof t && ((o = t), (n = null), (t = null)),
        null == t && (t = []),
        "function" == typeof n ? (o = n) : null != n && Z(n, "options"),
        null == n && (n = R),
        null != o && W(o, "callback"),
        null != n.argv0 &&
          (ee(n.argv0, "options.argv0"),
          validateArgumentNullCheck(n.argv0, "options.argv0")),
        { file: e, args: t, options: n, callback: o }
      );
    }
    function execFile(e, t, n, o) {
      ({
        file: e,
        args: t,
        options: n,
        callback: o,
      } = normalizeExecFileArgs(e, t, n, o)),
        validateTimeout(
          (n = {
            __proto__: null,
            encoding: "utf8",
            timeout: 0,
            maxBuffer: le,
            killSignal: "SIGTERM",
            cwd: null,
            env: null,
            shell: !1,
            ...n,
          }).timeout
        ),
        validateMaxBuffer(n.maxBuffer),
        (n.killSignal = sanitizeKillSignal(n.killSignal));
      const i = spawn(e, t, {
        cwd: n.cwd,
        env: n.env,
        gid: n.gid,
        shell: n.shell,
        signal: n.signal,
        uid: n.uid,
        windowsHide: !!n.windowsHide,
        windowsVerbatimArguments: !!n.windowsVerbatimArguments,
      });
      let r;
      const l = [],
        s = [];
      r =
        "buffer" !== n.encoding && D.isEncoding(n.encoding) ? n.encoding : null;
      let a,
        u = 0,
        f = 0,
        p = !1,
        g = !1,
        m = null,
        v = e;
      function exithandler(e, n) {
        if (g) return;
        if (((g = !0), a && (K(a), (a = null)), !o)) return;
        let u, d;
        (u =
          r || (i.stdout && i.stdout.readableEncoding)
            ? c(l, "")
            : D.concat(l)),
          (d =
            r || (i.stderr && i.stderr.readableEncoding)
              ? c(s, "")
              : D.concat(s)),
          m || 0 !== e || null !== n
            ? (t?.length && (v += ` ${c(t, " ")}`),
              m ||
                (m = z(`Command failed: ${v}\n${d}`, {
                  code: e < 0 ? T(e) : e,
                  killed: i.killed || p,
                  signal: n,
                })),
              (m.cmd = v),
              o(m, u, d))
            : o(null, u, d);
      }
      function kill() {
        i.stdout && i.stdout.destroy(),
          i.stderr && i.stderr.destroy(),
          (p = !0);
        try {
          i.kill(n.killSignal);
        } catch (e) {
          (m = e), exithandler();
        }
      }
      return (
        n.timeout > 0 &&
          (a = M(function delayedKill() {
            kill(), (a = null);
          }, n.timeout)),
        i.stdout &&
          (r && i.stdout.setEncoding(r),
          i.stdout.on("data", function onChildStdout(e) {
            if (n.maxBuffer === 1 / 0) return void d(l, e);
            const t = i.stdout.readableEncoding,
              o = t ? D.byteLength(e, t) : e.length,
              r = t ? S : (e, ...t) => e.slice(...t);
            if (((u += o), u > n.maxBuffer)) {
              const t = n.maxBuffer - (u - o);
              d(l, r(e, 0, t)), (m = new j("stdout")), kill();
            } else d(l, e);
          })),
        i.stderr &&
          (r && i.stderr.setEncoding(r),
          i.stderr.on("data", function onChildStderr(e) {
            if (n.maxBuffer === 1 / 0) return void d(s, e);
            const t = i.stderr.readableEncoding,
              o = t ? D.byteLength(e, t) : e.length;
            if (((f += o), f > n.maxBuffer)) {
              const t = n.maxBuffer - (f - o);
              d(s, e.slice(0, t)), (m = new j("stderr")), kill();
            } else d(s, e);
          })),
        i.addListener("close", exithandler),
        i.addListener("error", function errorhandler(e) {
          (m = e),
            i.stdout && i.stdout.destroy(),
            i.stderr && i.stderr.destroy(),
            exithandler();
        }),
        i
      );
    }
    function copyProcessEnvToEnv(e, t, n) {
      !o.env[t] || (n && _(n, t)) || (e[t] = o.env[t]);
    }
    function normalizeSpawnArguments(e, t, n) {
      if ((ee(e, "file"), validateArgumentNullCheck(e, "file"), 0 === e.length))
        throw new $("file", e, "cannot be empty");
      if (l(t)) t = f(t);
      else if (null == t) t = [];
      else {
        if ("object" != typeof t) throw new U("args", "object", t);
        (n = t), (t = []);
      }
      validateArgumentsNullCheck(t, "args"),
        void 0 === n ? (n = R) : Z(n, "options");
      let i = n.cwd;
      if (
        (null != i && (i = X(i, "options.cwd")),
        null != n.detached && q(n.detached, "options.detached"),
        null != n.uid && !J(n.uid))
      )
        throw new U("options.uid", "int32", n.uid);
      if (null != n.gid && !J(n.gid))
        throw new U("options.gid", "int32", n.gid);
      if (
        null != n.shell &&
        "boolean" != typeof n.shell &&
        "string" != typeof n.shell
      )
        throw new U("options.shell", ["boolean", "string"], n.shell);
      null != n.argv0 &&
        (ee(n.argv0, "options.argv0"),
        validateArgumentNullCheck(n.argv0, "options.argv0")),
        null != n.windowsHide && q(n.windowsHide, "options.windowsHide");
      let { windowsVerbatimArguments: r } = n;
      if ((null != r && q(r, "options.windowsVerbatimArguments"), n.shell)) {
        validateArgumentNullCheck(n.shell, "options.shell");
        const i = c([e, ...t], " ");
        "win32" === o.platform
          ? ((e =
              "string" == typeof n.shell
                ? n.shell
                : o.env.comspec || "cmd.exe"),
            null !== E(/^(?:.*\\)?cmd(?:\.exe)?$/i, e)
              ? ((t = ["/d", "/s", "/c", `"${i}"`]), (r = !0))
              : (t = ["-c", i]))
          : ((e =
              "string" == typeof n.shell
                ? n.shell
                : "android" === o.platform
                ? "/system/bin/sh"
                : "/bin/sh"),
            (t = ["-c", i]));
      }
      "string" == typeof n.argv0 ? m(t, n.argv0) : m(t, e);
      const a = n.env || o.env,
        u = [];
      copyProcessEnvToEnv(a, "NODE_V8_COVERAGE", n.env),
        se &&
          (copyProcessEnvToEnv(a, "_BPXK_AUTOCVT", n.env),
          copyProcessEnvToEnv(a, "_CEE_RUNOPTS", n.env),
          copyProcessEnvToEnv(a, "_TAG_REDIR_ERR", n.env),
          copyProcessEnvToEnv(a, "_TAG_REDIR_IN", n.env),
          copyProcessEnvToEnv(a, "_TAG_REDIR_OUT", n.env),
          copyProcessEnvToEnv(a, "STEPLIB", n.env),
          copyProcessEnvToEnv(a, "LIBPATH", n.env),
          copyProcessEnvToEnv(a, "_EDC_SIG_DFLT", n.env),
          copyProcessEnvToEnv(a, "_EDC_SUSV3", n.env));
      let g = [];
      for (const e in a) d(g, e);
      if ("win32" === o.platform) {
        const e = new A();
        g = s(p(g), (t) => {
          const n = P(t);
          return !e.has(n) && (e.add(n), !0);
        });
      }
      for (const e of g) {
        const t = a[e];
        void 0 !== t &&
          (validateArgumentNullCheck(e, `options.env['${e}']`),
          validateArgumentNullCheck(t, `options.env['${e}']`),
          d(u, `${e}=${t}`));
      }
      return {
        __proto__: null,
        ...n,
        args: t,
        cwd: i,
        detached: !!n.detached,
        envPairs: u,
        file: e,
        windowsHide: !!n.windowsHide,
        windowsVerbatimArguments: !!r,
      };
    }
    function spawn(e, n, i) {
      validateTimeout((i = normalizeSpawnArguments(e, n, i)).timeout),
        Q(i.signal, "options.signal");
      const r = sanitizeKillSignal(i.killSignal),
        l = new ie();
      if ((B("spawn", i), l.spawn(i), i.timeout > 0)) {
        let e = M(() => {
          if (e) {
            try {
              l.kill(r);
            } catch (e) {
              l.emit("error", e);
            }
            e = null;
          }
        }, i.timeout);
        l.once("exit", () => {
          e && (K(e), (e = null));
        });
      }
      if (i.signal) {
        let onAbortListener = function () {
          !(function abortChildProcess(e, t, n) {
            if (e)
              try {
                e.kill(t) && e.emit("error", new O(void 0, { cause: n }));
              } catch (t) {
                e.emit("error", t);
              }
          })(l, r, i.signal.reason);
        };
        const e = i.signal;
        if (e.aborted) o.nextTick(onAbortListener);
        else {
          ae ??= t("events").addAbortListener;
          const n = ae(e, onAbortListener);
          l.once("exit", n[b]);
        }
      }
      return l;
    }
    function spawnSync(e, t, n) {
      if (
        ((n = {
          __proto__: null,
          maxBuffer: le,
          ...normalizeSpawnArguments(e, t, n),
        }),
        B("spawnSync", n),
        validateTimeout(n.timeout),
        validateMaxBuffer(n.maxBuffer),
        (n.killSignal = sanitizeKillSignal(n.killSignal)),
        (n.stdio = ne(n.stdio || "pipe", !0).stdio),
        n.input)
      ) {
        (n.stdio[0] = { ...n.stdio[0] }).input = n.input;
      }
      for (let e = 0; e < n.stdio.length; e++) {
        const t = n.stdio[e] && n.stdio[e].input;
        if (null != t) {
          const o = (n.stdio[e] = { ...n.stdio[e] });
          if (N(t)) o.input = t;
          else {
            if ("string" != typeof t)
              throw new U(
                `options.stdio[${e}]`,
                ["Buffer", "TypedArray", "DataView", "string"],
                t
              );
            o.input = D.from(t, n.encoding);
          }
        }
      }
      return te.spawnSync(n);
    }
    function checkExecSyncError(e, t, n) {
      let o;
      if (e.error) (o = e.error), y(o, e);
      else if (0 !== e.status) {
        let i = "Command failed: ";
        (i += n || c(t, " ")),
          e.stderr && e.stderr.length > 0 && (i += `\n${e.stderr.toString()}`),
          (o = z(i, e));
      }
      return o;
    }
    function validateArgumentNullCheck(e, t) {
      if ("string" == typeof e && x(e, "\0"))
        throw new $(t, e, "must be a string without null bytes");
    }
    function validateArgumentsNullCheck(e, t) {
      for (let n = 0; n < e.length; ++n)
        validateArgumentNullCheck(e[n], `${t}[${n}]`);
    }
    function validateTimeout(e) {
      if (null != e && !(h(e) && e >= 0))
        throw new G("timeout", "an unsigned integer", e);
    }
    function validateMaxBuffer(e) {
      if (null != e && !("number" == typeof e && e >= 0))
        throw new G("options.maxBuffer", "a positive number", e);
    }
    function sanitizeKillSignal(e) {
      if ("string" == typeof e || "number" == typeof e) return k(e);
      if (null != e) throw new U("options.killSignal", ["string", "number"], e);
    }
    w(exec, I.custom, {
      __proto__: null,
      enumerable: !1,
      value: customPromiseExecFunction(exec),
    }),
      w(execFile, I.custom, {
        __proto__: null,
        enumerable: !1,
        value: customPromiseExecFunction(execFile),
      }),
      (n.exports = {
        _forkChild: function _forkChild(e, t) {
          const n = new F(L.IPC);
          n.open(e), n.unref();
          const i = oe(o, n, t);
          o.on("newListener", function onNewListener(e) {
            ("message" !== e && "disconnect" !== e) || i.refCounted();
          }),
            o.on("removeListener", function onRemoveListener(e) {
              ("message" !== e && "disconnect" !== e) || i.unrefCounted();
            });
        },
        ChildProcess: ie,
        exec: exec,
        execFile: execFile,
        execFileSync: function execFileSync(e, t, n) {
          ({ file: e, args: t, options: n } = normalizeExecFileArgs(e, t, n));
          const i = !n.stdio,
            r = spawnSync(e, t, n);
          i && r.stderr && o.stderr.write(r.stderr);
          const l = [n.argv0 || e];
          v(l, t);
          const s = checkExecSyncError(r, l);
          if (s) throw s;
          return r.stdout;
        },
        execSync: function execSync(e, t) {
          const n = normalizeExecArgs(e, t, null),
            i = !n.options.stdio,
            r = spawnSync(n.file, n.options);
          i && r.stderr && o.stderr.write(r.stderr);
          const l = checkExecSyncError(r, void 0, e);
          if (l) throw l;
          return r.stdout;
        },
        fork: function fork(e, t = [], n) {
          let i;
          if (
            ((e = X(e, "modulePath")),
            null == t
              ? (t = [])
              : "object" != typeof t || l(t)
              ? Y(t, "args")
              : ((n = t), (t = [])),
            null != n && Z(n, "options"),
            ((n = { __proto__: null, ...n, shell: !1 }).execPath =
              n.execPath || o.execPath),
            validateArgumentNullCheck(n.execPath, "options.execPath"),
            (i = n.execArgv || o.execArgv),
            validateArgumentsNullCheck(i, "options.execArgv"),
            i === o.execArgv && null != o._eval)
          ) {
            const e = u(i, o._eval);
            e > 0 && ((i = f(i)), g(i, e - 1, 2));
          }
          if (((t = [...i, e, ...t]), "string" == typeof n.stdio))
            n.stdio = re(n.stdio, "ipc");
          else if (l(n.stdio)) {
            if (!a(n.stdio, "ipc")) throw new H("options.stdio");
          } else n.stdio = re(n.silent ? "pipe" : "inherit", "ipc");
          return spawn(n.execPath, t, n);
        },
        spawn: spawn,
        spawnSync: spawnSync,
      });
  },
  cluster: function (t, r, e, n, c, o) {
    "use strict";
    const { ObjectPrototypeHasOwnProperty: s } = o,
      i = s(n.env, "NODE_UNIQUE_ID") ? "child" : "primary";
    e.exports = r(`internal/cluster/${i}`);
  },
  console: function (n, o, t, e, l, s) {
    "use strict";
    t.exports = o("internal/console/global");
  },
  constants: function (s, o, t, n, e, c) {
    "use strict";
    const { ObjectAssign: r, ObjectFreeze: i } = c,
      p = e("constants");
    r(s, p.os.dlopen, p.os.errno, p.os.priority, p.os.signals, p.fs, p.crypto),
      i(s);
  },
  crypto: function (e, r, t, n, i, a) {
    "use strict";
    const { ObjectDefineProperty: c, ObjectDefineProperties: l } = a,
      { assertCrypto: o, deprecate: p } = r("internal/util");
    o();
    const { ERR_CRYPTO_FIPS_FORCED: u } = r("internal/errors").codes,
      s = i("constants").crypto,
      { getOptionValue: y } = r("internal/options"),
      { getFipsCrypto: f, setFipsCrypto: g, timingSafeEqual: m } = i("crypto"),
      {
        checkPrime: _,
        checkPrimeSync: d,
        generatePrime: h,
        generatePrimeSync: b,
        randomBytes: D,
        randomFill: C,
        randomFillSync: H,
        randomInt: v,
        randomUUID: E,
      } = r("internal/crypto/random"),
      { pbkdf2: S, pbkdf2Sync: P } = r("internal/crypto/pbkdf2"),
      { scrypt: F, scryptSync: w } = r("internal/crypto/scrypt"),
      { hkdf: k, hkdfSync: K } = r("internal/crypto/hkdf"),
      {
        generateKeyPair: R,
        generateKeyPairSync: O,
        generateKey: I,
        generateKeySync: G,
      } = r("internal/crypto/keygen"),
      {
        createSecretKey: U,
        createPublicKey: V,
        createPrivateKey: B,
        KeyObject: A,
      } = r("internal/crypto/keys"),
      {
        DiffieHellman: N,
        DiffieHellmanGroup: L,
        ECDH: j,
        diffieHellman: z,
      } = r("internal/crypto/diffiehellman"),
      {
        Cipher: T,
        Cipheriv: W,
        Decipher: x,
        Decipheriv: q,
        privateDecrypt: X,
        privateEncrypt: Y,
        publicDecrypt: $,
        publicEncrypt: J,
        getCipherInfo: M,
      } = r("internal/crypto/cipher"),
      {
        Sign: Q,
        signOneShot: Z,
        Verify: ee,
        verifyOneShot: re,
      } = r("internal/crypto/sig"),
      { Hash: te, Hmac: ne } = r("internal/crypto/hash"),
      { X509Certificate: ie } = r("internal/crypto/x509"),
      {
        getCiphers: ae,
        getCurves: ce,
        getDefaultEncoding: le,
        getHashes: oe,
        setDefaultEncoding: pe,
        setEngine: ue,
        secureHeapUsed: se,
      } = r("internal/crypto/util"),
      ye = r("internal/crypto/certificate");
    let fe;
    function lazyWebCrypto() {
      return (fe ??= r("internal/crypto/webcrypto")), fe;
    }
    function createDiffieHellmanGroup(e) {
      return new L(e);
    }
    function getFips() {
      return y("--force-fips") ? 1 : f();
    }
    function setFips(e) {
      if (y("--force-fips")) {
        if (e) return;
        throw new u();
      }
      g(e);
    }
    function getRandomValues(e) {
      return lazyWebCrypto().crypto.getRandomValues(e);
    }
    function getRandomBytesAlias(e) {
      return {
        enumerable: !1,
        configurable: !0,
        get() {
          let r;
          return (
            (r = y("--pending-deprecation")
              ? p(D, `crypto.${e} is deprecated.`, "DEP0115")
              : D),
            c(this, e, {
              __proto__: null,
              enumerable: !1,
              configurable: !0,
              writable: !0,
              value: r,
            }),
            r
          );
        },
        set(r) {
          c(this, e, {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r,
          });
        },
      };
    }
    (t.exports = {
      checkPrime: _,
      checkPrimeSync: d,
      createCipheriv: function createCipheriv(e, r, t, n) {
        return new W(e, r, t, n);
      },
      createDecipheriv: function createDecipheriv(e, r, t, n) {
        return new q(e, r, t, n);
      },
      createDiffieHellman: function createDiffieHellman(e, r, t, n) {
        return new N(e, r, t, n);
      },
      createDiffieHellmanGroup: createDiffieHellmanGroup,
      createECDH: function createECDH(e) {
        return new j(e);
      },
      createHash: function createHash(e, r) {
        return new te(e, r);
      },
      createHmac: function createHmac(e, r, t) {
        return new ne(e, r, t);
      },
      createPrivateKey: B,
      createPublicKey: V,
      createSecretKey: U,
      createSign: function createSign(e, r) {
        return new Q(e, r);
      },
      createVerify: function createVerify(e, r) {
        return new ee(e, r);
      },
      diffieHellman: z,
      generatePrime: h,
      generatePrimeSync: b,
      getCiphers: ae,
      getCipherInfo: M,
      getCurves: ce,
      getDiffieHellman: createDiffieHellmanGroup,
      getHashes: oe,
      hkdf: k,
      hkdfSync: K,
      pbkdf2: S,
      pbkdf2Sync: P,
      generateKeyPair: R,
      generateKeyPairSync: O,
      generateKey: I,
      generateKeySync: G,
      privateDecrypt: X,
      privateEncrypt: Y,
      publicDecrypt: $,
      publicEncrypt: J,
      randomBytes: D,
      randomFill: C,
      randomFillSync: H,
      randomInt: v,
      randomUUID: E,
      scrypt: F,
      scryptSync: w,
      sign: Z,
      setEngine: ue,
      timingSafeEqual: m,
      getFips: getFips,
      setFips: setFips,
      verify: re,
      Certificate: ye,
      Cipher: T,
      Cipheriv: W,
      Decipher: x,
      Decipheriv: q,
      DiffieHellman: N,
      DiffieHellmanGroup: L,
      ECDH: j,
      Hash: te,
      Hmac: ne,
      KeyObject: A,
      Sign: Q,
      Verify: ee,
      X509Certificate: ie,
      secureHeapUsed: se,
    }),
      c(s, "defaultCipherList", {
        __proto__: null,
        get() {
          const e = y("--tls-cipher-list");
          return (
            c(this, "defaultCipherList", {
              __proto__: null,
              writable: !0,
              configurable: !0,
              enumerable: !0,
              value: e,
            }),
            e
          );
        },
        set(e) {
          c(this, "defaultCipherList", {
            __proto__: null,
            writable: !0,
            configurable: !0,
            enumerable: !0,
            value: e,
          });
        },
        configurable: !0,
        enumerable: !0,
      }),
      l(t.exports, {
        createCipher: {
          __proto__: null,
          enumerable: !1,
          value: p(
            function createCipher(e, r, t) {
              return new T(e, r, t);
            },
            "crypto.createCipher is deprecated.",
            "DEP0106"
          ),
        },
        createDecipher: {
          __proto__: null,
          enumerable: !1,
          value: p(
            function createDecipher(e, r, t) {
              return new x(e, r, t);
            },
            "crypto.createDecipher is deprecated.",
            "DEP0106"
          ),
        },
        fips: { __proto__: null, get: getFips, set: setFips },
        DEFAULT_ENCODING: {
          __proto__: null,
          enumerable: !1,
          configurable: !0,
          get: p(le, "crypto.DEFAULT_ENCODING is deprecated.", "DEP0091"),
          set: p(pe, "crypto.DEFAULT_ENCODING is deprecated.", "DEP0091"),
        },
        constants: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: s,
        },
        webcrypto: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          get: () => lazyWebCrypto().crypto,
          set: void 0,
        },
        subtle: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          get: () => lazyWebCrypto().crypto.subtle,
          set: void 0,
        },
        getRandomValues: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          get: () => getRandomValues,
          set: void 0,
        },
        prng: getRandomBytesAlias("prng"),
        pseudoRandomBytes: getRandomBytesAlias("pseudoRandomBytes"),
        rng: getRandomBytesAlias("rng"),
      });
  },
  dgram: function (e, t, n, o, i, r) {
    "use strict";
    const {
        Array: s,
        ArrayIsArray: c,
        ArrayPrototypePush: u,
        FunctionPrototypeBind: f,
        FunctionPrototypeCall: h,
        ObjectDefineProperty: d,
        ObjectSetPrototypeOf: l,
        ReflectApply: a,
        SymbolAsyncDispose: p,
        SymbolDispose: S,
      } = r,
      y = t("internal/errors"),
      {
        kStateSymbol: k,
        _createSocketHandle: _,
        newHandle: b,
      } = t("internal/dgram"),
      { guessHandleType: g } = i("util"),
      {
        ERR_BUFFER_OUT_OF_BOUNDS: v,
        ERR_INVALID_ARG_TYPE: m,
        ERR_MISSING_ARGS: w,
        ERR_SOCKET_ALREADY_BOUND: E,
        ERR_SOCKET_BAD_BUFFER_SIZE: A,
        ERR_SOCKET_BUFFER_SIZE: R,
        ERR_SOCKET_DGRAM_IS_CONNECTED: T,
        ERR_SOCKET_DGRAM_NOT_CONNECTED: D,
        ERR_SOCKET_DGRAM_NOT_RUNNING: L,
        ERR_INVALID_FD_TYPE: C,
      } = y.codes,
      {
        isInt32: B,
        validateAbortSignal: P,
        validateString: M,
        validateNumber: z,
        validatePort: O,
      } = t("internal/validators"),
      { Buffer: I } = t("buffer"),
      { deprecate: N, promisify: q } = t("internal/util"),
      { isArrayBufferView: x } = t("internal/util/types"),
      U = t("events"),
      {
        defaultTriggerAsyncIdScope: H,
        symbols: { async_id_symbol: F, owner_symbol: V },
      } = t("internal/async_hooks"),
      { UV_UDP_REUSEADDR: G } = i("constants").os,
      {
        constants: { UV_UDP_IPV6ONLY: j },
        UDP: K,
        SendWrap: Q,
      } = i("udp_wrap"),
      W = t("diagnostics_channel").channel("udp.socket"),
      Y = 0,
      Z = 2,
      J = 0,
      X = 2,
      $ = !0,
      ee = !1;
    let te = null;
    function lazyLoadCluster() {
      return te || (te = t("cluster")), te;
    }
    const ne = y.errnoException,
      oe = y.exceptionWithHostPort;
    function Socket(e, t) {
      let n, o, i, r;
      h(U, this),
        null !== e &&
          "object" == typeof e &&
          ((r = e),
          (e = r.type),
          (n = r.lookup),
          (o = r.recvBufferSize),
          (i = r.sendBufferSize));
      const s = b(e, n);
      if (
        ((s[V] = this),
        (this[F] = s.getAsyncId()),
        (this.type = e),
        "function" == typeof t && this.on("message", t),
        (this[k] = {
          handle: s,
          receiving: !1,
          bindState: Y,
          connectState: J,
          queue: void 0,
          reuseAddr: r && r.reuseAddr,
          ipv6Only: r && r.ipv6Only,
          recvBufferSize: o,
          sendBufferSize: i,
        }),
        void 0 !== r?.signal)
      ) {
        const { signal: e } = r;
        P(e, "options.signal");
        const onAborted = () => {
          this[k].handle && this.close();
        };
        if (e.aborted) onAborted();
        else {
          const t = U.addAbortListener(e, onAborted);
          this.once("close", t[S]);
        }
      }
      W.hasSubscribers && W.publish({ socket: this });
    }
    function startListening(e) {
      const t = e[k];
      (t.handle.onmessage = onMessage),
        (t.handle.onerror = onError),
        t.handle.recvStart(),
        (t.receiving = !0),
        (t.bindState = Z),
        t.recvBufferSize && bufferSize(e, t.recvBufferSize, $),
        t.sendBufferSize && bufferSize(e, t.sendBufferSize, ee),
        e.emit("listening");
    }
    function replaceHandle(e, t) {
      const n = e[k],
        o = n.handle;
      o.hasRef() || "function" != typeof t.unref || t.unref(),
        (t.lookup = o.lookup),
        (t.bind = o.bind),
        (t.send = o.send),
        (t[V] = e),
        o.close(),
        (n.handle = t);
    }
    function bufferSize(e, t, n) {
      if (t >>> 0 !== t) throw new A();
      const o = {},
        i = e[k].handle.bufferSize(t, n, o);
      if (void 0 === i) throw new R(o);
      return i;
    }
    function bindServerHandle(e, t, n) {
      const o = lazyLoadCluster(),
        i = e[k];
      o._getServer(e, t, (t, o) => {
        if (t) n(t);
        else {
          if (!i.handle) return o.close();
          replaceHandle(e, o), startListening(e);
        }
      });
    }
    function _connect(e, t, n) {
      const o = this[k];
      n && this.once("connect", n);
      o.handle.lookup(t, (o, i) => {
        H(this[F], doConnect, o, this, i, t, e, n);
      });
    }
    function doConnect(e, t, n, i, r, s) {
      const c = t[k];
      if (c.handle) {
        if (!e) {
          const t = c.handle.connect(n, r);
          t && (e = oe(t, "connect", i, r));
        }
        if (e)
          return (
            (c.connectState = J),
            o.nextTick(() => {
              s ? (t.removeListener("connect", s), s(e)) : t.emit("error", e);
            })
          );
        (c.connectState = X), o.nextTick(() => t.emit("connect"));
      }
    }
    function sliceBuffer(e, t, n) {
      if ("string" == typeof e) e = I.from(e);
      else if (!x(e))
        throw new m(
          "buffer",
          ["Buffer", "TypedArray", "DataView", "string"],
          e
        );
      if (((n >>>= 0), (t >>>= 0) > e.byteLength)) throw new v("offset");
      if (t + n > e.byteLength) throw new v("length");
      return I.from(e.buffer, e.byteOffset + t, n);
    }
    function enqueue(e, t) {
      const n = e[k];
      void 0 === n.queue &&
        ((n.queue = []),
        e.once(U.errorMonitor, onListenError),
        e.once("listening", onListenSuccess)),
        u(n.queue, t);
    }
    function onListenSuccess() {
      this.removeListener(U.errorMonitor, onListenError), h(clearQueue, this);
    }
    function onListenError(e) {
      this.removeListener("listening", onListenSuccess),
        (this[k].queue = void 0);
    }
    function clearQueue() {
      const e = this[k],
        t = e.queue;
      e.queue = void 0;
      for (const e of t) e();
    }
    function doSend(e, t, n, i, r, s, c) {
      const u = t[k];
      if (e)
        return "function" == typeof c
          ? void o.nextTick(c, e)
          : void o.nextTick(() => t.emit("error", e));
      if (!u.handle) return;
      const f = new Q();
      let h;
      if (
        ((f.list = i),
        (f.address = r),
        (f.port = s),
        c && ((f.callback = c), (f.oncomplete = afterSend)),
        (h = s
          ? u.handle.send(f, i, i.length, s, n, !!c)
          : u.handle.send(f, i, i.length, !!c)),
        h >= 1)
      )
        c && o.nextTick(c, null, h - 1);
      else if (h && c) {
        const e = oe(h, "send", r, s);
        o.nextTick(c, e);
      }
    }
    function afterSend(e, t) {
      (e = e ? oe(e, "send", this.address, this.port) : null),
        this.callback(e, t);
    }
    function socketCloseNT(e) {
      e.emit("close");
    }
    function healthCheck(e) {
      if (!e[k].handle) throw new L();
    }
    function stopReceiving(e) {
      const t = e[k];
      t.receiving && (t.handle.recvStop(), (t.receiving = !1));
    }
    function onMessage(e, t, n, o) {
      const i = t[V];
      if (e < 0) return i.emit("error", ne(e, "recvmsg"));
      (o.size = n.length), i.emit("message", n, o);
    }
    function onError(e, t, n) {
      return t[V].emit("error", n);
    }
    l(Socket.prototype, U.prototype),
      l(Socket, U),
      (Socket.prototype.bind = function (e, t) {
        let n = e;
        healthCheck(this);
        const o = this[k];
        if (o.bindState !== Y) throw new E();
        o.bindState = 1;
        const i = arguments.length && arguments[arguments.length - 1];
        if ("function" == typeof i) {
          let removeListeners = function () {
              this.removeListener("error", removeListeners),
                this.removeListener("listening", onListening);
            },
            onListening = function () {
              h(removeListeners, this), h(i, this);
            };
          this.on("error", removeListeners), this.on("listening", onListening);
        }
        if (
          null !== n &&
          "object" == typeof n &&
          "function" == typeof n.recvStart
        )
          return replaceHandle(this, n), startListening(this), this;
        if (null !== n && "object" == typeof n && B(n.fd) && n.fd > 0) {
          const e = n.fd,
            t = !!n.exclusive,
            o = this[k];
          if (lazyLoadCluster().isWorker && !t)
            return (
              bindServerHandle(
                this,
                {
                  address: null,
                  port: null,
                  addressType: this.type,
                  fd: e,
                  flags: null,
                },
                (e) => {
                  const t = ne(e, "open");
                  (o.bindState = Y), this.emit("error", t);
                }
              ),
              this
            );
          const i = g(e);
          if ("UDP" !== i) throw new C(i);
          const r = o.handle.open(e);
          if (r) throw ne(r, "open");
          return startListening(this), this;
        }
        let r, s;
        return (
          null !== n && "object" == typeof n
            ? ((r = n.address || ""), (s = !!n.exclusive), (n = n.port))
            : ((r = "function" == typeof t ? "" : t), (s = !1)),
          r || (r = "udp4" === this.type ? "0.0.0.0" : "::"),
          o.handle.lookup(r, (e, t) => {
            if (e) return (o.bindState = Y), void this.emit("error", e);
            const i = lazyLoadCluster();
            let r = 0;
            if (
              (o.reuseAddr && (r |= G),
              o.ipv6Only && (r |= j),
              i.isWorker && !s)
            )
              bindServerHandle(
                this,
                {
                  address: t,
                  port: n,
                  addressType: this.type,
                  fd: -1,
                  flags: r,
                },
                (e) => {
                  const i = oe(e, "bind", t, n);
                  (o.bindState = Y), this.emit("error", i);
                }
              );
            else {
              if (!o.handle) return;
              const e = o.handle.bind(t, n || 0, r);
              if (e) {
                const i = oe(e, "bind", t, n);
                return (o.bindState = Y), void this.emit("error", i);
              }
              startListening(this);
            }
          }),
          this
        );
      }),
      (Socket.prototype.connect = function (e, t, n) {
        (e = O(e, "Port", !1)),
          "function" == typeof t
            ? ((n = t), (t = ""))
            : void 0 === t && (t = ""),
          M(t, "address");
        const o = this[k];
        if (o.connectState !== J) throw new T();
        (o.connectState = 1),
          o.bindState === Y && this.bind({ port: 0, exclusive: !0 }, null),
          o.bindState === Z
            ? a(_connect, this, [e, t, n])
            : enqueue(this, f(_connect, this, e, t, n));
      }),
      (Socket.prototype.disconnect = function () {
        const e = this[k];
        if (e.connectState !== X) throw new D();
        const t = e.handle.disconnect();
        if (t) throw ne(t, "connect");
        e.connectState = J;
      }),
      (Socket.prototype.sendto = function (e, t, n, o, i, r) {
        z(t, "offset"),
          z(n, "length"),
          z(o, "port"),
          M(i, "address"),
          this.send(e, t, n, o, i, r);
      }),
      (Socket.prototype.send = function (e, t, n, o, i, r) {
        let h;
        const d = this[k],
          l = d.connectState === X;
        if (l) {
          if (
            ("number" == typeof n
              ? ((e = sliceBuffer(e, t, n)),
                "function" == typeof o && ((r = o), (o = null)))
              : (r = t),
            o || i)
          )
            throw new T();
        } else
          i || (o && "function" != typeof o)
            ? (e = sliceBuffer(e, t, n))
            : ((r = o), (o = t), (i = n));
        if (c(e)) {
          if (
            !(h = (function fixBufferList(e) {
              const t = new s(e.length);
              for (let n = 0, o = e.length; n < o; n++) {
                const o = e[n];
                if ("string" == typeof o) t[n] = I.from(o);
                else {
                  if (!x(o)) return null;
                  t[n] = I.from(o.buffer, o.byteOffset, o.byteLength);
                }
              }
              return t;
            })(e))
          )
            throw new m(
              "buffer list arguments",
              ["Buffer", "TypedArray", "DataView", "string"],
              e
            );
        } else if ("string" == typeof e) h = [I.from(e)];
        else {
          if (!x(e))
            throw new m(
              "buffer",
              ["Buffer", "TypedArray", "DataView", "string"],
              e
            );
          h = [e];
        }
        if (
          (l || (o = O(o, "Port", !1)),
          "function" != typeof r && (r = void 0),
          "function" == typeof i
            ? ((r = i), (i = void 0))
            : null != i && M(i, "address"),
          healthCheck(this),
          d.bindState === Y && this.bind({ port: 0, exclusive: !0 }, null),
          0 === h.length && u(h, I.alloc(0)),
          d.bindState !== Z)
        )
          return void enqueue(this, f(this.send, this, h, o, i, r));
        const afterDns = (e, t) => {
          H(this[F], doSend, e, this, t, h, i, o, r);
        };
        l ? afterDns(null, null) : d.handle.lookup(i, afterDns);
      }),
      (Socket.prototype.close = function (e) {
        const t = this[k],
          n = t.queue;
        return (
          "function" == typeof e && this.on("close", e),
          void 0 !== n
            ? (u(n, f(this.close, this)), this)
            : (healthCheck(this),
              stopReceiving(this),
              t.handle.close(),
              (t.handle = null),
              H(this[F], o.nextTick, socketCloseNT, this),
              this)
        );
      }),
      (Socket.prototype[p] = async function () {
        if (this[k].handle) return h(q(this.close), this);
      }),
      (Socket.prototype.address = function () {
        healthCheck(this);
        const e = {},
          t = this[k].handle.getsockname(e);
        if (t) throw ne(t, "getsockname");
        return e;
      }),
      (Socket.prototype.remoteAddress = function () {
        healthCheck(this);
        const e = this[k];
        if (e.connectState !== X) throw new D();
        const t = {},
          n = e.handle.getpeername(t);
        if (n) throw ne(n, "getpeername");
        return t;
      }),
      (Socket.prototype.setBroadcast = function (e) {
        const t = this[k].handle.setBroadcast(e ? 1 : 0);
        if (t) throw ne(t, "setBroadcast");
      }),
      (Socket.prototype.setTTL = function (e) {
        z(e, "ttl");
        const t = this[k].handle.setTTL(e);
        if (t) throw ne(t, "setTTL");
        return e;
      }),
      (Socket.prototype.setMulticastTTL = function (e) {
        z(e, "ttl");
        const t = this[k].handle.setMulticastTTL(e);
        if (t) throw ne(t, "setMulticastTTL");
        return e;
      }),
      (Socket.prototype.setMulticastLoopback = function (e) {
        const t = this[k].handle.setMulticastLoopback(e ? 1 : 0);
        if (t) throw ne(t, "setMulticastLoopback");
        return e;
      }),
      (Socket.prototype.setMulticastInterface = function (e) {
        healthCheck(this), M(e, "interfaceAddress");
        const t = this[k].handle.setMulticastInterface(e);
        if (t) throw ne(t, "setMulticastInterface");
      }),
      (Socket.prototype.addMembership = function (e, t) {
        if ((healthCheck(this), !e)) throw new w("multicastAddress");
        const { handle: n } = this[k],
          o = n.addMembership(e, t);
        if (o) throw ne(o, "addMembership");
      }),
      (Socket.prototype.dropMembership = function (e, t) {
        if ((healthCheck(this), !e)) throw new w("multicastAddress");
        const { handle: n } = this[k],
          o = n.dropMembership(e, t);
        if (o) throw ne(o, "dropMembership");
      }),
      (Socket.prototype.addSourceSpecificMembership = function (e, t, n) {
        healthCheck(this), M(e, "sourceAddress"), M(t, "groupAddress");
        const o = this[k].handle.addSourceSpecificMembership(e, t, n);
        if (o) throw ne(o, "addSourceSpecificMembership");
      }),
      (Socket.prototype.dropSourceSpecificMembership = function (e, t, n) {
        healthCheck(this), M(e, "sourceAddress"), M(t, "groupAddress");
        const o = this[k].handle.dropSourceSpecificMembership(e, t, n);
        if (o) throw ne(o, "dropSourceSpecificMembership");
      }),
      (Socket.prototype.ref = function () {
        const e = this[k].handle;
        return e && e.ref(), this;
      }),
      (Socket.prototype.unref = function () {
        const e = this[k].handle;
        return e && e.unref(), this;
      }),
      (Socket.prototype.setRecvBufferSize = function (e) {
        bufferSize(this, e, $);
      }),
      (Socket.prototype.setSendBufferSize = function (e) {
        bufferSize(this, e, ee);
      }),
      (Socket.prototype.getRecvBufferSize = function () {
        return bufferSize(this, 0, $);
      }),
      (Socket.prototype.getSendBufferSize = function () {
        return bufferSize(this, 0, ee);
      }),
      (Socket.prototype.getSendQueueSize = function () {
        return this[k].handle.getSendQueueSize();
      }),
      (Socket.prototype.getSendQueueCount = function () {
        return this[k].handle.getSendQueueCount();
      }),
      d(Socket.prototype, "_handle", {
        __proto__: null,
        get: N(
          function () {
            return this[k].handle;
          },
          "Socket.prototype._handle is deprecated",
          "DEP0112"
        ),
        set: N(
          function (e) {
            this[k].handle = e;
          },
          "Socket.prototype._handle is deprecated",
          "DEP0112"
        ),
      }),
      d(Socket.prototype, "_receiving", {
        __proto__: null,
        get: N(
          function () {
            return this[k].receiving;
          },
          "Socket.prototype._receiving is deprecated",
          "DEP0112"
        ),
        set: N(
          function (e) {
            this[k].receiving = e;
          },
          "Socket.prototype._receiving is deprecated",
          "DEP0112"
        ),
      }),
      d(Socket.prototype, "_bindState", {
        __proto__: null,
        get: N(
          function () {
            return this[k].bindState;
          },
          "Socket.prototype._bindState is deprecated",
          "DEP0112"
        ),
        set: N(
          function (e) {
            this[k].bindState = e;
          },
          "Socket.prototype._bindState is deprecated",
          "DEP0112"
        ),
      }),
      d(Socket.prototype, "_queue", {
        __proto__: null,
        get: N(
          function () {
            return this[k].queue;
          },
          "Socket.prototype._queue is deprecated",
          "DEP0112"
        ),
        set: N(
          function (e) {
            this[k].queue = e;
          },
          "Socket.prototype._queue is deprecated",
          "DEP0112"
        ),
      }),
      d(Socket.prototype, "_reuseAddr", {
        __proto__: null,
        get: N(
          function () {
            return this[k].reuseAddr;
          },
          "Socket.prototype._reuseAddr is deprecated",
          "DEP0112"
        ),
        set: N(
          function (e) {
            this[k].reuseAddr = e;
          },
          "Socket.prototype._reuseAddr is deprecated",
          "DEP0112"
        ),
      }),
      (Socket.prototype._healthCheck = N(
        function () {
          healthCheck(this);
        },
        "Socket.prototype._healthCheck() is deprecated",
        "DEP0112"
      )),
      (Socket.prototype._stopReceiving = N(
        function () {
          stopReceiving(this);
        },
        "Socket.prototype._stopReceiving() is deprecated",
        "DEP0112"
      )),
      d(K.prototype, "owner", {
        __proto__: null,
        get() {
          return this[V];
        },
        set(e) {
          return (this[V] = e);
        },
      }),
      (n.exports = {
        _createSocketHandle: N(
          _,
          "dgram._createSocketHandle() is deprecated",
          "DEP0112"
        ),
        createSocket: function createSocket(e, t) {
          return new Socket(e, t);
        },
        Socket: Socket,
      });
  },
  diagnostics_channel: function (e, r, t, n, s, i) {
    "use strict";
    const {
        ArrayPrototypeIndexOf: a,
        ArrayPrototypePush: c,
        ArrayPrototypeSplice: o,
        SafeFinalizationRegistry: u,
        ObjectGetPrototypeOf: h,
        ObjectSetPrototypeOf: l,
        Promise: b,
        PromisePrototypeThen: f,
        PromiseResolve: y,
        PromiseReject: p,
        ReflectApply: d,
        SafeMap: S,
        SymbolHasInstance: C,
      } = i,
      {
        codes: { ERR_INVALID_ARG_TYPE: g },
      } = r("internal/errors"),
      { validateFunction: m } = r("internal/validators"),
      { triggerUncaughtException: _ } = s("errors"),
      { WeakReference: w } = s("util");
    function markActive(e) {
      l(e, ActiveChannel.prototype),
        (e._subscribers = []),
        (e._stores = new S());
    }
    function maybeMarkInactive(e) {
      e._subscribers.length ||
        e._stores.size ||
        (l(e, Channel.prototype),
        (e._subscribers = void 0),
        (e._stores = void 0));
    }
    function defaultTransform(e) {
      return e;
    }
    function wrapStoreRun(e, r, t, s = defaultTransform) {
      return () => {
        let i;
        try {
          i = s(r);
        } catch (e) {
          return (
            n.nextTick(() => {
              _(e, !1);
            }),
            t()
          );
        }
        return e.run(i, t);
      };
    }
    class ActiveChannel {
      subscribe(e) {
        m(e, "subscription"), c(this._subscribers, e), R.incRef(this.name);
      }
      unsubscribe(e) {
        const r = a(this._subscribers, e);
        return (
          -1 !== r &&
          (o(this._subscribers, r, 1),
          R.decRef(this.name),
          maybeMarkInactive(this),
          !0)
        );
      }
      bindStore(e, r) {
        this._stores.has(e) || R.incRef(this.name), this._stores.set(e, r);
      }
      unbindStore(e) {
        return (
          !!this._stores.has(e) &&
          (this._stores.delete(e),
          R.decRef(this.name),
          maybeMarkInactive(this),
          !0)
        );
      }
      get hasSubscribers() {
        return !0;
      }
      publish(e) {
        for (let r = 0; r < this._subscribers.length; r++)
          try {
            (0, this._subscribers[r])(e, this.name);
          } catch (e) {
            n.nextTick(() => {
              _(e, !1);
            });
          }
      }
      runStores(e, r, t, ...n) {
        let run = () => (this.publish(e), d(r, t, n));
        for (const r of this._stores.entries()) {
          const t = r[0],
            n = r[1];
          run = wrapStoreRun(t, e, run, n);
        }
        return run();
      }
    }
    class Channel {
      constructor(e) {
        (this._subscribers = void 0),
          (this._stores = void 0),
          (this.name = e),
          R.set(e, this);
      }
      static [C](e) {
        const r = h(e);
        return r === Channel.prototype || r === ActiveChannel.prototype;
      }
      subscribe(e) {
        markActive(this), this.subscribe(e);
      }
      unsubscribe() {
        return !1;
      }
      bindStore(e, r) {
        markActive(this), this.bindStore(e, r);
      }
      unbindStore() {
        return !1;
      }
      get hasSubscribers() {
        return !1;
      }
      publish() {}
      runStores(e, r, t, ...n) {
        return d(r, t, n);
      }
    }
    const R = new (class WeakRefMap extends S {
      #e = new u((e) => {
        this.delete(e);
      });
      set(e, r) {
        return this.#e.register(r, e), super.set(e, new w(r));
      }
      get(e) {
        return super.get(e)?.get();
      }
      incRef(e) {
        return super.get(e)?.incRef();
      }
      decRef(e) {
        return super.get(e)?.decRef();
      }
    })();
    function channel(e) {
      const r = R.get(e);
      if (r) return r;
      if ("string" != typeof e && "symbol" != typeof e)
        throw new g("channel", ["string", "symbol"], e);
      return new Channel(e);
    }
    const v = ["start", "end", "asyncStart", "asyncEnd", "error"];
    function assertChannel(e, r) {
      if (!(e instanceof Channel)) throw new g(r, ["Channel"], e);
    }
    class TracingChannel {
      constructor(e) {
        if ("string" == typeof e)
          (this.start = channel(`tracing:${e}:start`)),
            (this.end = channel(`tracing:${e}:end`)),
            (this.asyncStart = channel(`tracing:${e}:asyncStart`)),
            (this.asyncEnd = channel(`tracing:${e}:asyncEnd`)),
            (this.error = channel(`tracing:${e}:error`));
        else {
          if ("object" != typeof e)
            throw new g("nameOrChannels", ["string", "object", "Channel"], e);
          {
            const {
              start: r,
              end: t,
              asyncStart: n,
              asyncEnd: s,
              error: i,
            } = e;
            assertChannel(r, "nameOrChannels.start"),
              assertChannel(t, "nameOrChannels.end"),
              assertChannel(n, "nameOrChannels.asyncStart"),
              assertChannel(s, "nameOrChannels.asyncEnd"),
              assertChannel(i, "nameOrChannels.error"),
              (this.start = r),
              (this.end = t),
              (this.asyncStart = n),
              (this.asyncEnd = s),
              (this.error = i);
          }
        }
      }
      subscribe(e) {
        for (const r of v) e[r] && this[r]?.subscribe(e[r]);
      }
      unsubscribe(e) {
        let r = !0;
        for (const t of v) e[t] && (this[t]?.unsubscribe(e[t]) || (r = !1));
        return r;
      }
      traceSync(e, r = {}, t, ...n) {
        const { start: s, end: i, error: a } = this;
        return s.runStores(r, () => {
          try {
            const s = d(e, t, n);
            return (r.result = s), s;
          } catch (e) {
            throw ((r.error = e), a.publish(r), e);
          } finally {
            i.publish(r);
          }
        });
      }
      tracePromise(e, r = {}, t, ...n) {
        const { start: s, end: i, asyncStart: a, asyncEnd: c, error: o } = this;
        function reject(e) {
          return (r.error = e), o.publish(r), a.publish(r), c.publish(r), p(e);
        }
        function resolve(e) {
          return (r.result = e), a.publish(r), c.publish(r), e;
        }
        return s.runStores(r, () => {
          try {
            let r = d(e, t, n);
            return r instanceof b || (r = y(r)), f(r, resolve, reject);
          } catch (e) {
            throw ((r.error = e), o.publish(r), e);
          } finally {
            i.publish(r);
          }
        });
      }
      traceCallback(e, r = -1, t = {}, n, ...s) {
        const { start: i, end: a, asyncStart: c, asyncEnd: u, error: h } = this;
        const l = s.at(r);
        if ("function" != typeof l) throw new g("callback", ["function"], l);
        return (
          o(s, r, 1, function wrappedCallback(e, r) {
            e ? ((t.error = e), h.publish(t)) : (t.result = r),
              c.runStores(t, () => {
                try {
                  if (l) return d(l, this, arguments);
                } finally {
                  u.publish(t);
                }
              });
          }),
          i.runStores(t, () => {
            try {
              return d(e, n, s);
            } catch (e) {
              throw ((t.error = e), h.publish(t), e);
            } finally {
              a.publish(t);
            }
          })
        );
      }
    }
    t.exports = {
      channel: channel,
      hasSubscribers: function hasSubscribers(e) {
        const r = R.get(e);
        return !!r && r.hasSubscribers;
      },
      subscribe: function subscribe(e, r) {
        return channel(e).subscribe(r);
      },
      tracingChannel: function tracingChannel(e) {
        return new TracingChannel(e);
      },
      unsubscribe: function unsubscribe(e, r) {
        return channel(e).unsubscribe(r);
      },
      Channel: Channel,
    };
  },
  dns: function (e, t, l, n, o, a) {
    "use strict";
    const { ObjectDefineProperties: i, ObjectDefineProperty: s, Symbol: r } = a,
      u = o("cares_wrap"),
      { isIP: c } = t("internal/net"),
      { customPromisifyArgs: f } = t("internal/util"),
      d = t("internal/errors"),
      {
        bindDefaultResolver: A,
        setDefaultResolver: p,
        validateHints: D,
        emitInvalidHostnameWarning: R,
        getDefaultVerbatim: m,
        getDefaultResultOrder: E,
        setDefaultResultOrder: I,
        errorCodes: k,
      } = t("internal/dns/utils"),
      { Resolver: h } = t("internal/dns/callback_resolver"),
      {
        NODATA: v,
        FORMERR: N,
        SERVFAIL: O,
        NOTFOUND: b,
        NOTIMP: S,
        REFUSED: T,
        BADQUERY: P,
        BADNAME: _,
        BADFAMILY: L,
        BADRESP: y,
        CONNREFUSED: F,
        TIMEOUT: M,
        EOF: g,
        FILE: B,
        NOMEM: C,
        DESTRUCTION: U,
        BADSTR: w,
        BADFLAGS: x,
        NONAME: G,
        BADHINTS: H,
        NOTINITIALIZED: V,
        LOADIPHLPAPI: W,
        ADDRGETNETWORKPARAMS: Y,
        CANCELLED: j,
      } = k,
      {
        ERR_INVALID_ARG_TYPE: q,
        ERR_INVALID_ARG_VALUE: K,
        ERR_MISSING_ARGS: Q,
      } = d.codes,
      {
        validateBoolean: Z,
        validateFunction: z,
        validateNumber: J,
        validateOneOf: X,
        validatePort: $,
        validateString: ee,
      } = t("internal/validators"),
      { GetAddrInfoReqWrap: te, GetNameInfoReqWrap: le } = u,
      ne = r("kPerfHooksDnsLookupContext"),
      oe = r("kPerfHooksDnsLookupServiceContext"),
      {
        hasObserver: ae,
        startPerf: ie,
        stopPerf: se,
      } = t("internal/perf/observe"),
      re = d.dnsException;
    let ue = null;
    function onlookup(e, t) {
      if (e) return this.callback(re(e, "getaddrinfo", this.hostname));
      this.callback(null, t[0], this.family || c(t[0])),
        this[ne] && ae("dns") && se(this, ne, { detail: { addresses: t } });
    }
    function onlookupall(e, t) {
      if (e) return this.callback(re(e, "getaddrinfo", this.hostname));
      const l = this.family;
      for (let e = 0; e < t.length; e++) {
        const n = t[e];
        t[e] = { address: n, family: l || c(n) };
      }
      this.callback(null, t),
        this[ne] && ae("dns") && se(this, ne, { detail: { addresses: t } });
    }
    const ce = [0, 4, 6];
    function lookup(e, t, l) {
      let o = 0,
        a = 0,
        i = !1,
        s = m();
      if ((e && ee(e, "hostname"), "function" == typeof t)) (l = t), (a = 0);
      else if ("number" == typeof t)
        z(l, "callback"), X(t, "family", ce), (a = t);
      else {
        if (void 0 !== t && "object" != typeof t)
          throw (
            (z(2 === arguments.length ? t : l, "callback"),
            new q("options", ["integer", "object"], t))
          );
        if (
          (z(l, "callback"),
          null != t?.hints &&
            (J(t.hints, "options.hints"), (o = t.hints >>> 0), D(o)),
          null != t?.family)
        )
          switch (t.family) {
            case "IPv4":
              a = 4;
              break;
            case "IPv6":
              a = 6;
              break;
            default:
              X(t.family, "options.family", ce), (a = t.family);
          }
        null != t?.all && (Z(t.all, "options.all"), (i = t.all)),
          null != t?.verbatim &&
            (Z(t.verbatim, "options.verbatim"), (s = t.verbatim));
      }
      if (!e)
        return (
          R(e),
          i
            ? n.nextTick(l, null, [])
            : n.nextTick(l, null, null, 6 === a ? 6 : 4),
          {}
        );
      const r = c(e);
      if (r)
        return (
          i
            ? n.nextTick(l, null, [{ address: e, family: r }])
            : n.nextTick(l, null, e, r),
          {}
        );
      const f = new te();
      (f.callback = l),
        (f.family = a),
        (f.hostname = e),
        (f.oncomplete = i ? onlookupall : onlookup);
      const d = u.getaddrinfo(f, e, a, o, s);
      if (d) return n.nextTick(l, re(d, "getaddrinfo", e)), {};
      if (ae("dns")) {
        ie(f, ne, {
          type: "dns",
          name: "lookup",
          detail: { hostname: e, family: a, hints: o, verbatim: s },
        });
      }
      return f;
    }
    function onlookupservice(e, t, l) {
      if (e) return this.callback(re(e, "getnameinfo", this.hostname));
      this.callback(null, t, l),
        this[oe] &&
          ae("dns") &&
          se(this, oe, { detail: { hostname: t, service: l } });
    }
    function lookupService(e, t, l) {
      if (3 !== arguments.length) throw new Q("address", "port", "callback");
      if (0 === c(e)) throw new K("address", e);
      $(t), z(l, "callback"), (t = +t);
      const n = new le();
      (n.callback = l),
        (n.hostname = e),
        (n.port = t),
        (n.oncomplete = onlookupservice);
      const o = u.getnameinfo(n, e, t);
      if (o) throw re(o, "getnameinfo", e);
      return (
        ae("dns") &&
          ie(n, oe, {
            type: "dns",
            name: "lookupService",
            detail: { host: e, port: t },
          }),
        n
      );
    }
    s(lookup, f, {
      __proto__: null,
      value: ["address", "family"],
      enumerable: !1,
    }),
      s(lookupService, f, {
        __proto__: null,
        value: ["hostname", "service"],
        enumerable: !1,
      }),
      (l.exports = {
        lookup: lookup,
        lookupService: lookupService,
        Resolver: h,
        getDefaultResultOrder: E,
        setDefaultResultOrder: I,
        setServers: function defaultResolverSetServers(e) {
          const t = new h();
          t.setServers(e),
            p(t),
            A(l.exports, h.prototype),
            null !== ue && A(ue, ue.Resolver.prototype);
        },
        ADDRCONFIG: u.AI_ADDRCONFIG,
        ALL: u.AI_ALL,
        V4MAPPED: u.AI_V4MAPPED,
        NODATA: v,
        FORMERR: N,
        SERVFAIL: O,
        NOTFOUND: b,
        NOTIMP: S,
        REFUSED: T,
        BADQUERY: P,
        BADNAME: _,
        BADFAMILY: L,
        BADRESP: y,
        CONNREFUSED: F,
        TIMEOUT: M,
        EOF: g,
        FILE: B,
        NOMEM: C,
        DESTRUCTION: U,
        BADSTR: w,
        BADFLAGS: x,
        NONAME: G,
        BADHINTS: H,
        NOTINITIALIZED: V,
        LOADIPHLPAPI: W,
        ADDRGETNETWORKPARAMS: Y,
        CANCELLED: j,
      }),
      A(l.exports, h.prototype),
      i(l.exports, {
        promises: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get: () => (null === ue && (ue = t("internal/dns/promises")), ue),
        },
      });
  },
  "dns/promises": function (s, n, t, e, i, r) {
    "use strict";
    t.exports = n("internal/dns/promises");
  },
  domain: function (e, t, n, o, i, r) {
    "use strict";
    const {
        ArrayPrototypeEvery: a,
        ArrayPrototypeIndexOf: c,
        ArrayPrototypeLastIndexOf: u,
        ArrayPrototypePush: l,
        ArrayPrototypeSlice: s,
        ArrayPrototypeSplice: m,
        Error: p,
        FunctionPrototypeCall: d,
        ObjectDefineProperty: h,
        Promise: f,
        ReflectApply: _,
        SafeMap: g,
        SafeWeakMap: b,
        Symbol: y,
      } = r,
      E = t("events"),
      {
        ERR_DOMAIN_CALLBACK_NOT_AVAILABLE: C,
        ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE: v,
        ERR_UNHANDLED_ERROR: x,
      } = t("internal/errors").codes,
      { createHook: D } = t("async_hooks"),
      { useDomainTrampoline: w } = t("internal/async_hooks"),
      k = y("kWeak"),
      { WeakReference: A } = i("util"),
      U = [null];
    h(o, "domain", {
      __proto__: null,
      enumerable: !0,
      get: function () {
        return U[0];
      },
      set: function (e) {
        return (U[0] = e);
      },
    });
    const R = new b(),
      L = new g(),
      P = D({
        init(e, t, n, i) {
          null !== o.domain &&
            void 0 !== o.domain &&
            (L.set(e, o.domain[k]),
            "PROMISE" !== t || i instanceof f
              ? h(i, "domain", {
                  __proto__: null,
                  configurable: !0,
                  enumerable: !1,
                  value: o.domain,
                  writable: !0,
                })
              : R.set(i, o.domain));
        },
        before(e) {
          const t = L.get(e);
          void 0 !== t && (t.incRef(), t.get().enter());
        },
        after(e) {
          const t = L.get(e);
          if (void 0 !== t) {
            const e = t.get();
            t.decRef(), e.exit();
          }
        },
        destroy(e) {
          L.delete(e);
        },
      });
    if (o.hasUncaughtExceptionCaptureCallback()) throw new C();
    const T = new p("require(`domain`) at this point").stack,
      { setUncaughtExceptionCaptureCallback: N } = o;
    o.setUncaughtExceptionCaptureCallback = function (e) {
      const t = new v();
      throw ((t.stack = t.stack + "\n" + "-".repeat(40) + "\n" + T), t);
    };
    let O = !1;
    let I = [];
    function updateExceptionCapture() {
      a(I, (e) => 0 === e.listenerCount("error"))
        ? N(null)
        : (N(null), N((e) => o.domain._errorHandler(e)));
    }
    function domainUncaughtExceptionClear() {
      (I.length = 0), (e.active = o.domain = null), updateExceptionCapture();
    }
    (e._stack = I),
      w(function topLevelDomainCallback(t, ...n) {
        const i = this.domain;
        e.active &&
          i &&
          (function emitMakeCallbackDeprecation({ target: e, method: t }) {
            O ||
              (o.emitWarning(
                `Using a domain property in MakeCallback is deprecated. Use the async_context variant of MakeCallback or the AsyncResource class instead. (Triggered by calling ${
                  t?.name || "<anonymous>"
                } on ${e?.constructor?.name}.)`,
                "DeprecationWarning",
                "DEP0097"
              ),
              (O = !0));
          })({ target: this, method: t }),
          i && i.enter();
        const r = _(t, this, n);
        return i && i.exit(), r;
      }),
      o.on("newListener", (e, t) => {
        "uncaughtException" === e &&
          t !== domainUncaughtExceptionClear &&
          (o.removeListener(e, domainUncaughtExceptionClear),
          o.prependListener(e, domainUncaughtExceptionClear));
      }),
      o.on("removeListener", (e, t) => {
        if ("uncaughtException" === e && t !== domainUncaughtExceptionClear) {
          const t = o.listeners("uncaughtException");
          1 === t.length &&
            t[0] === domainUncaughtExceptionClear &&
            o.removeListener(e, domainUncaughtExceptionClear);
        }
      });
    class Domain extends E {
      constructor() {
        super(),
          (this.members = []),
          (this[k] = new A(this)),
          P.enable(),
          this.on("removeListener", updateExceptionCapture),
          this.on("newListener", updateExceptionCapture);
      }
    }
    (e.Domain = Domain),
      (e.create = e.createDomain =
        function createDomain() {
          return new Domain();
        }),
      (e.active = null),
      (Domain.prototype.members = void 0),
      (Domain.prototype._errorHandler = function (t) {
        let n = !1;
        for (
          (("object" == typeof t && null !== t) || "function" == typeof t) &&
          (h(t, "domain", {
            __proto__: null,
            configurable: !0,
            enumerable: !1,
            value: this,
            writable: !0,
          }),
          (t.domainThrown = !0));
          e.active === this;

        )
          this.exit();
        if (0 === I.length) {
          if (E.listenerCount(this, "error") > 0) {
            N(null);
            try {
              n = this.emit("error", t);
            } finally {
              updateExceptionCapture();
            }
          }
        } else
          try {
            n = this.emit("error", t);
          } catch (t) {
            if ((updateExceptionCapture(), !I.length)) throw t;
            (e.active = o.domain = I[I.length - 1]),
              (n = o.domain._errorHandler(t));
          }
        return domainUncaughtExceptionClear(), n;
      }),
      (Domain.prototype.enter = function () {
        (e.active = o.domain = this), l(I, this), updateExceptionCapture();
      }),
      (Domain.prototype.exit = function () {
        const t = u(I, this);
        -1 !== t &&
          (m(I, t),
          (e.active = 0 === I.length ? void 0 : I[I.length - 1]),
          (o.domain = e.active),
          updateExceptionCapture());
      }),
      (Domain.prototype.add = function (e) {
        if (e.domain !== this) {
          if (
            (e.domain && e.domain.remove(e), this.domain && e instanceof Domain)
          )
            for (let t = this.domain; t; t = t.domain) if (e === t) return;
          h(e, "domain", {
            __proto__: null,
            configurable: !0,
            enumerable: !1,
            value: this,
            writable: !0,
          }),
            l(this.members, e);
        }
      }),
      (Domain.prototype.remove = function (e) {
        e.domain = null;
        const t = c(this.members, e);
        -1 !== t && m(this.members, t, 1);
      }),
      (Domain.prototype.run = function (e) {
        this.enter();
        const t = _(e, this, s(arguments, 1));
        return this.exit(), t;
      }),
      (Domain.prototype.intercept = function (e) {
        const t = this;
        return function runIntercepted() {
          return (function intercepted(e, t, n, o) {
            if (o[0] && o[0] instanceof p) {
              const e = o[0];
              return (
                (e.domainBound = n),
                (e.domainThrown = !1),
                h(e, "domain", {
                  __proto__: null,
                  configurable: !0,
                  enumerable: !1,
                  value: t,
                  writable: !0,
                }),
                void t.emit("error", e)
              );
            }
            t.enter();
            const i = _(n, e, s(o, 1));
            return t.exit(), i;
          })(this, t, e, arguments);
        };
      }),
      (Domain.prototype.bind = function (e) {
        const t = this;
        function runBound() {
          return (function bound(e, t, n, o) {
            t.enter();
            const i = _(n, e, o);
            return t.exit(), i;
          })(this, t, e, arguments);
        }
        return (
          h(runBound, "domain", {
            __proto__: null,
            configurable: !0,
            enumerable: !1,
            value: this,
            writable: !0,
          }),
          runBound
        );
      }),
      (E.usingDomains = !0);
    const M = E.init;
    E.init = function (t) {
      return (
        h(this, "domain", {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: null,
          writable: !0,
        }),
        !e.active || this instanceof e.Domain || (this.domain = e.active),
        d(M, this, t)
      );
    };
    const S = E.prototype.emit;
    E.prototype.emit = function emit(...t) {
      const n = this.domain,
        i = t[0];
      if (
        ("error" === i && this.listenerCount(i) > 0) ||
        null == n ||
        this === o
      )
        return _(S, this, t);
      if ("error" === i) {
        const i = t.length > 1 && t[1] ? t[1] : new x();
        "object" == typeof i &&
          ((i.domainEmitter = this),
          h(i, "domain", {
            __proto__: null,
            configurable: !0,
            enumerable: !1,
            value: n,
            writable: !0,
          }),
          (i.domainThrown = !1));
        const r = s(I),
          a = o.domain;
        let c = I.length - 1;
        for (; c > -1 && o.domain === I[c]; ) --c;
        return (
          c < 0 ? (I.length = 0) : m(I, c + 1),
          I.length > 0
            ? (e.active = o.domain = I[I.length - 1])
            : (e.active = o.domain = null),
          updateExceptionCapture(),
          n.emit("error", i),
          (e._stack = I = r),
          (e.active = o.domain = a),
          updateExceptionCapture(),
          !1
        );
      }
      n.enter();
      const r = _(S, this, t);
      return n.exit(), r;
    };
  },
  events: function (e, t, n, r, i, o) {
    "use strict";
    const {
        ArrayPrototypeJoin: s,
        ArrayPrototypeShift: c,
        ArrayPrototypeSlice: a,
        ArrayPrototypeSplice: u,
        ArrayPrototypeUnshift: l,
        Boolean: v,
        Error: f,
        ErrorCaptureStackTrace: p,
        FunctionPrototypeBind: E,
        FunctionPrototypeCall: m,
        NumberIsNaN: h,
        ObjectCreate: d,
        ObjectDefineProperty: g,
        ObjectDefineProperties: y,
        ObjectGetPrototypeOf: _,
        ObjectSetPrototypeOf: L,
        Promise: R,
        PromiseReject: w,
        PromiseResolve: A,
        ReflectApply: b,
        ReflectOwnKeys: x,
        String: T,
        StringPrototypeSplit: k,
        Symbol: C,
        SymbolFor: S,
        SymbolAsyncIterator: M,
        SymbolDispose: I,
      } = o,
      j = S("nodejs.rejection"),
      { kEmptyObject: P } = t("internal/util"),
      { inspect: O, identicalSequenceRange: N } = t("internal/util/inspect");
    let D, H;
    const {
        AbortError: F,
        kEnhanceStackBeforeInspector: W,
        codes: {
          ERR_INVALID_ARG_TYPE: U,
          ERR_INVALID_THIS: $,
          ERR_OUT_OF_RANGE: B,
          ERR_UNHANDLED_ERROR: q,
        },
        genericNodeError: G,
      } = t("internal/errors"),
      {
        validateAbortSignal: V,
        validateBoolean: z,
        validateFunction: J,
        validateString: K,
      } = t("internal/validators"),
      Y = C("kCapture"),
      Q = C("events.errorMonitor"),
      X = C("events.maxEventTargetListeners"),
      Z = C("events.maxEventTargetListenersWarned");
    let ee;
    function EventEmitter(e) {
      EventEmitter.init.call(this, e);
    }
    (n.exports = EventEmitter),
      (n.exports.addAbortListener = function addAbortListener(e, n) {
        if (void 0 === e) throw new U("signal", "AbortSignal", e);
        let r;
        V(e, "signal"),
          J(n, "listener"),
          e.aborted
            ? ((ie ??= t("internal/process/task_queues").queueMicrotask),
              ie(() => n()))
            : ((H ??= t("internal/event_target").kResistStopPropagation),
              e.addEventListener("abort", n, {
                __proto__: null,
                once: !0,
                [H]: !0,
              }),
              (r = () => {
                e.removeEventListener("abort", n);
              }));
        return {
          __proto__: null,
          [I]() {
            r?.();
          },
        };
      }),
      (n.exports.once = async function once(e, n, r = P) {
        const i = r?.signal;
        if ((V(i, "options.signal"), i?.aborted))
          throw new F(void 0, { cause: i?.reason });
        return new R((r, o) => {
          const errorListener = (t) => {
              e.removeListener(n, resolver),
                null != i &&
                  eventTargetAgnosticRemoveListener(i, "abort", abortListener),
                o(t);
            },
            resolver = (...t) => {
              "function" == typeof e.removeListener &&
                e.removeListener("error", errorListener),
                null != i &&
                  eventTargetAgnosticRemoveListener(i, "abort", abortListener),
                r(t);
            };
          H ??= t("internal/event_target").kResistStopPropagation;
          function abortListener() {
            eventTargetAgnosticRemoveListener(e, n, resolver),
              eventTargetAgnosticRemoveListener(e, "error", errorListener),
              o(new F(void 0, { cause: i?.reason }));
          }
          eventTargetAgnosticAddListener(e, n, resolver, {
            __proto__: null,
            once: !0,
            [H]: !0,
          }),
            "error" !== n &&
              "function" == typeof e.once &&
              e.once("error", errorListener),
            null != i &&
              eventTargetAgnosticAddListener(i, "abort", abortListener, {
                __proto__: null,
                once: !0,
                [H]: !0,
              });
        });
      }),
      (n.exports.on = function on(e, n, r = P) {
        const i = r?.signal;
        if ((V(i, "options.signal"), i?.aborted))
          throw new F(void 0, { cause: i?.reason });
        const o = [],
          s = [];
        let a = null,
          u = !1;
        const l = L(
          {
            next() {
              const e = o.shift();
              if (e) return A(createIterResult(e, !1));
              if (a) {
                const e = w(a);
                return (a = null), e;
              }
              return u
                ? A(createIterResult(void 0, !0))
                : new R(function (e, t) {
                    s.push({ resolve: e, reject: t });
                  });
            },
            return() {
              eventTargetAgnosticRemoveListener(e, n, eventHandler),
                eventTargetAgnosticRemoveListener(e, "error", errorHandler),
                i &&
                  eventTargetAgnosticRemoveListener(i, "abort", abortListener, {
                    once: !0,
                  }),
                (u = !0);
              for (const e of s) e.resolve(createIterResult(void 0, !0));
              return A(createIterResult(void 0, !0));
            },
            throw(t) {
              if (!(t && t instanceof f))
                throw new U("EventEmitter.AsyncIterator", "Error", t);
              (a = t),
                eventTargetAgnosticRemoveListener(e, n, eventHandler),
                eventTargetAgnosticRemoveListener(e, "error", errorHandler);
            },
            [M]() {
              return this;
            },
          },
          re
        );
        eventTargetAgnosticAddListener(e, n, eventHandler),
          "error" !== n &&
            "function" == typeof e.on &&
            e.on("error", errorHandler);
        i &&
          ((H ??= t("internal/event_target").kResistStopPropagation),
          eventTargetAgnosticAddListener(i, "abort", abortListener, {
            __proto__: null,
            once: !0,
            [H]: !0,
          }));
        function abortListener() {
          errorHandler(new F(void 0, { cause: i?.reason }));
        }
        function eventHandler(...e) {
          const t = c(s);
          t ? t.resolve(createIterResult(e, !1)) : o.push(e);
        }
        function errorHandler(e) {
          u = !0;
          const t = c(s);
          t ? t.reject(e) : (a = e), l.return();
        }
        return l;
      }),
      (n.exports.getEventListeners = function getEventListeners(e, n) {
        if ("function" == typeof e.listeners) return e.listeners(n);
        const { isEventTarget: r, kEvents: i } = t("internal/event_target");
        if (r(e)) {
          const t = e[i].get(n),
            r = [];
          let o = t?.next;
          for (; void 0 !== o?.listener; ) {
            const e = o.listener?.deref ? o.listener.deref() : o.listener;
            r.push(e), (o = o.next);
          }
          return r;
        }
        throw new U("emitter", ["EventEmitter", "EventTarget"], e);
      }),
      (n.exports.getMaxListeners = function getMaxListeners(e) {
        if ("function" == typeof e?.getMaxListeners) return _getMaxListeners(e);
        if (e?.[X]) return e[X];
        throw new U("emitter", ["EventEmitter", "EventTarget"], e);
      }),
      (EventEmitter.EventEmitter = EventEmitter),
      (EventEmitter.usingDomains = !1),
      (EventEmitter.captureRejectionSymbol = j),
      g(EventEmitter, "captureRejections", {
        __proto__: null,
        get: () => EventEmitter.prototype[Y],
        set(e) {
          z(e, "EventEmitter.captureRejections"),
            (EventEmitter.prototype[Y] = e);
        },
        enumerable: !0,
      }),
      g(EventEmitter, "EventEmitterAsyncResource", {
        __proto__: null,
        enumerable: !0,
        get: function lazyEventEmitterAsyncResource() {
          if (void 0 === ee) {
            const { AsyncResource: e } = t("async_hooks"),
              n = C("kEventEmitter"),
              r = C("kAsyncResource");
            class EventEmitterReferencingAsyncResource extends e {
              constructor(e, t, r) {
                super(t, r), (this[n] = e);
              }
              get eventEmitter() {
                if (void 0 === this[n])
                  throw new $("EventEmitterReferencingAsyncResource");
                return this[n];
              }
            }
            ee = class EventEmitterAsyncResource2 extends EventEmitter {
              constructor(e = void 0) {
                let t;
                "string" == typeof e
                  ? ((t = e), (e = void 0))
                  : (new.target === EventEmitterAsyncResource2 &&
                      K(e?.name, "options.name"),
                    (t = e?.name || new.target.name)),
                  super(e),
                  (this[r] = new EventEmitterReferencingAsyncResource(
                    this,
                    t,
                    e
                  ));
              }
              emit(e, ...t) {
                if (void 0 === this[r])
                  throw new $("EventEmitterAsyncResource");
                const { asyncResource: n } = this;
                return l(t, super.emit, this, e), b(n.runInAsyncScope, n, t);
              }
              emitDestroy() {
                if (void 0 === this[r])
                  throw new $("EventEmitterAsyncResource");
                this.asyncResource.emitDestroy();
              }
              get asyncId() {
                if (void 0 === this[r])
                  throw new $("EventEmitterAsyncResource");
                return this.asyncResource.asyncId();
              }
              get triggerAsyncId() {
                if (void 0 === this[r])
                  throw new $("EventEmitterAsyncResource");
                return this.asyncResource.triggerAsyncId();
              }
              get asyncResource() {
                if (void 0 === this[r])
                  throw new $("EventEmitterAsyncResource");
                return this[r];
              }
            };
          }
          return ee;
        },
        set: void 0,
        configurable: !0,
      }),
      (EventEmitter.errorMonitor = Q),
      g(EventEmitter.prototype, Y, {
        __proto__: null,
        value: !1,
        writable: !0,
        enumerable: !1,
      }),
      (EventEmitter.prototype._events = void 0),
      (EventEmitter.prototype._eventsCount = 0),
      (EventEmitter.prototype._maxListeners = void 0);
    let te,
      ne = 10;
    function checkListener(e) {
      J(e, "listener");
    }
    function addCatch(e, t, n, i) {
      if (e[Y])
        try {
          const o = t.then;
          "function" == typeof o &&
            o.call(t, void 0, function (t) {
              r.nextTick(emitUnhandledRejectionOrErr, e, t, n, i);
            });
        } catch (t) {
          e.emit("error", t);
        }
    }
    function emitUnhandledRejectionOrErr(e, t, n, r) {
      if ("function" == typeof e[j]) e[j](t, n, ...r);
      else {
        const n = e[Y];
        try {
          (e[Y] = !1), e.emit("error", t);
        } finally {
          e[Y] = n;
        }
      }
    }
    function _getMaxListeners(e) {
      return void 0 === e._maxListeners
        ? EventEmitter.defaultMaxListeners
        : e._maxListeners;
    }
    function enhanceStackTrace(e, t) {
      let n = "";
      try {
        const { name: e } = this.constructor;
        "EventEmitter" !== e && (n = ` on ${e} instance`);
      } catch {}
      const r = `\nEmitted 'error' event${n} at:\n`,
        i = a(k(e.stack, "\n"), 1),
        o = a(k(t.stack, "\n"), 1),
        { len: c, offset: l } = N(o, i);
      return (
        c > 0 &&
          u(
            o,
            l + 1,
            c - 2,
            "    [... lines matching original stack trace ...]"
          ),
        e.stack + r + s(o, "\n")
      );
    }
    function _addListener(e, t, n, i) {
      let o, s, c;
      if (
        (checkListener(n),
        (s = e._events),
        void 0 === s
          ? ((s = e._events = d(null)), (e._eventsCount = 0))
          : (void 0 !== s.newListener &&
              (e.emit("newListener", t, n.listener ?? n), (s = e._events)),
            (c = s[t])),
        void 0 === c)
      )
        (s[t] = n), ++e._eventsCount;
      else if (
        ("function" == typeof c
          ? (c = s[t] = i ? [n, c] : [c, n])
          : i
          ? c.unshift(n)
          : c.push(n),
        (o = _getMaxListeners(e)),
        o > 0 && c.length > o && !c.warned)
      ) {
        c.warned = !0;
        const n = G(
          `Possible EventEmitter memory leak detected. ${c.length} ${T(
            t
          )} listeners added to ${O(e, {
            depth: -1,
          })}. Use emitter.setMaxListeners() to increase limit`,
          {
            name: "MaxListenersExceededWarning",
            emitter: e,
            type: t,
            count: c.length,
          }
        );
        r.emitWarning(n);
      }
      return e;
    }
    function onceWrapper() {
      if (!this.fired)
        return (
          this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          0 === arguments.length
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments)
        );
    }
    function _onceWrap(e, t, n) {
      const r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n },
        i = onceWrapper.bind(r);
      return (i.listener = n), (r.wrapFn = i), i;
    }
    function _listeners(e, t, n) {
      const r = e._events;
      if (void 0 === r) return [];
      const i = r[t];
      return void 0 === i
        ? []
        : "function" == typeof i
        ? n
          ? [i.listener || i]
          : [i]
        : n
        ? (function unwrapListeners(e) {
            const t = arrayClone(e);
            for (let e = 0; e < t.length; ++e) {
              const n = t[e].listener;
              "function" == typeof n && (t[e] = n);
            }
            return t;
          })(i)
        : arrayClone(i);
    }
    function listenerCount(e, t) {
      const n = this._events;
      if (void 0 !== n) {
        const r = n[e];
        if ("function" == typeof r)
          return null != t ? (t === r || t === r.listener ? 1 : 0) : 1;
        if (void 0 !== r) {
          if (null != t) {
            let e = 0;
            for (let n = 0, i = r.length; n < i; n++)
              (r[n] !== t && r[n].listener !== t) || e++;
            return e;
          }
          return r.length;
        }
      }
      return 0;
    }
    function arrayClone(e) {
      switch (e.length) {
        case 2:
          return [e[0], e[1]];
        case 3:
          return [e[0], e[1], e[2]];
        case 4:
          return [e[0], e[1], e[2], e[3]];
        case 5:
          return [e[0], e[1], e[2], e[3], e[4]];
        case 6:
          return [e[0], e[1], e[2], e[3], e[4], e[5]];
      }
      return a(e);
    }
    g(EventEmitter, "defaultMaxListeners", {
      __proto__: null,
      enumerable: !0,
      get: function () {
        return ne;
      },
      set: function (e) {
        if ("number" != typeof e || e < 0 || h(e))
          throw new B("defaultMaxListeners", "a non-negative number", e);
        ne = e;
      },
    }),
      y(EventEmitter, {
        kMaxEventTargetListeners: {
          __proto__: null,
          value: X,
          enumerable: !1,
          configurable: !1,
          writable: !1,
        },
        kMaxEventTargetListenersWarned: {
          __proto__: null,
          value: Z,
          enumerable: !1,
          configurable: !1,
          writable: !1,
        },
      }),
      (EventEmitter.setMaxListeners = function (e = ne, ...n) {
        if ("number" != typeof e || e < 0 || h(e))
          throw new B("n", "a non-negative number", e);
        if (0 === n.length) ne = e;
        else {
          void 0 === te && (te = t("internal/event_target").isEventTarget);
          for (let t = 0; t < n.length; t++) {
            const r = n[t];
            if (te(r)) (r[X] = e), (r[Z] = !1);
            else {
              if ("function" != typeof r.setMaxListeners)
                throw new U("eventTargets", ["EventEmitter", "EventTarget"], r);
              r.setMaxListeners(e);
            }
          }
        }
      }),
      (EventEmitter.init = function (e) {
        (void 0 !== this._events && this._events !== _(this)._events) ||
          ((this._events = d(null)), (this._eventsCount = 0)),
          (this._maxListeners = this._maxListeners || void 0),
          e?.captureRejections
            ? (z(e.captureRejections, "options.captureRejections"),
              (this[Y] = v(e.captureRejections)))
            : (this[Y] = EventEmitter.prototype[Y]);
      }),
      (EventEmitter.prototype.setMaxListeners = function setMaxListeners(e) {
        if ("number" != typeof e || e < 0 || h(e))
          throw new B("n", "a non-negative number", e);
        return (this._maxListeners = e), this;
      }),
      (EventEmitter.prototype.getMaxListeners = function getMaxListeners2() {
        return _getMaxListeners(this);
      }),
      (EventEmitter.prototype.emit = function emit(e, ...t) {
        let n = "error" === e;
        const r = this._events;
        if (void 0 !== r)
          n && void 0 !== r[Q] && this.emit(Q, ...t),
            (n = n && void 0 === r.error);
        else if (!n) return !1;
        if (n) {
          let e, n;
          if ((t.length > 0 && (e = t[0]), e instanceof f)) {
            try {
              const t = {};
              p(t, EventEmitter.prototype.emit),
                g(e, W, {
                  __proto__: null,
                  value: E(enhanceStackTrace, this, e, t),
                  configurable: !0,
                });
            } catch {}
            throw e;
          }
          try {
            n = O(e);
          } catch {
            n = e;
          }
          const r = new q(n);
          throw ((r.context = e), r);
        }
        const i = r[e];
        if (void 0 === i) return !1;
        if ("function" == typeof i) {
          const n = i.apply(this, t);
          null != n && addCatch(this, n, e, t);
        } else {
          const n = i.length,
            r = arrayClone(i);
          for (let i = 0; i < n; ++i) {
            const n = r[i].apply(this, t);
            null != n && addCatch(this, n, e, t);
          }
        }
        return !0;
      }),
      (EventEmitter.prototype.addListener = function addListener(e, t) {
        return _addListener(this, e, t, !1);
      }),
      (EventEmitter.prototype.on = EventEmitter.prototype.addListener),
      (EventEmitter.prototype.prependListener = function prependListener(e, t) {
        return _addListener(this, e, t, !0);
      }),
      (EventEmitter.prototype.once = function once2(e, t) {
        return checkListener(t), this.on(e, _onceWrap(this, e, t)), this;
      }),
      (EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(e, t) {
          return (
            checkListener(t),
            this.prependListener(e, _onceWrap(this, e, t)),
            this
          );
        }),
      (EventEmitter.prototype.removeListener = function removeListener(e, n) {
        checkListener(n);
        const r = this._events;
        if (void 0 === r) return this;
        const i = r[e];
        if (void 0 === i) return this;
        if (i === n || i.listener === n)
          0 == --this._eventsCount
            ? (this._events = d(null))
            : (delete r[e],
              r.removeListener &&
                this.emit("removeListener", e, i.listener || n));
        else if ("function" != typeof i) {
          let o = -1;
          for (let e = i.length - 1; e >= 0; e--)
            if (i[e] === n || i[e].listener === n) {
              o = e;
              break;
            }
          if (o < 0) return this;
          0 === o
            ? i.shift()
            : (void 0 === D && (D = t("internal/util").spliceOne), D(i, o)),
            1 === i.length && (r[e] = i[0]),
            void 0 !== r.removeListener && this.emit("removeListener", e, n);
        }
        return this;
      }),
      (EventEmitter.prototype.off = EventEmitter.prototype.removeListener),
      (EventEmitter.prototype.removeAllListeners = function removeAllListeners(
        e
      ) {
        const t = this._events;
        if (void 0 === t) return this;
        if (void 0 === t.removeListener)
          return (
            0 === arguments.length
              ? ((this._events = d(null)), (this._eventsCount = 0))
              : void 0 !== t[e] &&
                (0 == --this._eventsCount
                  ? (this._events = d(null))
                  : delete t[e]),
            this
          );
        if (0 === arguments.length) {
          for (const e of x(t))
            "removeListener" !== e && this.removeAllListeners(e);
          return (
            this.removeAllListeners("removeListener"),
            (this._events = d(null)),
            (this._eventsCount = 0),
            this
          );
        }
        const n = t[e];
        if ("function" == typeof n) this.removeListener(e, n);
        else if (void 0 !== n)
          for (let t = n.length - 1; t >= 0; t--) this.removeListener(e, n[t]);
        return this;
      }),
      (EventEmitter.prototype.listeners = function listeners(e) {
        return _listeners(this, e, !0);
      }),
      (EventEmitter.prototype.rawListeners = function rawListeners(e) {
        return _listeners(this, e, !1);
      }),
      (EventEmitter.listenerCount = function (e, t) {
        return "function" == typeof e.listenerCount
          ? e.listenerCount(t)
          : m(listenerCount, e, t);
      }),
      (EventEmitter.prototype.listenerCount = listenerCount),
      (EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? x(this._events) : [];
      });
    const re = _(_(async function* () {}).prototype);
    function createIterResult(e, t) {
      return { value: e, done: t };
    }
    function eventTargetAgnosticRemoveListener(e, t, n, r) {
      if ("function" == typeof e.removeListener) e.removeListener(t, n);
      else {
        if ("function" != typeof e.removeEventListener)
          throw new U("emitter", "EventEmitter", e);
        e.removeEventListener(t, n, r);
      }
    }
    function eventTargetAgnosticAddListener(e, t, n, r) {
      if ("function" == typeof e.on) r?.once ? e.once(t, n) : e.on(t, n);
      else {
        if ("function" != typeof e.addEventListener)
          throw new U("emitter", "EventEmitter", e);
        e.addEventListener(t, n, r);
      }
    }
    let ie;
  },
  fs: function (e, t, n, o, a, c) {
    "use strict";
    const {
        ArrayPrototypePush: i,
        BigIntPrototypeToString: r,
        Boolean: l,
        MathMax: s,
        Number: f,
        ObjectDefineProperties: u,
        ObjectDefineProperty: d,
        Promise: p,
        ReflectApply: m,
        SafeMap: y,
        SafeSet: h,
        String: g,
        StringPrototypeCharCodeAt: S,
        StringPrototypeIndexOf: b,
        StringPrototypeSlice: v,
      } = c,
      { fs: w } = a("constants"),
      {
        S_IFIFO: k,
        S_IFLNK: P,
        S_IFMT: _,
        S_IFREG: F,
        S_IFSOCK: N,
        F_OK: C,
        R_OK: L,
        W_OK: R,
        X_OK: O,
        O_WRONLY: A,
        O_SYMLINK: T,
      } = w,
      x = t("path"),
      { isArrayBufferView: E } = t("internal/util/types"),
      I = a("fs"),
      { Buffer: X } = t("buffer"),
      {
        aggregateTwoErrors: W,
        codes: {
          ERR_FS_FILE_TOO_LARGE: B,
          ERR_INVALID_ARG_VALUE: D,
          ERR_FEATURE_UNAVAILABLE_ON_PLATFORM: z,
        },
        AbortError: K,
        uvErrmapGet: U,
        uvException: M,
      } = t("internal/errors"),
      { FSReqCallback: V } = I,
      { toPathIfFileURL: j } = t("internal/url"),
      {
        customPromisifyArgs: $,
        deprecate: G,
        kEmptyObject: H,
        promisify: { custom: Y },
        SideEffectFreeRegExpPrototypeExec: q,
        defineLazyProperties: Z,
      } = t("internal/util"),
      {
        constants: { kIoMaxLength: J, kMaxUserId: Q },
        copyObject: ee,
        Dirent: te,
        emitRecursiveRmdirWarning: ne,
        getDirent: oe,
        getDirents: ae,
        getOptions: ce,
        getValidatedFd: ie,
        getValidatedPath: re,
        getValidMode: le,
        handleErrorFromBinding: se,
        preprocessSymlinkDestination: fe,
        Stats: ue,
        getStatFsFromBinding: de,
        getStatsFromBinding: pe,
        realpathCacheKey: me,
        stringToFlags: ye,
        stringToSymlinkType: he,
        toUnixTimestamp: ge,
        validateBufferArray: Se,
        validateCpOptions: be,
        validateOffsetLengthRead: ve,
        validateOffsetLengthWrite: we,
        validatePath: ke,
        validatePosition: Pe,
        validateRmOptions: _e,
        validateRmOptionsSync: Fe,
        validateRmdirOptions: Ne,
        validateStringAfterArrayBufferView: Ce,
        validatePrimitiveStringAfterArrayBufferView: Le,
        warnOnNonPortableTemplate: Re,
      } = t("internal/fs/utils"),
      { CHAR_FORWARD_SLASH: Oe, CHAR_BACKWARD_SLASH: Ae } =
        t("internal/constants"),
      {
        isUint32: Te,
        parseFileMode: xe,
        validateBoolean: Ee,
        validateBuffer: Ie,
        validateEncoding: Xe,
        validateFunction: We,
        validateInteger: Be,
        validateObject: De,
      } = t("internal/validators");
    let ze,
      Ke,
      Ue,
      Me,
      Ve,
      je,
      $e,
      Ge,
      He,
      Ye,
      qe = !0,
      Ze = null;
    const Je = "win32" === o.platform,
      Qe = "darwin" === o.platform,
      et = G(
        () => {},
        "Implicit coercion of objects with own toString property is deprecated.",
        "DEP0162"
      );
    function showTruncateDeprecation() {
      qe &&
        (o.emitWarning(
          "Using fs.truncate with a file descriptor is deprecated. Please use fs.ftruncate with a file descriptor instead.",
          "DeprecationWarning",
          "DEP0081"
        ),
        (qe = !1));
    }
    function maybeCallback(e) {
      return We(e, "cb"), e;
    }
    function makeCallback(e) {
      return We(e, "cb"), (...t) => m(e, this, t);
    }
    function makeStatsCallback(e) {
      return (
        We(e, "cb"),
        (t, n) => {
          if (t) return e(t);
          e(t, pe(n));
        }
      );
    }
    const tt = Te;
    function isFileType(e, t) {
      let n = e[1];
      return "bigint" == typeof n && (n = f(n)), (n & _) === t;
    }
    function exists(e, t) {
      maybeCallback(t);
      try {
        ze.access(e, C, function suppressedCallback(e) {
          t(!e);
        });
      } catch {
        return t(!1);
      }
    }
    function readFileAfterOpen(e, t) {
      const n = this.context;
      if (e) return void n.callback(e);
      n.fd = t;
      const o = new V();
      (o.oncomplete = readFileAfterStat), (o.context = n), I.fstat(t, !1, o);
    }
    function readFileAfterStat(e, t) {
      const n = this.context;
      if (e) return n.close(e);
      const o = (n.size = isFileType(t, F) ? t[8] : 0);
      if (o > J) return (e = new B(o)), n.close(e);
      try {
        0 === o ? (n.buffers = []) : (n.buffer = X.allocUnsafeSlow(o));
      } catch (e) {
        return n.close(e);
      }
      n.read();
    }
    function checkAborted(e, t) {
      return !!e?.aborted && (t(new K(void 0, { cause: e?.reason })), !0);
    }
    function tryReadSync(e, t, n, o, a) {
      let c,
        i = !0;
      try {
        (c = ze.readSync(e, n, o, a)), (i = !1);
      } finally {
        i && !t && ze.closeSync(e);
      }
      return c;
    }
    function defaultCloseCallback(e) {
      if (null != e) throw e;
    }
    function read(e, t, n, a, c, i) {
      e = ie(e);
      let r = n,
        l = null;
      if (
        (arguments.length <= 4 &&
          (4 === arguments.length
            ? (De(n, "options", { nullable: !0 }), (i = a), (l = n))
            : 3 === arguments.length
            ? (E(t) || ((l = t), ({ buffer: t = X.alloc(16384) } = l ?? H)),
              (i = n))
            : ((i = t), (t = X.alloc(16384))),
          ({
            offset: r = 0,
            length: a = t.byteLength - r,
            position: c = null,
          } = l ?? H)),
        Ie(t),
        (i = maybeCallback(i)),
        null == r ? (r = 0) : Be(r, "offset", 0),
        0 === (a |= 0))
      )
        return o.nextTick(function tick() {
          i(null, 0, t);
        });
      if (0 === t.byteLength)
        throw new D("buffer", t, "is empty and cannot be written");
      ve(r, a, t.byteLength), null == c && (c = -1), Pe(c, "position");
      const s = new V();
      (s.oncomplete = function wrapper(e, n) {
        i(e, n || 0, t);
      }),
        I.read(e, t, r, a, c, s);
    }
    function readv(e, t, n, o) {
      (e = ie(e)), Se(t), (o = maybeCallback(o || n));
      const a = new V();
      return (
        (a.oncomplete = function wrapper(e, n) {
          o(e, n || 0, t);
        }),
        "number" != typeof n && (n = null),
        I.readBuffers(e, t, n, a)
      );
    }
    function write(e, t, n, o, a, c) {
      function wrapper(e, n) {
        c(e, n || 0, t);
      }
      e = ie(e);
      let i = n;
      if (E(t)) {
        (c = maybeCallback(c || a || o || i)),
          "object" == typeof i &&
            ({
              offset: i = 0,
              length: o = t.byteLength - i,
              position: a = null,
            } = n ?? H),
          null == i || "function" == typeof i ? (i = 0) : Be(i, "offset", 0),
          "number" != typeof o && (o = t.byteLength - i),
          "number" != typeof a && (a = null),
          we(i, o, t.byteLength);
        const r = new V();
        return (r.oncomplete = wrapper), I.writeBuffer(e, t, i, o, a, r);
      }
      Ce(t, "buffer"),
        "string" != typeof t && et(),
        "function" != typeof a &&
          ("function" == typeof i ? ((a = i), (i = null)) : (a = o),
          (o = "utf8"));
      const r = g(t);
      Xe(r, o), (c = maybeCallback(a));
      const l = new V();
      return (l.oncomplete = wrapper), I.writeString(e, r, i, o, l);
    }
    function writev(e, t, n, a) {
      if (((e = ie(e)), Se(t), (a = maybeCallback(a || n)), 0 === t.length))
        return void o.nextTick(a, null, 0, t);
      const c = new V();
      return (
        (c.oncomplete = function wrapper(e, n) {
          a(e, n || 0, t);
        }),
        "number" != typeof n && (n = null),
        I.writeBuffers(e, t, n, c)
      );
    }
    function lazyLoadCp() {
      void 0 === Ke &&
        (({ cpFn: Ke } = t("internal/fs/cp/cp")),
        (Ke = t("util").callbackify(Ke)),
        ({ cpSyncFn: Ue } = t("internal/fs/cp/cp-sync")));
    }
    function lazyLoadRimraf() {
      void 0 === je &&
        ({ rimraf: je, rimrafSync: $e } = t("internal/fs/rimraf"));
    }
    function readdirSyncRecursive(e, t) {
      const n = l(t.withFileTypes),
        o = t.encoding,
        a = [],
        c = [e],
        r = { path: e };
      function read2(t) {
        r.path = t;
        const l = I.readdir(x.toNamespacedPath(t), o, n, void 0, r);
        if ((se(r), n)) {
          const e = l[0].length;
          for (let n = 0; n < e; n++) {
            const e = oe(t, l[0][n], l[1][n]);
            i(a, e), e.isDirectory() && i(c, x.join(e.path, e.name));
          }
        } else
          for (let n = 0; n < l.length; n++) {
            const o = x.join(t, l[n]),
              r = x.relative(e, o),
              s = I.internalModuleStat(o);
            i(a, r), 1 === s && i(c, o);
          }
      }
      for (let e = 0; e < c.length; e++) read2(c[e]);
      return a;
    }
    function stat(e, t = { bigint: !1 }, n) {
      "function" == typeof t && ((n = t), (t = H)),
        (n = makeStatsCallback(n)),
        (e = re(e));
      const o = new V(t.bigint);
      (o.oncomplete = n), I.stat(x.toNamespacedPath(e), t.bigint, o);
    }
    function hasNoEntryError(e) {
      if (e.errno) {
        const t = U(e.errno);
        return "ENOENT" === t?.[0];
      }
      return !!e.error && "ENOENT" === e.error.code;
    }
    function statSync(e, t = { bigint: !1, throwIfNoEntry: !0 }) {
      const n = { path: (e = re(e)) },
        o = I.stat(x.toNamespacedPath(e), t.bigint, void 0, n);
      if (!1 !== t.throwIfNoEntry || !hasNoEntryError(n)) return se(n), pe(o);
    }
    function writeAll(e, t, n, o, a, c, i) {
      if (c?.aborted) {
        const n = new K(void 0, { cause: c?.reason });
        t
          ? i(n)
          : ze.close(e, (e) => {
              i(W(e, n));
            });
      } else
        ze.write(e, n, o, a, null, (r, l) => {
          r
            ? t
              ? i(r)
              : ze.close(e, (e) => {
                  i(W(e, r));
                })
            : l === a
            ? t
              ? i(null)
              : ze.close(e, i)
            : writeAll(e, t, n, (o += l), (a -= l), c, i);
        });
    }
    d(exists, Y, {
      __proto__: null,
      value: function exists2(e) {
        return new p((t) => ze.exists(e, t));
      },
    }),
      d(read, $, {
        __proto__: null,
        value: ["bytesRead", "buffer"],
        enumerable: !1,
      }),
      d(readv, $, {
        __proto__: null,
        value: ["bytesRead", "buffers"],
        enumerable: !1,
      }),
      d(write, $, {
        __proto__: null,
        value: ["bytesWritten", "buffer"],
        enumerable: !1,
      }),
      d(writev, $, {
        __proto__: null,
        value: ["bytesWritten", "buffer"],
        enumerable: !1,
      });
    const nt = new y();
    let ot, at;
    if (Je) {
      const e = /^(?:[a-zA-Z]:|[\\/]{2}[^\\/]+[\\/][^\\/]+)?[\\/]*/;
      ot = function splitRoot2(t) {
        return q(e, t)[0];
      };
    } else
      ot = function splitRoot2(e) {
        for (let t = 0; t < e.length; ++t)
          if (S(e, t) !== Oe) return v(e, 0, t);
        return e;
      };
    function encodeRealpathResult(e, t) {
      if (!t || !t.encoding || "utf8" === t.encoding) return e;
      const n = X.from(e);
      return "buffer" === t.encoding ? n : n.toString(t.encoding);
    }
    function realpathSync(e, t) {
      (t = ce(t)),
        "string" != typeof (e = j(e)) && (e += ""),
        ke(e),
        (e = x.resolve(e));
      const n = t[me],
        o = n?.get(e);
      if (o) return o;
      const a = new y(),
        c = new h(),
        i = e;
      let l, s, f, u;
      if (((s = f = ot(e)), (l = s.length), Je)) {
        const e = { path: f };
        I.lstat(x.toNamespacedPath(f), !1, void 0, e), se(e), c.add(f);
      }
      for (; l < e.length; ) {
        const t = at(e, l);
        if (((u = s), -1 === t)) {
          const t = v(e, l);
          (s += t), (f = u + t), (l = e.length);
        } else (s += v(e, l, t + 1)), (f = u + v(e, l, t)), (l = t + 1);
        if (c.has(f) || n?.get(f) === f) {
          if (isFileType(I.statValues, k) || isFileType(I.statValues, N)) break;
          continue;
        }
        let o;
        const i = n?.get(f);
        if (i) o = i;
        else {
          const e = x.toNamespacedPath(f),
            t = { path: f },
            i = I.lstat(e, !0, void 0, t);
          if ((se(t), !isFileType(i, P))) {
            c.add(f), n?.set(f, f);
            continue;
          }
          let l,
            s = null;
          if (!Je) {
            (l = `${r(i[0], 32)}:${r(i[7], 32)}`), a.has(l) && (s = a.get(l));
          }
          if (null === s) {
            const t = { path: f };
            I.stat(e, !1, void 0, t),
              se(t),
              (s = I.readlink(e, void 0, void 0, t)),
              se(t);
          }
          (o = x.resolve(u, s)), n?.set(f, o), Je || a.set(l, s);
        }
        if (
          ((e = x.resolve(o, v(e, l))),
          (s = f = ot(e)),
          (l = s.length),
          Je && !c.has(f))
        ) {
          const e = { path: f };
          I.lstat(x.toNamespacedPath(f), !1, void 0, e), se(e), c.add(f);
        }
      }
      return n?.set(i, e), encodeRealpathResult(e, t);
    }
    function realpath(e, t, n) {
      (n = "function" == typeof t ? t : maybeCallback(n)),
        (t = ce(t)),
        "string" != typeof (e = j(e)) && (e += ""),
        ke(e),
        (e = x.resolve(e));
      const a = new y(),
        c = new h();
      let i, l, s, f;
      function LOOP() {
        if (i >= e.length) return n(null, encodeRealpathResult(e, t));
        const a = at(e, i);
        if (((f = l), -1 === a)) {
          const t = v(e, i);
          (l += t), (s = f + t), (i = e.length);
        } else (l += v(e, i, a + 1)), (s = f + v(e, i, a)), (i = a + 1);
        return c.has(s)
          ? isFileType(I.statValues, k) || isFileType(I.statValues, N)
            ? n(null, encodeRealpathResult(e, t))
            : o.nextTick(LOOP)
          : ze.lstat(s, { bigint: !0 }, gotStat);
      }
      function gotStat(e, t) {
        if (e) return n(e);
        if (!t.isSymbolicLink()) return c.add(s), o.nextTick(LOOP);
        let i;
        if (!Je) {
          const e = r(t.dev, 32),
            n = r(t.ino, 32);
          if (((i = `${e}:${n}`), a.has(i))) return gotTarget(null, a.get(i));
        }
        ze.stat(s, (e) => {
          if (e) return n(e);
          ze.readlink(s, (e, t) => {
            Je || a.set(i, t), gotTarget(e, t);
          });
        });
      }
      function gotTarget(t, a) {
        if (t) return n(t);
        !(function gotResolvedLink(t) {
          (e = x.resolve(t, v(e, i))),
            (l = s = ot(e)),
            (i = l.length),
            Je && !c.has(s)
              ? ze.lstat(s, (e) => {
                  if (e) return n(e);
                  c.add(s), LOOP();
                })
              : o.nextTick(LOOP);
        })(x.resolve(f, a));
      }
      (l = s = ot(e)),
        (i = l.length),
        Je && !c.has(s)
          ? ze.lstat(s, (e, t) => {
              if (e) return n(e);
              c.add(s), LOOP();
            })
          : o.nextTick(LOOP);
    }
    function lazyLoadStreams() {
      Me ||
        (({ ReadStream: Me, WriteStream: Ve } = t("internal/fs/streams")),
        (He = Me),
        (Ye = Ve));
    }
    (at = Je
      ? function nextPart2(e, t) {
          for (; t < e.length; ++t) {
            const n = S(e, t);
            if (n === Ae || n === Oe) return t;
          }
          return -1;
        }
      : function nextPart2(e, t) {
          return b(e, "/", t);
        }),
      (realpathSync.native = (e, t) => {
        t = ce(t);
        const n = { path: (e = re(e)) },
          o = I.realpath(x.toNamespacedPath(e), t.encoding, void 0, n);
        return se(n), o;
      }),
      (realpath.native = (e, t, n) => {
        (n = makeCallback(n || t)), (t = ce(t)), (e = re(e));
        const o = new V();
        return (
          (o.oncomplete = n), I.realpath(x.toNamespacedPath(e), t.encoding, o)
        );
      }),
      (n.exports = ze =
        {
          appendFile: function appendFile(e, t, n, o) {
            (o = maybeCallback(o || n)),
              (n = ce(n, { encoding: "utf8", mode: 438, flag: "a" })),
              ((n = ee(n)).flag && !tt(e)) || (n.flag = "a"),
              ze.writeFile(e, t, n, o);
          },
          appendFileSync: function appendFileSync(e, t, n) {
            (n = ce(n, { encoding: "utf8", mode: 438, flag: "a" })),
              ((n = ee(n)).flag && !tt(e)) || (n.flag = "a"),
              ze.writeFileSync(e, t, n);
          },
          access: function access(e, t, n) {
            "function" == typeof t && ((n = t), (t = C)),
              (e = re(e)),
              (t = le(t, "access")),
              (n = makeCallback(n));
            const o = new V();
            (o.oncomplete = n), I.access(x.toNamespacedPath(e), t, o);
          },
          accessSync: function accessSync(e, t) {
            (e = re(e)), (t = le(t, "access"));
            const n = { path: e };
            I.access(x.toNamespacedPath(e), t, void 0, n), se(n);
          },
          chown: function chown(e, t, n, o) {
            (o = makeCallback(o)),
              (e = re(e)),
              Be(t, "uid", -1, Q),
              Be(n, "gid", -1, Q);
            const a = new V();
            (a.oncomplete = o), I.chown(x.toNamespacedPath(e), t, n, a);
          },
          chownSync: function chownSync(e, t, n) {
            (e = re(e)), Be(t, "uid", -1, Q), Be(n, "gid", -1, Q);
            const o = { path: e };
            I.chown(x.toNamespacedPath(e), t, n, void 0, o), se(o);
          },
          chmod: function chmod(e, t, n) {
            (e = re(e)), (t = xe(t, "mode")), (n = makeCallback(n));
            const o = new V();
            (o.oncomplete = n), I.chmod(x.toNamespacedPath(e), t, o);
          },
          chmodSync: function chmodSync(e, t) {
            (e = re(e)), (t = xe(t, "mode"));
            const n = { path: e };
            I.chmod(x.toNamespacedPath(e), t, void 0, n), se(n);
          },
          close: function close(e, t = defaultCloseCallback) {
            (e = ie(e)), t !== defaultCloseCallback && (t = makeCallback(t));
            const n = new V();
            (n.oncomplete = t), I.close(e, n);
          },
          closeSync: function closeSync(e) {
            e = ie(e);
            const t = {};
            I.close(e, void 0, t), se(t);
          },
          copyFile: function copyFile(e, t, n, o) {
            "function" == typeof n && ((o = n), (n = 0)),
              (e = re(e, "src")),
              (t = re(t, "dest")),
              (e = x._makeLong(e)),
              (t = x._makeLong(t)),
              (n = le(n, "copyFile")),
              (o = makeCallback(o));
            const a = new V();
            (a.oncomplete = o), I.copyFile(e, t, n, a);
          },
          copyFileSync: function copyFileSync(e, t, n) {
            const o = { path: (e = re(e, "src")), dest: (t = re(t, "dest")) };
            (e = x._makeLong(e)),
              (t = x._makeLong(t)),
              (n = le(n, "copyFile")),
              I.copyFile(e, t, n, void 0, o),
              se(o);
          },
          cp: function cp(e, t, n, o) {
            "function" == typeof n && ((o = n), (n = void 0)),
              (o = makeCallback(o)),
              (n = be(n)),
              (e = x.toNamespacedPath(re(e, "src"))),
              (t = x.toNamespacedPath(re(t, "dest"))),
              lazyLoadCp(),
              Ke(e, t, n, o);
          },
          cpSync: function cpSync(e, t, n) {
            (n = be(n)),
              (e = x.toNamespacedPath(re(e, "src"))),
              (t = x.toNamespacedPath(re(t, "dest"))),
              lazyLoadCp(),
              Ue(e, t, n);
          },
          createReadStream: function createReadStream(e, t) {
            return lazyLoadStreams(), new Me(e, t);
          },
          createWriteStream: function createWriteStream(e, t) {
            return lazyLoadStreams(), new Ve(e, t);
          },
          exists: exists,
          existsSync: function existsSync(e) {
            try {
              e = re(e);
            } catch {
              return !1;
            }
            const t = { path: e },
              n = x.toNamespacedPath(e);
            return (
              I.access(n, C, void 0, t),
              Je && void 0 === t.errno && I.stat(n, !1, void 0, t),
              void 0 === t.errno
            );
          },
          fchown: function fchown(e, t, n, o) {
            (e = ie(e)),
              Be(t, "uid", -1, Q),
              Be(n, "gid", -1, Q),
              (o = makeCallback(o));
            const a = new V();
            (a.oncomplete = o), I.fchown(e, t, n, a);
          },
          fchownSync: function fchownSync(e, t, n) {
            (e = ie(e)), Be(t, "uid", -1, Q), Be(n, "gid", -1, Q);
            const o = {};
            I.fchown(e, t, n, void 0, o), se(o);
          },
          fchmod: function fchmod(e, t, n) {
            (e = ie(e)), (t = xe(t, "mode")), (n = makeCallback(n));
            const o = new V();
            (o.oncomplete = n), I.fchmod(e, t, o);
          },
          fchmodSync: function fchmodSync(e, t) {
            (e = ie(e)), (t = xe(t, "mode"));
            const n = {};
            I.fchmod(e, t, void 0, n), se(n);
          },
          fdatasync: function fdatasync(e, t) {
            e = ie(e);
            const n = new V();
            (n.oncomplete = makeCallback(t)), I.fdatasync(e, n);
          },
          fdatasyncSync: function fdatasyncSync(e) {
            e = ie(e);
            const t = {};
            I.fdatasync(e, void 0, t), se(t);
          },
          fstat: function fstat(e, t = { bigint: !1 }, n) {
            "function" == typeof t && ((n = t), (t = H)),
              (e = ie(e)),
              (n = makeStatsCallback(n));
            const o = new V(t.bigint);
            (o.oncomplete = n), I.fstat(e, t.bigint, o);
          },
          fstatSync: function fstatSync(e, t = { bigint: !1 }) {
            const n = { fd: (e = ie(e)) },
              o = I.fstat(e, t.bigint, void 0, n);
            return se(n), pe(o);
          },
          fsync: function fsync(e, t) {
            e = ie(e);
            const n = new V();
            (n.oncomplete = makeCallback(t)), I.fsync(e, n);
          },
          fsyncSync: function fsyncSync(e) {
            e = ie(e);
            const t = {};
            I.fsync(e, void 0, t), se(t);
          },
          ftruncate: function ftruncate(e, t = 0, n) {
            "function" == typeof t && ((n = t), (t = 0)),
              (e = ie(e)),
              Be(t, "len"),
              (t = s(0, t)),
              (n = makeCallback(n));
            const o = new V();
            (o.oncomplete = n), I.ftruncate(e, t, o);
          },
          ftruncateSync: function ftruncateSync(e, t = 0) {
            (e = ie(e)), Be(t, "len"), (t = s(0, t));
            const n = {};
            I.ftruncate(e, t, void 0, n), se(n);
          },
          futimes: function futimes(e, t, n, o) {
            (e = ie(e)),
              (t = ge(t, "atime")),
              (n = ge(n, "mtime")),
              (o = makeCallback(o));
            const a = new V();
            (a.oncomplete = o), I.futimes(e, t, n, a);
          },
          futimesSync: function futimesSync(e, t, n) {
            (e = ie(e)), (t = ge(t, "atime")), (n = ge(n, "mtime"));
            const o = {};
            I.futimes(e, t, n, void 0, o), se(o);
          },
          lchown: function lchown(e, t, n, o) {
            (o = makeCallback(o)),
              (e = re(e)),
              Be(t, "uid", -1, Q),
              Be(n, "gid", -1, Q);
            const a = new V();
            (a.oncomplete = o), I.lchown(x.toNamespacedPath(e), t, n, a);
          },
          lchownSync: function lchownSync(e, t, n) {
            (e = re(e)), Be(t, "uid", -1, Q), Be(n, "gid", -1, Q);
            const o = { path: e };
            I.lchown(x.toNamespacedPath(e), t, n, void 0, o), se(o);
          },
          lchmod:
            void 0 !== w.O_SYMLINK
              ? function lchmod(e, t, n) {
                  (n = maybeCallback(n)),
                    (t = xe(t, "mode")),
                    ze.open(e, A | T, (e, o) => {
                      e
                        ? n(e)
                        : ze.fchmod(o, t, (e) => {
                            ze.close(o, (t) => {
                              n(W(t, e));
                            });
                          });
                    });
                }
              : void 0,
          lchmodSync:
            void 0 !== w.O_SYMLINK
              ? function lchmodSync(e, t) {
                  const n = ze.openSync(e, A | T);
                  let o;
                  try {
                    o = ze.fchmodSync(n, t);
                  } finally {
                    ze.closeSync(n);
                  }
                  return o;
                }
              : void 0,
          link: function link(e, t, n) {
            (n = makeCallback(n)),
              (e = re(e, "existingPath")),
              (t = re(t, "newPath"));
            const o = new V();
            (o.oncomplete = n),
              I.link(x.toNamespacedPath(e), x.toNamespacedPath(t), o);
          },
          linkSync: function linkSync(e, t) {
            const n = {
                path: (e = re(e, "existingPath")),
                dest: (t = re(t, "newPath")),
              },
              o = I.link(
                x.toNamespacedPath(e),
                x.toNamespacedPath(t),
                void 0,
                n
              );
            return se(n), o;
          },
          lstat: function lstat(e, t = { bigint: !1 }, n) {
            "function" == typeof t && ((n = t), (t = H)),
              (n = makeStatsCallback(n)),
              (e = re(e));
            const o = new V(t.bigint);
            (o.oncomplete = n), I.lstat(x.toNamespacedPath(e), t.bigint, o);
          },
          lstatSync: function lstatSync(
            e,
            t = { bigint: !1, throwIfNoEntry: !0 }
          ) {
            const n = { path: (e = re(e)) },
              o = I.lstat(x.toNamespacedPath(e), t.bigint, void 0, n);
            if (!1 !== t.throwIfNoEntry || !hasNoEntryError(n))
              return se(n), pe(o);
          },
          lutimes: function lutimes(e, t, n, o) {
            (o = makeCallback(o)), (e = re(e));
            const a = new V();
            (a.oncomplete = o),
              I.lutimes(x.toNamespacedPath(e), ge(t), ge(n), a);
          },
          lutimesSync: function lutimesSync(e, t, n) {
            const o = { path: (e = re(e)) };
            I.lutimes(x.toNamespacedPath(e), ge(t), ge(n), void 0, o), se(o);
          },
          mkdir: function mkdir(e, t, n) {
            let o = 511,
              a = !1;
            "function" == typeof t
              ? (n = t)
              : "number" == typeof t || "string" == typeof t
              ? (o = t)
              : t &&
                (void 0 !== t.recursive && (a = t.recursive),
                void 0 !== t.mode && (o = t.mode)),
              (n = makeCallback(n)),
              (e = re(e)),
              Ee(a, "options.recursive");
            const c = new V();
            (c.oncomplete = n),
              I.mkdir(x.toNamespacedPath(e), xe(o, "mode"), a, c);
          },
          mkdirSync: function mkdirSync(e, t) {
            let n = 511,
              o = !1;
            "number" == typeof t || "string" == typeof t
              ? (n = t)
              : t &&
                (void 0 !== t.recursive && (o = t.recursive),
                void 0 !== t.mode && (n = t.mode)),
              (e = re(e)),
              Ee(o, "options.recursive");
            const a = { path: e },
              c = I.mkdir(x.toNamespacedPath(e), xe(n, "mode"), o, void 0, a);
            if ((se(a), o)) return c;
          },
          mkdtemp: function mkdtemp(e, t, n) {
            let o;
            (n = makeCallback("function" == typeof t ? t : n)),
              (t = ce(t)),
              (e = re(e, "prefix")),
              Re(e),
              (o =
                "string" == typeof e
                  ? `${e}XXXXXX`
                  : X.concat([e, X.from("XXXXXX")]));
            const a = new V();
            (a.oncomplete = n), I.mkdtemp(o, t.encoding, a);
          },
          mkdtempSync: function mkdtempSync(e, t) {
            let n;
            (t = ce(t)),
              (e = re(e, "prefix")),
              Re(e),
              (n =
                "string" == typeof e
                  ? `${e}XXXXXX`
                  : X.concat([e, X.from("XXXXXX")]));
            const o = { path: n },
              a = I.mkdtemp(n, t.encoding, void 0, o);
            return se(o), a;
          },
          open: function open(e, t, n, o) {
            (e = re(e)),
              arguments.length < 3
                ? ((o = t), (t = "r"), (n = 438))
                : "function" == typeof n
                ? ((o = n), (n = 438))
                : (n = xe(n, "mode", 438));
            const a = ye(t);
            o = makeCallback(o);
            const c = new V();
            (c.oncomplete = o), I.open(x.toNamespacedPath(e), a, n, c);
          },
          openSync: function openSync(e, t, n) {
            e = re(e);
            const o = ye(t);
            n = xe(n, "mode", 438);
            const a = { path: e },
              c = I.open(x.toNamespacedPath(e), o, n, void 0, a);
            return se(a), c;
          },
          readdir: function readdir(e, t, n) {
            if (
              ((n = makeCallback("function" == typeof t ? t : n)),
              (t = ce(t)),
              (e = re(e)),
              null != t.recursive && Ee(t.recursive, "options.recursive"),
              t.recursive)
            )
              return void n(null, readdirSyncRecursive(e, t));
            const o = new V();
            t.withFileTypes
              ? (o.oncomplete = (t, o) => {
                  t ? n(t) : ae(e, o, n);
                })
              : (o.oncomplete = n),
              I.readdir(
                x.toNamespacedPath(e),
                t.encoding,
                !!t.withFileTypes,
                o
              );
          },
          readdirSync: function readdirSync(e, t) {
            if (
              ((t = ce(t)),
              (e = re(e)),
              null != t.recursive && Ee(t.recursive, "options.recursive"),
              t.recursive)
            )
              return readdirSyncRecursive(e, t);
            const n = { path: e },
              o = I.readdir(
                x.toNamespacedPath(e),
                t.encoding,
                !!t.withFileTypes,
                void 0,
                n
              );
            return se(n), t.withFileTypes ? ae(e, o) : o;
          },
          read: read,
          readSync: function readSync(e, t, n, o, a) {
            if (((e = ie(e)), Ie(t), arguments.length <= 3)) {
              const e = n || H;
              ({
                offset: n = 0,
                length: o = t.byteLength - n,
                position: a = null,
              } = e);
            }
            if ((null == n ? (n = 0) : Be(n, "offset", 0), 0 === (o |= 0)))
              return 0;
            if (0 === t.byteLength)
              throw new D("buffer", t, "is empty and cannot be written");
            ve(n, o, t.byteLength), null == a && (a = -1), Pe(a, "position");
            const c = {},
              i = I.read(e, t, n, o, a, void 0, c);
            return se(c), i;
          },
          readv: readv,
          readvSync: function readvSync(e, t, n) {
            (e = ie(e)), Se(t);
            const o = {};
            "number" != typeof n && (n = null);
            const a = I.readBuffers(e, t, n, void 0, o);
            return se(o), a;
          },
          readFile: function readFile(e, n, a) {
            (a = maybeCallback(a || n)), (n = ce(n, { flag: "r" }));
            const c = new (t("internal/fs/read_file_context"))(a, n.encoding);
            if (
              ((c.isUserFd = tt(e)),
              n.signal && (c.signal = n.signal),
              c.isUserFd)
            )
              return void o.nextTick(function tick(t) {
                m(readFileAfterOpen, { context: t }, [null, e]);
              }, c);
            if (checkAborted(n.signal, a)) return;
            const i = ye(n.flag, "options.flag");
            e = re(e);
            const r = new V();
            (r.context = c),
              (r.oncomplete = readFileAfterOpen),
              I.open(x.toNamespacedPath(e), i, 438, r);
          },
          readFileSync: function readFileSync(e, t) {
            t = ce(t, { flag: "r" });
            const n = tt(e),
              o = n ? e : ze.openSync(e, t.flag, 438),
              a = (function tryStatSync(e, t) {
                const n = {},
                  o = I.fstat(e, !1, void 0, n);
                if (void 0 !== n.errno && !t) throw (ze.closeSync(e), M(n));
                return o;
              })(o, n),
              c = isFileType(a, F) ? a[8] : 0;
            let r,
              l,
              s,
              f = 0;
            if (
              (0 === c
                ? (l = [])
                : (r = (function tryCreateBuffer(e, t, n) {
                    let o,
                      a = !0;
                    try {
                      if (e > J) throw new B(e);
                      (o = X.allocUnsafe(e)), (a = !1);
                    } finally {
                      a && !n && ze.closeSync(t);
                    }
                    return o;
                  })(c, o, n)),
              0 !== c)
            )
              do {
                (s = tryReadSync(o, n, r, f, c - f)), (f += s);
              } while (0 !== s && f < c);
            else
              do {
                (r = X.allocUnsafe(8192)),
                  (s = tryReadSync(o, n, r, 0, 8192)),
                  0 !== s && i(l, r.slice(0, s)),
                  (f += s);
              } while (0 !== s);
            return (
              n || ze.closeSync(o),
              0 === c ? (r = X.concat(l, f)) : f < c && (r = r.slice(0, f)),
              t.encoding && (r = r.toString(t.encoding)),
              r
            );
          },
          readlink: function readlink(e, t, n) {
            (n = makeCallback("function" == typeof t ? t : n)),
              (t = ce(t)),
              (e = re(e, "oldPath"));
            const o = new V();
            (o.oncomplete = n),
              I.readlink(x.toNamespacedPath(e), t.encoding, o);
          },
          readlinkSync: function readlinkSync(e, t) {
            t = ce(t);
            const n = { path: (e = re(e, "oldPath")) },
              o = I.readlink(x.toNamespacedPath(e), t.encoding, void 0, n);
            return se(n), o;
          },
          realpath: realpath,
          realpathSync: realpathSync,
          rename: function rename(e, t, n) {
            (n = makeCallback(n)),
              (e = re(e, "oldPath")),
              (t = re(t, "newPath"));
            const o = new V();
            (o.oncomplete = n),
              I.rename(x.toNamespacedPath(e), x.toNamespacedPath(t), o);
          },
          renameSync: function renameSync(e, t) {
            const n = {
              path: (e = re(e, "oldPath")),
              dest: (t = re(t, "newPath")),
            };
            I.rename(x.toNamespacedPath(e), x.toNamespacedPath(t), void 0, n),
              se(n);
          },
          rm: function rm(e, t, n) {
            "function" == typeof t && ((n = t), (t = void 0)),
              (e = re(e)),
              _e(e, t, !1, (t, o) =>
                t ? n(t) : (lazyLoadRimraf(), je(x.toNamespacedPath(e), o, n))
              );
          },
          rmSync: function rmSync(e, t) {
            return (
              (e = re(e)),
              (t = Fe(e, t, !1)),
              lazyLoadRimraf(),
              $e(x.toNamespacedPath(e), t)
            );
          },
          rmdir: function rmdir(e, t, n) {
            if (
              ("function" == typeof t && ((n = t), (t = void 0)),
              (n = makeCallback(n)),
              (e = x.toNamespacedPath(re(e))),
              !t?.recursive)
            ) {
              Ne(t);
              const o = new V();
              return (o.oncomplete = n), I.rmdir(e, o);
            }
            ne(),
              _e(e, { ...t, force: !1 }, !0, (t, o) => {
                if (!1 === t) {
                  const t = new V();
                  return (t.oncomplete = n), I.rmdir(e, t);
                }
                if (t) return n(t);
                lazyLoadRimraf(), je(e, o, n);
              });
          },
          rmdirSync: function rmdirSync(e, t) {
            if (((e = re(e)), t?.recursive)) {
              if ((ne(), !1 !== (t = Fe(e, { ...t, force: !1 }, !0))))
                return lazyLoadRimraf(), $e(x.toNamespacedPath(e), t);
            } else Ne(t);
            const n = { path: e };
            return I.rmdir(x.toNamespacedPath(e), void 0, n), se(n);
          },
          stat: stat,
          statfs: function statfs(e, t = { bigint: !1 }, n) {
            "function" == typeof t && ((n = t), (t = H)),
              (n = maybeCallback(n)),
              (e = re(e));
            const o = new V(t.bigint);
            (o.oncomplete = (e, t) => {
              if (e) return n(e);
              n(e, de(t));
            }),
              I.statfs(x.toNamespacedPath(e), t.bigint, o);
          },
          statSync: statSync,
          statfsSync: function statfsSync(e, t = { bigint: !1 }) {
            const n = { path: (e = re(e)) },
              o = I.statfs(x.toNamespacedPath(e), t.bigint, void 0, n);
            return se(n), de(o);
          },
          symlink: function symlink(e, t, n, o) {
            const a = "string" == typeof n ? n : null,
              c = makeCallback(arguments[arguments.length - 1]);
            if (((e = re(e, "target")), (t = re(t)), Je && null === a)) {
              let n;
              try {
                n = x.resolve(t, "..", e);
              } catch {}
              if (void 0 !== n)
                return void stat(n, (n, o) => {
                  const a = !n && o.isDirectory() ? "dir" : "file",
                    i = he(a),
                    r = fe(e, a, t),
                    l = new V();
                  (l.oncomplete = c), I.symlink(r, x.toNamespacedPath(t), i, l);
                });
            }
            const i = fe(e, a, t),
              r = he(a),
              l = new V();
            (l.oncomplete = c), I.symlink(i, x.toNamespacedPath(t), r, l);
          },
          symlinkSync: function symlinkSync(e, t, n) {
            if (((n = "string" == typeof n ? n : null), Je && null === n)) {
              const o = x.resolve(`${t}`, "..", `${e}`);
              statSync(o, { throwIfNoEntry: !1 })?.isDirectory() && (n = "dir");
            }
            (e = re(e, "target")), (t = re(t));
            const o = he(n),
              a = { path: e, dest: t };
            I.symlink(fe(e, n, t), x.toNamespacedPath(t), o, void 0, a), se(a);
          },
          truncate: function truncate(e, t, n) {
            if ("number" == typeof e)
              return showTruncateDeprecation(), ze.ftruncate(e, t, n);
            "function" == typeof t
              ? ((n = t), (t = 0))
              : void 0 === t && (t = 0),
              Be(t, "len"),
              (t = s(0, t)),
              (n = maybeCallback(n)),
              ze.open(e, "r+", (e, o) => {
                if (e) return n(e);
                const a = new V();
                (a.oncomplete = function oncomplete(e) {
                  ze.close(o, (t) => {
                    n(W(t, e));
                  });
                }),
                  I.ftruncate(o, t, a);
              });
          },
          truncateSync: function truncateSync(e, t) {
            if ("number" == typeof e)
              return showTruncateDeprecation(), ze.ftruncateSync(e, t);
            void 0 === t && (t = 0);
            const n = ze.openSync(e, "r+");
            let o;
            try {
              o = ze.ftruncateSync(n, t);
            } finally {
              ze.closeSync(n);
            }
            return o;
          },
          unwatchFile: function unwatchFile(e, n) {
            (e = re(e)), (e = x.resolve(e));
            const o = nt.get(e);
            if (void 0 === o) return;
            const a = t("internal/fs/watchers");
            if ("function" == typeof n) {
              const e = o.listenerCount("change");
              o.removeListener("change", n),
                o.listenerCount("change") < e &&
                  o[a.kFSStatWatcherAddOrCleanRef]("clean");
            } else
              o.removeAllListeners("change"),
                o[a.kFSStatWatcherAddOrCleanRef]("cleanAll");
            0 === o.listenerCount("change") && (o.stop(), nt.delete(e));
          },
          unlink: function unlink(e, t) {
            (t = makeCallback(t)), (e = re(e));
            const n = new V();
            (n.oncomplete = t), I.unlink(x.toNamespacedPath(e), n);
          },
          unlinkSync: function unlinkSync(e) {
            const t = { path: (e = re(e)) };
            I.unlink(x.toNamespacedPath(e), void 0, t), se(t);
          },
          utimes: function utimes(e, t, n, o) {
            (o = makeCallback(o)), (e = re(e));
            const a = new V();
            (a.oncomplete = o),
              I.utimes(x.toNamespacedPath(e), ge(t), ge(n), a);
          },
          utimesSync: function utimesSync(e, t, n) {
            const o = { path: (e = re(e)) };
            I.utimes(x.toNamespacedPath(e), ge(t), ge(n), void 0, o), se(o);
          },
          watch: function watch(e, n, a) {
            if (
              ("function" == typeof n && (a = n),
              (n = ce(n)),
              void 0 === (n = ee(n)).persistent && (n.persistent = !0),
              void 0 === n.recursive && (n.recursive = !1),
              n.recursive && !Qe && !Je)
            )
              throw new z("watch recursively");
            const c = t("internal/fs/watchers"),
              i = new c.FSWatcher();
            if (
              (i[c.kFSWatchStart](e, n.persistent, n.recursive, n.encoding),
              a && i.addListener("change", a),
              n.signal)
            )
              if (n.signal.aborted) o.nextTick(() => i.close());
              else {
                const listener2 = () => i.close();
                (Ge ??= t("internal/event_target").kResistStopPropagation),
                  n.signal.addEventListener("abort", listener2, {
                    __proto__: null,
                    [Ge]: !0,
                  }),
                  i.once("close", () => {
                    n.signal.removeEventListener("abort", listener2);
                  });
              }
            return i;
          },
          watchFile: function watchFile(e, n, o) {
            let a;
            (e = re(e)),
              (e = x.resolve(e)),
              (null !== n && "object" == typeof n) || ((o = n), (n = null)),
              (n = { interval: 5007, persistent: !0, ...n }),
              We(o, "listener"),
              (a = nt.get(e));
            const c = t("internal/fs/watchers");
            return (
              void 0 === a
                ? ((a = new c.StatWatcher(n.bigint)),
                  a[c.kFSStatWatcherStart](e, n.persistent, n.interval),
                  nt.set(e, a))
                : a[c.kFSStatWatcherAddOrCleanRef]("add"),
              a.addListener("change", o),
              a
            );
          },
          writeFile: function writeFile(e, t, n, o) {
            o = maybeCallback(o || n);
            const a =
              (n = ce(n, { encoding: "utf8", mode: 438, flag: "w" })).flag ||
              "w";
            if (
              (E(t) ||
                (Ce(t, "data"),
                "string" != typeof t && et(),
                (t = X.from(g(t), n.encoding || "utf8"))),
              tt(e))
            ) {
              const a = !0,
                c = n.signal;
              writeAll(e, a, t, 0, t.byteLength, c, o);
            } else
              checkAborted(n.signal, o) ||
                ze.open(e, a, n.mode, (e, a) => {
                  if (e) o(e);
                  else {
                    const e = !1,
                      c = n.signal;
                    writeAll(a, e, t, 0, t.byteLength, c, o);
                  }
                });
          },
          writeFileSync: function writeFileSync(e, t, n) {
            (n = ce(n, { encoding: "utf8", mode: 438, flag: "w" })),
              E(t) ||
                (Ce(t, "data"),
                "string" != typeof t && et(),
                (t = X.from(g(t), n.encoding || "utf8")));
            const o = n.flag || "w",
              a = tt(e),
              c = a ? e : ze.openSync(e, o, n.mode);
            let i = 0,
              r = t.byteLength;
            try {
              for (; r > 0; ) {
                const e = ze.writeSync(c, t, i, r);
                (i += e), (r -= e);
              }
            } finally {
              a || ze.closeSync(c);
            }
          },
          write: write,
          writeSync: function writeSync(e, t, n, o, a) {
            e = ie(e);
            const c = {};
            let i,
              r = n;
            return (
              E(t)
                ? ("object" == typeof r &&
                    ({
                      offset: r = 0,
                      length: o = t.byteLength - r,
                      position: a = null,
                    } = n ?? H),
                  void 0 === a && (a = null),
                  null == r ? (r = 0) : Be(r, "offset", 0),
                  "number" != typeof o && (o = t.byteLength - r),
                  we(r, o, t.byteLength),
                  (i = I.writeBuffer(e, t, r, o, a, void 0, c)))
                : (Le(t, "buffer"),
                  Xe(t, o),
                  void 0 === r && (r = null),
                  (i = I.writeString(e, t, r, o, void 0, c))),
              se(c),
              i
            );
          },
          writev: writev,
          writevSync: function writevSync(e, t, n) {
            if (((e = ie(e)), Se(t), 0 === t.length)) return 0;
            const o = {};
            "number" != typeof n && (n = null);
            const a = I.writeBuffers(e, t, n, void 0, o);
            return se(o), a;
          },
          Dirent: te,
          Stats: ue,
          get ReadStream() {
            return lazyLoadStreams(), Me;
          },
          set ReadStream(e) {
            Me = e;
          },
          get WriteStream() {
            return lazyLoadStreams(), Ve;
          },
          set WriteStream(e) {
            Ve = e;
          },
          get FileReadStream() {
            return lazyLoadStreams(), He;
          },
          set FileReadStream(e) {
            He = e;
          },
          get FileWriteStream() {
            return lazyLoadStreams(), Ye;
          },
          set FileWriteStream(e) {
            Ye = e;
          },
          _toUnixTimestamp: ge,
        }),
      Z(ze, "internal/fs/dir", ["Dir", "opendir", "opendirSync"]),
      u(ze, {
        F_OK: { __proto__: null, enumerable: !0, value: C || 0 },
        R_OK: { __proto__: null, enumerable: !0, value: L || 0 },
        W_OK: { __proto__: null, enumerable: !0, value: R || 0 },
        X_OK: { __proto__: null, enumerable: !0, value: O || 0 },
        constants: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: w,
        },
        promises: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get: () => ((Ze ??= t("internal/fs/promises").exports), Ze),
        },
      });
  },
  "fs/promises": function (s, t, e, r, i, n) {
    "use strict";
    e.exports = t("internal/fs/promises").exports;
  },
  http: function (e, t, r, n, a, o) {
    "use strict";
    const {
        ArrayPrototypeSlice: s,
        ArrayPrototypeSort: i,
        ObjectDefineProperty: l,
      } = o,
      { validateInteger: g } = t("internal/validators"),
      u = t("_http_agent"),
      { ClientRequest: _ } = t("_http_client"),
      { methods: c, parsers: p } = t("_http_common"),
      { IncomingMessage: d } = t("_http_incoming"),
      {
        validateHeaderName: S,
        validateHeaderValue: m,
        OutgoingMessage: v,
      } = t("_http_outgoing"),
      {
        _connectionListener: h,
        STATUS_CODES: A,
        Server: b,
        ServerResponse: f,
      } = t("_http_server");
    let x;
    function request(e, t, r) {
      return new _(e, t, r);
    }
    (r.exports = {
      _connectionListener: h,
      METHODS: i(s(c)),
      STATUS_CODES: A,
      Agent: u.Agent,
      ClientRequest: _,
      IncomingMessage: d,
      OutgoingMessage: v,
      Server: b,
      ServerResponse: f,
      createServer: function createServer(e, t) {
        return new b(e, t);
      },
      validateHeaderName: S,
      validateHeaderValue: m,
      get: function get(e, t, r) {
        const n = request(e, t, r);
        return n.end(), n;
      },
      request: request,
      setMaxIdleHTTPParsers(e) {
        g(e, "max", 1), (p.max = e);
      },
    }),
      l(r.exports, "maxHeaderSize", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get() {
          if (void 0 === x) {
            const { getOptionValue: e } = t("internal/options");
            x = e("--max-http-header-size");
          }
          return x;
        },
      }),
      l(r.exports, "globalAgent", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: () => u.globalAgent,
        set(e) {
          u.globalAgent = e;
        },
      });
  },
  http2: function (e, t, r, s, n, c) {
    "use strict";
    const {
      connect: S,
      constants: a,
      createServer: i,
      createSecureServer: g,
      getDefaultSettings: o,
      getPackedSettings: p,
      getUnpackedSettings: v,
      sensitiveHeaders: u,
      Http2ServerRequest: d,
      Http2ServerResponse: H,
    } = t("internal/http2/core");
    r.exports = {
      connect: S,
      constants: a,
      createServer: i,
      createSecureServer: g,
      getDefaultSettings: o,
      getPackedSettings: p,
      getUnpackedSettings: v,
      sensitiveHeaders: u,
      Http2ServerRequest: d,
      Http2ServerResponse: H,
    };
  },
  https: function (e, t, s, n, o, r) {
    "use strict";
    const {
        ArrayPrototypeIndexOf: i,
        ArrayPrototypePush: c,
        ArrayPrototypeShift: p,
        ArrayPrototypeSplice: a,
        ArrayPrototypeUnshift: h,
        FunctionPrototypeCall: l,
        JSONStringify: u,
        ObjectAssign: y,
        ObjectSetPrototypeOf: g,
        ReflectApply: f,
        ReflectConstruct: d,
      } = r,
      { assertCrypto: C, kEmptyObject: S } = t("internal/util");
    C();
    const v = t("tls"),
      { Agent: _ } = t("_http_agent"),
      {
        httpServerPreClose: m,
        Server: A,
        setupConnectionsTracking: P,
        storeHTTPOptions: x,
        _connectionListener: O,
      } = t("_http_server"),
      { ClientRequest: b } = t("_http_client");
    let j = t("internal/util/debuglog").debuglog("https", (e) => {
      j = e;
    });
    const { URL: K, urlToHttpOptions: I, isURL: L } = t("internal/url");
    function Server(e, t) {
      if (!(this instanceof Server)) return new Server(e, t);
      "function" == typeof e && ((t = e), (e = void 0)),
        (e = { ...e }).ALPNProtocols || (e.ALPNProtocols = ["http/1.1"]),
        l(x, this, e),
        l(v.Server, this, e, O),
        (this.httpAllowHalfOpen = !1),
        t && this.addListener("request", t),
        this.addListener("tlsClientError", function addListener(e, t) {
          this.emit("clientError", e, t) || t.destroy(e);
        }),
        (this.timeout = 0),
        (this.maxHeadersCount = null),
        this.on("listening", P);
    }
    function Agent(e) {
      if (!(this instanceof Agent)) return new Agent(e);
      l(_, this, e),
        (this.defaultPort = 443),
        (this.protocol = "https:"),
        (this.maxCachedSessions = this.options.maxCachedSessions),
        void 0 === this.maxCachedSessions && (this.maxCachedSessions = 100),
        (this._sessionCache = { map: {}, list: [] });
    }
    g(Server.prototype, v.Server.prototype),
      g(Server, v.Server),
      (Server.prototype.closeAllConnections = A.prototype.closeAllConnections),
      (Server.prototype.closeIdleConnections =
        A.prototype.closeIdleConnections),
      (Server.prototype.setTimeout = A.prototype.setTimeout),
      (Server.prototype.close = function () {
        m(this), f(v.Server.prototype.close, this, arguments);
      }),
      g(Agent.prototype, _.prototype),
      g(Agent, _),
      (Agent.prototype.createConnection = function createConnection(e, t, s) {
        if (
          ((s =
            null !== e && "object" == typeof e
              ? e
              : null !== t && "object" == typeof t
              ? { ...t }
              : null === s || "object" != typeof s
              ? {}
              : { ...s }),
          "number" == typeof e && (s.port = e),
          "string" == typeof t && (s.host = t),
          j("createConnection", s),
          s._agentKey)
        ) {
          const e = this._getSession(s._agentKey);
          e &&
            (j("reuse session for %j", s._agentKey),
            (s = { session: e, ...s }));
        }
        const n = v.connect(s);
        return (
          s._agentKey &&
            (n.on("session", (e) => {
              this._cacheSession(s._agentKey, e);
            }),
            n.once("close", (e) => {
              e && this._evictSession(s._agentKey);
            })),
          n
        );
      }),
      (Agent.prototype.getName = function getName(e = S) {
        let t = l(_.prototype.getName, this, e);
        return (
          (t += ":"),
          e.ca && (t += e.ca),
          (t += ":"),
          e.cert && (t += e.cert),
          (t += ":"),
          e.clientCertEngine && (t += e.clientCertEngine),
          (t += ":"),
          e.ciphers && (t += e.ciphers),
          (t += ":"),
          e.key && (t += e.key),
          (t += ":"),
          e.pfx && (t += e.pfx),
          (t += ":"),
          void 0 !== e.rejectUnauthorized && (t += e.rejectUnauthorized),
          (t += ":"),
          e.servername && e.servername !== e.host && (t += e.servername),
          (t += ":"),
          e.minVersion && (t += e.minVersion),
          (t += ":"),
          e.maxVersion && (t += e.maxVersion),
          (t += ":"),
          e.secureProtocol && (t += e.secureProtocol),
          (t += ":"),
          e.crl && (t += e.crl),
          (t += ":"),
          void 0 !== e.honorCipherOrder && (t += e.honorCipherOrder),
          (t += ":"),
          e.ecdhCurve && (t += e.ecdhCurve),
          (t += ":"),
          e.dhparam && (t += e.dhparam),
          (t += ":"),
          void 0 !== e.secureOptions && (t += e.secureOptions),
          (t += ":"),
          e.sessionIdContext && (t += e.sessionIdContext),
          (t += ":"),
          e.sigalgs && (t += u(e.sigalgs)),
          (t += ":"),
          e.privateKeyIdentifier && (t += e.privateKeyIdentifier),
          (t += ":"),
          e.privateKeyEngine && (t += e.privateKeyEngine),
          t
        );
      }),
      (Agent.prototype._getSession = function _getSession(e) {
        return this._sessionCache.map[e];
      }),
      (Agent.prototype._cacheSession = function _cacheSession(e, t) {
        if (0 !== this.maxCachedSessions)
          if (this._sessionCache.map[e]) this._sessionCache.map[e] = t;
          else {
            if (this._sessionCache.list.length >= this.maxCachedSessions) {
              const e = p(this._sessionCache.list);
              j("evicting %j", e), delete this._sessionCache.map[e];
            }
            c(this._sessionCache.list, e), (this._sessionCache.map[e] = t);
          }
      }),
      (Agent.prototype._evictSession = function _evictSession(e) {
        const t = i(this._sessionCache.list, e);
        -1 !== t &&
          (a(this._sessionCache.list, t, 1), delete this._sessionCache.map[e]);
      });
    const E = new Agent();
    function request(...e) {
      let t = {};
      if ("string" == typeof e[0]) {
        const s = p(e);
        t = I(new K(s));
      } else L(e[0]) && (t = I(p(e)));
      return (
        e[0] && "function" != typeof e[0] && y(t, p(e)),
        (t._defaultAgent = s.exports.globalAgent),
        h(e, t),
        d(b, e)
      );
    }
    s.exports = {
      Agent: Agent,
      globalAgent: E,
      Server: Server,
      createServer: function createServer(e, t) {
        return new Server(e, t);
      },
      get: function get(e, t, s) {
        const n = request(e, t, s);
        return n.end(), n;
      },
      request: request,
    };
  },
  inspector: function (e, t, n, s, i, o) {
    "use strict";
    const { JSONParse: r, JSONStringify: c, SafeMap: a, Symbol: h } = o,
      {
        ERR_INSPECTOR_ALREADY_ACTIVATED: l,
        ERR_INSPECTOR_ALREADY_CONNECTED: E,
        ERR_INSPECTOR_CLOSED: _,
        ERR_INSPECTOR_COMMAND: d,
        ERR_INSPECTOR_NOT_AVAILABLE: R,
        ERR_INSPECTOR_NOT_CONNECTED: u,
        ERR_INSPECTOR_NOT_ACTIVE: T,
        ERR_INSPECTOR_NOT_WORKER: f,
      } = t("internal/errors").codes,
      { hasInspector: p } = i("config");
    if (!p) throw new R();
    const w = t("events"),
      { queueMicrotask: N } = t("internal/process/task_queues"),
      {
        isUint32: O,
        validateFunction: C,
        validateInt32: S,
        validateObject: g,
        validateString: I,
      } = t("internal/validators"),
      { isMainThread: m } = t("worker_threads"),
      { _debugEnd: A } = i("process_methods"),
      {
        Connection: D,
        MainThreadConnection: P,
        open: b,
        url: M,
        isEnabled: v,
        waitForDebugger: k,
        console: y,
      } = i("inspector"),
      F = h("connectionProperty"),
      L = h("messageCallbacks"),
      x = h("nextId"),
      V = h("onMessage");
    n.exports = {
      open: function inspectorOpen(e, t, n) {
        if (v()) throw new l();
        O(e) && S(e, "port", 0, 65535), b(e, t), n && k();
      },
      close: A,
      url: M,
      waitForDebugger: function inspectorWaitForDebugger() {
        if (!k()) throw new T();
      },
      console: y,
      Session: class Session extends w {
        constructor() {
          super(), (this[F] = null), (this[x] = 1), (this[L] = new a());
        }
        connect() {
          if (this[F]) throw new E("The inspector session");
          this[F] = new D((e) => this[V](e));
        }
        connectToMainThread() {
          if (m) throw new f();
          if (this[F]) throw new E("The inspector session");
          this[F] = new P((e) => N(() => this[V](e)));
        }
        [V](e) {
          const t = r(e);
          try {
            if (t.id) {
              const e = this[L].get(t.id);
              if ((this[L].delete(t.id), e)) {
                if (t.error) return e(new d(t.error.code, t.error.message));
                e(null, t.result);
              }
            } else
              this.emit(t.method, t), this.emit("inspectorNotification", t);
          } catch (e) {
            s.emitWarning(e);
          }
        }
        post(e, t, n) {
          if (
            (I(e, "method"),
            n || "function" != typeof t || ((n = t), (t = null)),
            t && g(t, "params"),
            n && C(n, "callback"),
            !this[F])
          )
            throw new u();
          const s = this[x]++,
            i = { id: s, method: e };
          t && (i.params = t), n && this[L].set(s, n), this[F].dispatch(c(i));
        }
        disconnect() {
          if (!this[F]) return;
          this[F].disconnect(), (this[F] = null);
          const e = this[L].values();
          for (const t of e) s.nextTick(t, new _());
          this[L].clear(), (this[x] = 1);
        }
      },
    };
  },
  "internal/abort_controller": function (t, e, r, o, n, a) {
    "use strict";
    const {
        ObjectAssign: i,
        ObjectDefineProperties: s,
        ObjectSetPrototypeOf: l,
        ObjectDefineProperty: b,
        PromiseResolve: c,
        SafeFinalizationRegistry: d,
        SafeSet: u,
        Symbol: g,
        SymbolToStringTag: f,
        WeakRef: h,
      } = a,
      {
        defineEventHandler: A,
        EventTarget: p,
        Event: S,
        kTrustEvent: m,
        kNewListener: w,
        kRemoveListener: v,
        kResistStopPropagation: _,
        kWeakHandler: y,
      } = e("internal/event_target"),
      {
        createDeferredPromise: C,
        customInspectSymbol: T,
        kEmptyObject: k,
        kEnumerableProperty: E,
      } = e("internal/util"),
      { inspect: R } = e("internal/util/inspect"),
      {
        codes: {
          ERR_ILLEGAL_CONSTRUCTOR: I,
          ERR_INVALID_ARG_TYPE: z,
          ERR_INVALID_THIS: O,
        },
      } = e("internal/errors"),
      {
        validateAbortSignal: D,
        validateAbortSignalArray: L,
        validateObject: M,
        validateUint32: P,
      } = e("internal/validators"),
      { DOMException: j } = n("messaging"),
      { clearTimeout: N, setTimeout: x } = e("timers"),
      F = e("internal/assert"),
      {
        messaging_deserialize_symbol: H,
        messaging_transfer_symbol: W,
        messaging_transfer_list_symbol: G,
      } = n("symbols");
    let U, V;
    function lazyMakeTransferable(t) {
      return (
        (V ??= e("internal/worker/js_transferable").makeTransferable), V(t)
      );
    }
    const $ = new d(N),
      Y = new u(),
      q = g("kAborted"),
      B = g("kReason"),
      J = g("kCloneData"),
      K = g("kTimeout"),
      Q = g("kMakeTransferable"),
      X = g("kComposite"),
      Z = g("kSourceSignals"),
      tt = g("kDependantSignals");
    function customInspect(t, e, r, o) {
      if (r < 0) return t;
      const n = i({}, o, { depth: null === o.depth ? null : o.depth - 1 });
      return `${t.constructor.name} ${R(e, n)}`;
    }
    function validateThisAbortSignal(t) {
      if (void 0 === t?.[q]) throw new O("AbortSignal");
    }
    class AbortSignal extends p {
      constructor() {
        throw new I();
      }
      get aborted() {
        return validateThisAbortSignal(this), !!this[q];
      }
      get reason() {
        return validateThisAbortSignal(this), this[B];
      }
      throwIfAborted() {
        if ((validateThisAbortSignal(this), this[q])) throw this[B];
      }
      [T](t, e) {
        return customInspect(this, { aborted: this.aborted }, t, e);
      }
      static abort(t = new j("This operation was aborted", "AbortError")) {
        return createAbortSignal({ aborted: !0, reason: t });
      }
      static timeout(t) {
        P(t, "delay", !1);
        const e = createAbortSignal();
        return (
          (e[K] = !0),
          $.register(
            e,
            (function setWeakAbortSignalTimeout(t, e) {
              const r = x(() => {
                const e = t.deref();
                void 0 !== e &&
                  (Y.delete(e),
                  abortSignal(
                    e,
                    new j(
                      "The operation was aborted due to timeout",
                      "TimeoutError"
                    )
                  ));
              }, e);
              return r.unref(), r;
            })(new h(e), t)
          ),
          e
        );
      }
      static any(t) {
        L(t, "signals");
        const e = createAbortSignal({ composite: !0 });
        if (!t.length) return e;
        const r = new h(e);
        e[Z] = new u();
        for (let o = 0; o < t.length; o++) {
          const n = t[o];
          if (n.aborted) return abortSignal(e, n.reason), e;
          if (((n[tt] ??= new u()), n[X])) {
            if (!n[Z]) continue;
            for (const t of n[Z]) {
              const o = t.deref();
              o &&
                (F(!o.aborted),
                F(!o[X]),
                e[Z].has(t) || (e[Z].add(t), o[tt].add(r)));
            }
          } else e[Z].add(new h(n)), n[tt].add(r);
        }
        return e;
      }
      [w](t, e, r, o, n, a, i) {
        super[w](t, e, r, o, n, a, i);
        !(this[K] || (this[X] && this[Z]?.size)) ||
          "abort" !== e ||
          this.aborted ||
          i ||
          1 !== t ||
          Y.add(this);
      }
      [v](t, e, r, o) {
        super[v](t, e, r, o);
        (this[K] || (this[X] && this[Z]?.size)) &&
          "abort" === e &&
          0 === t &&
          Y.delete(this);
      }
      [W]() {
        validateThisAbortSignal(this);
        const t = this.aborted;
        if (t) {
          return {
            data: { aborted: t, reason: this.reason },
            deserializeInfo: "internal/abort_controller:ClonedAbortSignal",
          };
        }
        const { port1: e, port2: r } = this[J];
        return (
          (this[J] = void 0),
          this.addEventListener(
            "abort",
            () => {
              e.postMessage(this.reason), e.close();
            },
            { once: !0 }
          ),
          {
            data: { port: r },
            deserializeInfo: "internal/abort_controller:ClonedAbortSignal",
          }
        );
      }
      [G]() {
        if (!this.aborted) {
          const { port1: t, port2: r } = (function lazyMessageChannel() {
            return (U ??= e("internal/worker/io").MessageChannel), new U();
          })();
          return t.unref(), r.unref(), (this[J] = { port1: t, port2: r }), [r];
        }
        return [];
      }
      [H]({ aborted: t, reason: e, port: r }) {
        if (t) return (this[q] = t), void (this[B] = e);
        (r.onmessage = ({ data: t }) => {
          abortSignal(this, t), r.close(), (r.onmessage = void 0);
        }),
          r.unref();
      }
    }
    function ClonedAbortSignal() {
      return createAbortSignal({ transferable: !0 });
    }
    function createAbortSignal(t = k) {
      const {
          aborted: e = !1,
          reason: r,
          transferable: o = !1,
          composite: n = !1,
        } = t,
        a = new p();
      return (
        l(a, AbortSignal.prototype),
        (a[q] = e),
        (a[B] = r),
        (a[X] = n),
        o ? lazyMakeTransferable(a) : a
      );
    }
    function abortSignal(t, e) {
      if (t[q]) return;
      (t[q] = !0), (t[B] = e);
      const r = new S("abort", { [m]: !0 });
      t.dispatchEvent(r),
        t[tt]?.forEach((t) => {
          const r = t.deref();
          r && abortSignal(r, e);
        });
    }
    (ClonedAbortSignal.prototype[H] = () => {}),
      s(AbortSignal.prototype, { aborted: E }),
      b(AbortSignal.prototype, f, {
        __proto__: null,
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: "AbortSignal",
      }),
      A(AbortSignal.prototype, "abort");
    const et = g("signal");
    function validateAbortController(t) {
      if (void 0 === t?.[et]) throw new O("AbortController");
    }
    class AbortController {
      constructor() {
        this[et] = createAbortSignal();
      }
      get signal() {
        return validateAbortController(this), this[et];
      }
      abort(t = new j("This operation was aborted", "AbortError")) {
        validateAbortController(this), abortSignal(this[et], t);
      }
      [T](t, e) {
        return customInspect(this, { signal: this.signal }, t, e);
      }
      static [Q]() {
        const t = new AbortController();
        return (t[et] = transferableAbortSignal(t[et])), t;
      }
    }
    function transferableAbortSignal(t) {
      if (void 0 === t?.[q]) throw new z("signal", "AbortSignal", t);
      return lazyMakeTransferable(t);
    }
    s(AbortController.prototype, { signal: E, abort: E }),
      b(AbortController.prototype, f, {
        __proto__: null,
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: "AbortController",
      }),
      (r.exports = {
        AbortController: AbortController,
        AbortSignal: AbortSignal,
        ClonedAbortSignal: ClonedAbortSignal,
        aborted: async function aborted(t, e) {
          if (void 0 === t) throw new z("signal", "AbortSignal", t);
          if (
            (D(t, "signal"),
            M(e, "resource", {
              nullable: !1,
              allowFunction: !0,
              allowArray: !0,
            }),
            t.aborted)
          )
            return c();
          const r = C(),
            o = { __proto__: null, [y]: e, once: !0, [_]: !0 };
          return t.addEventListener("abort", r.resolve, o), r.promise;
        },
        transferableAbortSignal: transferableAbortSignal,
        transferableAbortController: function transferableAbortController() {
          return AbortController[Q]();
        },
      });
  },
  "internal/assert": function (r, t, n, e, o, s) {
    "use strict";
    let a;
    function lazyError() {
      return a || (a = t("internal/errors").codes.ERR_INTERNAL_ASSERTION), a;
    }
    function assert(r, t) {
      if (!r) {
        throw new (lazyError())(t);
      }
    }
    (assert.fail = function fail(r) {
      throw new (lazyError())(r);
    }),
      (n.exports = assert);
  },
  "internal/assert/assertion_error": function (e, t, n, l, o, r) {
    "use strict";
    const {
        ArrayPrototypeJoin: s,
        ArrayPrototypePop: i,
        Error: c,
        ErrorCaptureStackTrace: a,
        MathMax: u,
        ObjectCreate: p,
        ObjectDefineProperty: $,
        ObjectGetPrototypeOf: h,
        ObjectKeys: d,
        String: f,
        StringPrototypeEndsWith: g,
        StringPrototypeRepeat: E,
        StringPrototypeSlice: b,
        StringPrototypeSplit: y,
      } = r,
      { inspect: q } = t("internal/util/inspect"),
      { removeColors: x } = t("internal/util"),
      S = t("internal/util/colors"),
      { validateObject: m } = t("internal/validators"),
      { isErrorStackTraceLimitWritable: j } = t("internal/errors"),
      w = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject:
          'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        notDeepStrictEqual:
          'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject:
          'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notIdentical: "Values have same structure but are not reference-equal:",
        notDeepEqualUnequal: "Expected values not to be loosely deep-equal:",
      };
    function copyError(e) {
      const t = d(e),
        n = p(h(e));
      for (const l of t) n[l] = e[l];
      return $(n, "message", { __proto__: null, value: e.message }), n;
    }
    function inspectValue(e) {
      return q(e, {
        compact: !1,
        customInspect: !1,
        depth: 1e3,
        maxArrayLength: 1 / 0,
        showHidden: !1,
        showProxy: !1,
        sorted: !0,
        getters: !0,
      });
    }
    function addEllipsis(e) {
      const t = y(e, "\n", 11);
      return t.length > 10
        ? ((t.length = 10), `${s(t, "\n")}\n...`)
        : e.length > 512
        ? `${b(e, 512)}...`
        : e;
    }
    class AssertionError extends c {
      constructor(e) {
        m(e, "options");
        const {
          message: t,
          operator: n,
          stackStartFn: o,
          details: r,
          stackStartFunction: p,
        } = e;
        let { actual: h, expected: d } = e;
        const O = c.stackTraceLimit;
        if ((j() && (c.stackTraceLimit = 0), null != t)) super(f(t));
        else if (
          (S.refresh(),
          "object" == typeof h &&
            null !== h &&
            "object" == typeof d &&
            null !== d &&
            "stack" in h &&
            h instanceof c &&
            "stack" in d &&
            d instanceof c &&
            ((h = copyError(h)), (d = copyError(d))),
          "deepStrictEqual" === n || "strictEqual" === n)
        )
          super(
            (function createErrDiff(e, t, n) {
              let o = "",
                r = "",
                c = "",
                a = !1;
              const p = inspectValue(e),
                $ = y(p, "\n"),
                h = y(inspectValue(t), "\n");
              let d = 0,
                f = "";
              if (
                ("strictEqual" === n &&
                  (("object" == typeof e &&
                    null !== e &&
                    "object" == typeof t &&
                    null !== t) ||
                    ("function" == typeof e && "function" == typeof t)) &&
                  (n = "strictEqualObject"),
                1 === $.length && 1 === h.length && $[0] !== h[0])
              ) {
                const o = q.defaultOptions.colors,
                  r = o ? x($[0]) : $[0],
                  s = o ? x(h[0]) : h[0],
                  i = r.length + s.length;
                if (i <= 12) {
                  if (
                    !(
                      ("object" == typeof e && null !== e) ||
                      ("object" == typeof t && null !== t) ||
                      (0 === e && 0 === t)
                    )
                  )
                    return `${w[n]}\n\n${$[0]} !== ${h[0]}\n`;
                } else if (
                  "strictEqualObject" !== n &&
                  i < (l.stderr.isTTY ? l.stderr.columns : 80)
                ) {
                  for (; r[d] === s[d]; ) d++;
                  d > 2 && ((f = `\n  ${E(" ", d)}^`), (d = 0));
                }
              }
              let m = $[$.length - 1],
                j = h[h.length - 1];
              for (
                ;
                m === j &&
                (d++ < 3 ? (c = `\n  ${m}${c}`) : (o = m),
                i($),
                i(h),
                0 !== $.length && 0 !== h.length);

              )
                (m = $[$.length - 1]), (j = h[h.length - 1]);
              const O = u($.length, h.length);
              if (0 === O) {
                const e = y(p, "\n");
                if (e.length > 50)
                  for (e[46] = `${S.blue}...${S.white}`; e.length > 47; ) i(e);
                return `${w.notIdentical}\n\n${s(e, "\n")}\n`;
              }
              d >= 5 && ((c = `\n${S.blue}...${S.white}${c}`), (a = !0)),
                "" !== o && ((c = `\n  ${o}${c}`), (o = ""));
              let k = 0,
                v = 0;
              const _ =
                  w[n] +
                  `\n${S.green}+ actual${S.white} ${S.red}- expected${S.white}`,
                P = ` ${S.blue}...${S.white} Lines skipped`;
              let A = $,
                T = `${S.green}+${S.white}`,
                D = h.length;
              for (
                $.length < O &&
                  ((A = h), (T = `${S.red}-${S.white}`), (D = $.length)),
                  d = 0;
                d < O;
                d++
              ) {
                if (D < d + 1)
                  v > 2 &&
                    (v > 3 &&
                      (v > 4 &&
                        (5 === v
                          ? ((r += `\n  ${A[d - 3]}`), k++)
                          : ((r += `\n${S.blue}...${S.white}`), (a = !0))),
                      (r += `\n  ${A[d - 2]}`),
                      k++),
                    (r += `\n  ${A[d - 1]}`),
                    k++),
                    (v = 0),
                    A === $ ? (r += `\n${T} ${A[d]}`) : (o += `\n${T} ${A[d]}`),
                    k++;
                else {
                  const e = h[d];
                  let t = $[d],
                    n = t !== e && (!g(t, ",") || b(t, 0, -1) !== e);
                  n && g(e, ",") && b(e, 0, -1) === t && ((n = !1), (t += ",")),
                    n
                      ? (v > 2 &&
                          (v > 3 &&
                            (v > 4 &&
                              (5 === v
                                ? ((r += `\n  ${$[d - 3]}`), k++)
                                : ((r += `\n${S.blue}...${S.white}`),
                                  (a = !0))),
                            (r += `\n  ${$[d - 2]}`),
                            k++),
                          (r += `\n  ${$[d - 1]}`),
                          k++),
                        (v = 0),
                        (r += `\n${S.green}+${S.white} ${t}`),
                        (o += `\n${S.red}-${S.white} ${e}`),
                        (k += 2))
                      : ((r += o),
                        (o = ""),
                        v++,
                        v <= 2 && ((r += `\n  ${t}`), k++));
                }
                if (k > 50 && d < O - 2)
                  return `${_}${P}\n${r}\n${S.blue}...${S.white}${o}\n${S.blue}...${S.white}`;
              }
              return `${_}${a ? P : ""}\n${r}${o}${c}${f}`;
            })(h, d, n)
          );
        else if ("notDeepStrictEqual" === n || "notStrictEqual" === n) {
          let e = w[n];
          const t = y(inspectValue(h), "\n");
          if (
            ("notStrictEqual" === n &&
              (("object" == typeof h && null !== h) ||
                "function" == typeof h) &&
              (e = w.notStrictEqualObject),
            t.length > 50)
          )
            for (t[46] = `${S.blue}...${S.white}`; t.length > 47; ) i(t);
          1 === t.length
            ? super(`${e}${t[0].length > 5 ? "\n\n" : " "}${t[0]}`)
            : super(`${e}\n\n${s(t, "\n")}\n`);
        } else {
          let e = inspectValue(h),
            t = inspectValue(d);
          const l = w[n];
          if ("notDeepEqual" === n && e === t)
            (e = `${l}\n\n${e}`),
              e.length > 1024 && (e = `${b(e, 0, 1021)}...`),
              super(e);
          else {
            if (
              (e.length > 512 && (e = `${b(e, 0, 509)}...`),
              t.length > 512 && (t = `${b(t, 0, 509)}...`),
              "deepEqual" === n)
            )
              e = `${l}\n\n${e}\n\nshould loosely deep-equal\n\n`;
            else {
              const l = w[`${n}Unequal`];
              l
                ? (e = `${l}\n\n${e}\n\nshould not loosely deep-equal\n\n`)
                : (t = ` ${n} ${t}`);
            }
            super(`${e}${t}`);
          }
        }
        if (
          (j() && (c.stackTraceLimit = O),
          (this.generatedMessage = !t),
          $(this, "name", {
            __proto__: null,
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: !1,
            writable: !0,
            configurable: !0,
          }),
          (this.code = "ERR_ASSERTION"),
          r)
        ) {
          (this.actual = void 0),
            (this.expected = void 0),
            (this.operator = void 0);
          for (let e = 0; e < r.length; e++)
            (this["message " + e] = r[e].message),
              (this["actual " + e] = r[e].actual),
              (this["expected " + e] = r[e].expected),
              (this["operator " + e] = r[e].operator),
              (this["stack trace " + e] = r[e].stack);
        } else (this.actual = h), (this.expected = d), (this.operator = n);
        a(this, o || p), this.stack, (this.name = "AssertionError");
      }
      toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
      }
      [q.custom](e, t) {
        const n = this.actual,
          l = this.expected;
        "string" == typeof this.actual &&
          (this.actual = addEllipsis(this.actual)),
          "string" == typeof this.expected &&
            (this.expected = addEllipsis(this.expected));
        const o = q(this, { ...t, customInspect: !1, depth: 0 });
        return (this.actual = n), (this.expected = l), o;
      }
    }
    n.exports = AssertionError;
  },
  "internal/assert/calltracker": function (e, t, s, r, c, a) {
    "use strict";
    const {
        ArrayPrototypePush: n,
        ArrayPrototypeSlice: l,
        Error: i,
        FunctionPrototype: o,
        ObjectFreeze: h,
        Proxy: d,
        ReflectApply: u,
        SafeSet: p,
        SafeWeakMap: k,
      } = a,
      {
        codes: { ERR_UNAVAILABLE_DURING_EXIT: g, ERR_INVALID_ARG_VALUE: x },
      } = t("internal/errors"),
      f = t("internal/assert/assertion_error"),
      { validateUint32: m } = t("internal/validators"),
      _ = o;
    class CallTrackerContext {
      #e;
      #t;
      #s;
      #r;
      constructor({ expected: e, stackTrace: t, name: s }) {
        (this.#t = []), (this.#e = e), (this.#r = t), (this.#s = s);
      }
      track(e, t) {
        const s = h(l(t));
        n(this.#t, h({ thisArg: e, arguments: s }));
      }
      get delta() {
        return this.#t.length - this.#e;
      }
      reset() {
        this.#t = [];
      }
      getCalls() {
        return h(l(this.#t));
      }
      report() {
        if (0 !== this.delta) {
          return {
            message: `Expected the ${this.#s} function to be executed ${
              this.#e
            } time(s) but was executed ${this.#t.length} time(s).`,
            actual: this.#t.length,
            expected: this.#e,
            operator: this.#s,
            stack: this.#r,
          };
        }
      }
    }
    s.exports = class CallTracker {
      #c = new p();
      #a = new k();
      #n(e) {
        if (!this.#a.has(e))
          throw new x("tracked", e, "is not a tracked function");
        return this.#a.get(e);
      }
      reset(e) {
        void 0 !== e ? this.#n(e).reset() : this.#c.forEach((e) => e.reset());
      }
      getCalls(e) {
        return this.#n(e).getCalls();
      }
      calls(e, t = 1) {
        if (r._exiting) throw new g();
        "number" == typeof e ? ((t = e), (e = _)) : void 0 === e && (e = _),
          m(t, "expected", !0);
        const s = new CallTrackerContext({
            expected: t,
            stackTrace: new i(),
            name: e.name || "calls",
          }),
          c = new d(e, {
            __proto__: null,
            apply: (e, t, r) => (s.track(t, r), u(e, t, r)),
          });
        return this.#c.add(s), this.#a.set(c, s), c;
      }
      report() {
        const e = [];
        for (const t of this.#c) {
          const s = t.report();
          void 0 !== s && n(e, s);
        }
        return e;
      }
      verify() {
        const e = this.report();
        if (0 === e.length) return;
        const t =
          1 === e.length
            ? e[0].message
            : "Functions were not called the expected number of times";
        throw new f({ message: t, details: e });
      }
    };
  },
  "internal/async_hooks": function (o, t, e, n, r, s) {
    "use strict";
    const {
        ArrayPrototypeSlice: i,
        ErrorCaptureStackTrace: c,
        ObjectPrototypeHasOwnProperty: a,
        ObjectDefineProperty: y,
        Symbol: l,
      } = s,
      u = r("async_wrap"),
      { setCallbackTrampoline: k } = u,
      {
        async_hook_fields: f,
        async_id_fields: p,
        execution_async_resources: m,
      } = u,
      {
        pushAsyncContext: d,
        popAsyncContext: _,
        executionAsyncResource: H,
        clearAsyncIdStack: A,
      } = u,
      g = { array: [], call_depth: 0, tmp_array: null, tmp_fields: null },
      { registerDestroyHook: I } = u,
      { enqueueMicrotask: b } = r("task_queue"),
      { resource_symbol: h, owner_symbol: x } = r("symbols"),
      {
        kInit: v,
        kBefore: D,
        kAfter: E,
        kDestroy: T,
        kTotals: P,
        kPromiseResolve: S,
        kCheck: C,
        kExecutionAsyncId: R,
        kAsyncIdCounter: w,
        kTriggerAsyncId: N,
        kDefaultTriggerAsyncId: B,
        kStackLength: O,
        kUsesExecutionAsyncResource: F,
      } = u.constants,
      { async_id_symbol: M, trigger_async_id_symbol: j } = r("symbols");
    let q;
    const W = l("init"),
      V = l("before"),
      L = l("after"),
      U = l("destroy"),
      z = l("promiseResolve"),
      G = emitHookFactory(V, "emitBeforeNative"),
      J = emitHookFactory(L, "emitAfterNative"),
      K = emitHookFactory(U, "emitDestroyNative"),
      Q = emitHookFactory(z, "emitPromiseResolveNative");
    let X;
    function callbackTrampoline(o, t, e, ...n) {
      const r = f[O] - 1;
      let s;
      return (
        (m[r] = t),
        0 !== o && hasHooks(D) && G(o),
        0 === o && "function" == typeof X
          ? (n.unshift(e), (s = X.apply(this, n)))
          : (s = e.apply(this, n)),
        0 !== o && hasHooks(E) && J(o),
        m.pop(),
        s
      );
    }
    const Y = {};
    function fatalError(o) {
      if ("string" == typeof o?.stack) n._rawDebug(o.stack);
      else {
        const e = (function inspectExceptionValue(o) {
          return (q ??= t("internal/util/inspect").inspect), { message: q(o) };
        })(o);
        c(e, fatalError), n._rawDebug(e.stack);
      }
      const { getOptionValue: e } = t("internal/options");
      e("--abort-on-uncaught-exception") && n.abort(), n.exit(1);
    }
    function lookupPublicResource(o) {
      if ("object" != typeof o || null === o) return o;
      const t = o[h];
      return void 0 !== t ? t : o;
    }
    function emitInitNative(o, t, e, n) {
      (g.call_depth += 1), (n = lookupPublicResource(n));
      try {
        for (var r = 0; r < g.array.length; r++)
          "function" == typeof g.array[r][W] && g.array[r][W](o, t, e, n);
      } catch (o) {
        fatalError(o);
      } finally {
        g.call_depth -= 1;
      }
      0 === g.call_depth && null !== g.tmp_array && restoreActiveHooks();
    }
    function emitHook(o, t) {
      g.call_depth += 1;
      try {
        for (var e = 0; e < g.array.length; e++)
          "function" == typeof g.array[e][o] && g.array[e][o](t);
      } catch (o) {
        fatalError(o);
      } finally {
        g.call_depth -= 1;
      }
      0 === g.call_depth && null !== g.tmp_array && restoreActiveHooks();
    }
    function emitHookFactory(o, t) {
      const e = emitHook.bind(void 0, o);
      return y(e, "name", { __proto__: null, value: t }), e;
    }
    function copyHooks(o, t) {
      (o[v] = t[v]), (o[D] = t[D]), (o[E] = t[E]), (o[T] = t[T]), (o[S] = t[S]);
    }
    function restoreActiveHooks() {
      (g.array = g.tmp_array),
        copyHooks(f, g.tmp_fields),
        (g.tmp_array = null),
        (g.tmp_fields = null);
    }
    function trackPromise(o, t) {
      if (o[M]) return;
      const e = t ? getOrSetAsyncId(t) : getDefaultTriggerAsyncId();
      (o[M] = newAsyncId()), (o[j] = e);
    }
    function promiseInitHook(o, t) {
      trackPromise(o, t);
      emitInitScript(o[M], "PROMISE", o[j], o);
    }
    function promiseInitHookWithDestroyTracking(o, t) {
      promiseInitHook(o, t), destroyTracking(o, t);
    }
    function destroyTracking(o, t) {
      trackPromise(o, t);
      const e = o[M];
      I(o, e);
    }
    function promiseBeforeHook(o) {
      trackPromise(o);
      emitBeforeScript(o[M], o[j], o);
    }
    function promiseAfterHook(o) {
      trackPromise(o);
      const t = o[M];
      hasHooks(E) && J(t), t === executionAsyncId() && popAsyncContext(t);
    }
    function promiseResolveHook(o) {
      trackPromise(o);
      const t = o[M];
      Q(t);
    }
    let Z,
      $ = !1;
    function disablePromiseHookIfNecessary() {
      !$ && Z && Z();
    }
    function newAsyncId() {
      return ++p[w];
    }
    function getOrSetAsyncId(o) {
      return a(o, M) ? o[M] : (o[M] = newAsyncId());
    }
    function getDefaultTriggerAsyncId() {
      const o = p[B];
      return o < 0 ? p[R] : o;
    }
    function hasHooks(o) {
      return f[o] > 0;
    }
    function enabledHooksExist() {
      return hasHooks(C);
    }
    function initHooksExist() {
      return hasHooks(v);
    }
    function destroyHooksExist() {
      return hasHooks(T);
    }
    function emitInitScript(o, t, e, n) {
      hasHooks(v) &&
        (null === e && (e = getDefaultTriggerAsyncId()),
        emitInitNative(o, t, e, n));
    }
    function emitBeforeScript(o, t, e) {
      pushAsyncContext(o, t, e), hasHooks(D) && G(o);
    }
    function pushAsyncContext(o, t, e) {
      const n = f[O];
      if (((m[n] = e), 2 * n >= u.async_ids_stack.length)) return d(o, t);
      (u.async_ids_stack[2 * n] = p[R]),
        (u.async_ids_stack[2 * n + 1] = p[N]),
        f[O]++,
        (p[R] = o),
        (p[N] = t);
    }
    function popAsyncContext(o) {
      const t = f[O];
      if (0 === t) return !1;
      if (enabledHooksExist() && p[R] !== o) return _(o);
      const e = t - 1;
      return (
        (p[R] = u.async_ids_stack[2 * e]),
        (p[N] = u.async_ids_stack[2 * e + 1]),
        m.pop(),
        (f[O] = e),
        e > 0
      );
    }
    function executionAsyncId() {
      return p[R];
    }
    e.exports = {
      executionAsyncId: executionAsyncId,
      triggerAsyncId: function triggerAsyncId() {
        return p[N];
      },
      getHookArrays: function getHookArrays() {
        return 0 === g.call_depth
          ? [g.array, f]
          : (null === g.tmp_array &&
              (function storeActiveHooks() {
                (g.tmp_array = i(g.array)),
                  (g.tmp_fields = []),
                  copyHooks(g.tmp_fields, f);
              })(),
            [g.tmp_array, g.tmp_fields]);
      },
      symbols: {
        async_id_symbol: M,
        trigger_async_id_symbol: j,
        init_symbol: W,
        before_symbol: V,
        after_symbol: L,
        destroy_symbol: U,
        promise_resolve_symbol: z,
        owner_symbol: x,
      },
      constants: {
        kInit: v,
        kBefore: D,
        kAfter: E,
        kDestroy: T,
        kTotals: P,
        kPromiseResolve: S,
      },
      enableHooks: function enableHooks() {
        (f[C] += 1), k(callbackTrampoline);
      },
      disableHooks: function disableHooks() {
        (f[C] -= 1), ($ = !1), k(), b(disablePromiseHookIfNecessary);
      },
      updatePromiseHookMode: function updatePromiseHookMode() {
        let o;
        ($ = !0),
          initHooksExist()
            ? (o = destroyHooksExist()
                ? promiseInitHookWithDestroyTracking
                : promiseInitHook)
            : destroyHooksExist() && (o = destroyTracking),
          Z && Z();
        const e = t("internal/promise_hooks");
        Z = e.createHook({
          init: o,
          before: promiseBeforeHook,
          after: promiseAfterHook,
          settled: hasHooks(S) ? promiseResolveHook : void 0,
        });
      },
      clearDefaultTriggerAsyncId: function clearDefaultTriggerAsyncId() {
        p[B] = -1;
      },
      clearAsyncIdStack: A,
      hasAsyncIdStack: function hasAsyncIdStack() {
        return hasHooks(O);
      },
      executionAsyncResource: function executionAsyncResource() {
        f[F] = 1;
        const o = f[O] - 1;
        return -1 === o ? Y : lookupPublicResource(m[o] || H(o));
      },
      newAsyncId: newAsyncId,
      getOrSetAsyncId: getOrSetAsyncId,
      getDefaultTriggerAsyncId: getDefaultTriggerAsyncId,
      defaultTriggerAsyncIdScope: function defaultTriggerAsyncIdScope(
        o,
        t,
        ...e
      ) {
        if (void 0 === o) return t.apply(null, e);
        const n = p[B];
        p[B] = o;
        try {
          return t.apply(null, e);
        } finally {
          p[B] = n;
        }
      },
      enabledHooksExist: enabledHooksExist,
      initHooksExist: initHooksExist,
      afterHooksExist: function afterHooksExist() {
        return hasHooks(E);
      },
      destroyHooksExist: destroyHooksExist,
      emitInit: emitInitScript,
      emitBefore: emitBeforeScript,
      emitAfter: function emitAfterScript(o) {
        hasHooks(E) && J(o), popAsyncContext(o);
      },
      emitDestroy: function emitDestroyScript(o) {
        !hasHooks(T) || o <= 0 || u.queueDestroyAsyncId(o);
      },
      pushAsyncContext: pushAsyncContext,
      popAsyncContext: popAsyncContext,
      registerDestroyHook: I,
      useDomainTrampoline: function useDomainTrampoline(o) {
        X = o;
      },
      nativeHooks: {
        init: emitInitNative,
        before: G,
        after: J,
        destroy: K,
        promise_resolve: Q,
      },
      asyncWrap: { Providers: u.Providers },
    };
  },
  "internal/blob": function (e, t, r, n, i, o) {
    "use strict";
    const {
        ArrayFrom: s,
        MathMax: l,
        MathMin: a,
        ObjectDefineProperties: c,
        ObjectDefineProperty: u,
        PromiseResolve: h,
        PromiseReject: b,
        SafePromisePrototypeFinally: f,
        ReflectConstruct: y,
        RegExpPrototypeExec: p,
        RegExpPrototypeSymbolReplace: B,
        StringPrototypeToLowerCase: d,
        StringPrototypeSplit: w,
        Symbol: R,
        SymbolIterator: m,
        SymbolToStringTag: g,
        Uint8Array: _,
      } = o,
      { createBlob: v, FixedSizeBlobCopyJob: E, getDataObject: S } = i("blob"),
      { TextDecoder: L, TextEncoder: A } = t("internal/encoding"),
      {
        makeTransferable: P,
        kClone: k,
        kDeserialize: z,
      } = t("internal/worker/js_transferable"),
      { isAnyArrayBuffer: I, isArrayBufferView: x } = t("internal/util/types"),
      {
        createDeferredPromise: D,
        customInspectSymbol: O,
        kEmptyObject: T,
        kEnumerableProperty: j,
      } = t("internal/util"),
      { inspect: C } = t("internal/util/inspect"),
      {
        AbortError: U,
        codes: {
          ERR_INVALID_ARG_TYPE: F,
          ERR_INVALID_ARG_VALUE: $,
          ERR_INVALID_THIS: V,
          ERR_BUFFER_TOO_LARGE: M,
        },
      } = t("internal/errors"),
      { isUint32: N, validateDictionary: q } = t("internal/validators"),
      G = R("kHandle"),
      H = R("kState"),
      J = R("kIndex"),
      Y = R("kType"),
      K = R("kLength"),
      Q = R("kArrayBufferPromise"),
      W = 65536,
      X = /[^\u{0020}-\u{007E}]/u;
    let Z, ee;
    const te = new A();
    let re;
    function lazyURL(e) {
      return (ee ??= t("internal/url").URL), new ee(e);
    }
    function lazyReadableStream(e) {
      return (
        (Z ??= t("internal/webstreams/readablestream").ReadableStream), new Z(e)
      );
    }
    const { EOL: ne } = t("internal/constants");
    function isBlob(e) {
      return void 0 !== e?.[G];
    }
    class Blob {
      constructor(e = [], t) {
        if (null === e || "function" != typeof e[m] || "string" == typeof e)
          throw new F("sources", "a sequence", e);
        q(t, "options");
        let { type: r = "", endings: n = "transparent" } = t ?? T;
        if (((n = `${n}`), "transparent" !== n && "native" !== n))
          throw new $("options.endings", n);
        let i = 0;
        const o = s(e, (e) => {
          const { 0: t, 1: r } = (function getSource(e, t) {
            if (isBlob(e)) return [e.size, e[G]];
            I(e)
              ? (e = new _(e))
              : x(e) ||
                ((e = `${e}`),
                "native" === t && (e = B(/\n|\r\n/g, e, ne)),
                (e = te.encode(e)));
            const { buffer: r, byteOffset: n, byteLength: i } = e,
              o = r.slice(n, n + i);
            return [i, new _(o)];
          })(e, n);
          return (i += t), r;
        });
        if (!N(i)) throw new M(4294967295);
        return (
          (this[G] = v(o, i)),
          (this[K] = i),
          (r = `${r}`),
          (this[Y] = null !== p(X, r) ? "" : d(r)),
          P(this)
        );
      }
      [O](e, t) {
        if (e < 0) return this;
        const r = { ...t, depth: null == t.depth ? null : t.depth - 1 };
        return `Blob ${C({ size: this.size, type: this.type }, r)}`;
      }
      [k]() {
        return {
          data: { handle: this[G], type: this[Y], length: this[K] },
          deserializeInfo: "internal/blob:ClonedBlob",
        };
      }
      [z]({ handle: e, type: t, length: r }) {
        (this[G] = e), (this[Y] = t), (this[K] = r);
      }
      get type() {
        if (!isBlob(this)) throw new V("Blob");
        return this[Y];
      }
      get size() {
        if (!isBlob(this)) throw new V("Blob");
        return this[K];
      }
      slice(e = 0, t = this[K], r = "") {
        if (!isBlob(this)) throw new V("Blob");
        (e = e < 0 ? l(this[K] + e, 0) : a(e, this[K])),
          (e |= 0),
          (t = t < 0 ? l(this[K] + t, 0) : a(t, this[K])),
          (t |= 0),
          (r = null !== p(X, (r = `${r}`)) ? "" : d(r));
        const n = l(t - e, 0);
        return createBlob(this[G].slice(e, e + n), n, r);
      }
      arrayBuffer() {
        if (!isBlob(this)) return b(new V("Blob"));
        if (this[Q]) return this[Q];
        const e = new E(this[G]),
          t = e.run();
        if (void 0 !== t) return h(t);
        const { promise: r, resolve: n, reject: i } = D();
        return (
          (e.ondone = (e, t) => {
            if (void 0 !== e) return i(new U(void 0, { cause: e }));
            n(t);
          }),
          (this[Q] = f(r, () => (this[Q] = void 0))),
          this[Q]
        );
      }
      async text() {
        if (!isBlob(this)) throw new V("Blob");
        return (re ??= new L()), re.decode(await this.arrayBuffer());
      }
      stream() {
        if (!isBlob(this)) throw new V("Blob");
        const e = this;
        return new lazyReadableStream({
          async start() {
            (this[H] = await e.arrayBuffer()), (this[J] = 0);
          },
          pull(e) {
            this[H].byteLength - this[J] <= W
              ? (e.enqueue(new _(this[H], this[J])),
                e.close(),
                (this[H] = void 0))
              : (e.enqueue(new _(this[H], this[J], W)), (this[J] += W));
          },
        });
      }
    }
    function ClonedBlob() {
      return P(y(function () {}, [], Blob));
    }
    function createBlob(e, t, r = "") {
      return P(
        y(
          function () {
            (this[G] = e), (this[Y] = r), (this[K] = t);
          },
          [],
          Blob
        )
      );
    }
    (ClonedBlob.prototype[z] = () => {}),
      u(Blob.prototype, g, {
        __proto__: null,
        configurable: !0,
        value: "Blob",
      }),
      c(Blob.prototype, {
        size: j,
        type: j,
        slice: j,
        stream: j,
        text: j,
        arrayBuffer: j,
      }),
      (r.exports = {
        Blob: Blob,
        ClonedBlob: ClonedBlob,
        createBlob: createBlob,
        isBlob: isBlob,
        kHandle: G,
        resolveObjectURL: function resolveObjectURL(e) {
          e = `${e}`;
          try {
            const t = new lazyURL(e),
              r = w(t.pathname, ":");
            if (2 !== r.length) return;
            const { 0: n, 1: i } = r;
            if ("nodedata" !== n) return;
            const o = S(i);
            if (void 0 === o) return;
            const { 0: s, 1: l, 2: a } = o;
            if (void 0 !== s) return createBlob(s, l, a);
          } catch {}
        },
      });
  },
  "internal/blocklist": function (e, t, s, r, i, n) {
    "use strict";
    const { Boolean: l, ObjectSetPrototypeOf: a, Symbol: o } = n,
      { BlockList: d } = i("block_list"),
      { customInspectSymbol: c } = t("internal/util"),
      { SocketAddress: k, kHandle: h } = t("internal/socketaddress"),
      {
        JSTransferable: p,
        kClone: u,
        kDeserialize: f,
      } = t("internal/worker/js_transferable"),
      { inspect: y } = t("internal/util/inspect"),
      m = o("kHandle"),
      { owner_symbol: L } = i("symbols"),
      { ERR_INVALID_ARG_VALUE: B } = t("internal/errors").codes,
      { validateInt32: b, validateString: S } = t("internal/validators");
    class BlockList extends p {
      constructor() {
        super(), (this[m] = new d()), (this[m][L] = this);
      }
      [c](e, t) {
        if (e < 0) return this;
        const s = { ...t, depth: null == t.depth ? null : t.depth - 1 };
        return `BlockList ${y({ rules: this.rules }, s)}`;
      }
      addAddress(e, t = "ipv4") {
        k.isSocketAddress(e) ||
          (S(e, "address"),
          S(t, "family"),
          (e = new k({ address: e, family: t }))),
          this[m].addAddress(e[h]);
      }
      addRange(e, t, s = "ipv4") {
        k.isSocketAddress(e) ||
          (S(e, "start"),
          S(s, "family"),
          (e = new k({ address: e, family: s }))),
          k.isSocketAddress(t) ||
            (S(t, "end"),
            S(s, "family"),
            (t = new k({ address: t, family: s })));
        if (!1 === this[m].addRange(e[h], t[h]))
          throw new B("start", e, "must come before end");
      }
      addSubnet(e, t, s = "ipv4") {
        switch (
          (k.isSocketAddress(e) ||
            (S(e, "network"),
            S(s, "family"),
            (e = new k({ address: e, family: s }))),
          e.family)
        ) {
          case "ipv4":
            b(t, "prefix", 0, 32);
            break;
          case "ipv6":
            b(t, "prefix", 0, 128);
        }
        this[m].addSubnet(e[h], t);
      }
      check(e, t = "ipv4") {
        if (!k.isSocketAddress(e)) {
          S(e, "address"), S(t, "family");
          try {
            e = new k({ address: e, family: t });
          } catch {
            return !1;
          }
        }
        return l(this[m].check(e[h]));
      }
      get rules() {
        return this[m].getRules();
      }
      [u]() {
        return {
          data: { handle: this[m] },
          deserializeInfo: "internal/blocklist:InternalBlockList",
        };
      }
      [f]({ handle: e }) {
        (this[m] = e), (this[m][L] = this);
      }
    }
    class InternalBlockList extends p {
      constructor(e) {
        super(), (this[m] = e), void 0 !== e && (e[L] = this);
      }
    }
    (InternalBlockList.prototype.constructor = BlockList.prototype.constructor),
      a(InternalBlockList.prototype, BlockList.prototype),
      (s.exports = {
        BlockList: BlockList,
        InternalBlockList: InternalBlockList,
      });
  },
  "internal/bootstrap/browser": function (e, t, r, a) {
    "use strict";
    const { ObjectDefineProperty: n, globalThis: o } = a,
      {
        defineOperation: l,
        exposeInterface: s,
        lazyDOMExceptionClass: i,
        defineLazyProperties: c,
        defineReplaceableLazyAttribute: m,
        exposeLazyInterfaces: b,
      } = t("internal/util"),
      u = r("config");
    !(function exposeNamespace(e, t, r) {
      n(e, t, {
        __proto__: null,
        writable: !0,
        enumerable: !1,
        configurable: !0,
        value: r,
      });
    })(
      o,
      "console",
      (function createGlobalConsole() {
        const e = t("internal/console/global");
        if (u.hasInspector) {
          const a = t("internal/util/inspector");
          a.wrapConsole(e);
          const { setConsoleExtensionInstaller: n } = r("inspector");
          n(a.installConsoleExtensions);
        }
        return e;
      })()
    );
    const { URL: f, URLSearchParams: p } = t("internal/url");
    s(o, "URL", f),
      s(o, "URLSearchParams", p),
      (function exposeGetterAndSetter(e, t, r, a) {
        n(e, t, {
          __proto__: null,
          enumerable: !1,
          configurable: !0,
          get: r,
          set: a,
        });
      })(
        o,
        "DOMException",
        () => {
          const e = i();
          return s(o, "DOMException", e), e;
        },
        (e) => {
          s(o, "DOMException", e);
        }
      );
    const g = t("timers");
    l(o, "clearInterval", g.clearInterval),
      l(o, "clearTimeout", g.clearTimeout),
      l(o, "setInterval", g.setInterval),
      l(o, "setTimeout", g.setTimeout),
      b(o, "internal/worker/io", ["BroadcastChannel"]),
      b(o, "internal/abort_controller", ["AbortController", "AbortSignal"]);
    const { EventTarget: S, Event: d } = t("internal/event_target");
    s(o, "Event", d),
      s(o, "EventTarget", S),
      b(o, "internal/worker/io", [
        "MessageChannel",
        "MessagePort",
        "MessageEvent",
      ]),
      c(o, "buffer", ["atob", "btoa"]),
      b(o, "internal/blob", ["Blob"]),
      b(o, "perf_hooks", ["Performance"]),
      m(o, "perf_hooks", ["performance"]),
      b(o, "internal/encoding", ["TextEncoder", "TextDecoder"]),
      b(o, "internal/webstreams/transformstream", [
        "TransformStream",
        "TransformStreamDefaultController",
      ]),
      b(o, "internal/webstreams/writablestream", [
        "WritableStream",
        "WritableStreamDefaultController",
        "WritableStreamDefaultWriter",
      ]),
      b(o, "internal/webstreams/readablestream", [
        "ReadableStream",
        "ReadableStreamDefaultReader",
        "ReadableStreamBYOBReader",
        "ReadableStreamBYOBRequest",
        "ReadableByteStreamController",
        "ReadableStreamDefaultController",
      ]),
      b(o, "internal/webstreams/queuingstrategies", [
        "ByteLengthQueuingStrategy",
        "CountQueuingStrategy",
      ]),
      b(o, "internal/webstreams/encoding", [
        "TextEncoderStream",
        "TextDecoderStream",
      ]),
      b(o, "internal/webstreams/compression", [
        "CompressionStream",
        "DecompressionStream",
      ]);
  },
  "internal/bootstrap/node": function (e, t, r, n) {
    "use strict";
    const {
        FunctionPrototypeCall: s,
        JSONParse: a,
        ObjectDefineProperty: o,
        ObjectGetPrototypeOf: i,
        ObjectPreventExtensions: l,
        ObjectSetPrototypeOf: c,
        ReflectGet: u,
        ReflectSet: p,
        SymbolToStringTag: g,
        globalThis: d,
      } = n,
      _ = r("config"),
      b = t("internal/timers"),
      {
        defineOperation: m,
        deprecate: f,
        defineLazyProperties: y,
      } = t("internal/util"),
      {
        privateSymbols: { exiting_aliased_Uint32Array: h },
      } = r("util");
    !(function setupProcessObject() {
      const r = t("events"),
        n = i(e);
      c(n, r.prototype),
        s(r, e),
        o(e, g, {
          __proto__: null,
          enumerable: !1,
          writable: !0,
          configurable: !1,
          value: "process",
        });
      let a = e;
      o(d, "process", {
        __proto__: null,
        get: () => a,
        set(e) {
          a = e;
        },
        enumerable: !1,
        configurable: !0,
      });
    })(),
      (function setupGlobalProxy() {
        o(d, g, {
          __proto__: null,
          value: "global",
          writable: !1,
          enumerable: !1,
          configurable: !0,
        }),
          (d.global = d);
      })(),
      (function setupBuffer() {
        const { Buffer: e } = t("buffer"),
          n = r("buffer");
        n.setBufferPrototype(e.prototype),
          delete n.setBufferPrototype,
          delete n.zeroFill;
        let s = e;
        o(d, "Buffer", {
          __proto__: null,
          get: () => s,
          set(e) {
            s = e;
          },
          enumerable: !1,
          configurable: !0,
        });
      })(),
      (e.domain = null);
    {
      const t = e[h];
      o(e, "_exiting", {
        __proto__: null,
        get: () => 1 === t[0],
        set(e) {
          t[0] = e ? 1 : 0;
        },
        enumerable: !0,
        configurable: !0,
      });
    }
    e._exiting = !1;
    const x = {
        warned: !1,
        message:
          "Setting process.config is deprecated. In the future the property will be read-only.",
        code: "DEP0150",
        maybeWarn() {
          this.warned ||
            (e.emitWarning(this.message, {
              type: "DeprecationWarning",
              code: this.code,
            }),
            (this.warned = !0));
        },
        defineProperty(e, t, r) {
          return this.maybeWarn(), o(e, t, r);
        },
        deleteProperty(e, t) {
          this.maybeWarn(), delete e[t];
        },
        preventExtensions(e) {
          return this.maybeWarn(), l(e);
        },
        set(e, t, r) {
          return this.maybeWarn(), p(e, t, r);
        },
        get(e, t, r) {
          const n = u(e, t, r);
          return null != n && "object" == typeof n ? new Proxy(n, x) : n;
        },
        setPrototypeOf(e, t) {
          return this.maybeWarn(), c(e, t);
        },
      },
      k = r("builtins");
    let v = new Proxy(a(k.config), x);
    o(e, "config", {
      __proto__: null,
      enumerable: !0,
      configurable: !0,
      get: () => v,
      set(e) {
        x.maybeWarn(), (v = e);
      },
    }),
      t("internal/worker/js_transferable").setup();
    const w = t("internal/process/per_thread"),
      P = r("process_methods");
    {
      (e.dlopen = P.dlopen),
        (e.uptime = P.uptime),
        (e._getActiveRequests = P._getActiveRequests),
        (e._getActiveHandles = P._getActiveHandles),
        (e.getActiveResourcesInfo = P.getActiveResourcesInfo),
        (e.reallyExit = P.reallyExit),
        (e._kill = P._kill);
      const t = w.wrapProcessMethods(P);
      (e._rawDebug = t._rawDebug),
        (e.cpuUsage = t.cpuUsage),
        (e.resourceUsage = t.resourceUsage),
        (e.memoryUsage = t.memoryUsage),
        (e.constrainedMemory = P.constrainedMemory),
        (e.kill = t.kill),
        (e.exit = t.exit),
        (e.hrtime = w.hrtime),
        (e.hrtime.bigint = w.hrtimeBigInt),
        (e.openStdin = function () {
          return e.stdin.resume(), e.stdin;
        });
    }
    const E = r("credentials");
    E.implementsPosixCredentials &&
      ((e.getuid = E.getuid),
      (e.geteuid = E.geteuid),
      (e.getgid = E.getgid),
      (e.getegid = E.getegid),
      (e.getgroups = E.getgroups));
    const { nativeHooks: C } = t("internal/async_hooks");
    r("async_wrap").setupHooks(C);
    const { setupTaskQueue: S, queueMicrotask: U } = t(
      "internal/process/task_queues"
    );
    m(d, "queueMicrotask", U);
    const M = t("timers");
    m(d, "clearImmediate", M.clearImmediate),
      m(d, "setImmediate", M.setImmediate),
      y(d, "internal/structured_clone", ["structuredClone"]);
    const { setTraceCategoryStateUpdateHandler: T } = r("trace_events");
    T(w.toggleTraceCategoryState),
      o(e, "allowedNodeEnvironmentFlags", {
        __proto__: null,
        get() {
          const t = w.buildAllowedFlags();
          return (
            (e.allowedNodeEnvironmentFlags = t), e.allowedNodeEnvironmentFlags
          );
        },
        set(e) {
          o(this, "allowedNodeEnvironmentFlags", {
            __proto__: null,
            value: e,
            configurable: !0,
            enumerable: !0,
            writable: !0,
          });
        },
        enumerable: !0,
        configurable: !0,
      }),
      (e.assert = f(
        w.assert,
        "process.assert() is deprecated. Please use the `assert` module instead.",
        "DEP0100"
      ));
    const { isDebugBuild: I, hasOpenSSL: O, hasInspector: W } = _;
    o(e, "features", {
      __proto__: null,
      enumerable: !0,
      writable: !1,
      configurable: !1,
      value: {
        inspector: W,
        debug: I,
        uv: !0,
        ipv6: !0,
        tls_alpn: O,
        tls_sni: O,
        tls_ocsp: O,
        tls: O,
        get cached_builtins() {
          return k.hasCachedBuiltins();
        },
      },
    });
    {
      const {
        onGlobalUncaughtException: r,
        setUncaughtExceptionCaptureCallback: n,
        hasUncaughtExceptionCaptureCallback: s,
      } = t("internal/process/execution");
      (e._fatalException = r),
        (e.setUncaughtExceptionCaptureCallback = n),
        (e.hasUncaughtExceptionCaptureCallback = s);
    }
    const { emitWarning: A } = t("internal/process/warning");
    e.emitWarning = A;
    {
      const { nextTick: t, runNextTicks: n } = S();
      (e.nextTick = t), (e._tickCallback = n);
      const { setupTimers: s } = r("timers"),
        { processImmediate: a, processTimers: o } = b.getTimerCallbacks(n);
      s(a, o);
    }
    {
      const {
          getSourceMapsEnabled: n,
          setSourceMapsEnabled: s,
          maybeCacheGeneratedSourceMap: a,
        } = t("internal/source_map/source_map_cache"),
        { setMaybeCacheGeneratedSourceMap: i } = r("errors");
      o(e, "sourceMapsEnabled", {
        __proto__: null,
        enumerable: !0,
        configurable: !0,
        get: () => n(),
      }),
        (e.setSourceMapsEnabled = s),
        i(a);
    }
  },
  "internal/bootstrap/realm": function (e, t, i, r) {
    "use strict";
    const {
        ArrayFrom: n,
        ArrayPrototypeMap: s,
        ArrayPrototypePush: o,
        ArrayPrototypeSlice: a,
        Error: l,
        ObjectCreate: u,
        ObjectDefineProperty: c,
        ObjectKeys: d,
        ObjectPrototypeHasOwnProperty: p,
        ObjectSetPrototypeOf: h,
        ReflectGet: f,
        SafeMap: y,
        SafeSet: B,
        String: w,
        StringPrototypeSlice: m,
        StringPrototypeStartsWith: g,
        TypeError: _,
      } = r,
      b = [];
    c(e, "moduleLoadList", {
      __proto__: null,
      value: b,
      configurable: !0,
      enumerable: !0,
      writable: !1,
    });
    const x = new B([
        "async_wrap",
        "buffer",
        "cares_wrap",
        "config",
        "constants",
        "contextify",
        "crypto",
        "fs",
        "fs_event_wrap",
        "http_parser",
        "icu",
        "inspector",
        "js_stream",
        "natives",
        "os",
        "pipe_wrap",
        "process_wrap",
        "signal_wrap",
        "spawn_sync",
        "stream_wrap",
        "tcp_wrap",
        "tls_wrap",
        "tty_wrap",
        "udp_wrap",
        "url",
        "util",
        "uv",
        "v8",
        "zlib",
      ]),
      S = new B([
        "async_wrap",
        "crypto",
        "http_parser",
        "signal_wrap",
        "url",
        "v8",
      ]),
      q = new B(["util"]),
      M = new B(["test", "test/reporters"]),
      E = new B();
    {
      const i = u(null);
      (e.binding = function binding(t) {
        if (((t = w(t)), x.has(t)))
          return (
            S.has(t) &&
              (S.delete(t),
              e.emitWarning(
                `Access to process.binding('${t}') is deprecated.`,
                "DeprecationWarning",
                "DEP0111"
              )),
            q.has(t)
              ? requireBuiltin("internal/legacy/processbinding")[t]()
              : P(t)
          );
        throw new l(`No such module: ${t}`);
      }),
        (e._linkedBinding = function _linkedBinding(e) {
          e = w(e);
          let r = i[e];
          return "object" != typeof r && (r = i[e] = t(e)), r;
        });
    }
    let P;
    {
      const e = u(null);
      P = function internalBinding2(t) {
        let r = e[t];
        return (
          "object" != typeof r &&
            ((r = e[t] = i(t)), o(b, `Internal Binding ${t}`)),
          r
        );
      };
    }
    const v = "internal/bootstrap/realm",
      {
        builtinIds: F,
        compileFunction: I,
        setInternalLoaders: R,
      } = P("builtins"),
      k = F.filter((e) => !g(e, "internal/") && !E.has(e)),
      W = F.filter((e) => g(e, "internal/") && e !== v),
      $ = new B(k),
      j = new B(k.filter((e) => !M.has(e)));
    class BuiltinModule {
      static map = new y(s(F, (e) => [e, new BuiltinModule(e)]));
      constructor(e) {
        (this.filename = `${e}.js`),
          (this.id = e),
          (this.exports = {}),
          (this.loaded = !1),
          (this.loading = !1),
          (this.module = void 0),
          (this.exportKeys = void 0);
      }
      static allowRequireByUsers(e) {
        if (e === v) throw new l(`Should not allow ${e}`);
        $.add(e), M.has(e) || j.add(e);
      }
      static exposeInternals() {
        for (let e = 0; e < W.length; ++e)
          BuiltinModule.allowRequireByUsers(W[e]);
      }
      static exists(e) {
        return BuiltinModule.map.has(e);
      }
      static canBeRequiredByUsers(e) {
        return $.has(e);
      }
      static canBeRequiredWithoutScheme(e) {
        return j.has(e);
      }
      static isBuiltin(e) {
        return (
          BuiltinModule.canBeRequiredWithoutScheme(e) ||
          ("string" == typeof e &&
            g(e, "node:") &&
            BuiltinModule.canBeRequiredByUsers(m(e, 5)))
        );
      }
      static getCanBeRequiredByUsersWithoutSchemeList() {
        return n(j);
      }
      static normalizeRequirableId(e) {
        if (g(e, "node:")) {
          const t = m(e, 5);
          if (BuiltinModule.canBeRequiredByUsers(t)) return t;
        } else if (BuiltinModule.canBeRequiredWithoutScheme(e)) return e;
      }
      static getSchemeOnlyModuleNames() {
        return n(M);
      }
      compileForPublicLoader() {
        if (!BuiltinModule.canBeRequiredByUsers(this.id))
          throw new l(`Should not compile ${this.id} for public use`);
        if ((this.compileForInternalLoader(), !this.exportKeys)) {
          const e = g(this.id, "internal/");
          this.exportKeys = e ? [] : d(this.exports);
        }
        return this.getESMFacade(), this.syncExports(), this.exports;
      }
      getESMFacade() {
        if (this.module) return this.module;
        const { ModuleWrap: e } = P("module_wrap");
        h(e.prototype, null);
        const t = `node:${this.id}`,
          i = this,
          r = a(this.exportKeys);
        return (
          o(r, "default"),
          (this.module = new e(t, void 0, r, function () {
            i.syncExports(), this.setExport("default", i.exports);
          })),
          this.module.instantiate(),
          this.module.evaluate(-1, !1),
          this.module
        );
      }
      syncExports() {
        const e = this.exportKeys;
        if (this.module)
          for (let n = 0; n < e.length; n++) {
            const s = e[n];
            "default" !== s &&
              this.module.setExport(
                s,
                ((t = this.exports),
                (i = s),
                (r = this.exports),
                p(t, i) ? f(t, i, r) : void 0)
              );
          }
        var t, i, r;
      }
      compileForInternalLoader() {
        if (this.loaded || this.loading) return this.exports;
        const t = this.id;
        this.loading = !0;
        try {
          const i = g(this.id, "internal/deps/")
            ? requireWithFallbackInDeps
            : requireBuiltin;
          I(t)(this.exports, i, this, e, P, r), (this.loaded = !0);
        } finally {
          this.loading = !1;
        }
        return o(b, `NativeModule ${t}`), this.exports;
      }
    }
    const L = {
      internalBinding: P,
      BuiltinModule: BuiltinModule,
      require: requireBuiltin,
    };
    function requireBuiltin(e) {
      if (e === v) return L;
      const t = BuiltinModule.map.get(e);
      if (!t) throw new _(`Missing internal module '${e}'`);
      return t.compileForInternalLoader();
    }
    function requireWithFallbackInDeps(e) {
      return (
        g(e, "node:")
          ? (e = m(e, 5))
          : BuiltinModule.map.has(e) || (e = `internal/deps/${e}`),
        requireBuiltin(e)
      );
    }
    R(P, requireBuiltin),
      (function setupPrepareStackTrace() {
        const {
            setEnhanceStackForFatalException: e,
            setPrepareStackTraceCallback: t,
          } = P("errors"),
          {
            prepareStackTrace: i,
            fatalExceptionStackEnhancers: {
              beforeInspector: r,
              afterInspector: n,
            },
          } = requireBuiltin("internal/errors");
        t(i), e(r, n);
      })();
  },
  "internal/bootstrap/switches/does_not_own_process_state": function (
    s,
    e,
    r,
    t
  ) {
    "use strict";
    const o = r("credentials"),
      i = r("process_methods"),
      { unavailable: c } = e("internal/process/worker_thread_only");
    (s.abort = c("process.abort()")),
      (s.chdir = c("process.chdir()")),
      (s.umask = function wrappedUmask(s) {
        if (void 0 !== s) throw new n("Setting process.umask()");
        return i.umask(s);
      }),
      (s.cwd = i.cwd),
      o.implementsPosixCredentials &&
        ((s.initgroups = c("process.initgroups()")),
        (s.setgroups = c("process.setgroups()")),
        (s.setegid = c("process.setegid()")),
        (s.seteuid = c("process.seteuid()")),
        (s.setgid = c("process.setgid()")),
        (s.setuid = c("process.setuid()")));
    const {
      codes: { ERR_WORKER_UNSUPPORTED_OPERATION: n },
    } = e("internal/errors");
  },
  "internal/bootstrap/switches/does_own_process_state": function (t, e, r, i) {
    "use strict";
    const s = r("credentials"),
      n = r("process_methods");
    if (
      ((t.abort = n.abort),
      (t.umask = function wrappedUmask(t) {
        void 0 !== t && (t = o(t, "mask"));
        return n.umask(t);
      }),
      (t.chdir = function wrappedChdir(t) {
        u(t, "directory"), n.chdir(t), (a = "");
      }),
      (t.cwd = function wrappedCwd() {
        "" === a && (a = n.cwd());
        return a;
      }),
      s.implementsPosixCredentials)
    ) {
      const r = (function wrapPosixCredentialSetters(t) {
        const {
            codes: { ERR_INVALID_ARG_TYPE: r, ERR_UNKNOWN_CREDENTIAL: i },
          } = e("internal/errors"),
          { validateUint32: s } = e("internal/validators"),
          {
            initgroups: n,
            setgroups: o,
            setegid: u,
            seteuid: a,
            setgid: p,
            setuid: g,
          } = t;
        function initgroups(t, e) {
          validateId(t, "user"), validateId(e, "extraGroup");
          const r = n(t, e);
          if (1 === r) throw new i("User", t);
          if (2 === r) throw new i("Group", e);
        }
        function setgroups(t) {
          d(t, "groups");
          for (let e = 0; e < t.length; e++) validateId(t[e], `groups[${e}]`);
          const e = o(t);
          if (e > 0) throw new i("Group", t[e - 1]);
        }
        function wrapIdSetter(t, e) {
          return function (r) {
            validateId(r, "id"), "number" == typeof r && (r >>>= 0);
            if (1 === e(r)) throw new i(t, r);
          };
        }
        function validateId(t, e) {
          if ("number" == typeof t) s(t, e);
          else if ("string" != typeof t)
            throw new r(e, ["number", "string"], t);
        }
        return {
          initgroups: initgroups,
          setgroups: setgroups,
          setegid: wrapIdSetter("Group", u),
          seteuid: wrapIdSetter("User", a),
          setgid: wrapIdSetter("Group", p),
          setuid: wrapIdSetter("User", g),
        };
      })(s);
      (t.initgroups = r.initgroups),
        (t.setgroups = r.setgroups),
        (t.setegid = r.setegid),
        (t.seteuid = r.seteuid),
        (t.setgid = r.setgid),
        (t.setuid = r.setuid);
    }
    const {
      parseFileMode: o,
      validateArray: d,
      validateString: u,
    } = e("internal/validators");
    let a = "";
  },
  "internal/bootstrap/switches/is_main_thread": function (e, t, n, r) {
    "use strict";
    const { ObjectDefineProperty: a } = r,
      i = n("process_methods"),
      {
        namespace: { addSerializeCallback: s, isBuildingSnapshot: o },
      } = t("internal/v8/startup_snapshot");
    function defineStream(t, n) {
      a(e, t, { __proto__: null, configurable: !0, enumerable: !0, get: n });
    }
    (e._debugProcess = i._debugProcess),
      (e._debugEnd = i._debugEnd),
      (e._startProfilerIdleNotifier = () => {}),
      (e._stopProfilerIdleNotifier = () => {}),
      defineStream("stdout", function getStdout() {
        if (S) return S;
        (S = createWritableStdioStream(1)),
          (S.destroySoon = S.destroy),
          (_ = S._destroy),
          (S._destroy = dummyDestroy),
          S.isTTY && e.on("SIGWINCH", refreshStdoutOnSigWinch);
        return (
          addCleanup(function cleanupStdout() {
            (S._destroy = _),
              S.destroy(),
              e.removeListener("SIGWINCH", refreshStdoutOnSigWinch),
              (S = void 0);
          }),
          S
        );
      }),
      defineStream("stdin", function getStdin() {
        if (u) return u;
        switch (c(0)) {
          case "TTY": {
            const e = t("tty");
            u = new e.ReadStream(0);
            break;
          }
          case "FILE": {
            const e = t("fs");
            u = new e.ReadStream(null, { fd: 0, autoClose: !1 });
            break;
          }
          case "PIPE":
          case "TCP": {
            const n = t("net");
            (u =
              e.channel && 0 === e.channel.fd
                ? new n.Socket({
                    handle: e.channel,
                    readable: !0,
                    writable: !1,
                    manualStart: !0,
                  })
                : new n.Socket({
                    fd: 0,
                    readable: !0,
                    writable: !1,
                    manualStart: !0,
                  })),
              (u._writableState.ended = !0);
            break;
          }
          default: {
            const { Readable: e } = t("stream");
            (u = new e({ read() {} })), u.push(null);
          }
        }
        (u.fd = 0),
          u._handle &&
            u._handle.readStop &&
            ((u._handle.reading = !1),
            (u._readableState.reading = !1),
            u._handle.readStop());
        function onpause() {
          u._handle &&
            u._handle.reading &&
            !u.readableFlowing &&
            ((u._readableState.reading = !1),
            (u._handle.reading = !1),
            u._handle.readStop());
        }
        return (
          u.on("pause", () => {
            e.nextTick(onpause);
          }),
          addCleanup(function cleanupStdin() {
            u.destroy(), (u = void 0);
          }),
          u
        );
      }),
      defineStream("stderr", function getStderr() {
        if (f) return f;
        (f = createWritableStdioStream(2)),
          (f.destroySoon = f.destroy),
          (h = f._destroy),
          (f._destroy = dummyDestroy),
          f.isTTY && e.on("SIGWINCH", refreshStderrOnSigWinch);
        return (
          addCleanup(function cleanupStderr() {
            (f._destroy = h),
              f.destroy(),
              e.removeListener("SIGWINCH", refreshStderrOnSigWinch),
              (f = void 0);
          }),
          f
        );
      });
    const { startListeningIfSignal: d, stopListeningIfSignal: l } = t(
      "internal/process/signal"
    );
    e.on("newListener", d), e.on("removeListener", l);
    const { guessHandleType: c } = n("util");
    function createWritableStdioStream(n) {
      let r;
      switch (c(n)) {
        case "TTY":
          (r = new (t("tty").WriteStream)(n)), (r._type = "tty");
          break;
        case "FILE":
          (r = new (t("internal/fs/sync_write_stream"))(n, { autoClose: !1 })),
            (r._type = "fs");
          break;
        case "PIPE":
        case "TCP": {
          const a = t("net");
          if (e.channel && e.channel.fd === n) {
            const { kChannelHandle: n } = t("internal/child_process");
            r = new a.Socket({ handle: e[n], readable: !1, writable: !0 });
          } else r = new a.Socket({ fd: n, readable: !1, writable: !0 });
          r._type = "pipe";
          break;
        }
        default: {
          const { Writable: e } = t("stream");
          r = new e({
            write(e, t, n) {
              n();
            },
          });
        }
      }
      return (r.fd = n), (r._isStdio = !0), r;
    }
    function dummyDestroy(t, n) {
      n(t),
        this._undestroy(),
        this._writableState.emitClose ||
          e.nextTick(() => {
            this.emit("close");
          });
    }
    let u, S, f, _, h;
    function refreshStdoutOnSigWinch() {
      S._refreshSize();
    }
    function refreshStderrOnSigWinch() {
      f._refreshSize();
    }
    function addCleanup(e) {
      o() && s(e);
    }
    (i.resetStdioForTesting = function () {
      (u = void 0), (S = void 0), (f = void 0);
    }),
      t("fs"),
      t("util"),
      t("url"),
      t("internal/modules/cjs/loader"),
      t("internal/modules/esm/utils"),
      t("internal/vm/module"),
      t("internal/perf/utils"),
      n("config").hasInspector && t("internal/inspector_async_hook"),
      n("wasm_web_api"),
      n("worker"),
      t("internal/modules/run_main"),
      t("internal/dns/utils"),
      t("internal/process/pre_execution");
  },
  "internal/bootstrap/switches/is_not_main_thread": function (e, t, r, n) {
    "use strict";
    const { ObjectDefineProperty: i } = n;
    function defineStream(t, r) {
      i(e, t, { __proto__: null, configurable: !0, enumerable: !0, get: r });
    }
    delete e._debugProcess,
      delete e._debugEnd,
      defineStream("stdout", function getStdout() {
        return lazyWorkerStdio().stdout;
      }),
      defineStream("stdin", function getStdin() {
        return lazyWorkerStdio().stdin;
      }),
      defineStream("stderr", function getStderr() {
        return lazyWorkerStdio().stderr;
      });
    const { startListeningIfSignal: o, stopListeningIfSignal: s } = t(
      "internal/process/signal"
    );
    e.removeListener("newListener", o), e.removeListener("removeListener", s);
    const { createWorkerStdio: d } = t("internal/worker/io");
    let u;
    function lazyWorkerStdio() {
      return u || (u = d()), u;
    }
  },
  "internal/buffer": function (t, n, r, i, e, o) {
    "use strict";
    const {
        BigInt: s,
        Float32Array: f,
        Float64Array: d,
        MathFloor: h,
        Number: E,
        Uint8Array: u,
      } = o,
      {
        ERR_BUFFER_OUT_OF_BOUNDS: a,
        ERR_INVALID_ARG_TYPE: I,
        ERR_OUT_OF_RANGE: c,
      } = n("internal/errors").codes,
      { validateNumber: w } = n("internal/validators"),
      {
        asciiSlice: B,
        base64Slice: U,
        base64urlSlice: l,
        latin1Slice: L,
        hexSlice: b,
        ucs2Slice: g,
        utf8Slice: v,
        asciiWrite: _,
        base64Write: F,
        base64urlWrite: k,
        latin1Write: x,
        hexWrite: y,
        ucs2Write: D,
        utf8Write: $,
        getZeroFillToggle: S,
      } = e("buffer"),
      {
        privateSymbols: { untransferable_object_private_symbol: W },
      } = e("util"),
      m = new f(1),
      p = new u(m.buffer),
      R = new d(1),
      A = new u(R.buffer);
    m[0] = -1;
    const N = 0 === p[3];
    function checkBounds(t, n, r) {
      w(n, "offset"),
        (void 0 !== t[n] && void 0 !== t[n + r]) ||
          boundsError(n, t.length - (r + 1));
    }
    function checkInt(t, n, r, i, e, o) {
      if (t > r || t < n) {
        const i = "bigint" == typeof n ? "n" : "";
        let e;
        throw (
          ((e =
            o > 3
              ? 0 === n || 0n === n
                ? `>= 0${i} and < 2${i} ** ${8 * (o + 1)}${i}`
                : `>= -(2${i} ** ${8 * (o + 1) - 1}${i}) and < 2${i} ** ${
                    8 * (o + 1) - 1
                  }${i}`
              : `>= ${n}${i} and <= ${r}${i}`),
          new c("value", e, t))
        );
      }
      checkBounds(i, e, o);
    }
    function boundsError(t, n, r) {
      if (h(t) !== t) throw (w(t, r), new c(r || "offset", "an integer", t));
      if (n < 0) throw new a();
      throw new c(r || "offset", `>= ${r ? 1 : 0} and <= ${n}`, t);
    }
    function readBigUInt64LE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 7];
      (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 8);
      const i = n + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
        e = this[++t] + 256 * this[++t] + 65536 * this[++t] + r * 2 ** 24;
      return s(i) + (s(e) << 32n);
    }
    function readBigUInt64BE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 7];
      (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 8);
      const i = n * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t],
        e = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r;
      return (s(i) << 32n) + s(e);
    }
    function readBigInt64LE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 7];
      (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 8);
      const i =
        this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (r << 24);
      return (
        (s(i) << 32n) +
        s(n + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
      );
    }
    function readBigInt64BE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 7];
      (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 8);
      const i = (n << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
      return (
        (s(i) << 32n) +
        s(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r)
      );
    }
    function readUIntLE(t, n) {
      if (void 0 === t) throw new I("offset", "number", t);
      return 6 === n
        ? (function readUInt48LE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 5];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 6);
            return (
              r +
              256 * t[++n] +
              65536 * t[++n] +
              t[++n] * 2 ** 24 +
              (t[++n] + 256 * i) * 2 ** 32
            );
          })(this, t)
        : 5 === n
        ? (function readUInt40LE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 4];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 5);
            return (
              r + 256 * t[++n] + 65536 * t[++n] + t[++n] * 2 ** 24 + i * 2 ** 32
            );
          })(this, t)
        : 3 === n
        ? (function readUInt24LE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 2];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 3);
            return r + 256 * t[++n] + 65536 * i;
          })(this, t)
        : 4 === n
        ? this.readUInt32LE(t)
        : 2 === n
        ? this.readUInt16LE(t)
        : 1 === n
        ? this.readUInt8(t)
        : void boundsError(n, 6, "byteLength");
    }
    function readUInt32LE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 3];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 4),
        n + 256 * this[++t] + 65536 * this[++t] + r * 2 ** 24
      );
    }
    function readUInt16LE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 1];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 2),
        n + 256 * r
      );
    }
    function readUInt8(t = 0) {
      w(t, "offset");
      const n = this[t];
      return void 0 === n && boundsError(t, this.length - 1), n;
    }
    function readUIntBE(t, n) {
      if (void 0 === t) throw new I("offset", "number", t);
      return 6 === n
        ? (function readUInt48BE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 5];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 6);
            return (
              (256 * r + t[++n]) * 2 ** 32 +
              t[++n] * 2 ** 24 +
              65536 * t[++n] +
              256 * t[++n] +
              i
            );
          })(this, t)
        : 5 === n
        ? (function readUInt40BE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 4];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 5);
            return (
              r * 2 ** 32 + t[++n] * 2 ** 24 + 65536 * t[++n] + 256 * t[++n] + i
            );
          })(this, t)
        : 3 === n
        ? (function readUInt24BE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 2];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 3);
            return 65536 * r + 256 * t[++n] + i;
          })(this, t)
        : 4 === n
        ? this.readUInt32BE(t)
        : 2 === n
        ? this.readUInt16BE(t)
        : 1 === n
        ? this.readUInt8(t)
        : void boundsError(n, 6, "byteLength");
    }
    function readUInt32BE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 3];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 4),
        n * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r
      );
    }
    function readUInt16BE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 1];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 2),
        256 * n + r
      );
    }
    function readIntLE(t, n) {
      if (void 0 === t) throw new I("offset", "number", t);
      return 6 === n
        ? (function readInt48LE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 5];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 6);
            const e = t[n + 4] + 256 * i;
            return (
              (e | (131070 * (32768 & e))) * 2 ** 32 +
              r +
              256 * t[++n] +
              65536 * t[++n] +
              t[++n] * 2 ** 24
            );
          })(this, t)
        : 5 === n
        ? (function readInt40LE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 4];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 5);
            return (
              (i | (33554430 * (128 & i))) * 2 ** 32 +
              r +
              256 * t[++n] +
              65536 * t[++n] +
              t[++n] * 2 ** 24
            );
          })(this, t)
        : 3 === n
        ? (function readInt24LE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 2];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 3);
            const e = r + 256 * t[++n] + 65536 * i;
            return e | (510 * (e & (2 ** 23)));
          })(this, t)
        : 4 === n
        ? this.readInt32LE(t)
        : 2 === n
        ? this.readInt16LE(t)
        : 1 === n
        ? this.readInt8(t)
        : void boundsError(n, 6, "byteLength");
    }
    function readInt32LE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 3];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 4),
        n + 256 * this[++t] + 65536 * this[++t] + (r << 24)
      );
    }
    function readInt16LE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 1];
      (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 2);
      const i = n + 256 * r;
      return i | (131070 * (32768 & i));
    }
    function readInt8(t = 0) {
      w(t, "offset");
      const n = this[t];
      return (
        void 0 === n && boundsError(t, this.length - 1),
        n | (33554430 * (128 & n))
      );
    }
    function readIntBE(t, n) {
      if (void 0 === t) throw new I("offset", "number", t);
      return 6 === n
        ? (function readInt48BE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 5];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 6);
            const e = t[++n] + 256 * r;
            return (
              (e | (131070 * (32768 & e))) * 2 ** 32 +
              t[++n] * 2 ** 24 +
              65536 * t[++n] +
              256 * t[++n] +
              i
            );
          })(this, t)
        : 5 === n
        ? (function readInt40BE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 4];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 5);
            return (
              (r | (33554430 * (128 & r))) * 2 ** 32 +
              t[++n] * 2 ** 24 +
              65536 * t[++n] +
              256 * t[++n] +
              i
            );
          })(this, t)
        : 3 === n
        ? (function readInt24BE(t, n = 0) {
            w(n, "offset");
            const r = t[n],
              i = t[n + 2];
            (void 0 !== r && void 0 !== i) || boundsError(n, t.length - 3);
            const e = 65536 * r + 256 * t[++n] + i;
            return e | (510 * (e & (2 ** 23)));
          })(this, t)
        : 4 === n
        ? this.readInt32BE(t)
        : 2 === n
        ? this.readInt16BE(t)
        : 1 === n
        ? this.readInt8(t)
        : void boundsError(n, 6, "byteLength");
    }
    function readInt32BE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 3];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 4),
        (n << 24) + 65536 * this[++t] + 256 * this[++t] + r
      );
    }
    function readInt16BE(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 1];
      (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 2);
      const i = 256 * n + r;
      return i | (131070 * (32768 & i));
    }
    function readFloatBackwards(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 3];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 4),
        (p[3] = n),
        (p[2] = this[++t]),
        (p[1] = this[++t]),
        (p[0] = r),
        m[0]
      );
    }
    function readFloatForwards(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 3];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 4),
        (p[0] = n),
        (p[1] = this[++t]),
        (p[2] = this[++t]),
        (p[3] = r),
        m[0]
      );
    }
    function readDoubleBackwards(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 7];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 8),
        (A[7] = n),
        (A[6] = this[++t]),
        (A[5] = this[++t]),
        (A[4] = this[++t]),
        (A[3] = this[++t]),
        (A[2] = this[++t]),
        (A[1] = this[++t]),
        (A[0] = r),
        R[0]
      );
    }
    function readDoubleForwards(t = 0) {
      w(t, "offset");
      const n = this[t],
        r = this[t + 7];
      return (
        (void 0 !== n && void 0 !== r) || boundsError(t, this.length - 8),
        (A[0] = n),
        (A[1] = this[++t]),
        (A[2] = this[++t]),
        (A[3] = this[++t]),
        (A[4] = this[++t]),
        (A[5] = this[++t]),
        (A[6] = this[++t]),
        (A[7] = r),
        R[0]
      );
    }
    function writeBigU_Int64LE(t, n, r, i, e) {
      checkInt(n, i, e, t, r, 7);
      let o = E(0xffffffffn & n);
      (t[r++] = o),
        (o >>= 8),
        (t[r++] = o),
        (o >>= 8),
        (t[r++] = o),
        (o >>= 8),
        (t[r++] = o);
      let s = E((n >> 32n) & 0xffffffffn);
      return (
        (t[r++] = s),
        (s >>= 8),
        (t[r++] = s),
        (s >>= 8),
        (t[r++] = s),
        (s >>= 8),
        (t[r++] = s),
        r
      );
    }
    function writeBigUInt64LE(t, n = 0) {
      return writeBigU_Int64LE(this, t, n, 0n, 0xffffffffffffffffn);
    }
    function writeBigU_Int64BE(t, n, r, i, e) {
      checkInt(n, i, e, t, r, 7);
      let o = E(0xffffffffn & n);
      (t[r + 7] = o),
        (o >>= 8),
        (t[r + 6] = o),
        (o >>= 8),
        (t[r + 5] = o),
        (o >>= 8),
        (t[r + 4] = o);
      let s = E((n >> 32n) & 0xffffffffn);
      return (
        (t[r + 3] = s),
        (s >>= 8),
        (t[r + 2] = s),
        (s >>= 8),
        (t[r + 1] = s),
        (s >>= 8),
        (t[r] = s),
        r + 8
      );
    }
    function writeBigUInt64BE(t, n = 0) {
      return writeBigU_Int64BE(this, t, n, 0n, 0xffffffffffffffffn);
    }
    function writeBigInt64LE(t, n = 0) {
      return writeBigU_Int64LE(
        this,
        t,
        n,
        -0x8000000000000000n,
        0x7fffffffffffffffn
      );
    }
    function writeBigInt64BE(t, n = 0) {
      return writeBigU_Int64BE(
        this,
        t,
        n,
        -0x8000000000000000n,
        0x7fffffffffffffffn
      );
    }
    function writeUIntLE(t, n, r) {
      return 6 === r
        ? writeU_Int48LE(this, t, n, 0, 0xffffffffffff)
        : 5 === r
        ? writeU_Int40LE(this, t, n, 0, 0xffffffffff)
        : 3 === r
        ? writeU_Int24LE(this, t, n, 0, 16777215)
        : 4 === r
        ? writeU_Int32LE(this, t, n, 0, 4294967295)
        : 2 === r
        ? writeU_Int16LE(this, t, n, 0, 65535)
        : 1 === r
        ? writeU_Int8(this, t, n, 0, 255)
        : void boundsError(r, 6, "byteLength");
    }
    function writeU_Int48LE(t, n, r, i, e) {
      checkInt((n = +n), i, e, t, r, 5);
      const o = h(n * 2 ** -32);
      return (
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (t[r++] = o),
        (t[r++] = o >>> 8),
        r
      );
    }
    function writeU_Int40LE(t, n, r, i, e) {
      checkInt((n = +n), i, e, t, r, 4);
      const o = n;
      return (
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (t[r++] = h(o * 2 ** -32)),
        r
      );
    }
    function writeU_Int32LE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 3),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        r
      );
    }
    function writeUInt32LE(t, n = 0) {
      return writeU_Int32LE(this, t, n, 0, 4294967295);
    }
    function writeU_Int24LE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 2),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        (n >>>= 8),
        (t[r++] = n),
        r
      );
    }
    function writeU_Int16LE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 1), (t[r++] = n), (t[r++] = n >>> 8), r
      );
    }
    function writeUInt16LE(t, n = 0) {
      return writeU_Int16LE(this, t, n, 0, 65535);
    }
    function writeU_Int8(t, n, r, i, e) {
      if (((n = +n), w(r, "offset"), n > e || n < i))
        throw new c("value", `>= ${i} and <= ${e}`, n);
      return void 0 === t[r] && boundsError(r, t.length - 1), (t[r] = n), r + 1;
    }
    function writeUInt8(t, n = 0) {
      return writeU_Int8(this, t, n, 0, 255);
    }
    function writeUIntBE(t, n, r) {
      return 6 === r
        ? writeU_Int48BE(this, t, n, 0, 0xffffffffffff)
        : 5 === r
        ? writeU_Int40BE(this, t, n, 0, 0xffffffffff)
        : 3 === r
        ? writeU_Int24BE(this, t, n, 0, 16777215)
        : 4 === r
        ? writeU_Int32BE(this, t, n, 0, 4294967295)
        : 2 === r
        ? writeU_Int16BE(this, t, n, 0, 65535)
        : 1 === r
        ? writeU_Int8(this, t, n, 0, 255)
        : void boundsError(r, 6, "byteLength");
    }
    function writeU_Int48BE(t, n, r, i, e) {
      checkInt((n = +n), i, e, t, r, 5);
      const o = h(n * 2 ** -32);
      return (
        (t[r++] = o >>> 8),
        (t[r++] = o),
        (t[r + 3] = n),
        (n >>>= 8),
        (t[r + 2] = n),
        (n >>>= 8),
        (t[r + 1] = n),
        (n >>>= 8),
        (t[r] = n),
        r + 4
      );
    }
    function writeU_Int40BE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 4),
        (t[r++] = h(n * 2 ** -32)),
        (t[r + 3] = n),
        (n >>>= 8),
        (t[r + 2] = n),
        (n >>>= 8),
        (t[r + 1] = n),
        (n >>>= 8),
        (t[r] = n),
        r + 4
      );
    }
    function writeU_Int32BE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 3),
        (t[r + 3] = n),
        (n >>>= 8),
        (t[r + 2] = n),
        (n >>>= 8),
        (t[r + 1] = n),
        (n >>>= 8),
        (t[r] = n),
        r + 4
      );
    }
    function writeUInt32BE(t, n = 0) {
      return writeU_Int32BE(this, t, n, 0, 4294967295);
    }
    function writeU_Int24BE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 2),
        (t[r + 2] = n),
        (n >>>= 8),
        (t[r + 1] = n),
        (n >>>= 8),
        (t[r] = n),
        r + 3
      );
    }
    function writeU_Int16BE(t, n, r, i, e) {
      return (
        checkInt((n = +n), i, e, t, r, 1), (t[r++] = n >>> 8), (t[r++] = n), r
      );
    }
    function writeUInt16BE(t, n = 0) {
      return writeU_Int16BE(this, t, n, 0, 65535);
    }
    function writeIntLE(t, n, r) {
      return 6 === r
        ? writeU_Int48LE(this, t, n, -0x800000000000, 0x7fffffffffff)
        : 5 === r
        ? writeU_Int40LE(this, t, n, -549755813888, 549755813887)
        : 3 === r
        ? writeU_Int24LE(this, t, n, -8388608, 8388607)
        : 4 === r
        ? writeU_Int32LE(this, t, n, -2147483648, 2147483647)
        : 2 === r
        ? writeU_Int16LE(this, t, n, -32768, 32767)
        : 1 === r
        ? writeU_Int8(this, t, n, -128, 127)
        : void boundsError(r, 6, "byteLength");
    }
    function writeInt32LE(t, n = 0) {
      return writeU_Int32LE(this, t, n, -2147483648, 2147483647);
    }
    function writeInt16LE(t, n = 0) {
      return writeU_Int16LE(this, t, n, -32768, 32767);
    }
    function writeInt8(t, n = 0) {
      return writeU_Int8(this, t, n, -128, 127);
    }
    function writeIntBE(t, n, r) {
      return 6 === r
        ? writeU_Int48BE(this, t, n, -0x800000000000, 0x7fffffffffff)
        : 5 === r
        ? writeU_Int40BE(this, t, n, -549755813888, 549755813887)
        : 3 === r
        ? writeU_Int24BE(this, t, n, -8388608, 8388607)
        : 4 === r
        ? writeU_Int32BE(this, t, n, -2147483648, 2147483647)
        : 2 === r
        ? writeU_Int16BE(this, t, n, -32768, 32767)
        : 1 === r
        ? writeU_Int8(this, t, n, -128, 127)
        : void boundsError(r, 6, "byteLength");
    }
    function writeInt32BE(t, n = 0) {
      return writeU_Int32BE(this, t, n, -2147483648, 2147483647);
    }
    function writeInt16BE(t, n = 0) {
      return writeU_Int16BE(this, t, n, -32768, 32767);
    }
    function writeDoubleForwards(t, n = 0) {
      return (
        (t = +t),
        checkBounds(this, n, 7),
        (R[0] = t),
        (this[n++] = A[0]),
        (this[n++] = A[1]),
        (this[n++] = A[2]),
        (this[n++] = A[3]),
        (this[n++] = A[4]),
        (this[n++] = A[5]),
        (this[n++] = A[6]),
        (this[n++] = A[7]),
        n
      );
    }
    function writeDoubleBackwards(t, n = 0) {
      return (
        (t = +t),
        checkBounds(this, n, 7),
        (R[0] = t),
        (this[n++] = A[7]),
        (this[n++] = A[6]),
        (this[n++] = A[5]),
        (this[n++] = A[4]),
        (this[n++] = A[3]),
        (this[n++] = A[2]),
        (this[n++] = A[1]),
        (this[n++] = A[0]),
        n
      );
    }
    function writeFloatForwards(t, n = 0) {
      return (
        (t = +t),
        checkBounds(this, n, 3),
        (m[0] = t),
        (this[n++] = p[0]),
        (this[n++] = p[1]),
        (this[n++] = p[2]),
        (this[n++] = p[3]),
        n
      );
    }
    function writeFloatBackwards(t, n = 0) {
      return (
        (t = +t),
        checkBounds(this, n, 3),
        (m[0] = t),
        (this[n++] = p[3]),
        (this[n++] = p[2]),
        (this[n++] = p[1]),
        (this[n++] = p[0]),
        n
      );
    }
    class FastBuffer extends u {
      constructor(t, n, r) {
        super(t, n, r);
      }
    }
    let T = S();
    r.exports = {
      FastBuffer: FastBuffer,
      addBufferPrototypeMethods: function addBufferPrototypeMethods(t) {
        (t.readBigUInt64LE = readBigUInt64LE),
          (t.readBigUInt64BE = readBigUInt64BE),
          (t.readBigUint64LE = readBigUInt64LE),
          (t.readBigUint64BE = readBigUInt64BE),
          (t.readBigInt64LE = readBigInt64LE),
          (t.readBigInt64BE = readBigInt64BE),
          (t.writeBigUInt64LE = writeBigUInt64LE),
          (t.writeBigUInt64BE = writeBigUInt64BE),
          (t.writeBigUint64LE = writeBigUInt64LE),
          (t.writeBigUint64BE = writeBigUInt64BE),
          (t.writeBigInt64LE = writeBigInt64LE),
          (t.writeBigInt64BE = writeBigInt64BE),
          (t.readUIntLE = readUIntLE),
          (t.readUInt32LE = readUInt32LE),
          (t.readUInt16LE = readUInt16LE),
          (t.readUInt8 = readUInt8),
          (t.readUIntBE = readUIntBE),
          (t.readUInt32BE = readUInt32BE),
          (t.readUInt16BE = readUInt16BE),
          (t.readUintLE = readUIntLE),
          (t.readUint32LE = readUInt32LE),
          (t.readUint16LE = readUInt16LE),
          (t.readUint8 = readUInt8),
          (t.readUintBE = readUIntBE),
          (t.readUint32BE = readUInt32BE),
          (t.readUint16BE = readUInt16BE),
          (t.readIntLE = readIntLE),
          (t.readInt32LE = readInt32LE),
          (t.readInt16LE = readInt16LE),
          (t.readInt8 = readInt8),
          (t.readIntBE = readIntBE),
          (t.readInt32BE = readInt32BE),
          (t.readInt16BE = readInt16BE),
          (t.writeUIntLE = writeUIntLE),
          (t.writeUInt32LE = writeUInt32LE),
          (t.writeUInt16LE = writeUInt16LE),
          (t.writeUInt8 = writeUInt8),
          (t.writeUIntBE = writeUIntBE),
          (t.writeUInt32BE = writeUInt32BE),
          (t.writeUInt16BE = writeUInt16BE),
          (t.writeUintLE = writeUIntLE),
          (t.writeUint32LE = writeUInt32LE),
          (t.writeUint16LE = writeUInt16LE),
          (t.writeUint8 = writeUInt8),
          (t.writeUintBE = writeUIntBE),
          (t.writeUint32BE = writeUInt32BE),
          (t.writeUint16BE = writeUInt16BE),
          (t.writeIntLE = writeIntLE),
          (t.writeInt32LE = writeInt32LE),
          (t.writeInt16LE = writeInt16LE),
          (t.writeInt8 = writeInt8),
          (t.writeIntBE = writeIntBE),
          (t.writeInt32BE = writeInt32BE),
          (t.writeInt16BE = writeInt16BE),
          (t.readFloatLE = N ? readFloatBackwards : readFloatForwards),
          (t.readFloatBE = N ? readFloatForwards : readFloatBackwards),
          (t.readDoubleLE = N ? readDoubleBackwards : readDoubleForwards),
          (t.readDoubleBE = N ? readDoubleForwards : readDoubleBackwards),
          (t.writeFloatLE = N ? writeFloatBackwards : writeFloatForwards),
          (t.writeFloatBE = N ? writeFloatForwards : writeFloatBackwards),
          (t.writeDoubleLE = N ? writeDoubleBackwards : writeDoubleForwards),
          (t.writeDoubleBE = N ? writeDoubleForwards : writeDoubleBackwards),
          (t.asciiSlice = B),
          (t.base64Slice = U),
          (t.base64urlSlice = l),
          (t.latin1Slice = L),
          (t.hexSlice = b),
          (t.ucs2Slice = g),
          (t.utf8Slice = v),
          (t.asciiWrite = _),
          (t.base64Write = F),
          (t.base64urlWrite = k),
          (t.latin1Write = x),
          (t.hexWrite = y),
          (t.ucs2Write = D),
          (t.utf8Write = $);
      },
      markAsUntransferable: function markAsUntransferable(t) {
        ("object" != typeof t && "function" != typeof t) ||
          null === t ||
          (t[W] = !0);
      },
      createUnsafeBuffer: function createUnsafeBuffer(t) {
        T[0] = 0;
        try {
          return new FastBuffer(t);
        } finally {
          T[0] = 1;
        }
      },
      readUInt16BE: readUInt16BE,
      readUInt32BE: readUInt32BE,
      reconnectZeroFillToggle: function reconnectZeroFillToggle() {
        T = S();
      },
    };
  },
  "internal/child_process": function (e, n, t, s, i, o) {
    "use strict";
    const {
        ArrayIsArray: l,
        ArrayPrototypePush: a,
        ArrayPrototypeReduce: r,
        ArrayPrototypeSlice: c,
        FunctionPrototype: d,
        FunctionPrototypeCall: h,
        ObjectDefineProperty: p,
        ObjectSetPrototypeOf: u,
        ReflectApply: f,
        StringPrototypeSlice: g,
        Symbol: _,
        SymbolDispose: y,
        Uint8Array: m,
      } = o,
      {
        errnoException: w,
        codes: {
          ERR_INVALID_ARG_TYPE: S,
          ERR_INVALID_ARG_VALUE: k,
          ERR_INVALID_HANDLE_TYPE: E,
          ERR_INVALID_SYNC_FORK_INPUT: C,
          ERR_IPC_CHANNEL_CLOSED: N,
          ERR_IPC_DISCONNECTED: v,
          ERR_IPC_ONE_PIPE: A,
          ERR_IPC_SYNC_FORK: P,
          ERR_MISSING_ARGS: b,
        },
      } = n("internal/errors"),
      {
        validateArray: T,
        validateObject: D,
        validateOneOf: H,
        validateString: O,
      } = n("internal/validators"),
      I = n("events"),
      M = n("net"),
      L = n("dgram"),
      R = n("internal/util/inspect").inspect,
      x = n("internal/assert"),
      { Process: V } = i("process_wrap"),
      {
        WriteWrap: Q,
        kReadBytesOrError: U,
        kArrayBufferOffset: W,
        kLastWriteWasAsync: F,
        streamBaseState: K,
      } = i("stream_wrap"),
      { Pipe: G, constants: j } = i("pipe_wrap"),
      { TCP: Y } = i("tcp_wrap"),
      { TTY: z } = i("tty_wrap"),
      { UDP: B } = i("udp_wrap"),
      $ = n("internal/socket_list"),
      { owner_symbol: Z } = n("internal/async_hooks").symbols,
      { convertToValidSignal: q, deprecate: J } = n("internal/util"),
      { isArrayBufferView: X } = n("internal/util/types"),
      ee = i("spawn_sync"),
      { kStateSymbol: ne } = n("internal/dgram"),
      {
        UV_EACCES: te,
        UV_EAGAIN: se,
        UV_EINVAL: ie,
        UV_EMFILE: oe,
        UV_ENFILE: le,
        UV_ENOENT: ae,
        UV_ENOSYS: re,
        UV_ESRCH: ce,
      } = i("uv"),
      { SocketListSend: de, SocketListReceive: he } = $;
    let pe, ue;
    const fe = _("kChannelHandle"),
      ge = _("kIsUsedAsStdio"),
      _e = _("kPendingMessages"),
      ye = {
        "net.Native": {
          simultaneousAccepts: !0,
          send: (e, n, t) => n,
          got(e, n, t) {
            t(n);
          },
        },
        "net.Server": {
          simultaneousAccepts: !0,
          send: (e, n, t) => n._handle,
          got(e, n, t) {
            const s = new M.Server();
            s.listen(n, () => {
              t(s);
            });
          },
        },
        "net.Socket": {
          send(e, t, s) {
            if (!t._handle) return;
            if (t.server) {
              e.key = t.server._connectionKey;
              const n = !this[fe].sockets.send[e.key],
                i = getSocketList("send", this, e.key);
              n && t.server._setupWorker(i),
                s.keepOpen || t.server._connections--;
            }
            const i = t._handle;
            return (
              s.keepOpen ||
                ((i.onread = ke),
                (t._handle = null),
                t.setTimeout(0),
                void 0 === pe && (pe = n("_http_common").freeParser),
                void 0 === ue && (ue = n("_http_common").HTTPParser),
                t.parser &&
                  t.parser instanceof ue &&
                  (pe(t.parser, null, t),
                  t._httpMessage && t._httpMessage.detachSocket(t))),
              i
            );
          },
          postSend(e, n, t, s, i) {
            n &&
              !t.keepOpen &&
              (i
                ? (x(!i._pendingMessage),
                  (i._pendingMessage = {
                    callback: s,
                    message: e,
                    handle: n,
                    options: t,
                    retransmissions: 0,
                  }))
                : n.close());
          },
          got(e, n, t) {
            const s = new M.Socket({ handle: n, readable: !0, writable: !0 });
            if (e.key) {
              getSocketList("got", this, e.key).add({ socket: s });
            }
            t(s);
          },
        },
        "dgram.Native": {
          simultaneousAccepts: !1,
          send: (e, n, t) => n,
          got(e, n, t) {
            t(n);
          },
        },
        "dgram.Socket": {
          simultaneousAccepts: !1,
          send: (e, n, t) => ((e.dgramType = n.type), n[ne].handle),
          got(e, n, t) {
            const s = new L.Socket(e.dgramType);
            s.bind(n, () => {
              t(s);
            });
          },
        },
      };
    function stdioStringToArray(e, n) {
      const t = [];
      switch (e) {
        case "ignore":
        case "overlapped":
        case "pipe":
          a(t, e, e, e);
          break;
        case "inherit":
          a(t, 0, 1, 2);
          break;
        default:
          throw new k("stdio", e);
      }
      return n && a(t, n), t;
    }
    function ChildProcess() {
      h(I, this),
        (this._closesNeeded = 1),
        (this._closesGot = 0),
        (this.connected = !1),
        (this.signalCode = null),
        (this.exitCode = null),
        (this.killed = !1),
        (this.spawnfile = null),
        (this._handle = new V()),
        (this._handle[Z] = this),
        (this._handle.onexit = (e, n) => {
          if (
            (n ? (this.signalCode = n) : (this.exitCode = e),
            this.stdin && this.stdin.destroy(),
            this._handle.close(),
            (this._handle = null),
            e < 0)
          ) {
            const n = this.spawnfile ? "spawn " + this.spawnfile : "spawn",
              t = w(e, n);
            this.spawnfile && (t.path = this.spawnfile),
              (t.spawnargs = c(this.spawnargs, 1)),
              this.emit("error", t);
          } else this.emit("exit", this.exitCode, this.signalCode);
          s.nextTick(flushStdio, this), maybeClose(this);
        });
    }
    function flushStdio(e) {
      const n = e.stdio;
      if (null != n)
        for (let e = 0; e < n.length; e++) {
          const t = n[e];
          t && t.readable && !t[ge] && t.resume();
        }
    }
    function getHandleWrapType(e) {
      return e instanceof G
        ? "pipe"
        : e instanceof z
        ? "tty"
        : e instanceof Y
        ? "tcp"
        : e instanceof B && "udp";
    }
    function closePendingHandle(e) {
      e._pendingMessage.handle.close(), (e._pendingMessage = null);
    }
    function onErrorNT(e, n) {
      e._handle.onexit(n);
    }
    function onSpawnNT(e) {
      e.emit("spawn");
    }
    u(ChildProcess.prototype, I.prototype),
      u(ChildProcess, I),
      (ChildProcess.prototype.spawn = function (e) {
        let n = 0;
        D(e, "options");
        let t = e.stdio || "pipe";
        t = getValidStdio(t, !1);
        const i = t.ipc,
          o = t.ipcFd;
        (t = e.stdio = t.stdio),
          H(e.serialization, "options.serialization", [
            void 0,
            "json",
            "advanced",
          ]);
        const l = e.serialization || "json";
        void 0 !== i &&
          (void 0 === e.envPairs
            ? (e.envPairs = [])
            : T(e.envPairs, "options.envPairs"),
          a(e.envPairs, `NODE_CHANNEL_FD=${o}`),
          a(e.envPairs, `NODE_CHANNEL_SERIALIZATION_MODE=${l}`)),
          O(e.file, "options.file"),
          (this.spawnfile = e.file),
          void 0 === e.args
            ? (this.spawnargs = [])
            : (T(e.args, "options.args"), (this.spawnargs = e.args));
        const r = this._handle.spawn(e);
        if (r === te || r === se || r === oe || r === le || r === ae) {
          if ((s.nextTick(onErrorNT, this, r), r === oe || r === le)) return r;
        } else {
          if (r) {
            for (n = 0; n < t.length; n++) {
              const e = t[n];
              "pipe" === e.type && e.handle.close();
            }
            throw (this._handle.close(), (this._handle = null), w(r, "spawn"));
          }
          s.nextTick(onSpawnNT, this);
        }
        for (this.pid = this._handle.pid, n = 0; n < t.length; n++) {
          const e = t[n];
          "ignore" !== e.type &&
            (e.ipc
              ? this._closesNeeded++
              : "wrap" !== e.type
              ? e.handle &&
                ((e.socket =
                  ((c = 0 !== this.pid ? e.handle : null),
                  (d = n > 0),
                  M.Socket({ handle: c, readable: d }))),
                n > 0 &&
                  0 !== this.pid &&
                  (this._closesNeeded++,
                  e.socket.on("close", () => {
                    maybeClose(this);
                  })))
              : ((e.handle.reading = !1),
                e.handle.readStop(),
                e._stdio.pause(),
                (e._stdio.readableFlowing = !1),
                (e._stdio._readableState.reading = !1),
                (e._stdio[ge] = !0)));
        }
        var c, d;
        for (
          this.stdin =
            t.length >= 1 && void 0 !== t[0].socket ? t[0].socket : null,
            this.stdout =
              t.length >= 2 && void 0 !== t[1].socket ? t[1].socket : null,
            this.stderr =
              t.length >= 3 && void 0 !== t[2].socket ? t[2].socket : null,
            this.stdio = [],
            n = 0;
          n < t.length;
          n++
        )
          a(this.stdio, void 0 === t[n].socket ? null : t[n].socket);
        return void 0 !== i && setupChannel(this, i, l), r;
      }),
      (ChildProcess.prototype.kill = function (e) {
        const n = 0 === e ? e : q(void 0 === e ? "SIGTERM" : e);
        if (this._handle) {
          const e = this._handle.kill(n);
          if (0 === e) return (this.killed = !0), !0;
          if (e === ce);
          else {
            if (e === ie || e === re) throw w(e, "kill");
            this.emit("error", w(e, "kill"));
          }
        }
        return !1;
      }),
      (ChildProcess.prototype[y] = function () {
        this.killed || this.kill();
      }),
      (ChildProcess.prototype.ref = function () {
        this._handle && this._handle.ref();
      }),
      (ChildProcess.prototype.unref = function () {
        this._handle && this._handle.unref();
      });
    class Control extends I {
      #e = null;
      #n = 0;
      #t = !1;
      constructor(e) {
        super(), (this.#e = e), (this[_e] = []);
      }
      refCounted() {
        1 != ++this.#n || this.#t || this.#e.ref();
      }
      unrefCounted() {
        0 != --this.#n || this.#t || (this.#e.unref(), this.emit("unref"));
      }
      ref() {
        (this.#t = !0), this.#e.ref();
      }
      unref() {
        (this.#t = !0), this.#e.unref();
      }
      get fd() {
        return this.#e ? this.#e.fd : void 0;
      }
    }
    const me = "_channel is deprecated. Use ChildProcess.channel instead.";
    let we;
    function setupChannel(e, t, i) {
      const o = new Control(t);
      (e.channel = o),
        (e[fe] = t),
        p(e, "_channel", {
          __proto__: null,
          get: J(() => e.channel, me, "DEP0129"),
          set: J(
            (n) => {
              e.channel = n;
            },
            me,
            "DEP0129"
          ),
          configurable: !0,
          enumerable: !1,
        }),
        (e._handleQueue = null),
        (e._pendingMessage = null),
        void 0 === we && (we = n("internal/child_process/serialization"));
      const {
        initMessageChannel: r,
        parseChannelMessages: c,
        writeChannelMessage: d,
      } = we[i];
      let h = null;
      function emit(n, t, s) {
        "internalMessage" === n || e.listenerCount("message")
          ? e.emit(n, t, s)
          : a(e.channel[_e], [n, t, s]);
      }
      function handleMessage(n, t, i) {
        if (!e.channel) return;
        const o = i ? "internalMessage" : "message";
        s.nextTick(emit, o, n, t);
      }
      return (
        r(t),
        (t.pendingHandle = null),
        (t.onread = function (n) {
          const s = t.pendingHandle;
          if (((t.pendingHandle = null), n)) {
            const e = K[U],
              i = K[W],
              o = new m(n, i, e);
            s && (h = s);
            for (const e of c(t, o))
              isInternal(e)
                ? "NODE_HANDLE" === e.cmd
                  ? (handleMessage(e, h, !0), (h = null))
                  : handleMessage(e, void 0, !0)
                : handleMessage(e, void 0, !1);
          } else
            (this.buffering = !1),
              e.disconnect(),
              (t.onread = ke),
              t.close(),
              (e.channel = null),
              maybeClose(e);
        }),
        (t.sockets = { got: {}, send: {} }),
        e.on("internalMessage", function (n, t) {
          if ("NODE_HANDLE_ACK" === n.cmd || "NODE_HANDLE_NACK" === n.cmd) {
            e._pendingMessage &&
              ("NODE_HANDLE_ACK" === n.cmd
                ? closePendingHandle(e)
                : 3 == e._pendingMessage.retransmissions++ &&
                  (closePendingHandle(e),
                  s.emitWarning(
                    "Handle did not reach the receiving process correctly",
                    "SentHandleNotReceivedWarning"
                  ))),
              x(l(e._handleQueue));
            const t = e._handleQueue;
            (e._handleQueue = null),
              e._pendingMessage &&
                e._send(
                  e._pendingMessage.message,
                  e._pendingMessage.handle,
                  e._pendingMessage.options,
                  e._pendingMessage.callback
                );
            for (let n = 0; n < t.length; n++) {
              const s = t[n];
              e._send(s.message, s.handle, s.options, s.callback);
            }
            return void (
              e.connected ||
              !e.channel ||
              e._handleQueue ||
              e._disconnect()
            );
          }
          if ("NODE_HANDLE" !== n.cmd) return;
          if (!t) return e._send({ cmd: "NODE_HANDLE_NACK" }, null, !0);
          e._send({ cmd: "NODE_HANDLE_ACK" }, null, !0);
          const i = ye[n.type];
          "win32" === s.platform && t.setSimultaneousAccepts(!1),
            i.got.call(this, n, t, (e) => {
              handleMessage(n.msg, e, isInternal(n.msg));
            });
        }),
        e.on("newListener", function () {
          s.nextTick(() => {
            if (!e.channel || !e.listenerCount("message")) return;
            const n = e.channel[_e],
              { length: t } = n;
            if (t) {
              for (let s = 0; s < t; s++) f(e.emit, e, n[s]);
              e.channel[_e] = [];
            }
          });
        }),
        (e.send = function (e, n, t, i) {
          if (
            ("function" == typeof n
              ? ((i = n), (n = void 0), (t = void 0))
              : "function" == typeof t
              ? ((i = t), (t = void 0))
              : void 0 !== t && D(t, "options"),
            (t = { swallowErrors: !1, ...t }),
            this.connected)
          )
            return this._send(e, n, t, i);
          const o = new N();
          return (
            "function" == typeof i
              ? s.nextTick(i, o)
              : s.nextTick(() => this.emit("error", o)),
            !1
          );
        }),
        (e._send = function (n, i, l, r) {
          if ((x(this.connected || this.channel), void 0 === n))
            throw new b("message");
          if (
            "string" != typeof n &&
            "object" != typeof n &&
            "number" != typeof n &&
            "boolean" != typeof n
          )
            throw new S(
              "message",
              ["string", "object", "number", "boolean"],
              n
            );
          let c;
          if (("boolean" == typeof l && (l = { swallowErrors: l }), i)) {
            if (
              ((n = { cmd: "NODE_HANDLE", type: null, msg: n }),
              i instanceof M.Socket)
            )
              n.type = "net.Socket";
            else if (i instanceof M.Server) n.type = "net.Server";
            else if (i instanceof Y || i instanceof G) n.type = "net.Native";
            else if (i instanceof L.Socket) n.type = "dgram.Socket";
            else {
              if (!(i instanceof B)) throw new E();
              n.type = "dgram.Native";
            }
            if (this._handleQueue)
              return (
                a(this._handleQueue, {
                  callback: r,
                  handle: i,
                  options: l,
                  message: n.msg,
                }),
                1 === this._handleQueue.length
              );
            (c = ye[n.type]),
              (i = f(ye[n.type].send, e, [n, i, l])) || (n = n.msg),
              c.simultaneousAccepts &&
                "win32" === s.platform &&
                i.setSimultaneousAccepts(!0);
          } else if (
            this._handleQueue &&
            (!n ||
              ("NODE_HANDLE_ACK" !== n.cmd && "NODE_HANDLE_NACK" !== n.cmd))
          )
            return (
              a(this._handleQueue, {
                callback: r,
                handle: null,
                options: l,
                message: n,
              }),
              1 === this._handleQueue.length
            );
          const h = new Q(),
            p = d(t, h, n, i),
            u = K[F];
          if (0 === p)
            i &&
              (this._handleQueue || (this._handleQueue = []),
              c && c.postSend && c.postSend(n, i, l, r, e)),
              u
                ? ((h.oncomplete = () => {
                    o.unrefCounted(), "function" == typeof r && r(null);
                  }),
                  o.refCounted())
                : "function" == typeof r && s.nextTick(r, null);
          else if (
            (c && c.postSend && c.postSend(n, i, l, r), !l.swallowErrors)
          ) {
            const e = w(p, "write");
            "function" == typeof r
              ? s.nextTick(r, e)
              : s.nextTick(() => this.emit("error", e));
          }
          return t.writeQueueSize < 131072;
        }),
        (e.connected = !0),
        (e.disconnect = function () {
          this.connected
            ? ((this.connected = !1), this._handleQueue || this._disconnect())
            : this.emit("error", new v());
        }),
        (e._disconnect = function () {
          x(this.channel),
            (this.channel = null),
            (this[fe] = null),
            this._pendingMessage && closePendingHandle(this);
          let n = !1;
          function finish() {
            n || ((n = !0), t.close(), e.emit("disconnect"));
          }
          if (t.buffering)
            return (
              this.once("message", finish),
              void this.once("internalMessage", finish)
            );
          s.nextTick(finish);
        }),
        t.readStart(),
        o
      );
    }
    const Se = "NODE_";
    function isInternal(e) {
      return (
        null !== e &&
        "object" == typeof e &&
        "string" == typeof e.cmd &&
        e.cmd.length > Se.length &&
        g(e.cmd, 0, Se.length) === Se
      );
    }
    const ke = d;
    function getValidStdio(e, n) {
      let t, s;
      if ("string" == typeof e) e = stdioStringToArray(e);
      else if (!l(e)) throw new k("stdio", e);
      for (; e.length < 3; ) a(e, void 0);
      return {
        stdio: (e = r(
          e,
          (e, i, o) => {
            function cleanup() {
              for (let n = 0; n < e.length; n++)
                ("pipe" !== e[n].type && "ipc" !== e[n].type) ||
                  !e[n].handle ||
                  e[n].handle.close();
            }
            if ((null == i && (i = o < 3 ? "pipe" : "ignore"), "ignore" === i))
              a(e, { type: "ignore" });
            else if (
              "pipe" === i ||
              "overlapped" === i ||
              ("number" == typeof i && i < 0)
            ) {
              const t = {
                type: "overlapped" === i ? "overlapped" : "pipe",
                readable: 0 === o,
                writable: 0 !== o,
              };
              n || (t.handle = new G(j.SOCKET)), a(e, t);
            } else if ("ipc" === i) {
              if (n || void 0 !== t) throw (cleanup(), n ? new P() : new A());
              (t = new G(j.IPC)),
                (s = o),
                a(e, { type: "pipe", handle: t, ipc: !0 });
            } else if ("inherit" === i) a(e, { type: "inherit", fd: o });
            else if ("number" == typeof i || "number" == typeof i.fd)
              a(e, { type: "fd", fd: "number" == typeof i ? i : i.fd });
            else if (
              getHandleWrapType(i) ||
              getHandleWrapType(i.handle) ||
              getHandleWrapType(i._handle)
            ) {
              const n = getHandleWrapType(i)
                ? i
                : getHandleWrapType(i.handle)
                ? i.handle
                : i._handle;
              a(e, {
                type: "wrap",
                wrapType: getHandleWrapType(n),
                handle: n,
                _stdio: i,
              });
            } else {
              if (!X(i) && "string" != typeof i)
                throw (cleanup(), new k("stdio", i));
              if (!n) throw (cleanup(), new C(R(i)));
            }
            return e;
          },
          []
        )),
        ipc: t,
        ipcFd: s,
      };
    }
    function getSocketList(e, n, t) {
      const s = n[fe].sockets[e];
      let i = s[t];
      if (!i) {
        const o = "send" === e ? de : he;
        i = s[t] = new o(n, t);
      }
      return i;
    }
    function maybeClose(e) {
      e._closesGot++,
        e._closesGot === e._closesNeeded &&
          e.emit("close", e.exitCode, e.signalCode);
    }
    t.exports = {
      ChildProcess: ChildProcess,
      kChannelHandle: fe,
      setupChannel: setupChannel,
      getValidStdio: getValidStdio,
      stdioStringToArray: stdioStringToArray,
      spawnSync: function spawnSync(e) {
        const n = ee.spawn(e);
        if (n.output && e.encoding && "buffer" !== e.encoding)
          for (let t = 0; t < n.output.length; t++)
            n.output[t] && (n.output[t] = n.output[t].toString(e.encoding));
        return (
          (n.stdout = n.output && n.output[1]),
          (n.stderr = n.output && n.output[2]),
          n.error &&
            ((n.error = w(n.error, "spawnSync " + e.file)),
            (n.error.path = e.file),
            (n.error.spawnargs = c(e.args, 1))),
          n
        );
      },
    };
  },
  "internal/child_process/serialization": function (e, r, t, s, i, n) {
    "use strict";
    const {
        JSONParse: a,
        JSONStringify: l,
        StringPrototypeSplit: f,
        ArrayPrototypePush: o,
        Symbol: u,
        TypedArrayPrototypeSubarray: c,
      } = n,
      { Buffer: g } = r("buffer"),
      { StringDecoder: d } = r("string_decoder"),
      h = r("v8"),
      { isArrayBufferView: w } = r("internal/util/types"),
      S = r("internal/assert"),
      { streamBaseState: y, kLastWriteWasAsync: b } = i("stream_wrap"),
      p = u("kMessageBuffer"),
      C = u("kMessageBufferSize"),
      B = u("kJSONBuffer"),
      P = u("kStringDecoder");
    class ChildProcessSerializer extends h.DefaultSerializer {
      _writeHostObject(e) {
        if (w(e)) return this.writeUint32(0), super._writeHostObject(e);
        this.writeUint32(1), this.writeValue({ ...e });
      }
    }
    class ChildProcessDeserializer extends h.DefaultDeserializer {
      _readHostObject() {
        const e = this.readUint32();
        return 0 === e
          ? super._readHostObject()
          : (S(1 === e), this.readValue());
      }
    }
    const _ = {
        initMessageChannel(e) {
          (e[p] = []), (e[C] = 0), (e.buffering = !1);
        },
        *parseChannelMessages(e, r) {
          if (0 === r.length) return;
          o(e[p], r), (e[C] += r.length);
          let t = e[p][0];
          for (; t.length >= 4; ) {
            const r = 4 + ((t[0] << 24) | (t[1] << 16) | (t[2] << 8) | t[3]);
            if (e[C] < r) break;
            const s = 1 === e[p].length ? e[p][0] : g.concat(e[p], e[C]),
              i = new ChildProcessDeserializer(c(s, 4, r));
            (t = c(s, r)),
              (e[C] = t.length),
              (e[p] = 0 !== e[C] ? [t] : []),
              i.readHeader(),
              yield i.readValue();
          }
          e.buffering = e[C] > 0;
        },
        writeChannelMessage(e, r, t, s) {
          const i = new ChildProcessSerializer();
          i.writeRawBytes(g.allocUnsafe(4)), i.writeHeader(), i.writeValue(t);
          const n = i.releaseBuffer(),
            a = n.length - 4;
          n.set([(a >> 24) & 255, (a >> 16) & 255, (a >> 8) & 255, 255 & a], 0);
          const l = e.writeBuffer(r, n, s);
          return y[b] && (r.buffer = n), l;
        },
      },
      D = {
        initMessageChannel(e) {
          (e[B] = ""), (e[P] = void 0);
        },
        *parseChannelMessages(e, r) {
          if (0 === r.length) return;
          void 0 === e[P] && (e[P] = new d("utf8"));
          const t = f(e[P].write(r), "\n"),
            s = t.length - 1,
            i = t[s];
          if (0 === s) e[B] += i;
          else {
            t[0] = e[B] + t[0];
            for (let e = 0; e < s; e++) yield a(t[e]);
            e[B] = i;
          }
          e.buffering = 0 !== e[B].length;
        },
        writeChannelMessage(e, r, t, s) {
          const i = l(t) + "\n";
          return e.writeUtf8String(r, i, s);
        },
      };
    t.exports = { advanced: _, json: D };
  },
  "internal/cli_table": function (t, n, e, o, r, l) {
    "use strict";
    const {
        ArrayPrototypeJoin: s,
        ArrayPrototypeMap: a,
        MathCeil: c,
        MathMax: i,
        MathMaxApply: p,
        ObjectPrototypeHasOwnProperty: h,
        StringPrototypeRepeat: y,
      } = l,
      { getStringWidth: g } = n("internal/util/inspect"),
      f = "─",
      M = "┼",
      u = "┐",
      P = "┌",
      x = "├",
      A = "┬",
      _ = "┘",
      d = "└",
      O = "┴",
      S = "┤",
      b = "│ ",
      j = " │",
      v = " │ ",
      renderRow = (t, n) => {
        let e = b;
        for (let o = 0; o < t.length; o++) {
          const r = t[o],
            l = g(r),
            s = (n[o] - l) / 2;
          (e += y(" ", s) + r + y(" ", c(s))), o !== t.length - 1 && (e += v);
        }
        return (e += j), e;
      };
    e.exports = (t, n) => {
      const e = [],
        o = a(t, (t) => g(t)),
        r = p(a(n, (t) => t.length));
      for (let l = 0; l < t.length; l++) {
        const t = n[l];
        for (let n = 0; n < r; n++) {
          void 0 === e[n] && (e[n] = []);
          const r = (e[n][l] = h(t, n) ? t[n] : ""),
            s = o[l] || 0,
            a = g(r);
          o[l] = i(s, a);
        }
      }
      const l = a(o, (t) => y(f, t + 2));
      let c =
        P +
        s(l, A) +
        u +
        "\n" +
        renderRow(t, o) +
        "\n" +
        x +
        s(l, M) +
        S +
        "\n";
      for (const t of e) c += `${renderRow(t, o)}\n`;
      return (c += d + s(l, O) + _), c;
    };
  },
  "internal/cluster/child": function (e, n, t, s, o, c) {
    "use strict";
    const {
        ArrayPrototypeJoin: i,
        FunctionPrototype: r,
        ObjectAssign: a,
        ReflectApply: d,
        SafeMap: l,
        SafeSet: u,
      } = c,
      f = n("internal/assert"),
      y = n("path"),
      x = n("events"),
      { owner_symbol: g } = n("internal/async_hooks").symbols,
      p = n("internal/cluster/worker"),
      { internal: h, sendHelper: k } = n("internal/cluster/utils"),
      { TIMEOUT_MAX: m } = n("internal/timers"),
      { setInterval: v, clearInterval: _ } = n("timers"),
      w = new x(),
      D = new l(),
      I = new l(),
      A = r;
    function removeIndexesKey(e, n) {
      const t = I.get(e);
      t && (t.set.delete(n), 0 === t.set.size && I.delete(e));
    }
    function send(e, n) {
      return k(s, e, null, n);
    }
    function _disconnect(e) {
      this.exitedAfterDisconnect = !0;
      let n = 1;
      function checkWaitingCount() {
        n--,
          0 === n &&
            (e
              ? s.disconnect()
              : send({ act: "exitedAfterDisconnect" }, () => s.disconnect()));
      }
      D.forEach((e) => {
        n++, e[g] ? e[g].close(checkWaitingCount) : e.close(checkWaitingCount);
      }),
        D.clear(),
        checkWaitingCount();
    }
    (t.exports = w),
      (w.isWorker = !0),
      (w.isMaster = !1),
      (w.isPrimary = !1),
      (w.worker = null),
      (w.Worker = p),
      (w._setupWorker = function () {
        const e = new p({
          id: 0 | +s.env.NODE_UNIQUE_ID,
          process: s,
          state: "online",
        });
        (w.worker = e),
          s.once("disconnect", () => {
            e.emit("disconnect"), e.exitedAfterDisconnect || s.exit(0);
          }),
          s.on(
            "internalMessage",
            h(e, function onmessage(n, t) {
              "newconn" === n.act
                ? (function onconnection(e, n) {
                    const t = e.key,
                      s = D.get(t);
                    let o = void 0 !== s;
                    if (o && s[g]) {
                      const e = s[g];
                      e.maxConnections &&
                        e._connections >= e.maxConnections &&
                        (o = !1);
                    }
                    send({ ack: e.seq, accepted: o }),
                      o ? s.onconnection(0, n) : n.close();
                  })(n, t)
                : "disconnect" === n.act && d(_disconnect, e, [!0]);
            })
          ),
          send({ act: "online" });
      }),
      (w._getServer = function (e, n, t) {
        let o = n.address;
        n.port < 0 &&
          "string" == typeof o &&
          "win32" !== s.platform &&
          (o = y.resolve(o));
        const c = i([o, n.port, n.addressType, n.fd], ":");
        let r = I.get(c);
        void 0 === r && ((r = { nextIndex: 0, set: new u() }), I.set(c, r));
        const l = r.nextIndex++;
        r.set.add(l);
        const x = { act: "queryServer", index: l, data: null, ...n };
        (x.address = o),
          e._getServerData && (x.data = e._getServerData()),
          send(x, (n, s) => {
            "function" == typeof e._setServerData && e._setServerData(n.data),
              s
                ? (function shared(
                    e,
                    { handle: n, indexesKey: t, index: s },
                    o
                  ) {
                    const c = e.key,
                      i = n.close;
                    (n.close = function () {
                      return (
                        send({ act: "close", key: c }),
                        D.delete(c),
                        removeIndexesKey(t, s),
                        d(i, n, arguments)
                      );
                    }),
                      f(!1 === D.has(c)),
                      D.set(c, n),
                      o(e.errno, n);
                  })(n, { handle: s, indexesKey: c, index: l }, t)
                : (function rr(e, { indexesKey: n, index: t }, s) {
                    if (e.errno) return s(e.errno, null);
                    let o = e.key,
                      c = null;
                    function ref() {
                      c || (c = v(A, m));
                    }
                    function unref() {
                      c && (_(c), (c = null));
                    }
                    function listen(e) {
                      return 0;
                    }
                    function close() {
                      void 0 !== o &&
                        (unref(),
                        send({ act: "close", key: o }),
                        D.delete(o),
                        removeIndexesKey(n, t),
                        (o = void 0));
                    }
                    function getsockname(n) {
                      return o && a(n, e.sockname), 0;
                    }
                    const i = {
                      close: close,
                      listen: listen,
                      ref: ref,
                      unref: unref,
                    };
                    i.ref(), e.sockname && (i.getsockname = getsockname);
                    f(!1 === D.has(o)), D.set(o, i), s(0, i);
                  })(n, { indexesKey: c, index: l }, t);
          }),
          e.once("listening", () => {
            if (!I.has(c)) return;
            w.worker.state = "listening";
            const t = e.address();
            (x.act = "listening"), (x.port = (t && t.port) || n.port), send(x);
          });
      }),
      (p.prototype.disconnect = function () {
        return (
          "disconnecting" !== this.state &&
            "destroying" !== this.state &&
            ((this.state = "disconnecting"), d(_disconnect, this, [])),
          this
        );
      }),
      (p.prototype.destroy = function () {
        "destroying" !== this.state &&
          ((this.exitedAfterDisconnect = !0),
          this.isConnected()
            ? ((this.state = "destroying"),
              send({ act: "exitedAfterDisconnect" }, () => s.disconnect()),
              s.once("disconnect", () => s.exit(0)))
            : s.exit(0));
      });
  },
  "internal/cluster/primary": function (e, t, n, s, i, r) {
    "use strict";
    const {
        ArrayPrototypePush: o,
        ArrayPrototypeSlice: c,
        ArrayPrototypeSome: d,
        ObjectKeys: a,
        ObjectValues: l,
        SafeMap: g,
        StringPrototypeStartsWith: u,
      } = r,
      {
        codes: { ERR_SOCKET_BAD_PORT: f },
      } = t("internal/errors"),
      p = t("internal/assert"),
      { fork: m } = t("child_process"),
      k = t("path"),
      v = t("events"),
      y = t("internal/cluster/round_robin_handle"),
      x = t("internal/cluster/shared_handle"),
      h = t("internal/cluster/worker"),
      { getInspectPort: w, isUsingInspector: A } = t("internal/util/inspector"),
      { internal: D, sendHelper: P } = t("internal/cluster/utils"),
      _ = new v(),
      T = new v();
    n.exports = _;
    const E = new g();
    (_.isWorker = !1),
      (_.isMaster = !0),
      (_.isPrimary = !0),
      (_.Worker = h),
      (_.workers = {}),
      (_.settings = {}),
      (_.SCHED_NONE = 1),
      (_.SCHED_RR = 2);
    let S = 0,
      N = !1,
      W = s.env.NODE_CLUSTER_SCHED_POLICY;
    function setupSettingsNT(e) {
      _.emit("setup", e);
    }
    function removeWorker(e) {
      p(e),
        delete _.workers[e.id],
        0 === a(_.workers).length &&
          (p(0 === E.size, "Resource leak detected."), T.emit("disconnect"));
    }
    function removeHandlesForWorker(e) {
      p(e),
        E.forEach((t, n) => {
          t.remove(e) && E.delete(n);
        });
    }
    function emitForkNT(e) {
      _.emit("fork", e);
    }
    (W = "rr" === W ? 2 : "none" === W || "win32" === s.platform ? 1 : 2),
      (_.schedulingPolicy = W),
      (_.setupPrimary = function (e) {
        const t = {
          args: c(s.argv, 2),
          exec: s.argv[1],
          execArgv: s.execArgv,
          silent: !1,
          ..._.settings,
          ...e,
        };
        if (
          (d(t.execArgv, (e) => u(e, "--prof")) &&
            !d(t.execArgv, (e) => u(e, "--logfile=")) &&
            (t.execArgv = [...t.execArgv, "--logfile=v8-%p.log"]),
          (_.settings = t),
          !0 === N)
        )
          return s.nextTick(setupSettingsNT, t);
        (N = !0),
          (W = _.schedulingPolicy),
          p(1 === W || 2 === W, `Bad cluster.schedulingPolicy: ${W}`),
          s.nextTick(setupSettingsNT, t),
          s.on("internalMessage", (e) => {
            if ("NODE_DEBUG_ENABLED" === e.cmd)
              for (const e of l(_.workers))
                "online" === e.state || "listening" === e.state
                  ? s._debugProcess(e.process.pid)
                  : e.once("online", function () {
                      s._debugProcess(this.process.pid);
                    });
          });
      }),
      (_.setupMaster = _.setupPrimary),
      (_.fork = function (e) {
        _.setupPrimary();
        const t = ++S,
          n = (function createWorkerProcess(e, t) {
            const n = { ...s.env, ...t, NODE_UNIQUE_ID: `${e}` },
              i = [..._.settings.execArgv];
            if (null === _.settings.inspectPort) throw new f("Port", null, !0);
            return (
              A(_.settings.execArgv) &&
                o(i, `--inspect-port=${w(_.settings.inspectPort)}`),
              m(_.settings.exec, _.settings.args, {
                cwd: _.settings.cwd,
                env: n,
                serialization: _.settings.serialization,
                silent: _.settings.silent,
                windowsHide: _.settings.windowsHide,
                execArgv: i,
                stdio: _.settings.stdio,
                gid: _.settings.gid,
                uid: _.settings.uid,
              })
            );
          })(t, e),
          i = new h({ id: t, process: n });
        return (
          i.on("message", function (e, t) {
            _.emit("message", this, e, t);
          }),
          i.process.once("exit", (e, t) => {
            i.isConnected() || (removeHandlesForWorker(i), removeWorker(i)),
              (i.exitedAfterDisconnect = !!i.exitedAfterDisconnect),
              (i.state = "dead"),
              i.emit("exit", e, t),
              _.emit("exit", i, e, t);
          }),
          i.process.once("disconnect", () => {
            removeHandlesForWorker(i),
              i.isDead() && removeWorker(i),
              (i.exitedAfterDisconnect = !!i.exitedAfterDisconnect),
              (i.state = "disconnected"),
              i.emit("disconnect"),
              _.emit("disconnect", i);
          }),
          i.process.on("internalMessage", D(i, onmessage)),
          s.nextTick(emitForkNT, i),
          (_.workers[i.id] = i),
          i
        );
      }),
      (_.disconnect = function (e) {
        if (0 === a(_.workers).length) s.nextTick(() => T.emit("disconnect"));
        else for (const e of l(_.workers)) e.isConnected() && e.disconnect();
        "function" == typeof e && T.once("disconnect", e);
      });
    const H = {
      close: function close(e, t) {
        const n = t.key,
          s = E.get(n);
        s && s.remove(e) && E.delete(n);
      },
      exitedAfterDisconnect: function exitedAfterDisconnect(e, t) {
        (e.exitedAfterDisconnect = !0), send(e, { ack: t.seq });
      },
      listening: function listening(e, t) {
        const n = {
          addressType: t.addressType,
          address: t.address,
          port: t.port,
          fd: t.fd,
        };
        (e.state = "listening"),
          e.emit("listening", n),
          _.emit("listening", e, n);
      },
      online: function online(e) {
        (e.state = "online"), e.emit("online"), _.emit("online", e);
      },
      queryServer: function queryServer(e, t) {
        if (e.exitedAfterDisconnect) return;
        const n = `${t.address}:${t.port}:${t.addressType}:${t.fd}:${t.index}`;
        let i = E.get(n);
        if (void 0 === i) {
          let e = t.address;
          t.port < 0 &&
            "string" == typeof e &&
            "win32" !== s.platform &&
            ((e = k.relative(s.cwd(), e)),
            t.address.length < e.length && (e = t.address)),
            (i =
              2 !== W || "udp4" === t.addressType || "udp6" === t.addressType
                ? new x(n, e, t)
                : new y(n, e, t)),
            E.set(n, i);
        }
        i.data || (i.data = t.data);
        i.add(e, (s, i, r) => {
          const { data: o } = E.get(n);
          s && E.delete(n),
            send(e, { errno: s, key: n, ack: t.seq, data: o, ...i }, r);
        });
      },
    };
    function onmessage(e, t) {
      const n = H[e.act];
      "function" == typeof n && n(this, e);
    }
    function send(e, t, n, s) {
      return P(e.process, t, n, s);
    }
    (h.prototype.disconnect = function () {
      return (
        (this.exitedAfterDisconnect = !0),
        send(this, { act: "disconnect" }),
        removeHandlesForWorker(this),
        removeWorker(this),
        this
      );
    }),
      (h.prototype.destroy = function (e) {
        const t = e || "SIGTERM";
        this.process.kill(t);
      });
  },
  "internal/cluster/round_robin_handle": function (e, t, n, s, l, i) {
    "use strict";
    const { ArrayIsArray: r, Boolean: o, ObjectCreate: a, SafeMap: h } = i,
      d = t("internal/assert"),
      c = t("net"),
      { sendHelper: u } = t("internal/cluster/utils"),
      {
        append: f,
        init: p,
        isEmpty: b,
        peek: v,
        remove: k,
      } = t("internal/linkedlist"),
      { constants: R } = l("tcp_wrap");
    function RoundRobinHandle(
      e,
      t,
      { port: n, fd: s, flags: l, backlog: i, readableAll: r, writableAll: u }
    ) {
      (this.key = e),
        (this.all = new h()),
        (this.free = new h()),
        (this.handles = p(a(null))),
        (this.handle = null),
        (this.server = c.createServer(d.fail)),
        s >= 0
          ? this.server.listen({ fd: s, backlog: i })
          : n >= 0
          ? this.server.listen({
              port: n,
              host: t,
              ipv6Only: o(l & R.UV_TCP_IPV6ONLY),
              backlog: i,
            })
          : this.server.listen({
              path: t,
              backlog: i,
              readableAll: r,
              writableAll: u,
            }),
        this.server.once("listening", () => {
          (this.handle = this.server._handle),
            (this.handle.onconnection = (e, t) => this.distribute(e, t)),
            (this.server._handle = null),
            (this.server = null);
        });
    }
    (n.exports = RoundRobinHandle),
      (RoundRobinHandle.prototype.add = function (e, t) {
        d(!1 === this.all.has(e.id)), this.all.set(e.id, e);
        const done = () => {
          if (this.handle.getsockname) {
            const e = {};
            this.handle.getsockname(e), t(null, { sockname: e }, null);
          } else t(null, null, null);
          this.handoff(e);
        };
        if (null === this.server) return done();
        this.server.once("listening", done),
          this.server.once("error", (e) => {
            t(e.errno, null);
          });
      }),
      (RoundRobinHandle.prototype.remove = function (e) {
        if (!this.all.delete(e.id)) return !1;
        if ((this.free.delete(e.id), 0 !== this.all.size)) return !1;
        for (; !b(this.handles); ) {
          const e = v(this.handles);
          e.close(), k(e);
        }
        return this.handle.close(), (this.handle = null), !0;
      }),
      (RoundRobinHandle.prototype.distribute = function (e, t) {
        if (e) return;
        f(this.handles, t);
        const [n] = this.free;
        if (r(n)) {
          const { 0: e, 1: t } = n;
          this.free.delete(e), this.handoff(t);
        }
      }),
      (RoundRobinHandle.prototype.handoff = function (e) {
        if (!this.all.has(e.id)) return;
        const t = v(this.handles);
        if (null === t) return void this.free.set(e.id, e);
        k(t);
        const n = { act: "newconn", key: this.key };
        u(e.process, n, t, (n) => {
          n.accepted ? t.close() : this.distribute(0, t), this.handoff(e);
        });
      });
  },
  "internal/cluster/shared_handle": function (e, r, t, s, n, a) {
    "use strict";
    const { SafeMap: d } = a,
      i = r("internal/assert"),
      h = r("internal/dgram"),
      o = r("net");
    function SharedHandle(e, r, { port: t, addressType: s, fd: n, flags: a }) {
      let i;
      (this.key = e),
        (this.workers = new d()),
        (this.handle = null),
        (this.errno = 0),
        (i =
          "udp4" === s || "udp6" === s
            ? h._createSocketHandle(r, t, s, n, a)
            : o._createServerHandle(r, t, s, n, a)),
        "number" == typeof i ? (this.errno = i) : (this.handle = i);
    }
    (t.exports = SharedHandle),
      (SharedHandle.prototype.add = function (e, r) {
        i(!this.workers.has(e.id)),
          this.workers.set(e.id, e),
          r(this.errno, null, this.handle);
      }),
      (SharedHandle.prototype.remove = function (e) {
        return (
          !!this.workers.has(e.id) &&
          (this.workers.delete(e.id),
          0 === this.workers.size &&
            (this.handle.close(), (this.handle = null), !0))
        );
      });
  },
  "internal/cluster/utils": function (e, n, t, c, r, o) {
    "use strict";
    const { ReflectApply: i, SafeMap: s } = o;
    t.exports = {
      sendHelper: function sendHelper(e, n, t, c) {
        if (!e.connected) return !1;
        (n = { cmd: "NODE_CLUSTER", ...n, seq: l }),
          "function" == typeof c && f.set(l, c);
        return (l += 1), e.send(n, t);
      },
      internal: function internal(e, n) {
        return function onInternalMessage(t, c) {
          if ("NODE_CLUSTER" !== t.cmd) return;
          let r = n;
          if (void 0 !== t.ack) {
            const e = f.get(t.ack);
            void 0 !== e && ((r = e), f.delete(t.ack));
          }
          i(r, e, arguments);
        };
      },
    };
    const f = new s();
    let l = 0;
  },
  "internal/cluster/worker": function (e, t, o, r, s, i) {
    "use strict";
    const { ObjectSetPrototypeOf: n, ReflectApply: c } = i,
      p = t("events"),
      { kEmptyObject: h } = t("internal/util");
    function Worker(e) {
      if (!(this instanceof Worker)) return new Worker(e);
      c(p, this, []),
        (null !== e && "object" == typeof e) || (e = h),
        (this.exitedAfterDisconnect = void 0),
        (this.state = e.state || "none"),
        (this.id = 0 | e.id),
        e.process &&
          ((this.process = e.process),
          this.process.on("error", (e, t) => this.emit("error", e, t)),
          this.process.on("message", (e, t) => this.emit("message", e, t)));
    }
    (o.exports = Worker),
      n(Worker.prototype, p.prototype),
      n(Worker, p),
      (Worker.prototype.kill = function () {
        c(this.destroy, this, arguments);
      }),
      (Worker.prototype.send = function () {
        return c(this.process.send, this.process, arguments);
      }),
      (Worker.prototype.isDead = function () {
        return null != this.process.exitCode || null != this.process.signalCode;
      }),
      (Worker.prototype.isConnected = function () {
        return this.process.connected;
      });
  },
  "internal/console/constructor": function (t, o, e, r, n, s) {
    "use strict";
    const {
        ArrayFrom: i,
        ArrayIsArray: l,
        ArrayPrototypeForEach: a,
        ArrayPrototypePush: u,
        ArrayPrototypeUnshift: c,
        Boolean: _,
        ErrorCaptureStackTrace: p,
        FunctionPrototypeBind: d,
        MathFloor: f,
        Number: h,
        NumberPrototypeToFixed: m,
        ObjectCreate: g,
        ObjectDefineProperties: y,
        ObjectDefineProperty: C,
        ObjectKeys: v,
        ObjectPrototypeHasOwnProperty: b,
        ObjectValues: E,
        ReflectApply: S,
        ReflectConstruct: w,
        ReflectOwnKeys: A,
        RegExpPrototypeSymbolReplace: $,
        SafeArrayIterator: I,
        SafeMap: R,
        SafeWeakMap: P,
        SafeSet: O,
        StringPrototypeIncludes: k,
        StringPrototypePadStart: L,
        StringPrototypeRepeat: T,
        StringPrototypeSlice: W,
        StringPrototypeSplit: B,
        Symbol: H,
        SymbolHasInstance: M,
        SymbolToStringTag: j,
      } = s,
      { trace: F } = n("trace_events"),
      {
        isStackOverflowError: x,
        codes: {
          ERR_CONSOLE_WRITABLE_STREAM: N,
          ERR_INVALID_ARG_VALUE: z,
          ERR_INCOMPATIBLE_OPTION_PAIR: G,
        },
      } = o("internal/errors"),
      {
        validateArray: U,
        validateInteger: D,
        validateObject: V,
      } = o("internal/validators"),
      { previewEntries: K } = n("util"),
      {
        Buffer: { isBuffer: Y },
      } = o("buffer"),
      { inspect: q, formatWithOptions: J } = o("internal/util/inspect"),
      {
        isTypedArray: Q,
        isSet: X,
        isMap: Z,
        isSetIterator: tt,
        isMapIterator: ot,
      } = o("internal/util/types"),
      {
        CHAR_LOWERCASE_B: et,
        CHAR_LOWERCASE_E: rt,
        CHAR_LOWERCASE_N: nt,
        CHAR_UPPERCASE_C: st,
      } = o("internal/constants"),
      it = H("counts"),
      lt = "node,node.console",
      at = 1e3,
      ut = 60 * at,
      ct = 60 * ut,
      _t = 1e3;
    let pt, dt;
    const ft = H("kGroupIndent"),
      ht = H("kGroupIndentWidth"),
      mt = H("kFormatForStderr"),
      gt = H("kFormatForStdout"),
      yt = H("kGetInspectOptions"),
      Ct = H("kColorMode"),
      vt = H("kIsConsole"),
      bt = H("kWriteToConsole"),
      Et = H("kBindProperties"),
      St = H("kBindStreamsEager"),
      wt = H("kBindStreamsLazy"),
      At = H("kUseStdout"),
      $t = H("kUseStderr"),
      It = new P();
    function Console(t) {
      if (void 0 === new.target) return w(Console, arguments);
      (t && "function" != typeof t.write) ||
        (t = { stdout: t, stderr: arguments[1], ignoreErrors: arguments[2] });
      const {
        stdout: o,
        stderr: e = o,
        ignoreErrors: r = !0,
        colorMode: n = "auto",
        inspectOptions: s,
        groupIndentation: i,
      } = t;
      if (!o || "function" != typeof o.write) throw new N("stdout");
      if (!e || "function" != typeof e.write) throw new N("stderr");
      if ("boolean" != typeof n && "auto" !== n) throw new z("colorMode", n);
      if ((void 0 !== i && D(i, "groupIndentation", 0, _t), void 0 !== s)) {
        if (
          (V(s, "options.inspectOptions"),
          void 0 !== s.colors && void 0 !== t.colorMode)
        )
          throw new G("options.inspectOptions.color", "colorMode");
        It.set(this, s);
      }
      a(v(Console.prototype), (t) => {
        (this[t] = d(this[t], this)),
          C(this[t], "name", { __proto__: null, value: t });
      }),
        this[St](o, e),
        this[Et](r, n, i);
    }
    const Rt = { writable: !0, enumerable: !1, configurable: !0 };
    C(Console, M, { __proto__: null, value: (t) => t[vt] });
    const Pt = { colors: !0 },
      Ot = {};
    function createWriteErrorHandler(t, o) {
      return (e) => {
        const r = o === At ? t._stdout : t._stderr;
        null === e ||
          r._writableState.errorEmitted ||
          (0 === r.listenerCount("error") && r.once("error", noop));
      };
    }
    y(Console.prototype, {
      [St]: {
        __proto__: null,
        ...Rt,
        value: function (t, o) {
          y(this, {
            _stdout: { __proto__: null, ...Rt, value: t },
            _stderr: { __proto__: null, ...Rt, value: o },
          });
        },
      },
      [wt]: {
        __proto__: null,
        ...Rt,
        value: function (t) {
          let o, e;
          y(this, {
            _stdout: {
              __proto__: null,
              enumerable: !1,
              configurable: !0,
              get: () => (o || (o = t.stdout), o),
              set(t) {
                o = t;
              },
            },
            _stderr: {
              __proto__: null,
              enumerable: !1,
              configurable: !0,
              get: () => (e || (e = t.stderr), e),
              set(t) {
                e = t;
              },
            },
          });
        },
      },
      [Et]: {
        __proto__: null,
        ...Rt,
        value: function (t, o, e = 2) {
          y(this, {
            _stdoutErrorHandler: {
              __proto__: null,
              ...Rt,
              value: createWriteErrorHandler(this, At),
            },
            _stderrErrorHandler: {
              ...Rt,
              __proto__: null,
              value: createWriteErrorHandler(this, $t),
            },
            _ignoreErrors: { __proto__: null, ...Rt, value: _(t) },
            _times: { __proto__: null, ...Rt, value: new R() },
            [it]: { __proto__: null, ...Rt, value: new R() },
            [Ct]: { __proto__: null, ...Rt, value: o },
            [vt]: { __proto__: null, ...Rt, value: !0 },
            [ft]: { __proto__: null, ...Rt, value: "" },
            [ht]: { __proto__: null, ...Rt, value: e },
            [j]: {
              __proto__: null,
              writable: !1,
              enumerable: !1,
              configurable: !0,
              value: "console",
            },
          });
        },
      },
      [bt]: {
        __proto__: null,
        ...Rt,
        value: function (t, o) {
          const e = this._ignoreErrors,
            r = this[ft],
            n = t === At,
            s = n ? this._stdout : this._stderr,
            i = n ? this._stdoutErrorHandler : this._stderrErrorHandler;
          if (
            (0 !== r.length &&
              (k(o, "\n") && (o = $(/\n/g, o, `\n${r}`)), (o = r + o)),
            (o += "\n"),
            !1 === e)
          )
            return s.write(o);
          try {
            0 === s.listenerCount("error") && s.once("error", noop),
              s.write(o, i);
          } catch (t) {
            if (x(t)) throw t;
          } finally {
            s.removeListener("error", noop);
          }
        },
      },
      [yt]: {
        __proto__: null,
        ...Rt,
        value: function (t) {
          let e = this[Ct];
          "auto" === e &&
            (e = (function lazyUtilColors() {
              return (dt ??= o("internal/util/colors")), dt;
            })().shouldColorize(t));
          const r = It.get(this);
          return r ? (void 0 === r.colors && (r.colors = e), r) : e ? Pt : Ot;
        },
      },
      [gt]: {
        __proto__: null,
        ...Rt,
        value: function (t) {
          const o = this[yt](this._stdout);
          return c(t, o), S(J, null, t);
        },
      },
      [mt]: {
        __proto__: null,
        ...Rt,
        value: function (t) {
          const o = this[yt](this._stderr);
          return c(t, o), S(J, null, t);
        },
      },
    });
    const kt = {
      log(...t) {
        this[bt](At, this[gt](t));
      },
      warn(...t) {
        this[bt]($t, this[mt](t));
      },
      dir(t, o) {
        this[bt](
          At,
          q(t, { customInspect: !1, ...this[yt](this._stdout), ...o })
        );
      },
      time(t = "default") {
        (t = `${t}`),
          this._times.has(t)
            ? r.emitWarning(`Label '${t}' already exists for console.time()`)
            : (F(et, lt, `time::${t}`, 0), this._times.set(t, r.hrtime()));
      },
      timeEnd(t = "default") {
        const o = timeLogImpl(this, "timeEnd", (t = `${t}`));
        F(rt, lt, `time::${t}`, 0), o && this._times.delete(t);
      },
      timeLog(t = "default", ...o) {
        timeLogImpl(this, "timeLog", (t = `${t}`), o),
          F(nt, lt, `time::${t}`, 0);
      },
      trace: function trace2(...t) {
        const o = { name: "Trace", message: this[mt](t) };
        p(o, trace2), this.error(o.stack);
      },
      assert(t, ...o) {
        t ||
          ((o[0] = "Assertion failed" + (0 === o.length ? "" : `: ${o[0]}`)),
          S(this.warn, this, o));
      },
      clear() {
        if (this._stdout.isTTY && "dumb" !== r.env.TERM) {
          const { cursorTo: t, clearScreenDown: e } = o(
            "internal/readline/callbacks"
          );
          t(this._stdout, 0, 0), e(this._stdout);
        }
      },
      count(t = "default") {
        t = `${t}`;
        const o = this[it];
        let e = o.get(t);
        void 0 === e ? (e = 1) : e++,
          o.set(t, e),
          F(st, lt, `count::${t}`, 0, e),
          this.log(`${t}: ${e}`);
      },
      countReset(t = "default") {
        const o = this[it];
        o.has(t)
          ? (F(st, lt, `count::${t}`, 0, 0), o.delete(`${t}`))
          : r.emitWarning(`Count for '${t}' does not exist`);
      },
      group(...t) {
        t.length > 0 && S(this.log, this, t), (this[ft] += T(" ", this[ht]));
      },
      groupEnd() {
        this[ft] = W(this[ft], 0, this[ft].length - this[ht]);
      },
      table(t, e) {
        if (
          (void 0 !== e && U(e, "properties"),
          null === t || "object" != typeof t)
        )
          return this.log(t);
        pt ??= o("internal/cli_table");
        const final = (t, o) => this.log(pt(t, o)),
          _inspect = (t) => {
            const o = {
              depth:
                null !== t &&
                "object" == typeof t &&
                !isArray(t) &&
                v(t).length > 2
                  ? -1
                  : 0,
              maxArrayLength: 3,
              breakLength: 1 / 0,
              ...this[yt](this._stdout),
            };
            return q(t, o);
          },
          getIndexArray = (t) => i({ length: t }, (t, o) => _inspect(o)),
          r = ot(t);
        let n = !1,
          s = 0;
        if (r) {
          const o = K(t, !0);
          (t = o[0]), (n = o[1]);
        }
        if (n || Z(t)) {
          const o = [],
            e = [];
          let n = 0;
          if (r)
            for (; s < t.length / 2; ++s)
              u(o, _inspect(t[2 * s])), u(e, _inspect(t[2 * s + 1])), n++;
          else
            for (const { 0: r, 1: s } of t)
              u(o, _inspect(r)), u(e, _inspect(s)), n++;
          return final([Bt, Lt, Tt], [getIndexArray(n), o, e]);
        }
        const l = tt(t);
        l && (t = K(t));
        if (l || r || X(t)) {
          const o = [];
          let e = 0;
          for (const r of t) u(o, _inspect(r)), e++;
          return final([Bt, Tt], [getIndexArray(e), o]);
        }
        const a = g(null);
        let _ = !1;
        const p = [],
          d = v(t);
        for (; s < d.length; s++) {
          const o = t[d[s]],
            r = null === o || ("function" != typeof o && "object" != typeof o);
          if (void 0 === e && r) (_ = !0), (p[s] = _inspect(o));
          else {
            const t = e || v(o);
            for (const n of t)
              (a[n] ??= []),
                (r && e) || !b(o, n)
                  ? (a[n][s] = "")
                  : (a[n][s] = _inspect(o[n]));
          }
        }
        const f = v(a),
          h = E(a);
        return _ && (u(f, Tt), u(h, p)), c(f, Wt), c(h, d), final(f, h);
      },
    };
    function timeLogImpl(t, o, e, n) {
      const s = t._times.get(e);
      if (void 0 === s)
        return r.emitWarning(`No such label '${e}' for console.${o}()`), !1;
      const i = r.hrtime(s),
        l = formatTime(1e3 * i[0] + i[1] / 1e6);
      return (
        void 0 === n
          ? t.log("%s: %s", e, l)
          : t.log("%s: %s", e, l, ...new I(n)),
        !0
      );
    }
    function pad(t) {
      return L(`${t}`, 2, "0");
    }
    function formatTime(t) {
      let o = 0,
        e = 0,
        r = 0;
      if (
        (t >= at &&
          (t >= ut &&
            (t >= ct && ((o = f(t / ct)), (t %= ct)),
            (e = f(t / ut)),
            (t %= ut)),
          (r = t / at)),
        0 !== o || 0 !== e)
      ) {
        ({ 0: r, 1: t } = B(m(r, 3), "."));
        return `${0 !== o ? `${o}:${pad(e)}` : e}:${pad(r)}.${t} (${
          0 !== o ? "h:m" : ""
        }m:ss.mmm)`;
      }
      return 0 !== r ? `${m(r, 3)}s` : `${h(m(t, 3))}ms`;
    }
    const Lt = "Key",
      Tt = "Values",
      Wt = "(index)",
      Bt = "(iteration index)",
      isArray = (t) => l(t) || Q(t) || Y(t);
    function noop() {}
    for (const t of A(kt)) Console.prototype[t] = kt[t];
    (Console.prototype.debug = Console.prototype.log),
      (Console.prototype.info = Console.prototype.log),
      (Console.prototype.dirxml = Console.prototype.log),
      (Console.prototype.error = Console.prototype.warn),
      (Console.prototype.groupCollapsed = Console.prototype.group),
      (e.exports = {
        Console: Console,
        kBindStreamsLazy: wt,
        kBindProperties: Et,
        initializeGlobalConsole: function initializeGlobalConsole(t) {
          t[wt](r), t[Et](!0, "auto");
          const {
            namespace: { addSerializeCallback: e, isBuildingSnapshot: s },
          } = o("internal/v8/startup_snapshot");
          if (!n("config").hasInspector || !s()) return;
          const { console: i } = n("inspector"),
            l = v(Console.prototype),
            a = v(i),
            u = new O(a.concat(l)),
            c = new O();
          for (const o of v(t)) u.has(o) || c.add(o);
          e(() => {
            for (const o of c) t[o] = void 0;
          });
        },
        formatTime: formatTime,
      });
  },
  "internal/console/global": function (e, o, t, n, c, r) {
    "use strict";
    const {
        FunctionPrototypeBind: l,
        ObjectCreate: s,
        ReflectDefineProperty: u,
        ReflectGetOwnPropertyDescriptor: f,
        ReflectOwnKeys: i,
      } = r,
      { Console: p } = o("internal/console/constructor"),
      a = s({});
    for (const e of i(p.prototype)) {
      if ("constructor" === e) continue;
      const o = f(p.prototype, e);
      if ("function" == typeof o.value) {
        const e = o.value.name;
        (o.value = l(o.value, a)),
          u(o.value, "name", { __proto__: null, value: e });
      }
      u(a, e, o);
    }
    (a.Console = p), (t.exports = a);
  },
  "internal/constants": function (A, R, _, C, E, H) {
    "use strict";
    const L = "win32" === C.platform;
    _.exports = {
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_UPPERCASE_C: 67,
      CHAR_LOWERCASE_B: 98,
      CHAR_LOWERCASE_E: 101,
      CHAR_LOWERCASE_N: 110,
      CHAR_DOT: 46,
      CHAR_FORWARD_SLASH: 47,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_VERTICAL_LINE: 124,
      CHAR_COLON: 58,
      CHAR_QUESTION_MARK: 63,
      CHAR_UNDERSCORE: 95,
      CHAR_LINE_FEED: 10,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_TAB: 9,
      CHAR_FORM_FEED: 12,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_HASH: 35,
      CHAR_SPACE: 32,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_LEFT_CURLY_BRACKET: 123,
      CHAR_RIGHT_CURLY_BRACKET: 125,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_PLUS: 43,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_PERCENT: 37,
      CHAR_SEMICOLON: 59,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_AT: 64,
      CHAR_AMPERSAND: 38,
      CHAR_EQUAL: 61,
      CHAR_0: 48,
      CHAR_9: 57,
      EOL: L ? "\r\n" : "\n",
    };
  },
  "internal/crypto/aes": function (e, t, r, a, n, i) {
    "use strict";
    const {
        ArrayBufferIsView: o,
        ArrayBufferPrototypeSlice: s,
        ArrayFrom: c,
        ArrayPrototypeIncludes: y,
        ArrayPrototypePush: h,
        MathFloor: l,
        SafeSet: u,
        TypedArrayPrototypeSlice: g,
      } = i,
      {
        AESCipherJob: A,
        KeyObjectHandle: p,
        kCryptoJobAsync: E,
        kKeyVariantAES_CTR_128: C,
        kKeyVariantAES_CBC_128: K,
        kKeyVariantAES_GCM_128: S,
        kKeyVariantAES_KW_128: m,
        kKeyVariantAES_CTR_192: w,
        kKeyVariantAES_CBC_192: k,
        kKeyVariantAES_GCM_192: d,
        kKeyVariantAES_KW_192: f,
        kKeyVariantAES_CTR_256: _,
        kKeyVariantAES_CBC_256: b,
        kKeyVariantAES_GCM_256: v,
        kKeyVariantAES_KW_256: V,
        kWebCryptoCipherDecrypt: W,
        kWebCryptoCipherEncrypt: D,
      } = n("crypto"),
      {
        hasAnyNotIn: B,
        jobPromise: G,
        validateByteLength: M,
        validateKeyOps: T,
        validateMaxBufferLength: I,
        kAesKeyLengths: L,
        kHandle: O,
        kKeyObject: P,
      } = t("internal/crypto/util"),
      { lazyDOMException: R, promisify: x } = t("internal/util"),
      { PromiseReject: J } = i,
      {
        InternalCryptoKey: N,
        SecretKeyObject: $,
        createSecretKey: j,
      } = t("internal/crypto/keys"),
      { generateKey: F } = t("internal/crypto/keygen"),
      U = 128,
      z = [32, 64, 96, 104, 112, 120, 128],
      H = x(F);
    function getAlgorithmName(e, t) {
      switch (e) {
        case "AES-CBC":
          return `A${t}CBC`;
        case "AES-CTR":
          return `A${t}CTR`;
        case "AES-GCM":
          return `A${t}GCM`;
        case "AES-KW":
          return `A${t}KW`;
      }
    }
    function validateKeyLength(e) {
      if (128 !== e && 192 !== e && 256 !== e)
        throw R("Invalid key length", "DataError");
    }
    function getVariant(e, t) {
      switch (e) {
        case "AES-CBC":
          switch (t) {
            case 128:
              return K;
            case 192:
              return k;
            case 256:
              return b;
          }
          break;
        case "AES-CTR":
          switch (t) {
            case 128:
              return C;
            case 192:
              return w;
            case 256:
              return _;
          }
          break;
        case "AES-GCM":
          switch (t) {
            case 128:
              return S;
            case 192:
              return d;
            case 256:
              return v;
          }
          break;
        case "AES-KW":
          switch (t) {
            case 128:
              return m;
            case 192:
              return f;
            case 256:
              return V;
          }
      }
    }
    r.exports = {
      aesCipher: function aesCipher(e, t, r, a) {
        switch (a.name) {
          case "AES-CTR":
            return (function asyncAesCtrCipher(
              e,
              t,
              r,
              { counter: a, length: n }
            ) {
              if ((M(a, "algorithm.counter", 16), 0 === n || n > U))
                throw R(
                  "AES-CTR algorithm.length must be between 1 and 128",
                  "OperationError"
                );
              return G(
                () =>
                  new A(
                    E,
                    e,
                    t[P][O],
                    r,
                    getVariant("AES-CTR", t.algorithm.length),
                    a,
                    n
                  )
              );
            })(e, t, r, a);
          case "AES-CBC":
            return (function asyncAesCbcCipher(e, t, r, { iv: a }) {
              return (
                M(a, "algorithm.iv", 16),
                G(
                  () =>
                    new A(
                      E,
                      e,
                      t[P][O],
                      r,
                      getVariant("AES-CBC", t.algorithm.length),
                      a
                    )
                )
              );
            })(e, t, r, a);
          case "AES-GCM":
            return (function asyncAesGcmCipher(
              e,
              t,
              r,
              { iv: a, additionalData: n, tagLength: i = 128 }
            ) {
              if (!y(z, i))
                return J(
                  R(`${i} is not a valid AES-GCM tag length`, "OperationError")
                );
              I(a, "algorithm.iv"),
                void 0 !== n && I(n, "algorithm.additionalData");
              const c = l(i / 8);
              let h;
              switch (e) {
                case W: {
                  const e = o(r) ? g : s;
                  if (((h = e(r, -c)), c > h.byteLength))
                    return J(
                      R("The provided data is too small.", "OperationError")
                    );
                  r = e(r, 0, -c);
                  break;
                }
                case D:
                  h = c;
              }
              return G(
                () =>
                  new A(
                    E,
                    e,
                    t[P][O],
                    r,
                    getVariant("AES-GCM", t.algorithm.length),
                    a,
                    h,
                    n
                  )
              );
            })(e, t, r, a);
          case "AES-KW":
            return (function asyncAesKwCipher(e, t, r) {
              return G(
                () =>
                  new A(
                    E,
                    e,
                    t[P][O],
                    r,
                    getVariant("AES-KW", t.algorithm.length)
                  )
              );
            })(e, t, r);
        }
      },
      aesGenerateKey: async function aesGenerateKey(e, t, r) {
        const { name: a, length: n } = e;
        if (!y(L, n))
          throw R(
            "AES key length must be 128, 192, or 256 bits",
            "OperationError"
          );
        const i = ["wrapKey", "unwrapKey"];
        "AES-KW" !== a && h(i, "encrypt", "decrypt");
        const o = new u(r);
        if (B(o, i))
          throw R("Unsupported key usage for an AES key", "SyntaxError");
        const s = await H("aes", { length: n }).catch((e) => {
          throw R(
            `The operation failed for an operation-specific reason[${e.message}]`,
            { name: "OperationError", cause: e }
          );
        });
        return new N(s, { name: a, length: n }, c(o), t);
      },
      aesImportKey: async function aesImportKey(e, t, r, a, n) {
        const { name: i } = e,
          o = ["wrapKey", "unwrapKey"];
        "AES-KW" !== i && h(o, "encrypt", "decrypt");
        const s = new u(n);
        if (B(s, o))
          throw R("Unsupported key usage for an AES key", "SyntaxError");
        let c, y;
        switch (t) {
          case "raw":
            validateKeyLength(8 * r.byteLength), (c = j(r));
            break;
          case "jwk": {
            if (!r.kty) throw R("Invalid keyData", "DataError");
            if ("oct" !== r.kty)
              throw R('Invalid JWK "kty" Parameter', "DataError");
            if (s.size > 0 && void 0 !== r.use && "enc" !== r.use)
              throw R('Invalid JWK "use" Parameter', "DataError");
            if ((T(r.key_ops, s), void 0 !== r.ext && !1 === r.ext && !0 === a))
              throw R(
                'JWK "ext" Parameter and extractable mismatch',
                "DataError"
              );
            const t = new p();
            if (
              (t.initJwk(r),
              ({ length: y } = t.keyDetail({})),
              validateKeyLength(y),
              void 0 !== r.alg && r.alg !== getAlgorithmName(e.name, y))
            )
              throw R(
                'JWK "alg" does not match the requested algorithm',
                "DataError"
              );
            c = new $(t);
            break;
          }
          default:
            throw R(
              `Unable to import AES key with format ${t}`,
              "NotSupportedError"
            );
        }
        return (
          void 0 === y &&
            (({ length: y } = c[O].keyDetail({})), validateKeyLength(y)),
          new N(c, { name: i, length: y }, n, a)
        );
      },
      getAlgorithmName: getAlgorithmName,
    };
  },
  "internal/crypto/certificate": function (e, t, r, i, c, p) {
    "use strict";
    const {
        certExportChallenge: a,
        certExportPublicKey: o,
        certVerifySpkac: n,
      } = c("crypto"),
      { getArrayBufferOrView: f } = t("internal/crypto/util");
    function verifySpkac(e, t) {
      return n(f(e, "spkac", t));
    }
    function exportPublicKey(e, t) {
      return o(f(e, "spkac", t));
    }
    function exportChallenge(e, t) {
      return a(f(e, "spkac", t));
    }
    function Certificate() {
      if (!(this instanceof Certificate)) return new Certificate();
    }
    (Certificate.prototype.verifySpkac = verifySpkac),
      (Certificate.prototype.exportPublicKey = exportPublicKey),
      (Certificate.prototype.exportChallenge = exportChallenge),
      (Certificate.exportChallenge = exportChallenge),
      (Certificate.exportPublicKey = exportPublicKey),
      (Certificate.verifySpkac = verifySpkac),
      (r.exports = Certificate);
  },
  "internal/crypto/cfrg": function (e, r, t, a, o, i) {
    "use strict";
    const { SafeSet: n } = i,
      { Buffer: c } = r("buffer"),
      {
        ECKeyExportJob: s,
        KeyObjectHandle: y,
        SignJob: d,
        kCryptoJobAsync: f,
        kKeyTypePrivate: p,
        kKeyTypePublic: l,
        kSignJobModeSign: h,
        kSignJobModeVerify: b,
      } = o("crypto"),
      {
        getUsagesUnion: w,
        hasAnyNotIn: k,
        jobPromise: g,
        validateKeyOps: u,
        kHandle: v,
        kKeyObject: E,
      } = r("internal/crypto/util"),
      {
        emitExperimentalWarning: K,
        lazyDOMException: m,
        promisify: D,
      } = r("internal/util"),
      { generateKeyPair: x } = r("internal/crypto/keygen"),
      {
        InternalCryptoKey: I,
        PrivateKeyObject: C,
        PublicKeyObject: P,
        createPrivateKey: S,
        createPublicKey: A,
      } = r("internal/crypto/keys"),
      J = D(x);
    function verifyAcceptableCfrgKeyUse(e, r, t) {
      let a;
      switch (e) {
        case "X25519":
        case "X448":
          a = r ? [] : ["deriveKey", "deriveBits"];
          break;
        case "Ed25519":
        case "Ed448":
          a = r ? ["verify"] : ["sign"];
          break;
        default:
          throw m("The algorithm is not supported", "NotSupportedError");
      }
      if (k(t, a))
        throw m(`Unsupported key usage for a ${e} key`, "SyntaxError");
    }
    function createCFRGRawKey(e, r, t) {
      const a = new y();
      switch (e) {
        case "Ed25519":
        case "X25519":
          if (32 !== r.byteLength)
            throw m(`${e} raw keys must be exactly 32-bytes`, "DataError");
          break;
        case "Ed448":
          if (57 !== r.byteLength)
            throw m(`${e} raw keys must be exactly 57-bytes`, "DataError");
          break;
        case "X448":
          if (56 !== r.byteLength)
            throw m(`${e} raw keys must be exactly 56-bytes`, "DataError");
      }
      const o = t ? l : p;
      if (!a.initEDRaw(e, r, o)) throw m("Invalid keyData", "DataError");
      return t ? new P(a) : new C(a);
    }
    t.exports = {
      cfrgExportKey: function cfrgExportKey(e, r) {
        return (
          K(`The ${e.algorithm.name} Web Crypto API algorithm`),
          g(() => new s(f, r, e[E][v]))
        );
      },
      cfrgImportKey: async function cfrgImportKey(e, r, t, a, o) {
        const { name: i } = t;
        let s;
        K(`The ${i} Web Crypto API algorithm`);
        const y = new n(o);
        switch (e) {
          case "spki":
            verifyAcceptableCfrgKeyUse(i, !0, y);
            try {
              s = A({ key: r, format: "der", type: "spki" });
            } catch (e) {
              throw m("Invalid keyData", { name: "DataError", cause: e });
            }
            break;
          case "pkcs8":
            verifyAcceptableCfrgKeyUse(i, !1, y);
            try {
              s = S({ key: r, format: "der", type: "pkcs8" });
            } catch (e) {
              throw m("Invalid keyData", { name: "DataError", cause: e });
            }
            break;
          case "jwk": {
            if (!r.kty) throw m("Invalid keyData", "DataError");
            if ("OKP" !== r.kty)
              throw m('Invalid JWK "kty" Parameter', "DataError");
            if (r.crv !== i)
              throw m(
                'JWK "crv" Parameter and algorithm name mismatch',
                "DataError"
              );
            const e = void 0 === r.d;
            if (y.size > 0 && void 0 !== r.use) {
              let e;
              switch (i) {
                case "Ed25519":
                case "Ed448":
                  e = "sig";
                  break;
                case "X25519":
                case "X448":
                  e = "enc";
              }
              if (r.use !== e)
                throw m('Invalid JWK "use" Parameter', "DataError");
            }
            if ((u(r.key_ops, y), void 0 !== r.ext && !1 === r.ext && !0 === a))
              throw m(
                'JWK "ext" Parameter and extractable mismatch',
                "DataError"
              );
            if (
              void 0 !== r.alg &&
              ("Ed25519" === i || "Ed448" === i) &&
              "EdDSA" !== r.alg
            )
              throw m(
                'JWK "alg" does not match the requested algorithm',
                "DataError"
              );
            if (!e && "string" != typeof r.x)
              throw m("Invalid JWK", "DataError");
            verifyAcceptableCfrgKeyUse(i, e, y);
            const t = createCFRGRawKey(i, c.from(r.x, "base64"), !0);
            if (e) s = t;
            else if (
              ((s = createCFRGRawKey(i, c.from(r.d, "base64"), !1)),
              !A(s).equals(t))
            )
              throw m("Invalid JWK", "DataError");
            break;
          }
          case "raw":
            verifyAcceptableCfrgKeyUse(i, !0, y),
              (s = createCFRGRawKey(i, r, !0));
        }
        if (s.asymmetricKeyType !== i.toLowerCase())
          throw m("Invalid key type", "DataError");
        return new I(s, { name: i }, o, a);
      },
      cfrgGenerateKey: async function cfrgGenerateKey(e, r, t) {
        const { name: a } = e;
        K(`The ${a} Web Crypto API algorithm`);
        const o = new n(t);
        switch (a) {
          case "Ed25519":
          case "Ed448":
            if (k(o, ["sign", "verify"]))
              throw m(`Unsupported key usage for an ${a} key`, "SyntaxError");
            break;
          case "X25519":
          case "X448":
            if (k(o, ["deriveKey", "deriveBits"]))
              throw m(`Unsupported key usage for an ${a} key`, "SyntaxError");
        }
        let i;
        switch (a) {
          case "Ed25519":
            i = "ed25519";
            break;
          case "Ed448":
            i = "ed448";
            break;
          case "X25519":
            i = "x25519";
            break;
          case "X448":
            i = "x448";
        }
        const c = await J(i).catch((e) => {
          throw m("The operation failed for an operation-specific reason", {
            name: "OperationError",
            cause: e,
          });
        });
        let s, y;
        switch (a) {
          case "Ed25519":
          case "Ed448":
            (s = w(o, "verify")), (y = w(o, "sign"));
            break;
          case "X25519":
          case "X448":
            (s = []), (y = w(o, "deriveKey", "deriveBits"));
        }
        const d = { name: a },
          f = new I(c.publicKey, d, s, !0);
        return { privateKey: new I(c.privateKey, d, y, r), publicKey: f };
      },
      eddsaSignVerify: function eddsaSignVerify(
        e,
        r,
        { name: t, context: a },
        o
      ) {
        K(`The ${t} Web Crypto API algorithm`);
        const i = void 0 === o ? h : b,
          n = i === h ? "private" : "public";
        if (e.type !== n)
          throw m(`Key must be a ${n} key`, "InvalidAccessError");
        if ("Ed448" === t && a?.byteLength)
          throw m(
            "Non zero-length context is not yet supported.",
            "NotSupportedError"
          );
        return g(
          () =>
            new d(
              f,
              i,
              e[E][v],
              void 0,
              void 0,
              void 0,
              r,
              void 0,
              void 0,
              void 0,
              void 0,
              o
            )
        );
      },
    };
  },
  "internal/crypto/cipher": function (t, e, i, r, n, o) {
    "use strict";
    const {
        ObjectSetPrototypeOf: p,
        ReflectApply: h,
        StringPrototypeToLowerCase: a,
      } = o,
      {
        CipherBase: s,
        privateDecrypt: c,
        privateEncrypt: u,
        publicDecrypt: d,
        publicEncrypt: f,
        getCipherInfo: y,
      } = n("crypto"),
      {
        crypto: { RSA_PKCS1_OAEP_PADDING: g, RSA_PKCS1_PADDING: l },
      } = n("constants"),
      {
        codes: {
          ERR_CRYPTO_INVALID_STATE: C,
          ERR_INVALID_ARG_TYPE: v,
          ERR_INVALID_ARG_VALUE: A,
          ERR_UNKNOWN_ENCODING: D,
        },
      } = e("internal/errors"),
      {
        validateEncoding: _,
        validateInt32: w,
        validateObject: P,
        validateString: I,
      } = e("internal/validators"),
      {
        preparePrivateKey: b,
        preparePublicOrPrivateKey: T,
        prepareSecretKey: m,
      } = e("internal/crypto/keys"),
      {
        getDefaultEncoding: E,
        getArrayBufferOrView: F,
        getStringOption: O,
        kHandle: R,
      } = e("internal/crypto/util"),
      { isArrayBufferView: L } = e("internal/util/types"),
      N = e("internal/assert"),
      S = e("internal/streams/lazy_transform"),
      { normalizeEncoding: V } = e("internal/util"),
      { StringDecoder: B } = e("string_decoder");
    function rsaFunctionFor(t, e, i) {
      return (r, n) => {
        const {
            format: o,
            type: p,
            data: h,
            passphrase: a,
          } = "private" === i ? b(r) : T(r),
          s = r.padding || e,
          { oaepHash: c, encoding: u } = r;
        let { oaepLabel: d } = r;
        return (
          void 0 !== c && I(c, "key.oaepHash"),
          void 0 !== d && (d = F(d, "key.oaepLabel", u)),
          (n = F(n, "buffer", u)),
          t(h, o, p, a, n, s, c, d)
        );
      };
    }
    const k = rsaFunctionFor(f, g, "public"),
      K = rsaFunctionFor(d, l, "public"),
      G = rsaFunctionFor(u, l, "private"),
      U = rsaFunctionFor(c, g, "private");
    function getDecoder(t, e) {
      const i = V(e);
      if ((t = t || new B(e)).encoding !== i) {
        if (void 0 === i) throw new D(e);
        N(!1, "Cannot change encoding");
      }
      return t;
    }
    function getUIntOption(t, e) {
      let i;
      if (t && null != (i = t[e])) {
        if (i >>> 0 !== i) throw new A(`options.${e}`, i);
        return i;
      }
      return -1;
    }
    function createCipherBase(t, e, i, r, n) {
      const o = getUIntOption(i, "authTagLength");
      (this[R] = new s(r)),
        void 0 === n ? this[R].init(t, e, o) : this[R].initiv(t, e, n, o),
        (this._decoder = null),
        h(S, this, [i]);
    }
    function createCipher(t, e, i, r) {
      I(t, "cipher"),
        (e = F(e, "password")),
        h(createCipherBase, this, [t, e, i, r]);
    }
    function createCipherWithIV(t, e, i, r, n) {
      I(t, "cipher");
      const o = O(i, "encoding");
      (e = m(e, o)),
        (n = null === n ? null : F(n, "iv")),
        h(createCipherBase, this, [t, e, i, r, n]);
    }
    function Cipher(t, e, i) {
      if (!(this instanceof Cipher)) return new Cipher(t, e, i);
      h(createCipher, this, [t, e, i, !0]);
    }
    function setAuthTag(t, e) {
      if (((t = F(t, "buffer", e)), !this[R].setAuthTag(t)))
        throw new C("setAuthTag");
      return this;
    }
    function Cipheriv(t, e, i, r) {
      if (!(this instanceof Cipheriv)) return new Cipheriv(t, e, i, r);
      h(createCipherWithIV, this, [t, e, r, !0, i]);
    }
    function addCipherPrototypeFunctions(t) {
      (t.prototype._transform = Cipher.prototype._transform),
        (t.prototype._flush = Cipher.prototype._flush),
        (t.prototype.update = Cipher.prototype.update),
        (t.prototype.final = Cipher.prototype.final),
        (t.prototype.setAutoPadding = Cipher.prototype.setAutoPadding),
        t === Cipheriv
          ? (t.prototype.getAuthTag = Cipher.prototype.getAuthTag)
          : (t.prototype.setAuthTag = setAuthTag),
        (t.prototype.setAAD = Cipher.prototype.setAAD);
    }
    function Decipher(t, e, i) {
      if (!(this instanceof Decipher)) return new Decipher(t, e, i);
      h(createCipher, this, [t, e, i, !1]);
    }
    function Decipheriv(t, e, i, r) {
      if (!(this instanceof Decipheriv)) return new Decipheriv(t, e, i, r);
      h(createCipherWithIV, this, [t, e, r, !1, i]);
    }
    p(Cipher.prototype, S.prototype),
      p(Cipher, S),
      (Cipher.prototype._transform = function _transform(t, e, i) {
        this.push(this[R].update(t, e)), i();
      }),
      (Cipher.prototype._flush = function _flush(t) {
        try {
          this.push(this[R].final());
        } catch (e) {
          return void t(e);
        }
        t();
      }),
      (Cipher.prototype.update = function update(t, e, i) {
        const r = E();
        if (((e = e || r), (i = i || r), "string" == typeof t)) _(t, e);
        else if (!L(t))
          throw new v(
            "data",
            ["string", "Buffer", "TypedArray", "DataView"],
            t
          );
        const n = this[R].update(t, e);
        return i && "buffer" !== i
          ? ((this._decoder = getDecoder(this._decoder, i)),
            this._decoder.write(n))
          : n;
      }),
      (Cipher.prototype.final = function final(t) {
        t = t || E();
        const e = this[R].final();
        return t && "buffer" !== t
          ? ((this._decoder = getDecoder(this._decoder, t)),
            this._decoder.end(e))
          : e;
      }),
      (Cipher.prototype.setAutoPadding = function setAutoPadding(t) {
        if (!this[R].setAutoPadding(!!t)) throw new C("setAutoPadding");
        return this;
      }),
      (Cipher.prototype.getAuthTag = function getAuthTag() {
        const t = this[R].getAuthTag();
        if (void 0 === t) throw new C("getAuthTag");
        return t;
      }),
      (Cipher.prototype.setAAD = function setAAD(t, e) {
        const i = O(e, "encoding"),
          r = getUIntOption(e, "plaintextLength");
        if (((t = F(t, "aadbuf", i)), !this[R].setAAD(t, r)))
          throw new C("setAAD");
        return this;
      }),
      p(Cipheriv.prototype, S.prototype),
      p(Cipheriv, S),
      addCipherPrototypeFunctions(Cipheriv),
      p(Decipher.prototype, S.prototype),
      p(Decipher, S),
      addCipherPrototypeFunctions(Decipher),
      p(Decipheriv.prototype, S.prototype),
      p(Decipheriv, S),
      addCipherPrototypeFunctions(Decipheriv),
      (i.exports = {
        Cipher: Cipher,
        Cipheriv: Cipheriv,
        Decipher: Decipher,
        Decipheriv: Decipheriv,
        privateDecrypt: U,
        privateEncrypt: G,
        publicDecrypt: K,
        publicEncrypt: k,
        getCipherInfo: function getCipherInfo(t, e) {
          if ("string" != typeof t && "number" != typeof t)
            throw new v("nameOrNid", ["string", "number"], t);
          let i, r;
          "number" == typeof t && w(t, "nameOrNid"),
            void 0 !== e &&
              (P(e, "options"),
              ({ keyLength: i, ivLength: r } = e),
              void 0 !== i && w(i, "options.keyLength"),
              void 0 !== r && w(r, "options.ivLength"));
          const n = y({}, t, i, r);
          return (
            void 0 !== n &&
              (n.name && (n.name = a(n.name)), n.type && (n.type = a(n.type))),
            n
          );
        },
      });
  },
  "internal/crypto/diffiehellman": function (e, t, r, i, n, o) {
    "use strict";
    const {
        ArrayBufferPrototypeSlice: a,
        MathCeil: f,
        ObjectDefineProperty: l,
        SafeSet: s,
      } = o,
      { Buffer: y } = t("buffer"),
      {
        DiffieHellman: c,
        DiffieHellmanGroup: p,
        ECDH: u,
        ECDHBitsJob: m,
        ECDHConvertKey: D,
        statelessDH: h,
        kCryptoJobAsync: H,
      } = n("crypto"),
      {
        codes: {
          ERR_CRYPTO_ECDH_INVALID_FORMAT: E,
          ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY: g,
          ERR_CRYPTO_INCOMPATIBLE_KEY: b,
          ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE: K,
          ERR_INVALID_ARG_TYPE: v,
          ERR_INVALID_ARG_VALUE: d,
        },
      } = t("internal/errors"),
      {
        validateInt32: P,
        validateObject: C,
        validateString: _,
      } = t("internal/validators"),
      { isArrayBufferView: w, isAnyArrayBuffer: I } = t("internal/util/types"),
      { lazyDOMException: O } = t("internal/util"),
      { KeyObject: A } = t("internal/crypto/keys"),
      {
        getArrayBufferOrView: R,
        getDefaultEncoding: G,
        jobPromise: N,
        toBuf: S,
        kHandle: B,
        kKeyObject: T,
      } = t("internal/crypto/util"),
      {
        crypto: {
          POINT_CONVERSION_COMPRESSED: k,
          POINT_CONVERSION_HYBRID: V,
          POINT_CONVERSION_UNCOMPRESSED: Y,
        },
      } = n("constants");
    function DiffieHellman(e, t, r, i) {
      if (!(this instanceof DiffieHellman))
        return new DiffieHellman(e, t, r, i);
      if ("number" != typeof e && "string" != typeof e && !w(e) && !I(e))
        throw new v(
          "sizeOrKey",
          [
            "number",
            "string",
            "ArrayBuffer",
            "Buffer",
            "TypedArray",
            "DataView",
          ],
          e
        );
      "number" == typeof e && P(e, "sizeOrKey"),
        t && !y.isEncoding(t) && "buffer" !== t && ((i = r), (r = t), (t = !1));
      const n = G();
      if (
        ((t = t || n), (i = i || n), "number" != typeof e && (e = S(e, t)), r)
      ) {
        if ("number" == typeof r) P(r, "generator");
        else if ("string" == typeof r) r = S(r, i);
        else if (!w(r) && !I(r))
          throw new v(
            "generator",
            [
              "number",
              "string",
              "ArrayBuffer",
              "Buffer",
              "TypedArray",
              "DataView",
            ],
            r
          );
      } else r = 2;
      (this[B] = new c(e, r)),
        l(this, "verifyError", {
          __proto__: null,
          enumerable: !0,
          value: this[B].verifyError,
          writable: !1,
        });
    }
    function DiffieHellmanGroup(e) {
      if (!(this instanceof DiffieHellmanGroup))
        return new DiffieHellmanGroup(e);
      (this[B] = new p(e)),
        l(this, "verifyError", {
          __proto__: null,
          enumerable: !0,
          value: this[B].verifyError,
          writable: !1,
        });
    }
    function ECDH(e) {
      if (!(this instanceof ECDH)) return new ECDH(e);
      _(e, "curve"), (this[B] = new u(e));
    }
    function encode(e, t) {
      return t && "buffer" !== t && (e = e.toString(t)), e;
    }
    function getFormat(e) {
      if (e) {
        if ("compressed" === e) return k;
        if ("hybrid" === e) return V;
        if ("uncompressed" !== e) throw new E(e);
      }
      return Y;
    }
    (DiffieHellmanGroup.prototype.generateKeys =
      DiffieHellman.prototype.generateKeys =
        function dhGenerateKeys(e) {
          const t = this[B].generateKeys();
          return (e = e || G()), encode(t, e);
        }),
      (DiffieHellmanGroup.prototype.computeSecret =
        DiffieHellman.prototype.computeSecret =
          function dhComputeSecret(e, t, r) {
            const i = G();
            (r = r || i), (e = R(e, "key", (t = t || i)));
            const n = this[B].computeSecret(e);
            if ("string" == typeof n) throw new g();
            return encode(n, r);
          }),
      (DiffieHellmanGroup.prototype.getPrime =
        DiffieHellman.prototype.getPrime =
          function dhGetPrime(e) {
            const t = this[B].getPrime();
            return (e = e || G()), encode(t, e);
          }),
      (DiffieHellmanGroup.prototype.getGenerator =
        DiffieHellman.prototype.getGenerator =
          function dhGetGenerator(e) {
            const t = this[B].getGenerator();
            return (e = e || G()), encode(t, e);
          }),
      (DiffieHellmanGroup.prototype.getPublicKey =
        DiffieHellman.prototype.getPublicKey =
          function dhGetPublicKey(e) {
            const t = this[B].getPublicKey();
            return (e = e || G()), encode(t, e);
          }),
      (DiffieHellmanGroup.prototype.getPrivateKey =
        DiffieHellman.prototype.getPrivateKey =
          function dhGetPrivateKey(e) {
            const t = this[B].getPrivateKey();
            return (e = e || G()), encode(t, e);
          }),
      (DiffieHellman.prototype.setPublicKey = function setPublicKey(e, t) {
        return (
          (t = t || G()), (e = R(e, "key", t)), this[B].setPublicKey(e), this
        );
      }),
      (DiffieHellman.prototype.setPrivateKey = function setPrivateKey(e, t) {
        return (
          (t = t || G()), (e = R(e, "key", t)), this[B].setPrivateKey(e), this
        );
      }),
      (ECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret),
      (ECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey),
      (ECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey),
      (ECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey),
      (ECDH.prototype.generateKeys = function generateKeys(e, t) {
        return this[B].generateKeys(), this.getPublicKey(e, t);
      }),
      (ECDH.prototype.getPublicKey = function getPublicKey(e, t) {
        const r = getFormat(t);
        return encode(this[B].getPublicKey(r), (e = e || G()));
      }),
      (ECDH.convertKey = function convertKey(e, t, r, i, n) {
        _(t, "curve");
        const o = r || G();
        (e = R(e, "key", o)), (i = i || o);
        const a = getFormat(n);
        return encode(D(e, t, a), i);
      });
    const L = new s(["dh", "ec", "x448", "x25519"]);
    r.exports = {
      DiffieHellman: DiffieHellman,
      DiffieHellmanGroup: DiffieHellmanGroup,
      ECDH: ECDH,
      diffieHellman: function diffieHellman(e) {
        C(e, "options");
        const { privateKey: t, publicKey: r } = e;
        if (!(t instanceof A)) throw new d("options.privateKey", t);
        if (!(r instanceof A)) throw new d("options.publicKey", r);
        if ("private" !== t.type) throw new K(t.type, "private");
        if ("public" !== r.type && "private" !== r.type)
          throw new K(r.type, "private or public");
        const i = t.asymmetricKeyType,
          n = r.asymmetricKeyType;
        if (i !== n || !L.has(i))
          throw new b("key types for Diffie-Hellman", `${i} and ${n}`);
        return h(t[B], r[B]);
      },
      ecdhDeriveBits: async function ecdhDeriveBits(e, t, r) {
        const { public: i } = e;
        if ("public" !== i.type)
          throw O(
            "algorithm.public must be a public key",
            "InvalidAccessError"
          );
        if ("private" !== t.type)
          throw O("baseKey must be a private key", "InvalidAccessError");
        if (
          "ECDH" !== i.algorithm.name &&
          "X25519" !== i.algorithm.name &&
          "X448" !== i.algorithm.name
        )
          throw O(
            "Keys must be ECDH, X25519, or X448 keys",
            "InvalidAccessError"
          );
        if (i.algorithm.name !== t.algorithm.name)
          throw O(
            "The public and private keys must be of the same type",
            "InvalidAccessError"
          );
        if (
          "ECDH" === i.algorithm.name &&
          i.algorithm.namedCurve !== t.algorithm.namedCurve
        )
          throw O("Named curve mismatch", "InvalidAccessError");
        const n = await N(
          () =>
            new m(
              H,
              "ECDH" === i.algorithm.name
                ? t.algorithm.namedCurve
                : t.algorithm.name,
              i[T][B],
              t[T][B]
            )
        );
        if (null === r) return n;
        r = f(r / 8);
        const { byteLength: o } = n;
        if (o < r) throw O("derived bit length is too small", "OperationError");
        return r === o ? n : a(n, 0, r);
      },
    };
  },
  "internal/crypto/ec": function (e, r, t, a, i, o) {
    "use strict";
    const { ArrayPrototypeIncludes: n, ObjectKeys: c, SafeSet: s } = o,
      {
        ECKeyExportJob: y,
        KeyObjectHandle: d,
        SignJob: p,
        kCryptoJobAsync: v,
        kKeyTypePrivate: u,
        kSignJobModeSign: E,
        kSignJobModeVerify: l,
        kSigEncP1363: f,
      } = i("crypto"),
      {
        getUsagesUnion: h,
        hasAnyNotIn: k,
        jobPromise: w,
        normalizeHashName: m,
        validateKeyOps: K,
        kHandle: D,
        kKeyObject: b,
        kNamedCurveAliases: C,
      } = r("internal/crypto/util"),
      { lazyDOMException: g, promisify: S } = r("internal/util"),
      { generateKeyPair: A } = r("internal/crypto/keygen"),
      {
        InternalCryptoKey: I,
        PrivateKeyObject: P,
        PublicKeyObject: x,
        createPrivateKey: J,
        createPublicKey: U,
      } = r("internal/crypto/keys"),
      H = S(A);
    function verifyAcceptableEcKeyUse(e, r, t) {
      let a;
      switch (e) {
        case "ECDH":
          a = r ? [] : ["deriveKey", "deriveBits"];
          break;
        case "ECDSA":
          a = r ? ["verify"] : ["sign"];
          break;
        default:
          throw g("The algorithm is not supported", "NotSupportedError");
      }
      if (k(t, a))
        throw g(`Unsupported key usage for a ${e} key`, "SyntaxError");
    }
    t.exports = {
      ecExportKey: function ecExportKey(e, r) {
        return w(() => new y(v, r, e[b][D]));
      },
      ecImportKey: async function ecImportKey(e, r, t, a, i) {
        const { name: o, namedCurve: y } = t;
        if (!n(c(C), y))
          throw g("Unrecognized namedCurve", "NotSupportedError");
        let p;
        const v = new s(i);
        switch (e) {
          case "spki":
            verifyAcceptableEcKeyUse(o, !0, v);
            try {
              p = U({ key: r, format: "der", type: "spki" });
            } catch (e) {
              throw g("Invalid keyData", { name: "DataError", cause: e });
            }
            break;
          case "pkcs8":
            verifyAcceptableEcKeyUse(o, !1, v);
            try {
              p = J({ key: r, format: "der", type: "pkcs8" });
            } catch (e) {
              throw g("Invalid keyData", { name: "DataError", cause: e });
            }
            break;
          case "jwk": {
            if (!r.kty) throw g("Invalid keyData", "DataError");
            if ("EC" !== r.kty)
              throw g('Invalid JWK "kty" Parameter', "DataError");
            if (r.crv !== y)
              throw g(
                'JWK "crv" does not match the requested algorithm',
                "DataError"
              );
            if (
              (verifyAcceptableEcKeyUse(o, void 0 === r.d, v),
              v.size > 0 && void 0 !== r.use)
            ) {
              const e = "ECDH" === o ? "enc" : "sig";
              if (r.use !== e)
                throw g('Invalid JWK "use" Parameter', "DataError");
            }
            if ((K(r.key_ops, v), void 0 !== r.ext && !1 === r.ext && !0 === a))
              throw g(
                'JWK "ext" Parameter and extractable mismatch',
                "DataError"
              );
            if ("ECDSA" === t.name && void 0 !== r.alg) {
              let e;
              switch (r.alg) {
                case "ES256":
                  e = "P-256";
                  break;
                case "ES384":
                  e = "P-384";
                  break;
                case "ES512":
                  e = "P-521";
              }
              if (e !== y)
                throw g(
                  'JWK "alg" does not match the requested algorithm',
                  "DataError"
                );
            }
            const e = new d(),
              i = e.initJwk(r, y);
            if (void 0 === i) throw g("Invalid JWK", "DataError");
            p = i === u ? new P(e) : new x(e);
            break;
          }
          case "raw":
            verifyAcceptableEcKeyUse(o, !0, v),
              (p = (function createECPublicKeyRaw(e, r) {
                const t = new d();
                if (!t.initECRaw(C[e], r))
                  throw g("Invalid keyData", "DataError");
                return new x(t);
              })(y, r));
        }
        switch (t.name) {
          case "ECDSA":
          case "ECDH":
            if ("ec" !== p.asymmetricKeyType)
              throw g("Invalid key type", "DataError");
        }
        if (!p[D].checkEcKeyData()) throw g("Invalid keyData", "DataError");
        const { namedCurve: E } = p[D].keyDetail({});
        if (C[y] !== E) throw g("Named curve mismatch", "DataError");
        return new I(p, { name: o, namedCurve: y }, i, a);
      },
      ecGenerateKey: async function ecGenerateKey(e, r, t) {
        const { name: a, namedCurve: i } = e;
        if (!n(c(C), i))
          throw g("Unrecognized namedCurve", "NotSupportedError");
        const o = new s(t);
        switch (a) {
          case "ECDSA":
            if (k(o, ["sign", "verify"]))
              throw g("Unsupported key usage for an ECDSA key", "SyntaxError");
            break;
          case "ECDH":
            if (k(o, ["deriveKey", "deriveBits"]))
              throw g("Unsupported key usage for an ECDH key", "SyntaxError");
        }
        const y = await H("ec", { namedCurve: i }).catch((e) => {
          throw g("The operation failed for an operation-specific reason", {
            name: "OperationError",
            cause: e,
          });
        });
        let d, p;
        switch (a) {
          case "ECDSA":
            (d = h(o, "verify")), (p = h(o, "sign"));
            break;
          case "ECDH":
            (d = []), (p = h(o, "deriveKey", "deriveBits"));
        }
        const v = { name: a, namedCurve: i };
        return {
          publicKey: new I(y.publicKey, v, d, !0),
          privateKey: new I(y.privateKey, v, p, r),
        };
      },
      ecdsaSignVerify: function ecdsaSignVerify(e, r, { name: t, hash: a }, i) {
        const o = void 0 === i ? E : l,
          n = o === E ? "private" : "public";
        if (e.type !== n)
          throw g(`Key must be a ${n} key`, "InvalidAccessError");
        const c = m(a.name);
        return w(
          () =>
            new p(
              v,
              o,
              e[b][D],
              void 0,
              void 0,
              void 0,
              r,
              c,
              void 0,
              void 0,
              f,
              i
            )
        );
      },
    };
  },
  "internal/crypto/hash": function (t, e, n, o, i, r) {
    "use strict";
    const { ObjectSetPrototypeOf: s, ReflectApply: a, Symbol: p } = r,
      { Hash: c, HashJob: h, Hmac: f, kCryptoJobAsync: u } = i("crypto"),
      {
        getDefaultEncoding: H,
        getStringOption: y,
        jobPromise: l,
        normalizeHashName: d,
        validateMaxBufferLength: m,
        kHandle: g,
      } = e("internal/crypto/util"),
      { prepareSecretKey: _ } = e("internal/crypto/keys"),
      { lazyDOMException: w } = e("internal/util"),
      { Buffer: A } = e("buffer"),
      {
        codes: {
          ERR_CRYPTO_HASH_FINALIZED: S,
          ERR_CRYPTO_HASH_UPDATE_FAILED: E,
          ERR_INVALID_ARG_TYPE: D,
        },
      } = e("internal/errors"),
      {
        validateEncoding: R,
        validateString: b,
        validateUint32: v,
      } = e("internal/validators"),
      { isArrayBufferView: I } = e("internal/util/types"),
      L = e("internal/streams/lazy_transform"),
      O = p("kState"),
      P = p("kFinalized");
    function Hash(t, e) {
      if (!(this instanceof Hash)) return new Hash(t, e);
      t instanceof c || b(t, "algorithm");
      const n = "object" == typeof e && null !== e ? e.outputLength : void 0;
      void 0 !== n && v(n, "options.outputLength"),
        (this[g] = new c(t, n)),
        (this[O] = { [P]: !1 }),
        a(L, this, [e]);
    }
    function Hmac(t, e, n) {
      if (!(this instanceof Hmac)) return new Hmac(t, e, n);
      b(t, "hmac");
      const o = y(n, "encoding");
      (e = _(e, o)),
        (this[g] = new f()),
        this[g].init(t, e),
        (this[O] = { [P]: !1 }),
        a(L, this, [n]);
    }
    s(Hash.prototype, L.prototype),
      s(Hash, L),
      (Hash.prototype.copy = function copy(t) {
        if (this[O][P]) throw new S();
        return new Hash(this[g], t);
      }),
      (Hash.prototype._transform = function _transform(t, e, n) {
        this[g].update(t, e), n();
      }),
      (Hash.prototype._flush = function _flush(t) {
        this.push(this[g].digest()), t();
      }),
      (Hash.prototype.update = function update(t, e) {
        e = e || H();
        if (this[O][P]) throw new S();
        if ("string" == typeof t) R(t, e);
        else if (!I(t))
          throw new D(
            "data",
            ["string", "Buffer", "TypedArray", "DataView"],
            t
          );
        if (!this[g].update(t, e)) throw new E();
        return this;
      }),
      (Hash.prototype.digest = function digest(t) {
        const e = this[O];
        if (e[P]) throw new S();
        t = t || H();
        const n = this[g].digest(`${t}`);
        return (e[P] = !0), n;
      }),
      s(Hmac.prototype, L.prototype),
      s(Hmac, L),
      (Hmac.prototype.update = Hash.prototype.update),
      (Hmac.prototype.digest = function digest(t) {
        const e = this[O];
        if (((t = t || H()), e[P])) {
          const e = A.from("");
          return "buffer" === t ? e : e.toString(t);
        }
        const n = this[g].digest(`${t}`);
        return (e[P] = !0), n;
      }),
      (Hmac.prototype._flush = Hash.prototype._flush),
      (Hmac.prototype._transform = Hash.prototype._transform),
      (n.exports = {
        Hash: Hash,
        Hmac: Hmac,
        asyncDigest: async function asyncDigest(t, e) {
          switch ((m(e, "data"), t.name)) {
            case "SHA-1":
            case "SHA-256":
            case "SHA-384":
            case "SHA-512":
              return l(() => new h(u, d(t.name), e));
          }
          throw w("Unrecognized algorithm name", "NotSupportedError");
        },
      });
  },
  "internal/crypto/hashnames": function (e, a, t, o, s, n) {
    "use strict";
    const { ObjectKeys: r, StringPrototypeToLowerCase: S } = n,
      h = {
        sha1: {
          1: "sha1",
          2: "SHA-1",
          3: "RS1",
          4: "PS1",
          5: "RSA-OAEP",
          6: "HS1",
        },
        sha256: {
          1: "sha256",
          2: "SHA-256",
          3: "RS256",
          4: "PS256",
          5: "RSA-OAEP-256",
          6: "HS256",
        },
        sha384: {
          1: "sha384",
          2: "SHA-384",
          3: "RS384",
          4: "PS384",
          5: "RSA-OAEP-384",
          6: "HS384",
        },
        sha512: {
          1: "sha512",
          2: "SHA-512",
          3: "RS512",
          4: "PS512",
          5: "RSA-OAEP-512",
          6: "HS512",
        },
      };
    {
      const e = r(h);
      for (let a = 0; a < e.length; a++) {
        const t = r(h[e[a]]);
        for (let o = 0; o < t.length; o++) {
          const s = S(h[e[a]][t[o]]);
          void 0 === h[s] && (h[s] = h[e[a]]);
        }
      }
    }
    function normalizeHashName(e, a = 1) {
      if ("string" != typeof e) return e;
      e = S(e);
      return (h[e] && h[e][a]) || e;
    }
    (normalizeHashName.kContextNode = 1),
      (normalizeHashName.kContextWebCrypto = 2),
      (normalizeHashName.kContextJwkRsa = 3),
      (normalizeHashName.kContextJwkRsaPss = 4),
      (normalizeHashName.kContextJwkRsaOaep = 5),
      (normalizeHashName.kContextJwkHmac = 6),
      (t.exports = normalizeHashName);
  },
  "internal/crypto/hkdf": function (t, e, n, r, i, o) {
    "use strict";
    const { FunctionPrototypeCall: a } = o,
      { HKDFJob: f, kCryptoJobAsync: c, kCryptoJobSync: l } = i("crypto"),
      {
        validateFunction: s,
        validateInteger: h,
        validateString: u,
      } = e("internal/validators"),
      { kMaxLength: y } = e("buffer"),
      {
        normalizeHashName: p,
        toBuf: d,
        validateByteSource: k,
        kKeyObject: b,
      } = e("internal/crypto/util"),
      { createSecretKey: g, isKeyObject: w } = e("internal/crypto/keys"),
      { lazyDOMException: m, promisify: O } = e("internal/util"),
      { isAnyArrayBuffer: A, isArrayBufferView: E } = e("internal/util/types"),
      {
        codes: { ERR_INVALID_ARG_TYPE: _, ERR_OUT_OF_RANGE: v },
        hideStackFrames: B,
      } = e("internal/errors"),
      S = B((t, e, n, r, i) => {
        if (
          (u(t, "digest"),
          (e = (function prepareKey(t) {
            if (w(t)) return t;
            if (A(t)) return g(t);
            if (((t = d(t)), !E(t)))
              throw new _(
                "ikm",
                [
                  "string",
                  "SecretKeyObject",
                  "ArrayBuffer",
                  "TypedArray",
                  "DataView",
                  "Buffer",
                ],
                t
              );
            return g(t);
          })(e)),
          (n = k(n, "salt")),
          (r = k(r, "info")),
          h(i, "length", 0, y),
          r.byteLength > 1024)
        )
          throw v(
            "info",
            "must not contain more than 1024 bytes",
            r.byteLength
          );
        return { hash: t, key: e, salt: n, info: r, length: i };
      });
    function hkdf(t, e, n, r, i, o) {
      ({ hash: t, key: e, salt: n, info: r, length: i } = S(t, e, n, r, i)),
        s(o, "callback");
      const l = new f(c, t, e, n, r, i);
      (l.ondone = (t, e) => {
        if (t) return a(o, l, t);
        a(o, l, null, e);
      }),
        l.run();
    }
    const D = O(hkdf);
    n.exports = {
      hkdf: hkdf,
      hkdfSync: function hkdfSync(t, e, n, r, i) {
        ({ hash: t, key: e, salt: n, info: r, length: i } = S(t, e, n, r, i));
        const o = new f(l, t, e, n, r, i),
          { 0: a, 1: c } = o.run();
        if (void 0 !== a) throw a;
        return c;
      },
      hkdfDeriveBits: async function hkdfDeriveBits(t, e, n) {
        const { hash: r, salt: i, info: o } = t;
        if (0 === n) throw m("length cannot be zero", "OperationError");
        if (null === n) throw m("length cannot be null", "OperationError");
        if (n % 8) throw m("length must be a multiple of 8", "OperationError");
        try {
          return await D(p(r.name), e[b], i, o, n / 8);
        } catch (t) {
          throw m("The operation failed for an operation-specific reason", {
            name: "OperationError",
            cause: t,
          });
        }
      },
    };
  },
  "internal/crypto/keygen": function (e, n, t, o, r, i) {
    "use strict";
    const {
        FunctionPrototypeCall: a,
        ObjectDefineProperty: s,
        SafeArrayIterator: p,
      } = i,
      {
        DhKeyPairGenJob: l,
        DsaKeyPairGenJob: c,
        EcKeyPairGenJob: u,
        NidKeyPairGenJob: y,
        RsaKeyPairGenJob: g,
        SecretKeyGenJob: h,
        kCryptoJobAsync: d,
        kCryptoJobSync: f,
        kKeyVariantRSA_PSS: K,
        kKeyVariantRSA_SSA_PKCS1_v1_5: w,
        EVP_PKEY_ED25519: E,
        EVP_PKEY_ED448: m,
        EVP_PKEY_X25519: b,
        EVP_PKEY_X448: P,
        OPENSSL_EC_NAMED_CURVE: v,
        OPENSSL_EC_EXPLICIT_CURVE: _,
      } = r("crypto"),
      {
        PublicKeyObject: S,
        PrivateKeyObject: A,
        SecretKeyObject: L,
        parsePublicKeyEncoding: k,
        parsePrivateKeyEncoding: O,
      } = n("internal/crypto/keys"),
      { kAesKeyLengths: I } = n("internal/crypto/util"),
      { customPromisifyArgs: J, kEmptyObject: R } = n("internal/util"),
      {
        validateFunction: C,
        validateBuffer: D,
        validateString: V,
        validateInteger: G,
        validateObject: N,
        validateOneOf: j,
        validateInt32: x,
        validateUint32: H,
      } = n("internal/validators"),
      {
        codes: {
          ERR_INCOMPATIBLE_OPTION_PAIR: T,
          ERR_INVALID_ARG_VALUE: U,
          ERR_MISSING_OPTION: W,
        },
      } = n("internal/errors"),
      { isArrayBufferView: Y } = n("internal/util/types"),
      { getOptionValue: B } = n("internal/options");
    function wrapKey(e, n) {
      return "string" == typeof e ||
        Y(e) ||
        (function isJwk(e) {
          return null != e && void 0 !== e.kty;
        })(e)
        ? e
        : new n(e);
    }
    function generateKeyPair(e, n, t) {
      "function" == typeof n && ((t = n), (n = void 0)), C(t, "callback");
      const o = createJob(d, e, n);
      (o.ondone = (e, n) => {
        if (e) return a(t, o, e);
        let { 0: r, 1: i } = n;
        (r = wrapKey(r, S)), (i = wrapKey(i, A)), a(t, o, null, r, i);
      }),
        o.run();
    }
    function createJob(e, n, t) {
      V(n, "type");
      const r = new p(
        (function parseKeyEncoding(e, n = R) {
          const { publicKeyEncoding: t, privateKeyEncoding: o } = n;
          let r, i, a, s, p, l;
          if (null == t) r = i = void 0;
          else {
            if ("object" != typeof t)
              throw new U("options.publicKeyEncoding", t);
            ({ format: r, type: i } = k(t, e, "publicKeyEncoding"));
          }
          if (null == o) a = s = void 0;
          else {
            if ("object" != typeof o)
              throw new U("options.privateKeyEncoding", o);
            ({
              format: a,
              type: s,
              cipher: p,
              passphrase: l,
            } = O(o, e, "privateKeyEncoding"));
          }
          return [r, i, a, s, p, l];
        })(n, t)
      );
      switch ((void 0 !== t && N(t, "options"), n)) {
        case "rsa":
        case "rsa-pss": {
          N(t, "options");
          const { modulusLength: i } = t;
          H(i, "options.modulusLength");
          let { publicExponent: a } = t;
          if (
            (null == a ? (a = 65537) : H(a, "options.publicExponent"),
            "rsa" === n)
          )
            return new g(e, w, i, a, ...r);
          const {
              hash: s,
              mgf1Hash: p,
              hashAlgorithm: l,
              mgf1HashAlgorithm: c,
              saltLength: u,
            } = t,
            y = B("--pending-deprecation");
          if (
            (void 0 !== u && x(u, "options.saltLength", 0),
            void 0 !== l && V(l, "options.hashAlgorithm"),
            void 0 !== c && V(c, "options.mgf1HashAlgorithm"),
            void 0 !== s &&
              (y &&
                o.emitWarning(
                  '"options.hash" is deprecated, use "options.hashAlgorithm" instead.',
                  "DeprecationWarning",
                  "DEP0154"
                ),
              V(s, "options.hash"),
              l && s !== l))
          )
            throw new U("options.hash", s);
          if (
            void 0 !== p &&
            (y &&
              o.emitWarning(
                '"options.mgf1Hash" is deprecated, use "options.mgf1HashAlgorithm" instead.',
                "DeprecationWarning",
                "DEP0154"
              ),
            V(p, "options.mgf1Hash"),
            c && p !== c)
          )
            throw new U("options.mgf1Hash", p);
          return new g(e, K, i, a, l || s, c || p, u, ...r);
        }
        case "dsa": {
          N(t, "options");
          const { modulusLength: n } = t;
          H(n, "options.modulusLength");
          let { divisorLength: o } = t;
          return (
            null == o ? (o = -1) : x(o, "options.divisorLength", 0),
            new c(e, n, o, ...r)
          );
        }
        case "ec": {
          N(t, "options");
          const { namedCurve: n } = t;
          V(n, "options.namedCurve");
          let { paramEncoding: o } = t;
          if (null == o || "named" === o) o = v;
          else {
            if ("explicit" !== o) throw new U("options.paramEncoding", o);
            o = _;
          }
          return new u(e, n, o, ...r);
        }
        case "ed25519":
        case "ed448":
        case "x25519":
        case "x448": {
          let t;
          switch (n) {
            case "ed25519":
              t = E;
              break;
            case "ed448":
              t = m;
              break;
            case "x25519":
              t = b;
              break;
            case "x448":
              t = P;
          }
          return new y(e, t, ...r);
        }
        case "dh": {
          N(t, "options");
          const { group: n, primeLength: o, prime: i, generator: a } = t;
          if (null != n) {
            if (null != i) throw new T("group", "prime");
            if (null != o) throw new T("group", "primeLength");
            if (null != a) throw new T("group", "generator");
            return V(n, "options.group"), new l(e, n, ...r);
          }
          if (null != i) {
            if (null != o) throw new T("prime", "primeLength");
            D(i, "options.prime");
          } else {
            if (null == o)
              throw new W(
                "At least one of the group, prime, or primeLength options"
              );
            x(o, "options.primeLength", 0);
          }
          return (
            null != a && x(a, "options.generator", 0),
            new l(e, null != i ? i : o, null == a ? 2 : a, ...r)
          );
        }
      }
      throw new U("type", n, "must be a supported key type");
    }
    function generateKeyJob(e, n, t) {
      V(n, "type"), N(t, "options");
      const { length: o } = t;
      switch (n) {
        case "hmac":
          G(o, "options.length", 8, 2 ** 31 - 1);
          break;
        case "aes":
          j(o, "options.length", I);
          break;
        default:
          throw new U("type", n, "must be a supported key type");
      }
      return new h(e, o);
    }
    function handleGenerateKeyError(e) {
      if (void 0 === e) return;
      const { 0: n, 1: t } = e;
      if (void 0 !== n) throw n;
      return wrapKey(t, L);
    }
    s(generateKeyPair, J, {
      __proto__: null,
      value: ["publicKey", "privateKey"],
      enumerable: !1,
    }),
      (t.exports = {
        generateKeyPair: generateKeyPair,
        generateKeyPairSync: function generateKeyPairSync(e, n) {
          return (function handleError(e) {
            if (null == e) return;
            const { 0: n, 1: t } = e;
            if (void 0 !== n) throw n;
            const { 0: o, 1: r } = t;
            return { publicKey: wrapKey(o, S), privateKey: wrapKey(r, A) };
          })(createJob(f, e, n).run());
        },
        generateKey: function generateKey(e, n, t) {
          "function" == typeof n && ((t = n), (n = void 0)), C(t, "callback");
          const o = generateKeyJob(d, e, n);
          (o.ondone = (e, n) => {
            if (e) return a(t, o, e);
            a(t, o, null, wrapKey(n, L));
          }),
            handleGenerateKeyError(o.run());
        },
        generateKeySync: function generateKeySync(e, n) {
          return handleGenerateKeyError(generateKeyJob(f, e, n).run());
        },
      });
  },
  "internal/crypto/keys": function (e, t, r, i, n, y) {
    "use strict";
    const {
        ArrayFrom: o,
        ArrayPrototypeSlice: s,
        ObjectDefineProperty: c,
        ObjectDefineProperties: a,
        ObjectSetPrototypeOf: p,
        Symbol: u,
        SymbolToStringTag: f,
        Uint8Array: K,
      } = y,
      {
        KeyObjectHandle: l,
        createNativeKeyObjectClass: d,
        kKeyTypeSecret: h,
        kKeyTypePublic: w,
        kKeyTypePrivate: k,
        kKeyFormatPEM: b,
        kKeyFormatDER: m,
        kKeyFormatJWK: g,
        kKeyEncodingPKCS1: O,
        kKeyEncodingPKCS8: v,
        kKeyEncodingSPKI: j,
        kKeyEncodingSEC1: E,
      } = n("crypto"),
      {
        validateObject: C,
        validateOneOf: P,
        validateString: A,
      } = t("internal/validators"),
      {
        codes: {
          ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS: _,
          ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE: T,
          ERR_CRYPTO_INVALID_JWK: x,
          ERR_ILLEGAL_CONSTRUCTOR: S,
          ERR_INVALID_ARG_TYPE: I,
          ERR_INVALID_ARG_VALUE: R,
          ERR_INVALID_THIS: D,
        },
      } = t("internal/errors"),
      {
        kHandle: B,
        kKeyObject: q,
        getArrayBufferOrView: L,
        bigIntArrayToUnsignedBigInt: F,
      } = t("internal/crypto/util"),
      { isAnyArrayBuffer: H, isArrayBufferView: J } = t("internal/util/types"),
      {
        makeTransferable: N,
        kClone: V,
        kDeserialize: Y,
      } = t("internal/worker/js_transferable"),
      { customInspectSymbol: z, kEnumerableProperty: U } = t("internal/util"),
      { inspect: X } = t("internal/util/inspect"),
      { Buffer: $ } = t("buffer"),
      G = u("kAlgorithm"),
      M = u("kExtractable"),
      W = u("kKeyType"),
      Q = u("kKeyUsages"),
      Z = 0,
      ee = 1,
      te = 2,
      re = 3,
      ie = [];
    for (const e of [
      [O, "pkcs1"],
      [v, "pkcs8"],
      [j, "spki"],
      [E, "sec1"],
    ])
      ie[e[0]] = e[1];
    const {
      0: ne,
      1: ye,
      2: oe,
      3: se,
    } = d((e) => {
      class KeyObject2 extends e {
        constructor(e, t) {
          if ("secret" !== e && "public" !== e && "private" !== e)
            throw new R("type", e);
          if ("object" != typeof t || !(t instanceof l))
            throw new I("handle", "object", t);
          super(t),
            (this[W] = e),
            c(this, B, {
              __proto__: null,
              value: t,
              enumerable: !1,
              configurable: !1,
              writable: !1,
            });
        }
        get type() {
          return this[W];
        }
        static from(e) {
          if (!isCryptoKey(e)) throw new I("key", "CryptoKey", e);
          return e[q];
        }
        equals(e) {
          if (!isKeyObject(e)) throw new I("otherKeyObject", "KeyObject", e);
          return e.type === this.type && this[B].equals(e[B]);
        }
      }
      a(KeyObject2.prototype, {
        [f]: { __proto__: null, configurable: !0, value: "KeyObject" },
      });
      const t = u("kAsymmetricKeyType"),
        r = u("kAsymmetricKeyDetails");
      class AsymmetricKeyObject extends KeyObject2 {
        constructor(e, t) {
          super(e, t);
        }
        get asymmetricKeyType() {
          return this[t] || (this[t] = this[B].getAsymmetricKeyType());
        }
        get asymmetricKeyDetails() {
          switch (this.asymmetricKeyType) {
            case "rsa":
            case "rsa-pss":
            case "dsa":
            case "ec":
              return (
                this[r] ||
                (this[r] = (function normalizeKeyDetails(e = {}) {
                  return void 0 !== e.publicExponent
                    ? { ...e, publicExponent: F(new K(e.publicExponent)) }
                    : e;
                })(this[B].keyDetail({})))
              );
            default:
              return {};
          }
        }
      }
      return [
        KeyObject2,
        class SecretKeyObject2 extends KeyObject2 {
          constructor(e) {
            super("secret", e);
          }
          get symmetricKeySize() {
            return this[B].getSymmetricKeySize();
          }
          export(e) {
            return void 0 !== e &&
              (C(e, "options"),
              P(e.format, "options.format", [void 0, "buffer", "jwk"]),
              "jwk" === e.format)
              ? this[B].exportJwk({}, !1)
              : this[B].export();
          }
        },
        class PublicKeyObject2 extends AsymmetricKeyObject {
          constructor(e) {
            super("public", e);
          }
          export(e) {
            if (e && "jwk" === e.format) return this[B].exportJwk({}, !1);
            const { format: t, type: r } = parsePublicKeyEncoding(
              e,
              this.asymmetricKeyType
            );
            return this[B].export(t, r);
          }
        },
        class PrivateKeyObject2 extends AsymmetricKeyObject {
          constructor(e) {
            super("private", e);
          }
          export(e) {
            if (e && "jwk" === e.format) {
              if (void 0 !== e.passphrase)
                throw new _("jwk", "does not support encryption");
              return this[B].exportJwk({}, !1);
            }
            const {
              format: t,
              type: r,
              cipher: i,
              passphrase: n,
            } = parsePrivateKeyEncoding(e, this.asymmetricKeyType);
            return this[B].export(t, r, i, n);
          }
        },
      ];
    });
    function option(e, t) {
      return void 0 === t ? `options.${e}` : `options.${t}.${e}`;
    }
    function parseKeyFormatAndType(e, t, r, i) {
      const { format: n, type: y } = e,
        o = void 0 === t,
        s = (function parseKeyFormat(e, t, r) {
          if (void 0 === e && void 0 !== t) return t;
          if ("pem" === e) return b;
          if ("der" === e) return m;
          if ("jwk" === e) return g;
          throw new R(r, e);
        })(n, o ? b : void 0, option("format", i)),
        c = (function parseKeyType(e, t, r, i, n) {
          if (void 0 !== e || t) {
            if ("pkcs1" === e) {
              if (void 0 !== r && "rsa" !== r)
                throw new _(e, "can only be used for RSA keys");
              return O;
            }
            if ("spki" === e && !1 !== i) return j;
            if ("pkcs8" === e && !0 !== i) return v;
            if ("sec1" === e && !0 !== i) {
              if (void 0 !== r && "ec" !== r)
                throw new _(e, "can only be used for EC keys");
              return E;
            }
            throw new R(n, e);
          }
        })(y, (!o || s === m) && s !== g, t, r, option("type", i));
      return { format: s, type: c };
    }
    function isStringOrBuffer(e) {
      return "string" == typeof e || J(e) || H(e);
    }
    function parseKeyEncoding(e, t, r, i) {
      C(e, "options");
      const n = void 0 === t,
        { format: y, type: o } = parseKeyFormatAndType(e, t, r, i);
      let s, c, a;
      if (!0 !== r) {
        if ((({ cipher: s, passphrase: c, encoding: a } = e), !n))
          if (null != s) {
            if ("string" != typeof s) throw new R(option("cipher", i), s);
            if (y === m && (o === O || o === E))
              throw new _(ie[o], "does not support encryption");
          } else if (void 0 !== c) throw new R(option("cipher", i), s);
        if (
          (n && void 0 !== c && !isStringOrBuffer(c)) ||
          (!n && null != s && !isStringOrBuffer(c))
        )
          throw new R(option("passphrase", i), c);
      }
      return (
        void 0 !== c && (c = L(c, "key.passphrase", a)),
        { format: y, type: o, cipher: s, passphrase: c }
      );
    }
    function parsePublicKeyEncoding(e, t, r) {
      return parseKeyEncoding(e, t, !!t || void 0, r);
    }
    function parsePrivateKeyEncoding(e, t, r) {
      return parseKeyEncoding(e, t, !1, r);
    }
    function getKeyObjectHandle(e, t) {
      if (t === re)
        throw new I(
          "key",
          ["string", "ArrayBuffer", "Buffer", "TypedArray", "DataView"],
          e
        );
      if ("private" !== e.type) {
        if (t === ee || t === te) throw new T(e.type, "private");
        if ("public" !== e.type) throw new T(e.type, "private or public");
      }
      return e[B];
    }
    function getKeyTypes(e, t = !1) {
      const r = [
        "ArrayBuffer",
        "Buffer",
        "TypedArray",
        "DataView",
        "string",
        "KeyObject",
        "CryptoKey",
      ];
      return t ? s(r, 0, 4) : e ? r : s(r, 0, 5);
    }
    function getKeyObjectHandleFromJwk(e, t) {
      C(e, "key"), P(e.kty, "key.kty", ["RSA", "EC", "OKP"]);
      const r = t === Z || t === te;
      if ("OKP" === e.kty) {
        let t;
        switch (
          (A(e.crv, "key.crv"),
          P(e.crv, "key.crv", ["Ed25519", "Ed448", "X25519", "X448"]),
          A(e.x, "key.x"),
          r || A(e.d, "key.d"),
          (t = r ? $.from(e.x, "base64") : $.from(e.d, "base64")),
          e.crv)
        ) {
          case "Ed25519":
          case "X25519":
            if (32 !== t.byteLength) throw new x();
            break;
          case "Ed448":
            if (57 !== t.byteLength) throw new x();
            break;
          case "X448":
            if (56 !== t.byteLength) throw new x();
        }
        const i = new l(),
          n = r ? w : k;
        if (!i.initEDRaw(e.crv, t, n)) throw new x();
        return i;
      }
      if ("EC" === e.kty) {
        A(e.crv, "key.crv"),
          P(e.crv, "key.crv", ["P-256", "secp256k1", "P-384", "P-521"]),
          A(e.x, "key.x"),
          A(e.y, "key.y");
        const t = { kty: e.kty, crv: e.crv, x: e.x, y: e.y };
        r || (A(e.d, "key.d"), (t.d = e.d));
        const i = new l();
        if (void 0 === i.initJwk(t, t.crv)) throw new x();
        return i;
      }
      A(e.n, "key.n"), A(e.e, "key.e");
      const i = { kty: e.kty, n: e.n, e: e.e };
      r ||
        (A(e.d, "key.d"),
        A(e.p, "key.p"),
        A(e.q, "key.q"),
        A(e.dp, "key.dp"),
        A(e.dq, "key.dq"),
        A(e.qi, "key.qi"),
        (i.d = e.d),
        (i.p = e.p),
        (i.q = e.q),
        (i.dp = e.dp),
        (i.dq = e.dq),
        (i.qi = e.qi));
      const n = new l();
      if (void 0 === n.initJwk(i)) throw new x();
      return n;
    }
    function prepareAsymmetricKey(e, t) {
      if (isKeyObject(e)) return { data: getKeyObjectHandle(e, t) };
      if (isCryptoKey(e)) return { data: getKeyObjectHandle(e[q], t) };
      if (isStringOrBuffer(e)) return { format: b, data: L(e, "key") };
      if ("object" == typeof e) {
        const { key: r, encoding: i, format: n } = e;
        if (isKeyObject(r)) return { data: getKeyObjectHandle(r, t) };
        if (isCryptoKey(r)) return { data: getKeyObjectHandle(r[q], t) };
        if ("jwk" === n)
          return (
            C(r, "key.key"),
            { data: getKeyObjectHandleFromJwk(r, t), format: "jwk" }
          );
        if (!isStringOrBuffer(r))
          throw new I("key.key", getKeyTypes(t !== re), r);
        const y = t !== ee && t !== re && void 0;
        return { data: L(r, "key", i), ...parseKeyEncoding(e, void 0, y) };
      }
      throw new I("key", getKeyTypes(t !== re), e);
    }
    function prepareSecretKey(e, t, r = !1) {
      if (!r) {
        if (isKeyObject(e)) {
          if ("secret" !== e.type) throw new T(e.type, "secret");
          return e[B];
        }
        if (isCryptoKey(e)) {
          if ("secret" !== e.type) throw new T(e.type, "secret");
          return e[q][B];
        }
      }
      if ("string" != typeof e && !J(e) && !H(e))
        throw new I("key", getKeyTypes(!r, r), e);
      return L(e, "key", t);
    }
    function isKeyObject(e) {
      return null != e && void 0 !== e[W];
    }
    class CryptoKey {
      constructor() {
        throw new S();
      }
      [z](e, t) {
        if (e < 0) return this;
        const r = { ...t, depth: null == t.depth ? null : t.depth - 1 };
        return `CryptoKey ${X(
          {
            type: this.type,
            extractable: this.extractable,
            algorithm: this.algorithm,
            usages: this.usages,
          },
          r
        )}`;
      }
      get type() {
        if (!(this instanceof CryptoKey)) throw new D("CryptoKey");
        return this[q].type;
      }
      get extractable() {
        if (!(this instanceof CryptoKey)) throw new D("CryptoKey");
        return this[M];
      }
      get algorithm() {
        if (!(this instanceof CryptoKey)) throw new D("CryptoKey");
        return this[G];
      }
      get usages() {
        if (!(this instanceof CryptoKey)) throw new D("CryptoKey");
        return o(this[Q]);
      }
    }
    a(CryptoKey.prototype, {
      type: U,
      extractable: U,
      algorithm: U,
      usages: U,
      [f]: { __proto__: null, configurable: !0, value: "CryptoKey" },
    });
    class InternalCryptoKey {
      constructor(e, t, r, i) {
        return (
          (this[q] = e), (this[G] = t), (this[M] = i), (this[Q] = r), N(this)
        );
      }
      [V]() {
        const e = this[q],
          t = this.algorithm,
          r = this.extractable;
        return {
          data: {
            keyObject: e,
            algorithm: t,
            usages: this.usages,
            extractable: r,
          },
          deserializeInfo: "internal/crypto/keys:InternalCryptoKey",
        };
      }
      [Y]({ keyObject: e, algorithm: t, usages: r, extractable: i }) {
        (this[q] = e), (this[G] = t), (this[Q] = r), (this[M] = i);
      }
    }
    function isCryptoKey(e) {
      return null != e && void 0 !== e[q];
    }
    (InternalCryptoKey.prototype.constructor = CryptoKey),
      p(InternalCryptoKey.prototype, CryptoKey.prototype),
      (r.exports = {
        createSecretKey: function createSecretKey(e, t) {
          e = prepareSecretKey(e, t, !0);
          const r = new l();
          return r.init(h, e), new ye(r);
        },
        createPublicKey: function createPublicKey(e) {
          const {
            format: t,
            type: r,
            data: i,
            passphrase: n,
          } = prepareAsymmetricKey(e, te);
          let y;
          return (
            "jwk" === t ? (y = i) : ((y = new l()), y.init(w, i, t, r, n)),
            new oe(y)
          );
        },
        createPrivateKey: function createPrivateKey(e) {
          const {
            format: t,
            type: r,
            data: i,
            passphrase: n,
          } = prepareAsymmetricKey(e, re);
          let y;
          return (
            "jwk" === t ? (y = i) : ((y = new l()), y.init(k, i, t, r, n)),
            new se(y)
          );
        },
        KeyObject: ne,
        CryptoKey: CryptoKey,
        InternalCryptoKey: InternalCryptoKey,
        parsePublicKeyEncoding: parsePublicKeyEncoding,
        parsePrivateKeyEncoding: parsePrivateKeyEncoding,
        parseKeyEncoding: parseKeyEncoding,
        preparePrivateKey: function preparePrivateKey(e) {
          return prepareAsymmetricKey(e, ee);
        },
        preparePublicOrPrivateKey: function preparePublicOrPrivateKey(e) {
          return prepareAsymmetricKey(e, Z);
        },
        prepareSecretKey: prepareSecretKey,
        SecretKeyObject: ye,
        PublicKeyObject: oe,
        PrivateKeyObject: se,
        isKeyObject: isKeyObject,
        isCryptoKey: isCryptoKey,
      });
  },
  "internal/crypto/mac": function (e, t, a, r, n, o) {
    "use strict";
    const { ArrayFrom: i, SafeSet: h } = o,
      {
        HmacJob: s,
        KeyObjectHandle: c,
        kCryptoJobAsync: y,
        kSignJobModeSign: l,
        kSignJobModeVerify: m,
      } = n("crypto"),
      {
        getBlockSize: g,
        hasAnyNotIn: f,
        jobPromise: d,
        normalizeHashName: p,
        validateBitLength: w,
        validateKeyOps: k,
        kHandle: u,
        kKeyObject: S,
      } = t("internal/crypto/util"),
      { lazyDOMException: K, promisify: v } = t("internal/util"),
      { generateKey: b } = t("internal/crypto/keygen"),
      {
        InternalCryptoKey: H,
        SecretKeyObject: A,
        createSecretKey: D,
      } = t("internal/crypto/keys"),
      E = v(b);
    a.exports = {
      hmacImportKey: async function hmacImportKey(e, t, a, r, n) {
        const o = new h(n);
        if (f(o, ["sign", "verify"]))
          throw K("Unsupported key usage for an HMAC key", "SyntaxError");
        let i;
        switch (e) {
          case "raw": {
            const e = 8 * t.byteLength;
            if (0 === e || 0 === a.length)
              throw K("Zero-length key is not supported", "DataError");
            if (void 0 !== a.length && a.length !== e)
              throw K("Invalid key length", "DataError");
            i = D(t);
            break;
          }
          case "jwk": {
            if (!t.kty) throw K("Invalid keyData", "DataError");
            if ("oct" !== t.kty)
              throw K('Invalid JWK "kty" Parameter', "DataError");
            if (o.size > 0 && void 0 !== t.use && "sig" !== t.use)
              throw K('Invalid JWK "use" Parameter', "DataError");
            if ((k(t.key_ops, o), void 0 !== t.ext && !1 === t.ext && !0 === r))
              throw K(
                'JWK "ext" Parameter and extractable mismatch',
                "DataError"
              );
            if (
              void 0 !== t.alg &&
              t.alg !==
                (function getAlgorithmName(e) {
                  switch (e) {
                    case "SHA-1":
                    case "SHA-256":
                    case "SHA-384":
                    case "SHA-512":
                      return `HS${e.slice(4)}`;
                    default:
                      throw K("Unsupported digest algorithm", "DataError");
                  }
                })(a.hash.name)
            )
              throw K(
                'JWK "alg" does not match the requested algorithm',
                "DataError"
              );
            const e = new c();
            e.initJwk(t), (i = new A(e));
            break;
          }
          default:
            throw K(`Unable to import HMAC key with format ${e}`);
        }
        const { length: s } = i[u].keyDetail({});
        return new H(i, { name: "HMAC", hash: a.hash, length: s }, n, r);
      },
      hmacGenerateKey: async function hmacGenerateKey(e, t, a) {
        const { hash: r, name: n } = e;
        let { length: o } = e;
        void 0 === o && (o = g(r.name)), w(o, "algorithm.length", !0);
        const s = new h(a);
        if (f(s, ["sign", "verify"]))
          throw K("Unsupported key usage for an HMAC key", "SyntaxError");
        const c = await E("hmac", { length: o }).catch((e) => {
          throw K("The operation failed for an operation-specific reason", {
            name: "OperationError",
            cause: e,
          });
        });
        return new H(
          c,
          { name: n, length: o, hash: { name: r.name } },
          i(s),
          t
        );
      },
      hmacSignVerify: function hmacSignVerify(e, t, a, r) {
        const n = void 0 === r ? l : m;
        return d(() => new s(y, n, p(e.algorithm.hash.name), e[S][u], t, r));
      },
    };
  },
  "internal/crypto/pbkdf2": function (t, n, r, e, o, i) {
    "use strict";
    const { FunctionPrototypeCall: a } = i,
      { Buffer: s } = n("buffer"),
      { PBKDF2Job: c, kCryptoJobAsync: f, kCryptoJobSync: l } = o("crypto"),
      {
        validateFunction: u,
        validateInt32: p,
        validateString: d,
      } = n("internal/validators"),
      {
        getArrayBufferOrView: b,
        getDefaultEncoding: y,
        normalizeHashName: k,
        kKeyObject: h,
      } = n("internal/crypto/util"),
      { lazyDOMException: w, promisify: g } = n("internal/util");
    function pbkdf2(t, n, r, e, o, i) {
      "function" == typeof o && ((i = o), (o = void 0)),
        ({
          password: t,
          salt: n,
          iterations: r,
          keylen: e,
          digest: o,
        } = check(t, n, r, e, o)),
        u(i, "callback");
      const l = new c(f, t, n, r, e, o),
        p = y();
      (l.ondone = (t, n) => {
        if (void 0 !== t) return a(i, l, t);
        const r = s.from(n);
        if ("buffer" === p) return a(i, l, null, r);
        a(i, l, null, r.toString(p));
      }),
        l.run();
    }
    function check(t, n, r, e, o) {
      return (
        d(o, "digest"),
        (t = b(t, "password")),
        (n = b(n, "salt")),
        p(r, "iterations", 1),
        p(e, "keylen", 0),
        { password: t, salt: n, iterations: r, keylen: e, digest: o }
      );
    }
    const m = g(pbkdf2);
    r.exports = {
      pbkdf2: pbkdf2,
      pbkdf2Sync: function pbkdf2Sync(t, n, r, e, o) {
        ({
          password: t,
          salt: n,
          iterations: r,
          keylen: e,
          digest: o,
        } = check(t, n, r, e, o));
        const i = new c(l, t, n, r, e, o),
          { 0: a, 1: f } = i.run();
        if (void 0 !== a) throw a;
        const u = s.from(f),
          p = y();
        return "buffer" === p ? u : u.toString(p);
      },
      pbkdf2DeriveBits: async function pbkdf2DeriveBits(t, n, r) {
        const { iterations: e, hash: o, salt: i } = t;
        if (0 === e) throw w("iterations cannot be zero", "OperationError");
        const a = n[h].export();
        if (0 === r) throw w("length cannot be zero", "OperationError");
        if (null === r) throw w("length cannot be null", "OperationError");
        if (r % 8) throw w("length must be a multiple of 8", "OperationError");
        let s;
        try {
          s = await m(a, i, e, r / 8, k(o.name));
        } catch (t) {
          throw w("The operation failed for an operation-specific reason", {
            name: "OperationError",
            cause: t,
          });
        }
        return s.buffer;
      },
    };
  },
  "internal/crypto/random": function (e, n, t, r, o, i) {
    "use strict";
    const {
        Array: a,
        ArrayBufferPrototypeGetByteLength: f,
        ArrayPrototypeForEach: c,
        ArrayPrototypePush: s,
        ArrayPrototypeShift: u,
        ArrayPrototypeSplice: l,
        BigInt: d,
        BigIntPrototypeToString: y,
        DataView: m,
        DataViewPrototypeGetUint8: h,
        FunctionPrototypeBind: g,
        FunctionPrototypeCall: w,
        MathMin: p,
        NumberIsNaN: b,
        NumberIsSafeInteger: B,
        NumberPrototypeToString: A,
        StringFromCharCodeApply: I,
        StringPrototypePadStart: P,
      } = i,
      {
        RandomBytesJob: S,
        RandomPrimeJob: E,
        CheckPrimeJob: T,
        kCryptoJobAsync: F,
        kCryptoJobSync: v,
        secureBuffer: R,
      } = o("crypto"),
      { kEmptyObject: k, lazyDOMException: U } = n("internal/util"),
      { Buffer: D, kMaxLength: _ } = n("buffer"),
      {
        codes: {
          ERR_INVALID_ARG_TYPE: x,
          ERR_MISSING_ARGS: z,
          ERR_OUT_OF_RANGE: L,
          ERR_OPERATION_FAILED: N,
        },
      } = n("internal/errors"),
      {
        validateNumber: O,
        validateBoolean: V,
        validateFunction: J,
        validateInt32: C,
        validateObject: M,
      } = n("internal/validators"),
      {
        isArrayBufferView: G,
        isAnyArrayBuffer: $,
        isTypedArray: Y,
        isFloat32Array: j,
        isFloat64Array: q,
      } = n("internal/util/types"),
      { FastBuffer: H } = n("internal/buffer"),
      Q = p(_, 2 ** 31 - 1);
    function assertOffset(e, n, t) {
      O(e, "offset"), (e *= n);
      const r = p(t, Q);
      if (b(e) || e > r || e < 0) throw new L("offset", `>= 0 && <= ${r}`, e);
      return e >>> 0;
    }
    function assertSize(e, n, t, r) {
      if ((O(e, "size"), b((e *= n)) || e > Q || e < 0))
        throw new L("size", `>= 0 && <= ${Q}`, e);
      if (e + t > r) throw new L("size + offset", `<= ${r}`, e + t);
      return e >>> 0;
    }
    function randomFillSync(e, n = 0, t) {
      if (!$(e) && !G(e))
        throw new x("buf", ["ArrayBuffer", "ArrayBufferView"], e);
      const r = e.BYTES_PER_ELEMENT || 1;
      if (
        ((n = assertOffset(n, r, e.byteLength)),
        0 ===
          (t =
            void 0 === t
              ? e.byteLength - n
              : assertSize(t, r, n, e.byteLength)))
      )
        return e;
      const o = new S(v, e, n, t).run()[0];
      if (o) throw o;
      return e;
    }
    function randomFill(e, n, t, r) {
      if (!$(e) && !G(e))
        throw new x("buf", ["ArrayBuffer", "ArrayBufferView"], e);
      const o = e.BYTES_PER_ELEMENT || 1;
      if (
        ("function" == typeof n
          ? ((r = n), (n = 0), (t = e.length))
          : "function" == typeof t
          ? ((r = t), (t = e.length - n))
          : J(r, "callback"),
        (n = assertOffset(n, o, e.byteLength)),
        0 ===
          (t =
            void 0 === t
              ? e.byteLength - n
              : assertSize(t, o, n, e.byteLength)))
      )
        return void r(null, e);
      const i = new S(F, e, n, t);
      (i.ondone = g(onJobDone, i, e, r)), i.run();
    }
    const K = 0xffffffffffff,
      W = new H(6144);
    let X = W.length,
      Z = !1;
    const ee = [];
    function randomInt(e, n, t) {
      const o = void 0 === n || "function" == typeof n;
      o && ((t = n), (n = e), (e = 0));
      const i = void 0 === t;
      if ((i || J(t, "callback"), !B(e)))
        throw new x("min", "a safe integer", e);
      if (!B(n)) throw new x("max", "a safe integer", n);
      if (n <= e)
        throw new L("max", `greater than the value of "min" (${e})`, n);
      const a = n - e;
      if (!(a <= K)) throw new L("max" + (o ? "" : " - min"), `<= ${K}`, a);
      const f = K - (K % a);
      for (; i || X < W.length; ) {
        X === W.length && (randomFillSync(W), (X = 0));
        const n = W.readUIntBE(X, 6);
        if (((X += 6), n < f)) {
          const o = (n % a) + e;
          return i ? o : void r.nextTick(t, void 0, o);
        }
      }
      s(ee, { min: e, max: n, callback: t }),
        (function asyncRefillRandomIntCache() {
          if (Z) return;
          (Z = !0),
            randomFill(W, (e) => {
              Z = !1;
              const n = ee,
                t = e && u(n);
              e || (X = 0),
                c(l(n, 0), (e) => {
                  randomInt(e.min, e.max, e.callback);
                }),
                t && t.callback(e);
            });
        })();
    }
    function onJobDone(e, n, t) {
      if (t) return w(n, this, t);
      w(n, this, null, e);
    }
    const ne = 128;
    let te,
      re,
      oe,
      ie = 0;
    function serializeUUID(e, n = 0) {
      const t = (function getHexBytes() {
        if (void 0 === oe) {
          oe = new a(256);
          for (let e = 0; e < oe.length; e++) {
            const n = A(e, 16);
            oe[e] = P(n, 2, "0");
          }
        }
        return oe;
      })();
      return (
        t[e[n]] +
        t[e[n + 1]] +
        t[e[n + 2]] +
        t[e[n + 3]] +
        "-" +
        t[e[n + 4]] +
        t[e[n + 5]] +
        "-" +
        t[(15 & e[n + 6]) | 64] +
        t[e[n + 7]] +
        "-" +
        t[(63 & e[n + 8]) | 128] +
        t[e[n + 9]] +
        "-" +
        t[e[n + 10]] +
        t[e[n + 11]] +
        t[e[n + 12]] +
        t[e[n + 13]] +
        t[e[n + 14]] +
        t[e[n + 15]]
      );
    }
    function createRandomPrimeJob(e, n, t) {
      M(t, "options");
      const { safe: r = !1, bigint: o = !1 } = t;
      let { add: i, rem: a } = t;
      if ((V(r, "options.safe"), V(o, "options.bigint"), void 0 !== i))
        if ("bigint" == typeof i) i = unsignedBigIntToBuffer(i, "options.add");
        else if (!$(i) && !G(i))
          throw new x(
            "options.add",
            ["ArrayBuffer", "TypedArray", "Buffer", "DataView", "bigint"],
            i
          );
      if (void 0 !== a)
        if ("bigint" == typeof a) a = unsignedBigIntToBuffer(a, "options.rem");
        else if (!$(a) && !G(a))
          throw new x(
            "options.rem",
            ["ArrayBuffer", "TypedArray", "Buffer", "DataView", "bigint"],
            a
          );
      const f = new E(e, n, r, i, a);
      return (f.result = o ? arrayBufferToUnsignedBigInt : (e) => e), f;
    }
    const numberToHexCharCode = (e) => (e < 10 ? 48 : 87) + e;
    function arrayBufferToUnsignedBigInt(e) {
      const n = f(e),
        t = a(2 * n),
        r = new m(e);
      for (let e = 0; e < n; e++) {
        const n = h(r, e);
        (t[2 * e] = numberToHexCharCode(n >> 4)),
          (t[2 * e + 1] = numberToHexCharCode(15 & n));
      }
      return d(`0x${I(t)}`);
    }
    function unsignedBigIntToBuffer(e, n) {
      if (e < 0) throw new L(n, ">= 0", e);
      const t = y(e, 16),
        r = P(t, t.length + (t.length % 2), 0);
      return D.from(r, "hex");
    }
    t.exports = {
      checkPrime: function checkPrime(e, n = k, t) {
        if (
          ("bigint" == typeof e && (e = unsignedBigIntToBuffer(e, "candidate")),
          !$(e) && !G(e))
        )
          throw new x(
            "candidate",
            ["ArrayBuffer", "TypedArray", "Buffer", "DataView", "bigint"],
            e
          );
        "function" == typeof n && ((t = n), (n = k)),
          J(t, "callback"),
          M(n, "options");
        const { checks: r = 0 } = n;
        C(r, "options.checks", 0);
        const o = new T(F, e, r);
        (o.ondone = t), o.run();
      },
      checkPrimeSync: function checkPrimeSync(e, n = k) {
        if (
          ("bigint" == typeof e && (e = unsignedBigIntToBuffer(e, "candidate")),
          !$(e) && !G(e))
        )
          throw new x(
            "candidate",
            ["ArrayBuffer", "TypedArray", "Buffer", "DataView", "bigint"],
            e
          );
        M(n, "options");
        const { checks: t = 0 } = n;
        C(t, "options.checks", 0);
        const r = new T(v, e, t),
          { 0: o, 1: i } = r.run();
        if (o) throw o;
        return i;
      },
      randomBytes: function randomBytes(e, n) {
        (e = assertSize(e, 1, 0, 1 / 0)), void 0 !== n && J(n, "callback");
        const t = new H(e);
        if (void 0 === n) return randomFillSync(t.buffer, 0, e), t;
        randomFill(t.buffer, 0, e, function (e) {
          if (e) return w(n, this, e);
          w(n, this, null, t);
        });
      },
      randomFill: randomFill,
      randomFillSync: randomFillSync,
      randomInt: randomInt,
      getRandomValues: function getRandomValues(e) {
        if (arguments.length < 1) throw new z("typedArray");
        if (!Y(e) || j(e) || q(e))
          throw U(
            "The data argument must be an integer-type TypedArray",
            "TypeMismatchError"
          );
        if (e.byteLength > 65536)
          throw U(
            "The requested length exceeds 65,536 bytes",
            "QuotaExceededError"
          );
        return randomFillSync(e, 0), e;
      },
      randomUUID: function randomUUID(e) {
        void 0 !== e && M(e, "options");
        const { disableEntropyCache: n = !1 } = e || k;
        return (
          V(n, "options.disableEntropyCache"),
          n
            ? (function getUnbufferedUUID() {
                if (((re ??= R(16)), void 0 === re))
                  throw new N("Out of memory");
                return randomFillSync(re), serializeUUID(re);
              })()
            : (function getBufferedUUID() {
                if (((te ??= R(16 * ne)), void 0 === te))
                  throw new N("Out of memory");
                return (
                  0 === ie && randomFillSync(te),
                  (ie = (ie + 1) % ne),
                  serializeUUID(te, 16 * ie)
                );
              })()
        );
      },
      generatePrime: function generatePrime(e, n, t) {
        C(e, "size", 1),
          "function" == typeof n && ((t = n), (n = k)),
          J(t, "callback");
        const r = createRandomPrimeJob(F, e, n);
        (r.ondone = (e, n) => {
          e ? t(e) : t(void 0, r.result(n));
        }),
          r.run();
      },
      generatePrimeSync: function generatePrimeSync(e, n = k) {
        C(e, "size", 1);
        const t = createRandomPrimeJob(v, e, n),
          { 0: r, 1: o } = t.run();
        if (r) throw r;
        return t.result(o);
      },
    };
  },
  "internal/crypto/rsa": function (e, r, t, a, n, i) {
    "use strict";
    const { SafeSet: o, Uint8Array: s } = i,
      {
        KeyObjectHandle: y,
        RSACipherJob: p,
        RSAKeyExportJob: c,
        SignJob: l,
        kCryptoJobAsync: h,
        kSignJobModeSign: u,
        kSignJobModeVerify: d,
        kKeyVariantRSA_SSA_PKCS1_v1_5: S,
        kKeyVariantRSA_PSS: m,
        kKeyVariantRSA_OAEP: f,
        kKeyTypePrivate: v,
        kWebCryptoCipherEncrypt: K,
        RSA_PKCS1_PSS_PADDING: k,
      } = n("crypto"),
      { validateInt32: b } = r("internal/validators"),
      {
        bigIntArrayToUnsignedInt: w,
        getUsagesUnion: A,
        hasAnyNotIn: g,
        jobPromise: E,
        normalizeHashName: P,
        validateKeyOps: R,
        validateMaxBufferLength: x,
        kHandle: I,
        kKeyObject: D,
      } = r("internal/crypto/util"),
      { lazyDOMException: O, promisify: _ } = r("internal/util"),
      {
        InternalCryptoKey: C,
        PrivateKeyObject: J,
        PublicKeyObject: U,
        createPublicKey: L,
        createPrivateKey: T,
      } = r("internal/crypto/keys"),
      { generateKeyPair: W } = r("internal/crypto/keygen"),
      j = { "RSASSA-PKCS1-v1_5": S, "RSA-PSS": m, "RSA-OAEP": f },
      N = _(W);
    function verifyAcceptableRsaKeyUse(e, r, t) {
      let a;
      switch (e) {
        case "RSA-OAEP":
          a = r ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "RSA-PSS":
        case "RSASSA-PKCS1-v1_5":
          a = r ? ["verify"] : ["sign"];
          break;
        default:
          throw O("The algorithm is not supported", "NotSupportedError");
      }
      if (g(t, a))
        throw O(`Unsupported key usage for an ${e} key`, "SyntaxError");
    }
    t.exports = {
      rsaCipher: function rsaOaepCipher(e, r, t, { label: a }) {
        const n = e === K ? "public" : "private";
        if (r.type !== n)
          throw O(
            "The requested operation is not valid for the provided key",
            "InvalidAccessError"
          );
        return (
          void 0 !== a && x(a, "algorithm.label"),
          E(() => new p(h, e, r[D][I], t, f, P(r.algorithm.hash.name), a))
        );
      },
      rsaExportKey: function rsaExportKey(e, r) {
        return E(() => new c(h, r, e[D][I], j[e.algorithm.name]));
      },
      rsaImportKey: async function rsaImportKey(e, r, t, a, n) {
        const i = new o(n);
        let p;
        switch (e) {
          case "spki":
            verifyAcceptableRsaKeyUse(t.name, !0, i);
            try {
              p = L({ key: r, format: "der", type: "spki" });
            } catch (e) {
              throw O("Invalid keyData", { name: "DataError", cause: e });
            }
            break;
          case "pkcs8":
            verifyAcceptableRsaKeyUse(t.name, !1, i);
            try {
              p = T({ key: r, format: "der", type: "pkcs8" });
            } catch (e) {
              throw O("Invalid keyData", { name: "DataError", cause: e });
            }
            break;
          case "jwk": {
            if (!r.kty) throw O("Invalid keyData", "DataError");
            if ("RSA" !== r.kty)
              throw O('Invalid JWK "kty" Parameter', "DataError");
            if (
              (verifyAcceptableRsaKeyUse(t.name, void 0 === r.d, i),
              i.size > 0 && void 0 !== r.use)
            ) {
              const e = "RSA-OAEP" === t.name ? "enc" : "sig";
              if (r.use !== e)
                throw O('Invalid JWK "use" Parameter', "DataError");
            }
            if ((R(r.key_ops, i), void 0 !== r.ext && !1 === r.ext && !0 === a))
              throw O(
                'JWK "ext" Parameter and extractable mismatch',
                "DataError"
              );
            if (void 0 !== r.alg) {
              if (P(r.alg, P.kContextWebCrypto) !== t.hash.name)
                throw O(
                  'JWK "alg" does not match the requested algorithm',
                  "DataError"
                );
            }
            const e = new y(),
              n = e.initJwk(r);
            if (void 0 === n) throw O("Invalid JWK", "DataError");
            p = n === v ? new J(e) : new U(e);
            break;
          }
          default:
            throw O(
              `Unable to import RSA key with format ${e}`,
              "NotSupportedError"
            );
        }
        if ("rsa" !== p.asymmetricKeyType)
          throw O("Invalid key type", "DataError");
        const { modulusLength: c, publicExponent: l } = p[I].keyDetail({});
        return new C(
          p,
          {
            name: t.name,
            modulusLength: c,
            publicExponent: new s(l),
            hash: t.hash,
          },
          n,
          a
        );
      },
      rsaKeyGenerate: async function rsaKeyGenerate(e, r, t) {
        const { name: a, modulusLength: n, publicExponent: i, hash: s } = e,
          y = new o(t),
          p = w(i);
        if (void 0 === p)
          throw O(
            "The publicExponent must be equivalent to an unsigned 32-bit value",
            "OperationError"
          );
        if ("RSA-OAEP" === a) {
          if (g(y, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]))
            throw O("Unsupported key usage for a RSA key", "SyntaxError");
        } else if (g(y, ["sign", "verify"]))
          throw O("Unsupported key usage for a RSA key", "SyntaxError");
        const c = await N("rsa", { modulusLength: n, publicExponent: p }).catch(
            (e) => {
              throw O("The operation failed for an operation-specific reason", {
                name: "OperationError",
                cause: e,
              });
            }
          ),
          l = {
            name: a,
            modulusLength: n,
            publicExponent: i,
            hash: { name: s.name },
          };
        let h, u;
        if ("RSA-OAEP" === a)
          (h = A(y, "encrypt", "wrapKey")), (u = A(y, "decrypt", "unwrapKey"));
        else (h = A(y, "verify")), (u = A(y, "sign"));
        return {
          publicKey: new C(c.publicKey, l, h, !0),
          privateKey: new C(c.privateKey, l, u, r),
        };
      },
      rsaSignVerify: function rsaSignVerify(e, r, { saltLength: t }, a) {
        let n;
        "RSA-PSS" === e.algorithm.name &&
          ((n = k), b(t, "algorithm.saltLength", -2));
        const i = (void 0 === a ? u : d) === u ? "private" : "public";
        if (e.type !== i)
          throw O(`Key must be a ${i} key`, "InvalidAccessError");
        return E(
          () =>
            new l(
              h,
              void 0 === a ? u : d,
              e[D][I],
              void 0,
              void 0,
              void 0,
              r,
              P(e.algorithm.hash.name),
              t,
              n,
              void 0,
              a
            )
        );
      },
    };
  },
  "internal/crypto/scrypt": function (t, o, r, n, e, i) {
    "use strict";
    const { FunctionPrototypeCall: a } = i,
      { Buffer: c } = o("buffer"),
      { ScryptJob: l, kCryptoJobAsync: s, kCryptoJobSync: m } = e("crypto"),
      {
        validateFunction: f,
        validateInteger: p,
        validateInt32: d,
        validateUint32: u,
      } = o("internal/validators"),
      {
        codes: {
          ERR_CRYPTO_SCRYPT_INVALID_PARAMETER: y,
          ERR_CRYPTO_SCRYPT_NOT_SUPPORTED: w,
        },
      } = o("internal/errors"),
      { getArrayBufferOrView: v, getDefaultEncoding: k } = o(
        "internal/crypto/util"
      ),
      N = { N: 16384, r: 8, p: 1, maxmem: 32 << 20 };
    function check(t, o, r, n) {
      if (void 0 === l) throw new w();
      (t = v(t, "password")), (o = v(o, "salt")), d(r, "keylen", 0);
      let { N: e, r: i, p: a, maxmem: c } = N;
      if (n && n !== N) {
        const t = void 0 !== n.N;
        if ((t && ((e = n.N), u(e, "N")), void 0 !== n.cost)) {
          if (t) throw new y();
          (e = n.cost), u(e, "cost");
        }
        const o = void 0 !== n.r;
        if ((o && ((i = n.r), u(i, "r")), void 0 !== n.blockSize)) {
          if (o) throw new y();
          (i = n.blockSize), u(i, "blockSize");
        }
        const r = void 0 !== n.p;
        if ((r && ((a = n.p), u(a, "p")), void 0 !== n.parallelization)) {
          if (r) throw new y();
          (a = n.parallelization), u(a, "parallelization");
        }
        void 0 !== n.maxmem && ((c = n.maxmem), p(c, "maxmem", 0)),
          0 === e && (e = N.N),
          0 === i && (i = N.r),
          0 === a && (a = N.p),
          0 === c && (c = N.maxmem);
      }
      return { password: t, salt: o, keylen: r, N: e, r: i, p: a, maxmem: c };
    }
    r.exports = {
      scrypt: function scrypt(t, o, r, n, e = N) {
        e === N && ((e = n), (n = N)), (n = check(t, o, r, n));
        const { N: i, r: m, p: p, maxmem: d } = n;
        ({ password: t, salt: o, keylen: r } = n), f(e, "callback");
        const u = new l(s, t, o, i, m, p, d, r),
          y = k();
        (u.ondone = (t, o) => {
          if (void 0 !== t) return a(e, u, t);
          const r = c.from(o);
          if ("buffer" === y) return a(e, u, null, r);
          a(e, u, null, r.toString(y));
        }),
          u.run();
      },
      scryptSync: function scryptSync(t, o, r, n = N) {
        n = check(t, o, r, n);
        const { N: e, r: i, p: a, maxmem: s } = n;
        ({ password: t, salt: o, keylen: r } = n);
        const f = new l(m, t, o, e, i, a, s, r),
          { 0: p, 1: d } = f.run();
        if (void 0 !== p) throw p;
        const u = c.from(d),
          y = k();
        return "buffer" === y ? u : u.toString(y);
      },
    };
  },
  "internal/crypto/sig": function (t, n, e, i, r, o) {
    "use strict";
    const {
        FunctionPrototypeCall: a,
        ObjectSetPrototypeOf: g,
        ReflectApply: f,
      } = o,
      {
        codes: {
          ERR_CRYPTO_SIGN_KEY_REQUIRED: p,
          ERR_INVALID_ARG_TYPE: s,
          ERR_INVALID_ARG_VALUE: u,
        },
      } = n("internal/errors"),
      {
        validateFunction: d,
        validateEncoding: y,
        validateString: c,
      } = n("internal/validators"),
      {
        Sign: S,
        SignJob: l,
        Verify: h,
        kCryptoJobAsync: w,
        kCryptoJobSync: E,
        kSigEncDER: V,
        kSigEncP1363: A,
        kSignJobModeSign: _,
        kSignJobModeVerify: v,
      } = r("crypto"),
      {
        getArrayBufferOrView: D,
        getDefaultEncoding: b,
        kHandle: P,
      } = n("internal/crypto/util"),
      { preparePrivateKey: R, preparePublicOrPrivateKey: O } = n(
        "internal/crypto/keys"
      ),
      { Writable: m } = n("stream"),
      { Buffer: k } = n("buffer"),
      { isArrayBufferView: I } = n("internal/util/types");
    function Sign(t, n) {
      if (!(this instanceof Sign)) return new Sign(t, n);
      c(t, "algorithm"), (this[P] = new S()), this[P].init(t), f(m, this, [n]);
    }
    function getPadding(t) {
      return getIntOption("padding", t);
    }
    function getSaltLength(t) {
      return getIntOption("saltLength", t);
    }
    function getDSASignatureEncoding(t) {
      if ("object" == typeof t) {
        const { dsaEncoding: n = "der" } = t;
        if ("der" === n) return V;
        if ("ieee-p1363" === n) return A;
        throw new u("options.dsaEncoding", n);
      }
      return V;
    }
    function getIntOption(t, n) {
      const e = n[t];
      if (void 0 !== e) {
        if (e === e >> 0) return e;
        throw new u(`options.${t}`, e);
      }
    }
    function Verify(t, n) {
      if (!(this instanceof Verify)) return new Verify(t, n);
      c(t, "algorithm"), (this[P] = new h()), this[P].init(t), f(m, this, [n]);
    }
    g(Sign.prototype, m.prototype),
      g(Sign, m),
      (Sign.prototype._write = function _write(t, n, e) {
        this.update(t, n), e();
      }),
      (Sign.prototype.update = function update(t, n) {
        if (((n = n || b()), "string" == typeof t)) y(t, n);
        else if (!I(t))
          throw new s(
            "data",
            ["string", "Buffer", "TypedArray", "DataView"],
            t
          );
        return this[P].update(t, n), this;
      }),
      (Sign.prototype.sign = function sign(t, n) {
        if (!t) throw new p();
        const { data: e, format: i, type: r, passphrase: o } = R(t, !0),
          a = getPadding(t),
          g = getSaltLength(t),
          f = getDSASignatureEncoding(t),
          s = this[P].sign(e, i, r, o, a, g, f);
        return (n = n || b()) && "buffer" !== n ? s.toString(n) : s;
      }),
      g(Verify.prototype, m.prototype),
      g(Verify, m),
      (Verify.prototype._write = Sign.prototype._write),
      (Verify.prototype.update = Sign.prototype.update),
      (Verify.prototype.verify = function verify(t, n, e) {
        const { data: i, format: r, type: o, passphrase: a } = O(t, !0);
        e = e || b();
        const g = getPadding(t),
          f = getSaltLength(t),
          p = getDSASignatureEncoding(t);
        return (
          (n = D(n, "signature", e)), this[P].verify(i, r, o, a, n, g, f, p)
        );
      }),
      (e.exports = {
        Sign: Sign,
        signOneShot: function signOneShot(t, n, e, i) {
          if (
            (null != t && c(t, "algorithm"),
            void 0 !== i && d(i, "callback"),
            (n = D(n, "data")),
            !e)
          )
            throw new p();
          const r = getPadding(e),
            o = getSaltLength(e),
            g = getDSASignatureEncoding(e),
            { data: f, format: s, type: u, passphrase: y } = R(e),
            S = new l(i ? w : E, _, f, s, u, y, n, t, o, r, g);
          if (!i) {
            const { 0: t, 1: n } = S.run();
            if (void 0 !== t) throw t;
            return k.from(n);
          }
          (S.ondone = (t, n) => {
            if (t) return a(i, S, t);
            a(i, S, null, k.from(n));
          }),
            S.run();
        },
        Verify: Verify,
        verifyOneShot: function verifyOneShot(t, n, e, i, r) {
          if (
            (null != t && c(t, "algorithm"),
            void 0 !== r && d(r, "callback"),
            (n = D(n, "data")),
            !I(n))
          )
            throw new s("data", ["Buffer", "TypedArray", "DataView"], n);
          const o = getPadding(e),
            g = getSaltLength(e),
            f = getDSASignatureEncoding(e);
          if (!I(i))
            throw new s("signature", ["Buffer", "TypedArray", "DataView"], i);
          const { data: p, format: u, type: y, passphrase: S } = O(e),
            h = new l(r ? w : E, v, p, u, y, S, n, t, g, o, f, i);
          if (!r) {
            const { 0: t, 1: n } = h.run();
            if (void 0 !== t) throw t;
            return n;
          }
          (h.ondone = (t, n) => {
            if (t) return a(r, h, t);
            a(r, h, null, n);
          }),
            h.run();
        },
      });
  },
  "internal/crypto/util": function (e, r, t, a, n, i) {
    "use strict";
    const {
        ArrayBufferIsView: s,
        ArrayBufferPrototypeGetByteLength: o,
        ArrayPrototypeIncludes: l,
        ArrayPrototypePush: f,
        BigInt: u,
        DataViewPrototypeGetBuffer: c,
        DataViewPrototypeGetByteLength: y,
        DataViewPrototypeGetByteOffset: A,
        FunctionPrototypeBind: m,
        Number: d,
        ObjectKeys: h,
        ObjectPrototypeHasOwnProperty: g,
        Promise: p,
        StringPrototypeToUpperCase: P,
        Symbol: S,
        TypedArrayPrototypeGetBuffer: E,
        TypedArrayPrototypeGetByteLength: B,
        TypedArrayPrototypeGetByteOffset: H,
        TypedArrayPrototypeSlice: K,
        Uint8Array: D,
      } = i,
      {
        getCiphers: C,
        getCurves: R,
        getHashes: v,
        setEngine: w,
        secureHeapUsed: I,
      } = n("crypto"),
      { getOptionValue: O } = r("internal/options"),
      {
        crypto: { ENGINE_METHOD_ALL: G },
      } = n("constants"),
      T = r("internal/crypto/hashnames"),
      {
        hideStackFrames: b,
        codes: {
          ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED: _,
          ERR_CRYPTO_ENGINE_UNKNOWN: N,
          ERR_INVALID_ARG_TYPE: L,
          ERR_INVALID_ARG_VALUE: U,
          ERR_OUT_OF_RANGE: V,
        },
      } = r("internal/errors"),
      {
        validateArray: k,
        validateNumber: M,
        validateString: z,
      } = r("internal/validators"),
      { Buffer: F } = r("buffer"),
      {
        cachedResult: x,
        filterDuplicateStrings: j,
        lazyDOMException: W,
      } = r("internal/util"),
      {
        isDataView: X,
        isArrayBufferView: $,
        isAnyArrayBuffer: Y,
      } = r("internal/util/types"),
      q = S("kHandle"),
      J = S("kKeyObject");
    let Q = "buffer";
    function toBuf(e, r) {
      return "string" == typeof e
        ? ("buffer" === r && (r = "utf8"), F.from(e, r))
        : e;
    }
    const Z = x(() => j(C())),
      ee = x(() => j(v())),
      re = x(() => j(R()));
    const te = b((e, r, t) => {
        if (Y(e)) return e;
        if ("string" == typeof e)
          return "buffer" === t && (t = "utf8"), F.from(e, t);
        if (!$(e))
          throw new L(
            r,
            ["string", "ArrayBuffer", "Buffer", "TypedArray", "DataView"],
            e
          );
        return e;
      }),
      ae = 2 ** 31 - 1,
      ne = {
        digest: {
          "SHA-1": null,
          "SHA-256": null,
          "SHA-384": null,
          "SHA-512": null,
        },
        generateKey: {
          "RSASSA-PKCS1-v1_5": "RsaHashedKeyGenParams",
          "RSA-PSS": "RsaHashedKeyGenParams",
          "RSA-OAEP": "RsaHashedKeyGenParams",
          ECDSA: "EcKeyGenParams",
          ECDH: "EcKeyGenParams",
          "AES-CTR": "AesKeyGenParams",
          "AES-CBC": "AesKeyGenParams",
          "AES-GCM": "AesKeyGenParams",
          "AES-KW": "AesKeyGenParams",
          HMAC: "HmacKeyGenParams",
          X25519: null,
          Ed25519: null,
          X448: null,
          Ed448: null,
        },
        sign: {
          "RSASSA-PKCS1-v1_5": null,
          "RSA-PSS": "RsaPssParams",
          ECDSA: "EcdsaParams",
          HMAC: null,
          Ed25519: null,
          Ed448: "Ed448Params",
        },
        verify: {
          "RSASSA-PKCS1-v1_5": null,
          "RSA-PSS": "RsaPssParams",
          ECDSA: "EcdsaParams",
          HMAC: null,
          Ed25519: null,
          Ed448: "Ed448Params",
        },
        importKey: {
          "RSASSA-PKCS1-v1_5": "RsaHashedImportParams",
          "RSA-PSS": "RsaHashedImportParams",
          "RSA-OAEP": "RsaHashedImportParams",
          ECDSA: "EcKeyImportParams",
          ECDH: "EcKeyImportParams",
          HMAC: "HmacImportParams",
          HKDF: null,
          PBKDF2: null,
          "AES-CTR": null,
          "AES-CBC": null,
          "AES-GCM": null,
          "AES-KW": null,
          Ed25519: null,
          X25519: null,
          Ed448: null,
          X448: null,
        },
        deriveBits: {
          HKDF: "HkdfParams",
          PBKDF2: "Pbkdf2Params",
          ECDH: "EcdhKeyDeriveParams",
          X25519: "EcdhKeyDeriveParams",
          X448: "EcdhKeyDeriveParams",
        },
        encrypt: {
          "RSA-OAEP": "RsaOaepParams",
          "AES-CBC": "AesCbcParams",
          "AES-GCM": "AesGcmParams",
          "AES-CTR": "AesCtrParams",
        },
        decrypt: {
          "RSA-OAEP": "RsaOaepParams",
          "AES-CBC": "AesCbcParams",
          "AES-GCM": "AesGcmParams",
          "AES-CTR": "AesCtrParams",
        },
        "get key length": {
          "AES-CBC": "AesDerivedKeyParams",
          "AES-CTR": "AesDerivedKeyParams",
          "AES-GCM": "AesDerivedKeyParams",
          "AES-KW": "AesDerivedKeyParams",
          HMAC: "HmacImportParams",
          HKDF: null,
          PBKDF2: null,
        },
        wrapKey: { "AES-KW": null },
        unwrapKey: { "AES-KW": null },
      },
      ie = {
        AesGcmParams: { iv: "BufferSource", additionalData: "BufferSource" },
        RsaHashedKeyGenParams: { hash: "HashAlgorithmIdentifier" },
        EcKeyGenParams: {},
        HmacKeyGenParams: { hash: "HashAlgorithmIdentifier" },
        RsaPssParams: {},
        EcdsaParams: { hash: "HashAlgorithmIdentifier" },
        HmacImportParams: { hash: "HashAlgorithmIdentifier" },
        HkdfParams: {
          hash: "HashAlgorithmIdentifier",
          salt: "BufferSource",
          info: "BufferSource",
        },
        Ed448Params: { context: "BufferSource" },
        Pbkdf2Params: { hash: "HashAlgorithmIdentifier", salt: "BufferSource" },
        RsaOaepParams: { label: "BufferSource" },
        RsaHashedImportParams: { hash: "HashAlgorithmIdentifier" },
        EcKeyImportParams: {},
      };
    let se;
    function getDataViewOrTypedArrayBuffer(e) {
      return X(e) ? c(e) : E(e);
    }
    function getDataViewOrTypedArrayByteLength(e) {
      return X(e) ? y(e) : B(e);
    }
    const oe = b((e, r) => {
      if (((e = toBuf(e)), Y(e) || $(e))) return e;
      throw new L(
        r,
        ["string", "ArrayBuffer", "TypedArray", "DataView", "Buffer"],
        e
      );
    });
    function onDone(e, r, t, a) {
      if (t)
        return r(
          W("The operation failed for an operation-specific reason", {
            name: "OperationError",
            cause: t,
          })
        );
      e(a);
    }
    const le = {
      sign: 1,
      verify: 2,
      encrypt: 3,
      decrypt: 4,
      wrapKey: 5,
      unwrapKey: 6,
      deriveKey: 7,
      deriveBits: 8,
    };
    t.exports = {
      getArrayBufferOrView: te,
      getCiphers: Z,
      getCurves: re,
      getDataViewOrTypedArrayBuffer: getDataViewOrTypedArrayBuffer,
      getDefaultEncoding: function getDefaultEncoding() {
        return Q;
      },
      getHashes: ee,
      kHandle: q,
      kKeyObject: J,
      setDefaultEncoding: function setDefaultEncoding(e) {
        Q = e;
      },
      setEngine: function setEngine(e, r) {
        if (
          (z(e, "id"),
          r && M(r, "flags"),
          0 === (r >>>= 0) && (r = G),
          "function" != typeof w)
        )
          throw new _();
        if (!w(e, r)) throw new N(e);
      },
      toBuf: toBuf,
      kHashTypes: ["SHA-1", "SHA-256", "SHA-384", "SHA-512"],
      kNamedCurveAliases: {
        "P-256": "prime256v1",
        "P-384": "secp384r1",
        "P-521": "secp521r1",
      },
      kAesKeyLengths: [128, 192, 256],
      normalizeAlgorithm: function normalizeAlgorithm(e, t) {
        if ("string" == typeof e) return normalizeAlgorithm({ name: e }, t);
        se ??= r("internal/crypto/webidl");
        const a = ne[t];
        let n,
          i = se.converters.Algorithm(e, {
            prefix: "Failed to normalize algorithm",
            context: "passed algorithm",
          }).name;
        for (const e in a) g(a, e) && P(e) === P(i) && ((i = e), (n = a[e]));
        if (void 0 === n)
          throw W("Unrecognized algorithm name", "NotSupportedError");
        if (null === n) return { name: i };
        const l = se.converters[n](e, {
          prefix: "Failed to normalize algorithm",
          context: "passed algorithm",
        });
        l.name = i;
        const f = ie[n],
          u = f ? h(f) : [];
        for (let e = 0; e < u.length; e++) {
          const r = u[e];
          if (!g(f, r)) continue;
          const t = f[r],
            a = l[r];
          if ("BufferSource" === t && a) {
            const e = s(a);
            l[r] = K(
              new D(
                e ? getDataViewOrTypedArrayBuffer(a) : a,
                e ? (X((c = a)) ? A(c) : H(c)) : 0,
                e ? getDataViewOrTypedArrayByteLength(a) : o(a)
              )
            );
          } else if ("HashAlgorithmIdentifier" === t)
            l[r] = normalizeAlgorithm(a, "digest");
          else if ("AlgorithmIdentifier" === t)
            throw W("Not implemented.", "NotSupportedError");
        }
        var c;
        return l;
      },
      normalizeHashName: T,
      hasAnyNotIn: function hasAnyNotIn(e, r) {
        for (const t of e) if (!l(r, t)) return !0;
        return !1;
      },
      validateBitLength: function validateBitLength(e, r, t = !1) {
        if (void 0 !== e || t) {
          if ((M(e, r), e < 0)) throw new V(r, "> 0");
          if (e % 8) throw new U(r, e, "must be a multiple of 8");
        }
      },
      validateByteLength: function validateByteLength(e, r, t) {
        if (e.byteLength !== t)
          throw W(`${r} must contain exactly ${t} bytes`, "OperationError");
      },
      validateByteSource: oe,
      validateKeyOps: function validateKeyOps(e, r) {
        if (void 0 === e) return;
        k(e, "keyData.key_ops");
        let t = 0;
        for (let r = 0; r < e.length; r++) {
          const a = e[r],
            n = le[a];
          if (void 0 !== n) {
            if (t & (1 << n)) throw W("Duplicate key operation", "DataError");
            t |= 1 << n;
          }
        }
        if (void 0 !== r)
          for (const t of r)
            if (!l(e, t))
              throw W("Key operations and usage mismatch", "DataError");
      },
      jobPromise: function jobPromise(e) {
        return new p((r, t) => {
          try {
            const a = e();
            (a.ondone = m(onDone, a, r, t)), a.run();
          } catch (e) {
            onDone(r, t, e);
          }
        });
      },
      validateMaxBufferLength: function validateMaxBufferLength(e, r) {
        if (e.byteLength > ae)
          throw W(`${r} must be less than 2147483648 bits`, "OperationError");
      },
      bigIntArrayToUnsignedBigInt: function bigIntArrayToUnsignedBigInt(e) {
        let r = 0n;
        for (let t = 0; t < e.length; ++t) {
          const a = e.length - t - 1;
          r |= u(e[t]) << (8n * u(a));
        }
        return r;
      },
      bigIntArrayToUnsignedInt: function bigIntArrayToUnsignedInt(e) {
        let r = 0;
        for (let t = 0; t < e.length; ++t) {
          const a = e.length - t - 1;
          if (a >= 4 && e[t]) return;
          r |= e[t] << (8 * a);
        }
        return r;
      },
      getBlockSize: function getBlockSize(e) {
        switch (e) {
          case "SHA-1":
          case "SHA-256":
            return 512;
          case "SHA-384":
          case "SHA-512":
            return 1024;
        }
      },
      getStringOption: function getStringOption(e, r) {
        let t;
        return e && null != (t = e[r]) && z(t, `options.${r}`), t;
      },
      getUsagesUnion: function getUsagesUnion(e, ...r) {
        const t = [];
        for (let a = 0; a < r.length; a++) e.has(r[a]) && f(t, r[a]);
        return t;
      },
      secureHeapUsed: function secureHeapUsed() {
        if (void 0 === I())
          return { total: 0, used: 0, utilization: 0, min: 0 };
        const e = d(I()),
          r = d(O("--secure-heap"));
        return {
          total: r,
          used: e,
          utilization: e / r,
          min: d(O("--secure-heap-min")),
        };
      },
    };
  },
  "internal/crypto/webcrypto": function (e, r, t, n, a, o) {
    "use strict";
    const {
        ArrayPrototypeIncludes: i,
        JSONParse: c,
        JSONStringify: s,
        ObjectDefineProperties: l,
        ReflectApply: p,
        ReflectConstruct: u,
        SafeSet: y,
        StringPrototypeRepeat: f,
        SymbolToStringTag: g,
      } = o,
      {
        kWebCryptoKeyFormatRaw: m,
        kWebCryptoKeyFormatPKCS8: h,
        kWebCryptoKeyFormatSPKI: d,
        kWebCryptoCipherEncrypt: x,
        kWebCryptoCipherDecrypt: w,
      } = a("crypto"),
      { TextDecoder: b, TextEncoder: S } = r("internal/encoding"),
      {
        codes: { ERR_ILLEGAL_CONSTRUCTOR: C, ERR_INVALID_THIS: v },
      } = r("internal/errors"),
      {
        CryptoKey: K,
        InternalCryptoKey: A,
        createSecretKey: E,
      } = r("internal/crypto/keys"),
      { asyncDigest: _ } = r("internal/crypto/hash"),
      {
        getBlockSize: k,
        hasAnyNotIn: I,
        normalizeAlgorithm: D,
        normalizeHashName: R,
        validateMaxBufferLength: B,
        kHandle: P,
        kKeyObject: F,
      } = r("internal/crypto/util"),
      { kEnumerableProperty: U, lazyDOMException: H } = r("internal/util"),
      { getRandomValues: O, randomUUID: W } = r("internal/crypto/random");
    let q;
    async function exportKey(e, t) {
      if (this !== N) throw new v("SubtleCrypto");
      q ??= r("internal/crypto/webidl");
      const n = "Failed to execute 'exportKey' on 'SubtleCrypto'";
      if (
        (q.requiredArguments(arguments.length, 2, { prefix: n }),
        (e = q.converters.KeyFormat(e, { prefix: n, context: "1st argument" })),
        !(t = q.converters.CryptoKey(t, { prefix: n, context: "2nd argument" }))
          .extractable)
      )
        throw H("key is not extractable", "InvalidAccessException");
      switch (e) {
        case "spki":
          return (async function exportKeySpki(e) {
            switch (e.algorithm.name) {
              case "RSASSA-PKCS1-v1_5":
              case "RSA-PSS":
              case "RSA-OAEP":
                if ("public" === e.type)
                  return r("internal/crypto/rsa").rsaExportKey(e, d);
                break;
              case "ECDSA":
              case "ECDH":
                if ("public" === e.type)
                  return r("internal/crypto/ec").ecExportKey(e, d);
                break;
              case "Ed25519":
              case "Ed448":
              case "X25519":
              case "X448":
                if ("public" === e.type)
                  return r("internal/crypto/cfrg").cfrgExportKey(e, d);
            }
            throw H(
              `Unable to export a raw ${e.algorithm.name} ${e.type} key`,
              "InvalidAccessError"
            );
          })(t);
        case "pkcs8":
          return (async function exportKeyPkcs8(e) {
            switch (e.algorithm.name) {
              case "RSASSA-PKCS1-v1_5":
              case "RSA-PSS":
              case "RSA-OAEP":
                if ("private" === e.type)
                  return r("internal/crypto/rsa").rsaExportKey(e, h);
                break;
              case "ECDSA":
              case "ECDH":
                if ("private" === e.type)
                  return r("internal/crypto/ec").ecExportKey(e, h);
                break;
              case "Ed25519":
              case "Ed448":
              case "X25519":
              case "X448":
                if ("private" === e.type)
                  return r("internal/crypto/cfrg").cfrgExportKey(e, h);
            }
            throw H(
              `Unable to export a pkcs8 ${e.algorithm.name} ${e.type} key`,
              "InvalidAccessError"
            );
          })(t);
        case "jwk":
          return (async function exportKeyJWK(e) {
            const t = e[F][P].exportJwk(
              { key_ops: e.usages, ext: e.extractable },
              !0
            );
            switch (e.algorithm.name) {
              case "RSASSA-PKCS1-v1_5":
                return (t.alg = R(e.algorithm.hash.name, R.kContextJwkRsa)), t;
              case "RSA-PSS":
                return (
                  (t.alg = R(e.algorithm.hash.name, R.kContextJwkRsaPss)), t
                );
              case "RSA-OAEP":
                return (
                  (t.alg = R(e.algorithm.hash.name, R.kContextJwkRsaOaep)), t
                );
              case "ECDSA":
              case "ECDH":
                return (t.crv ||= e.algorithm.namedCurve), t;
              case "X25519":
              case "X448":
                return (t.crv ||= e.algorithm.name), t;
              case "Ed25519":
              case "Ed448":
                return (t.crv ||= e.algorithm.name), (t.alg = "EdDSA"), t;
              case "AES-CTR":
              case "AES-CBC":
              case "AES-GCM":
              case "AES-KW":
                return (
                  (t.alg = r("internal/crypto/aes").getAlgorithmName(
                    e.algorithm.name,
                    e.algorithm.length
                  )),
                  t
                );
              case "HMAC":
                return (t.alg = R(e.algorithm.hash.name, R.kContextJwkHmac)), t;
            }
            throw H("Not yet supported", "NotSupportedError");
          })(t);
        case "raw":
          return (async function exportKeyRaw(e) {
            switch (e.algorithm.name) {
              case "ECDSA":
              case "ECDH":
                if ("public" === e.type)
                  return r("internal/crypto/ec").ecExportKey(e, m);
                break;
              case "Ed25519":
              case "Ed448":
              case "X25519":
              case "X448":
                if ("public" === e.type)
                  return r("internal/crypto/cfrg").cfrgExportKey(e, m);
                break;
              case "AES-CTR":
              case "AES-CBC":
              case "AES-GCM":
              case "AES-KW":
              case "HMAC":
                return e[F].export().buffer;
            }
            throw H(
              `Unable to export a raw ${e.algorithm.name} ${e.type} key`,
              "InvalidAccessError"
            );
          })(t);
      }
      throw H("Export format is unsupported", "NotSupportedError");
    }
    async function importKey(e, t, n, a, o) {
      if (this !== N) throw new v("SubtleCrypto");
      q ??= r("internal/crypto/webidl");
      const i = "Failed to execute 'importKey' on 'SubtleCrypto'";
      q.requiredArguments(arguments.length, 4, { prefix: i });
      const c =
        "jwk" ===
        (e = q.converters.KeyFormat(e, { prefix: i, context: "1st argument" }))
          ? "JsonWebKey"
          : "BufferSource";
      let s;
      switch (
        ((t = q.converters[c](t, { prefix: i, context: "2nd argument" })),
        (n = q.converters.AlgorithmIdentifier(n, {
          prefix: i,
          context: "3rd argument",
        })),
        (a = q.converters.boolean(a, { prefix: i, context: "4th argument" })),
        (o = q.converters["sequence<KeyUsage>"](o, {
          prefix: i,
          context: "5th argument",
        })),
        (n = D(n, "importKey")).name)
      ) {
        case "RSASSA-PKCS1-v1_5":
        case "RSA-PSS":
        case "RSA-OAEP":
          s = await r("internal/crypto/rsa").rsaImportKey(e, t, n, a, o);
          break;
        case "ECDSA":
        case "ECDH":
          s = await r("internal/crypto/ec").ecImportKey(e, t, n, a, o);
          break;
        case "Ed25519":
        case "Ed448":
        case "X25519":
        case "X448":
          s = await r("internal/crypto/cfrg").cfrgImportKey(e, t, n, a, o);
          break;
        case "HMAC":
          s = await r("internal/crypto/mac").hmacImportKey(e, t, n, a, o);
          break;
        case "AES-CTR":
        case "AES-CBC":
        case "AES-GCM":
        case "AES-KW":
          s = await r("internal/crypto/aes").aesImportKey(n, e, t, a, o);
          break;
        case "HKDF":
        case "PBKDF2":
          s = await (async function importGenericSecretKey(
            { name: e, length: r },
            t,
            n,
            a,
            o
          ) {
            const i = new y(o);
            if (a) throw H(`${e} keys are not extractable`, "SyntaxError");
            if (I(i, ["deriveKey", "deriveBits"]))
              throw H(`Unsupported key usage for a ${e} key`, "SyntaxError");
            if ("raw" === t) {
              if (I(i, ["deriveKey", "deriveBits"]))
                throw H(`Unsupported key usage for a ${e} key`, "SyntaxError");
              const t = 8 * n.byteLength;
              if (void 0 !== r && r !== t)
                throw H("Invalid key length", "DataError");
              const a = E(n);
              return new A(a, { name: e }, o, !1);
            }
            throw H(
              `Unable to import ${e} key with format ${t}`,
              "NotSupportedError"
            );
          })(n, e, t, a, o);
          break;
        default:
          throw H("Unrecognized algorithm name", "NotSupportedError");
      }
      if (
        ("secret" === s.type || "private" === s.type) &&
        0 === s.usages.length
      )
        throw H(
          `Usages cannot be empty when importing a ${s.type} key.`,
          "SyntaxError"
        );
      return s;
    }
    function signVerify(e, t, n, a) {
      let o = "sign";
      if (
        (void 0 !== a && (o = "verify"),
        (e = D(e, o)),
        !i(t.usages, o) || e.name !== t.algorithm.name)
      )
        throw H(`Unable to use this key to ${o}`, "InvalidAccessError");
      switch (e.name) {
        case "RSA-PSS":
        case "RSASSA-PKCS1-v1_5":
          return r("internal/crypto/rsa").rsaSignVerify(t, n, e, a);
        case "ECDSA":
          return r("internal/crypto/ec").ecdsaSignVerify(t, n, e, a);
        case "Ed25519":
        case "Ed448":
          return r("internal/crypto/cfrg").eddsaSignVerify(t, n, e, a);
        case "HMAC":
          return r("internal/crypto/mac").hmacSignVerify(t, n, e, a);
      }
      throw H("Unrecognized algorithm name", "NotSupportedError");
    }
    async function cipherOrWrap(e, t, n, a, o) {
      if (n.algorithm.name !== t.name || !i(n.usages, o))
        throw H(
          "The requested operation is not valid for the provided key",
          "InvalidAccessError"
        );
      switch ((B(a, "data"), t.name)) {
        case "RSA-OAEP":
          return r("internal/crypto/rsa").rsaCipher(e, n, a, t);
        case "AES-CTR":
        case "AES-CBC":
        case "AES-GCM":
          return r("internal/crypto/aes").aesCipher(e, n, a, t);
        case "AES-KW":
          if ("wrapKey" === o || "unwrapKey" === o)
            return r("internal/crypto/aes").aesCipher(e, n, a, t);
      }
      throw H("Unrecognized algorithm name", "NotSupportedError");
    }
    class SubtleCrypto {
      constructor() {
        throw new C();
      }
    }
    const N = u(function () {}, [], SubtleCrypto);
    class Crypto {
      constructor() {
        throw new C();
      }
      get subtle() {
        if (this !== X) throw new v("Crypto");
        return N;
      }
    }
    const X = u(function () {}, [], Crypto);
    l(Crypto.prototype, {
      [g]: {
        __proto__: null,
        enumerable: !1,
        configurable: !0,
        writable: !1,
        value: "Crypto",
      },
      subtle: U,
      getRandomValues: {
        __proto__: null,
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function getRandomValues(e) {
          if (this !== X) throw new v("Crypto");
          return (
            (q ??= r("internal/crypto/webidl")),
            q.requiredArguments(arguments.length, 1, {
              prefix: "Failed to execute 'getRandomValues' on 'Crypto'",
            }),
            p(O, this, arguments)
          );
        },
      },
      randomUUID: {
        __proto__: null,
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: function randomUUID() {
          if (this !== X) throw new v("Crypto");
          return W();
        },
      },
      CryptoKey: {
        __proto__: null,
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: K,
      },
    }),
      l(SubtleCrypto.prototype, {
        [g]: {
          __proto__: null,
          enumerable: !1,
          configurable: !0,
          writable: !1,
          value: "SubtleCrypto",
        },
        encrypt: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function encrypt(e, t, n) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const a = "Failed to execute 'encrypt' on 'SubtleCrypto'";
            return (
              q.requiredArguments(arguments.length, 3, { prefix: a }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: a,
                context: "1st argument",
              })),
              (t = q.converters.CryptoKey(t, {
                prefix: a,
                context: "2nd argument",
              })),
              (n = q.converters.BufferSource(n, {
                prefix: a,
                context: "3rd argument",
              })),
              (e = D(e, "encrypt")),
              cipherOrWrap(x, e, t, n, "encrypt")
            );
          },
        },
        decrypt: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function decrypt(e, t, n) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const a = "Failed to execute 'decrypt' on 'SubtleCrypto'";
            return (
              q.requiredArguments(arguments.length, 3, { prefix: a }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: a,
                context: "1st argument",
              })),
              (t = q.converters.CryptoKey(t, {
                prefix: a,
                context: "2nd argument",
              })),
              (n = q.converters.BufferSource(n, {
                prefix: a,
                context: "3rd argument",
              })),
              (e = D(e, "decrypt")),
              cipherOrWrap(w, e, t, n, "decrypt")
            );
          },
        },
        sign: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function sign(e, t, n) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const a = "Failed to execute 'sign' on 'SubtleCrypto'";
            return (
              q.requiredArguments(arguments.length, 3, { prefix: a }),
              signVerify(
                (e = q.converters.AlgorithmIdentifier(e, {
                  prefix: a,
                  context: "1st argument",
                })),
                (t = q.converters.CryptoKey(t, {
                  prefix: a,
                  context: "2nd argument",
                })),
                (n = q.converters.BufferSource(n, {
                  prefix: a,
                  context: "3rd argument",
                }))
              )
            );
          },
        },
        verify: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function verify(e, t, n, a) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const o = "Failed to execute 'verify' on 'SubtleCrypto'";
            return (
              q.requiredArguments(arguments.length, 4, { prefix: o }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: o,
                context: "1st argument",
              })),
              (t = q.converters.CryptoKey(t, {
                prefix: o,
                context: "2nd argument",
              })),
              (n = q.converters.BufferSource(n, {
                prefix: o,
                context: "3rd argument",
              })),
              signVerify(
                e,
                t,
                (a = q.converters.BufferSource(a, {
                  prefix: o,
                  context: "4th argument",
                })),
                n
              )
            );
          },
        },
        digest: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function digest(e, t) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const n = "Failed to execute 'digest' on 'SubtleCrypto'";
            return (
              q.requiredArguments(arguments.length, 2, { prefix: n }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: n,
                context: "1st argument",
              })),
              (t = q.converters.BufferSource(t, {
                prefix: n,
                context: "2nd argument",
              })),
              (e = D(e, "digest")),
              p(_, this, [e, t])
            );
          },
        },
        generateKey: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function generateKey(e, t, n) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const a = "Failed to execute 'generateKey' on 'SubtleCrypto'";
            let o, i;
            switch (
              (q.requiredArguments(arguments.length, 3, { prefix: a }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: a,
                context: "1st argument",
              })),
              (t = q.converters.boolean(t, {
                prefix: a,
                context: "2nd argument",
              })),
              (n = q.converters["sequence<KeyUsage>"](n, {
                prefix: a,
                context: "3rd argument",
              })),
              (e = D(e, "generateKey")).name)
            ) {
              case "RSASSA-PKCS1-v1_5":
              case "RSA-PSS":
              case "RSA-OAEP":
                (i = "CryptoKeyPair"),
                  (o = await r("internal/crypto/rsa").rsaKeyGenerate(e, t, n));
                break;
              case "Ed25519":
              case "Ed448":
              case "X25519":
              case "X448":
                (i = "CryptoKeyPair"),
                  (o = await r("internal/crypto/cfrg").cfrgGenerateKey(
                    e,
                    t,
                    n
                  ));
                break;
              case "ECDSA":
              case "ECDH":
                (i = "CryptoKeyPair"),
                  (o = await r("internal/crypto/ec").ecGenerateKey(e, t, n));
                break;
              case "HMAC":
                (i = "CryptoKey"),
                  (o = await r("internal/crypto/mac").hmacGenerateKey(e, t, n));
                break;
              case "AES-CTR":
              case "AES-CBC":
              case "AES-GCM":
              case "AES-KW":
                (i = "CryptoKey"),
                  (o = await r("internal/crypto/aes").aesGenerateKey(e, t, n));
                break;
              default:
                throw H("Unrecognized algorithm name", "NotSupportedError");
            }
            if (
              ("CryptoKey" === i &&
                ("secret" === o.type || "private" === o.type) &&
                0 === o.usages.length) ||
              ("CryptoKeyPair" === i && 0 === o.privateKey.usages.length)
            )
              throw H(
                "Usages cannot be empty when creating a key.",
                "SyntaxError"
              );
            return o;
          },
        },
        deriveKey: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function deriveKey(e, t, n, a, o) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const c = "Failed to execute 'deriveKey' on 'SubtleCrypto'";
            if (
              (q.requiredArguments(arguments.length, 5, { prefix: c }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: c,
                context: "1st argument",
              })),
              (t = q.converters.CryptoKey(t, {
                prefix: c,
                context: "2nd argument",
              })),
              (n = q.converters.AlgorithmIdentifier(n, {
                prefix: c,
                context: "3rd argument",
              })),
              (a = q.converters.boolean(a, {
                prefix: c,
                context: "4th argument",
              })),
              (o = q.converters["sequence<KeyUsage>"](o, {
                prefix: c,
                context: "5th argument",
              })),
              (e = D(e, "deriveBits")),
              (n = D(n, "importKey")),
              !i(t.usages, "deriveKey"))
            )
              throw H(
                "baseKey does not have deriveKey usage",
                "InvalidAccessError"
              );
            if (t.algorithm.name !== e.name)
              throw H("Key algorithm mismatch", "InvalidAccessError");
            const s = (function getKeyLength({ name: e, length: r, hash: t }) {
              switch (e) {
                case "AES-CTR":
                case "AES-CBC":
                case "AES-GCM":
                case "AES-KW":
                  if (128 !== r && 192 !== r && 256 !== r)
                    throw H("Invalid key length", "OperationError");
                  return r;
                case "HMAC":
                  if (void 0 === r) return k(t?.name);
                  if ("number" == typeof r && 0 !== r) return r;
                  throw H("Invalid key length", "OperationError");
                case "HKDF":
                case "PBKDF2":
                  return null;
              }
            })(D(arguments[2], "get key length"));
            let l;
            switch (e.name) {
              case "X25519":
              case "X448":
              case "ECDH":
                l = await r("internal/crypto/diffiehellman").ecdhDeriveBits(
                  e,
                  t,
                  s
                );
                break;
              case "HKDF":
                l = await r("internal/crypto/hkdf").hkdfDeriveBits(e, t, s);
                break;
              case "PBKDF2":
                l = await r("internal/crypto/pbkdf2").pbkdf2DeriveBits(e, t, s);
                break;
              default:
                throw H("Unrecognized algorithm name", "NotSupportedError");
            }
            return p(importKey, this, ["raw", l, n, a, o]);
          },
        },
        deriveBits: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function deriveBits(e, t, n) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const a = "Failed to execute 'deriveBits' on 'SubtleCrypto'";
            if (
              (q.requiredArguments(arguments.length, 3, { prefix: a }),
              (e = q.converters.AlgorithmIdentifier(e, {
                prefix: a,
                context: "1st argument",
              })),
              (t = q.converters.CryptoKey(t, {
                prefix: a,
                context: "2nd argument",
              })),
              null !== n &&
                (n = q.converters["unsigned long"](n, {
                  prefix: a,
                  context: "3rd argument",
                })),
              (e = D(e, "deriveBits")),
              !i(t.usages, "deriveBits"))
            )
              throw H(
                "baseKey does not have deriveBits usage",
                "InvalidAccessError"
              );
            if (t.algorithm.name !== e.name)
              throw H("Key algorithm mismatch", "InvalidAccessError");
            switch (e.name) {
              case "X25519":
              case "X448":
              case "ECDH":
                return r("internal/crypto/diffiehellman").ecdhDeriveBits(
                  e,
                  t,
                  n
                );
              case "HKDF":
                return r("internal/crypto/hkdf").hkdfDeriveBits(e, t, n);
              case "PBKDF2":
                return r("internal/crypto/pbkdf2").pbkdf2DeriveBits(e, t, n);
            }
            throw H("Unrecognized algorithm name", "NotSupportedError");
          },
        },
        importKey: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: importKey,
        },
        exportKey: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: exportKey,
        },
        wrapKey: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function wrapKey(e, t, n, a) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const o = "Failed to execute 'wrapKey' on 'SubtleCrypto'";
            q.requiredArguments(arguments.length, 4, { prefix: o }),
              (e = q.converters.KeyFormat(e, {
                prefix: o,
                context: "1st argument",
              })),
              (t = q.converters.CryptoKey(t, {
                prefix: o,
                context: "2nd argument",
              })),
              (n = q.converters.CryptoKey(n, {
                prefix: o,
                context: "3rd argument",
              })),
              (a = q.converters.AlgorithmIdentifier(a, {
                prefix: o,
                context: "4th argument",
              }));
            try {
              a = D(a, "wrapKey");
            } catch {
              a = D(a, "encrypt");
            }
            let i = await p(exportKey, this, [e, t]);
            if ("jwk" === e) {
              const e = new S(),
                r = s(i);
              i =
                "AES-KW" === a.name && r.length % 8 != 0
                  ? e.encode(r + f(" ", 8 - (r.length % 8)))
                  : e.encode(r);
            }
            return cipherOrWrap(x, a, n, i, "wrapKey");
          },
        },
        unwrapKey: {
          __proto__: null,
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: async function unwrapKey(e, t, a, o, i, s, l) {
            if (this !== N) throw new v("SubtleCrypto");
            q ??= r("internal/crypto/webidl");
            const u = "Failed to execute 'unwrapKey' on 'SubtleCrypto'";
            q.requiredArguments(arguments.length, 7, { prefix: u }),
              (e = q.converters.KeyFormat(e, {
                prefix: u,
                context: "1st argument",
              })),
              (t = q.converters.BufferSource(t, {
                prefix: u,
                context: "2nd argument",
              })),
              (a = q.converters.CryptoKey(a, {
                prefix: u,
                context: "3rd argument",
              })),
              (o = q.converters.AlgorithmIdentifier(o, {
                prefix: u,
                context: "4th argument",
              })),
              (i = q.converters.AlgorithmIdentifier(i, {
                prefix: u,
                context: "5th argument",
              })),
              (s = q.converters.boolean(s, {
                prefix: u,
                context: "6th argument",
              })),
              (l = q.converters["sequence<KeyUsage>"](l, {
                prefix: u,
                context: "7th argument",
              }));
            try {
              o = D(o, "unwrapKey");
            } catch {
              o = D(o, "decrypt");
            }
            let y = await cipherOrWrap(w, o, a, t, "unwrapKey");
            if ("jwk" === e) {
              const e = void 0 !== n.versions.icu ? { fatal: !0 } : void 0,
                r = new b("utf-8", e);
              try {
                y = c(r.decode(y));
              } catch {
                throw H("Invalid wrapped JWK key", "DataError");
              }
            }
            return p(importKey, this, [e, y, i, s, l]);
          },
        },
      }),
      (t.exports = {
        Crypto: Crypto,
        CryptoKey: K,
        SubtleCrypto: SubtleCrypto,
        crypto: X,
      });
  },
  "internal/crypto/webidl": function (e, r, t, n, o, a) {
    "use strict";
    const {
        ArrayBufferIsView: i,
        ArrayBufferPrototype: c,
        ArrayPrototypePush: s,
        ArrayPrototypeSort: u,
        MathPow: y,
        MathTrunc: f,
        Number: d,
        NumberIsFinite: m,
        ObjectAssign: v,
        ObjectPrototypeIsPrototypeOf: h,
        SafeArrayIterator: l,
        SafeSet: g,
        String: p,
        SymbolIterator: k,
        TypedArrayPrototypeGetBuffer: w,
        TypedArrayPrototypeGetSymbolToStringTag: P,
        TypeError: b,
        globalThis: { SharedArrayBuffer: A },
      } = a,
      { kEmptyObject: C, setOwnProperty: q } = r("internal/util"),
      { CryptoKey: S } = r("internal/crypto/webcrypto"),
      { getDataViewOrTypedArrayBuffer: I } = r("internal/crypto/util");
    function makeException(e, r = C) {
      return (function codedTypeError(e, r = C) {
        const t = new b(e);
        return v(t, r), t;
      })(
        `${r.prefix ? r.prefix + ": " : ""}${
          0 === r.context?.length ? "" : (r.context ?? "Value") + " "
        }${e}`,
        { code: r.code || "ERR_INVALID_ARG_TYPE" }
      );
    }
    function type(e) {
      if (null === e) return "Null";
      switch (typeof e) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "number":
          return "Number";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "bigint":
          return "BigInt";
        default:
          return "Object";
      }
    }
    const E = f;
    function createIntegerConversion(e) {
      const r = y(2, e) - 1,
        t = y(2, e);
      return (e, n = C) => {
        let o = (function toNumber(e, r = C) {
          switch (typeof e) {
            case "number":
              return e;
            case "bigint":
              throw makeException(
                "is a BigInt and cannot be converted to a number.",
                r
              );
            case "symbol":
              throw makeException(
                "is a Symbol and cannot be converted to a number.",
                r
              );
            default:
              return d(e);
          }
        })(e, n);
        if (n.enforceRange) {
          if (!m(o)) throw makeException("is not a finite number.", n);
          if (((o = E(o)), o < 0 || o > r))
            throw makeException(`is outside the expected range of 0 to ${r}.`, {
              __proto__: null,
              ...n,
              code: "ERR_OUT_OF_RANGE",
            });
          return o;
        }
        return m(o) && 0 !== o
          ? ((o = E(o)), (o >= 0 && o <= r) || (o %= t), o)
          : 0;
      };
    }
    const D = {};
    function isSharedArrayBuffer(e) {
      return h(A.prototype, e);
    }
    function createDictionaryConverter(e, r) {
      let t = !1;
      const n = [];
      for (let e = 0; e < r.length; e++) {
        const o = r[e];
        o.required && (t = !0), s(n, o);
      }
      return (
        u(n, (e, r) => (e.key === r.key ? 0 : e.key < r.key ? -1 : 1)),
        function (r, o = C) {
          const a = type(r);
          switch (a) {
            case "Undefined":
            case "Null":
            case "Object":
              break;
            default:
              throw makeException("can not be converted to a dictionary", o);
          }
          const i = r,
            c = {};
          if (null == r && !t) return c;
          for (const r of new l(n)) {
            const t = r.key;
            let n;
            if (
              ((n = "Undefined" === a || "Null" === a ? void 0 : i[t]),
              void 0 !== n)
            ) {
              const a = `'${t}' of '${e}'${o.context ? ` (${o.context})` : ""}`,
                i = (0, r.converter)(n, { __proto__: null, ...o, context: a });
              q(c, t, i);
            } else if (r.required)
              throw makeException(
                `can not be converted to '${e}' because '${t}' is required in '${e}'.`,
                { __proto__: null, ...o, code: "ERR_MISSING_OPTION" }
              );
          }
          return c;
        }
      );
    }
    function createEnumConverter(e, r) {
      const t = new g(r);
      return function (r, n = C) {
        const o = p(r);
        if (!t.has(o))
          throw makeException(
            `value '${o}' is not a valid enum value of type ${e}.`,
            { __proto__: null, ...n, code: "ERR_INVALID_ARG_VALUE" }
          );
        return o;
      };
    }
    function createSequenceConverter(e) {
      return function (r, t = C) {
        if ("Object" !== type(r))
          throw makeException("can not be converted to sequence.", t);
        const n = r?.[k]?.();
        if (void 0 === n)
          throw makeException("can not be converted to sequence.", t);
        const o = [];
        for (;;) {
          const r = n?.next?.();
          if (void 0 === r)
            throw makeException("can not be converted to sequence.", t);
          if (!0 === r.done) break;
          const a = e(r.value, {
            __proto__: null,
            ...t,
            context: `${t.context}, index ${o.length}`,
          });
          s(o, a);
        }
        return o;
      };
    }
    (D.boolean = (e) => !!e),
      (D.octet = createIntegerConversion(8)),
      (D["unsigned short"] = createIntegerConversion(16)),
      (D["unsigned long"] = createIntegerConversion(32)),
      (D.DOMString = function (e, r = C) {
        if ("string" == typeof e) return e;
        if ("symbol" == typeof e)
          throw makeException(
            "is a Symbol and cannot be converted to a string.",
            r
          );
        return p(e);
      }),
      (D.object = (e, r) => {
        if ("Object" !== type(e)) throw makeException("is not an object.", r);
        return e;
      }),
      (D.Uint8Array = (e, r = C) => {
        if (!i(e) || "Uint8Array" !== P(e))
          throw makeException("is not an Uint8Array object.", r);
        if (isSharedArrayBuffer(w(e)))
          throw makeException(
            "is a view on a SharedArrayBuffer, which is not allowed.",
            r
          );
        return e;
      }),
      (D.BufferSource = (e, r = C) => {
        if (i(e)) {
          if (isSharedArrayBuffer(I(e)))
            throw makeException(
              "is a view on a SharedArrayBuffer, which is not allowed.",
              r
            );
          return e;
        }
        if (
          !(function isNonSharedArrayBuffer(e) {
            return h(c, e);
          })(e)
        )
          throw makeException(
            "is not instance of ArrayBuffer, Buffer, TypedArray, or DataView.",
            r
          );
        return e;
      }),
      (D["sequence<DOMString>"] = createSequenceConverter(D.DOMString)),
      (D.AlgorithmIdentifier = (e, r) =>
        "Object" === type(e) ? D.object(e, r) : D.DOMString(e, r)),
      (D.KeyFormat = createEnumConverter("KeyFormat", [
        "raw",
        "pkcs8",
        "spki",
        "jwk",
      ])),
      (D.KeyUsage = createEnumConverter("KeyUsage", [
        "encrypt",
        "decrypt",
        "sign",
        "verify",
        "deriveKey",
        "deriveBits",
        "wrapKey",
        "unwrapKey",
      ])),
      (D["sequence<KeyUsage>"] = createSequenceConverter(D.KeyUsage)),
      (D.HashAlgorithmIdentifier = D.AlgorithmIdentifier);
    const _ = [{ key: "name", converter: D.DOMString, required: !0 }];
    (D.Algorithm = createDictionaryConverter("Algorithm", _)),
      (D.BigInteger = D.Uint8Array);
    const R = [
      ...new l(_),
      {
        key: "modulusLength",
        converter: (e, r) => D["unsigned long"](e, { ...r, enforceRange: !0 }),
        required: !0,
      },
      { key: "publicExponent", converter: D.BigInteger, required: !0 },
    ];
    (D.RsaKeyGenParams = createDictionaryConverter("RsaKeyGenParams", R)),
      (D.RsaHashedKeyGenParams = createDictionaryConverter(
        "RsaHashedKeyGenParams",
        [
          ...new l(R),
          { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
        ]
      )),
      (D.RsaHashedImportParams = createDictionaryConverter(
        "RsaHashedImportParams",
        [
          ...new l(_),
          { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
        ]
      )),
      (D.NamedCurve = D.DOMString),
      (D.EcKeyImportParams = createDictionaryConverter("EcKeyImportParams", [
        ...new l(_),
        { key: "namedCurve", converter: D.NamedCurve, required: !0 },
      ])),
      (D.EcKeyGenParams = createDictionaryConverter("EcKeyGenParams", [
        ...new l(_),
        { key: "namedCurve", converter: D.NamedCurve, required: !0 },
      ])),
      (D.AesKeyGenParams = createDictionaryConverter("AesKeyGenParams", [
        ...new l(_),
        {
          key: "length",
          converter: (e, r) =>
            D["unsigned short"](e, { ...r, enforceRange: !0 }),
          required: !0,
        },
      ])),
      (D.HmacKeyGenParams = createDictionaryConverter("HmacKeyGenParams", [
        ...new l(_),
        { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
        {
          key: "length",
          converter: (e, r) =>
            D["unsigned long"](e, { ...r, enforceRange: !0 }),
        },
      ])),
      (D.RsaPssParams = createDictionaryConverter("RsaPssParams", [
        ...new l(_),
        {
          key: "saltLength",
          converter: (e, r) =>
            D["unsigned long"](e, { ...r, enforceRange: !0 }),
          required: !0,
        },
      ])),
      (D.RsaOaepParams = createDictionaryConverter("RsaOaepParams", [
        ...new l(_),
        { key: "label", converter: D.BufferSource },
      ])),
      (D.EcdsaParams = createDictionaryConverter("EcdsaParams", [
        ...new l(_),
        { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
      ])),
      (D.HmacImportParams = createDictionaryConverter("HmacImportParams", [
        ...new l(_),
        { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
        {
          key: "length",
          converter: (e, r) =>
            D["unsigned long"](e, { ...r, enforceRange: !0 }),
        },
      ]));
    const simpleDomStringKey = (e) => ({ key: e, converter: D.DOMString });
    (D.RsaOtherPrimesInfo = createDictionaryConverter("RsaOtherPrimesInfo", [
      simpleDomStringKey("r"),
      simpleDomStringKey("d"),
      simpleDomStringKey("t"),
    ])),
      (D["sequence<RsaOtherPrimesInfo>"] = createSequenceConverter(
        D.RsaOtherPrimesInfo
      )),
      (D.JsonWebKey = createDictionaryConverter("JsonWebKey", [
        simpleDomStringKey("kty"),
        simpleDomStringKey("use"),
        { key: "key_ops", converter: D["sequence<DOMString>"] },
        simpleDomStringKey("alg"),
        { key: "ext", converter: D.boolean },
        simpleDomStringKey("crv"),
        simpleDomStringKey("x"),
        simpleDomStringKey("y"),
        simpleDomStringKey("d"),
        simpleDomStringKey("n"),
        simpleDomStringKey("e"),
        simpleDomStringKey("p"),
        simpleDomStringKey("q"),
        simpleDomStringKey("dp"),
        simpleDomStringKey("dq"),
        simpleDomStringKey("qi"),
        { key: "oth", converter: D["sequence<RsaOtherPrimesInfo>"] },
        simpleDomStringKey("k"),
      ])),
      (D.HkdfParams = createDictionaryConverter("HkdfParams", [
        ...new l(_),
        { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
        { key: "salt", converter: D.BufferSource, required: !0 },
        { key: "info", converter: D.BufferSource, required: !0 },
      ])),
      (D.Pbkdf2Params = createDictionaryConverter("Pbkdf2Params", [
        ...new l(_),
        { key: "hash", converter: D.HashAlgorithmIdentifier, required: !0 },
        {
          key: "iterations",
          converter: (e, r) =>
            D["unsigned long"](e, { ...r, enforceRange: !0 }),
          required: !0,
        },
        { key: "salt", converter: D.BufferSource, required: !0 },
      ])),
      (D.AesDerivedKeyParams = createDictionaryConverter(
        "AesDerivedKeyParams",
        [
          ...new l(_),
          {
            key: "length",
            converter: (e, r) =>
              D["unsigned short"](e, { ...r, enforceRange: !0 }),
            required: !0,
          },
        ]
      )),
      (D.AesCbcParams = createDictionaryConverter("AesCbcParams", [
        ...new l(_),
        { key: "iv", converter: D.BufferSource, required: !0 },
      ])),
      (D.AesGcmParams = createDictionaryConverter("AesGcmParams", [
        ...new l(_),
        { key: "iv", converter: D.BufferSource, required: !0 },
        {
          key: "tagLength",
          converter: (e, r) => D.octet(e, { ...r, enforceRange: !0 }),
        },
        { key: "additionalData", converter: D.BufferSource },
      ])),
      (D.AesCtrParams = createDictionaryConverter("AesCtrParams", [
        ...new l(_),
        { key: "counter", converter: D.BufferSource, required: !0 },
        {
          key: "length",
          converter: (e, r) => D.octet(e, { ...r, enforceRange: !0 }),
          required: !0,
        },
      ])),
      (D.CryptoKey = (function createInterfaceConverter(e, r) {
        return (t, n) => {
          if (!h(r, t)) throw makeException(`is not of type ${e}.`, n);
          return t;
        };
      })("CryptoKey", S.prototype)),
      (D.EcdhKeyDeriveParams = createDictionaryConverter(
        "EcdhKeyDeriveParams",
        [...new l(_), { key: "public", converter: D.CryptoKey, required: !0 }]
      )),
      (D.Ed448Params = createDictionaryConverter("Ed448Params", [
        ...new l(_),
        { key: "context", converter: D.BufferSource, required: !1 },
      ])),
      (t.exports = {
        converters: D,
        requiredArguments: function requiredArguments(e, r, t = C) {
          if (e < r)
            throw makeException(
              `${r} argument${
                1 === r ? "" : "s"
              } required, but only ${e} present.`,
              { __proto__: null, ...t, context: "", code: "ERR_MISSING_ARGS" }
            );
        },
      });
  },
  "internal/crypto/x509": function (t, e, i, r, s, n) {
    "use strict";
    const { ObjectSetPrototypeOf: a, SafeMap: c, Symbol: l } = n,
      {
        parseX509: o,
        X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT: h,
        X509_CHECK_FLAG_NEVER_CHECK_SUBJECT: u,
        X509_CHECK_FLAG_NO_WILDCARDS: f,
        X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS: g,
        X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS: p,
        X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS: d,
      } = s("crypto"),
      { PublicKeyObject: b, isKeyObject: C } = e("internal/crypto/keys"),
      { customInspectSymbol: y, kEmptyObject: _ } = e("internal/util"),
      {
        validateBoolean: v,
        validateObject: m,
        validateString: A,
      } = e("internal/validators"),
      { inspect: k } = e("internal/util/inspect"),
      { Buffer: w } = e("buffer"),
      { isArrayBufferView: I } = e("internal/util/types"),
      {
        codes: { ERR_INVALID_ARG_TYPE: L, ERR_INVALID_ARG_VALUE: X },
      } = e("internal/errors"),
      {
        JSTransferable: j,
        kClone: E,
        kDeserialize: N,
      } = e("internal/worker/js_transferable"),
      { kHandle: S } = e("internal/crypto/util");
    let K;
    const F = l("kInternalState");
    function isX509Certificate(t) {
      return void 0 !== t[F];
    }
    function getFlags(t = _) {
      m(t, "options");
      const {
        subject: e = "default",
        wildcards: i = !0,
        partialWildcards: r = !0,
        multiLabelWildcards: s = !1,
        singleLabelSubdomains: n = !1,
      } = { ...t };
      let a = 0;
      switch (
        (A(e, "options.subject"),
        v(i, "options.wildcards"),
        v(r, "options.partialWildcards"),
        v(s, "options.multiLabelWildcards"),
        v(n, "options.singleLabelSubdomains"),
        e)
      ) {
        case "default":
          break;
        case "always":
          a |= h;
          break;
        case "never":
          a |= u;
          break;
        default:
          throw new X("options.subject", e);
      }
      return i || (a |= f), r || (a |= g), s && (a |= p), n && (a |= d), a;
    }
    class InternalX509Certificate extends j {
      [F] = new c();
      constructor(t) {
        super(), (this[S] = t);
      }
    }
    class X509Certificate extends j {
      [F] = new c();
      constructor(t) {
        if (("string" == typeof t && (t = w.from(t)), !I(t)))
          throw new L(
            "buffer",
            ["string", "Buffer", "TypedArray", "DataView"],
            t
          );
        super(), (this[S] = o(t));
      }
      [y](t, e) {
        if (t < 0) return this;
        const i = { ...e, depth: null == e.depth ? null : e.depth - 1 };
        return `X509Certificate ${k(
          {
            subject: this.subject,
            subjectAltName: this.subjectAltName,
            issuer: this.issuer,
            infoAccess: this.infoAccess,
            validFrom: this.validFrom,
            validTo: this.validTo,
            fingerprint: this.fingerprint,
            fingerprint256: this.fingerprint256,
            fingerprint512: this.fingerprint512,
            keyUsage: this.keyUsage,
            serialNumber: this.serialNumber,
          },
          i
        )}`;
      }
      [E]() {
        return {
          data: { handle: this[S] },
          deserializeInfo: "internal/crypto/x509:InternalX509Certificate",
        };
      }
      [N]({ handle: t }) {
        this[S] = t;
      }
      get subject() {
        let t = this[F].get("subject");
        return (
          void 0 === t && ((t = this[S].subject()), this[F].set("subject", t)),
          t
        );
      }
      get subjectAltName() {
        let t = this[F].get("subjectAltName");
        return (
          void 0 === t &&
            ((t = this[S].subjectAltName()), this[F].set("subjectAltName", t)),
          t
        );
      }
      get issuer() {
        let t = this[F].get("issuer");
        return (
          void 0 === t && ((t = this[S].issuer()), this[F].set("issuer", t)), t
        );
      }
      get issuerCertificate() {
        let t = this[F].get("issuerCertificate");
        if (void 0 === t) {
          this[S].getIssuerCert() &&
            (t = new InternalX509Certificate(this[S].getIssuerCert())),
            this[F].set("issuerCertificate", t);
        }
        return t;
      }
      get infoAccess() {
        let t = this[F].get("infoAccess");
        return (
          void 0 === t &&
            ((t = this[S].infoAccess()), this[F].set("infoAccess", t)),
          t
        );
      }
      get validFrom() {
        let t = this[F].get("validFrom");
        return (
          void 0 === t &&
            ((t = this[S].validFrom()), this[F].set("validFrom", t)),
          t
        );
      }
      get validTo() {
        let t = this[F].get("validTo");
        return (
          void 0 === t && ((t = this[S].validTo()), this[F].set("validTo", t)),
          t
        );
      }
      get fingerprint() {
        let t = this[F].get("fingerprint");
        return (
          void 0 === t &&
            ((t = this[S].fingerprint()), this[F].set("fingerprint", t)),
          t
        );
      }
      get fingerprint256() {
        let t = this[F].get("fingerprint256");
        return (
          void 0 === t &&
            ((t = this[S].fingerprint256()), this[F].set("fingerprint256", t)),
          t
        );
      }
      get fingerprint512() {
        let t = this[F].get("fingerprint512");
        return (
          void 0 === t &&
            ((t = this[S].fingerprint512()), this[F].set("fingerprint512", t)),
          t
        );
      }
      get keyUsage() {
        let t = this[F].get("keyUsage");
        return (
          void 0 === t &&
            ((t = this[S].keyUsage()), this[F].set("keyUsage", t)),
          t
        );
      }
      get serialNumber() {
        let t = this[F].get("serialNumber");
        return (
          void 0 === t &&
            ((t = this[S].serialNumber()), this[F].set("serialNumber", t)),
          t
        );
      }
      get raw() {
        let t = this[F].get("raw");
        return void 0 === t && ((t = this[S].raw()), this[F].set("raw", t)), t;
      }
      get publicKey() {
        let t = this[F].get("publicKey");
        return (
          void 0 === t &&
            ((t = new b(this[S].publicKey())), this[F].set("publicKey", t)),
          t
        );
      }
      toString() {
        let t = this[F].get("pem");
        return void 0 === t && ((t = this[S].pem()), this[F].set("pem", t)), t;
      }
      toJSON() {
        return this.toString();
      }
      get ca() {
        let t = this[F].get("ca");
        return (
          void 0 === t && ((t = this[S].checkCA()), this[F].set("ca", t)), t
        );
      }
      checkHost(t, e) {
        return A(t, "name"), this[S].checkHost(t, getFlags(e));
      }
      checkEmail(t, e) {
        return A(t, "email"), this[S].checkEmail(t, getFlags(e));
      }
      checkIP(t, e) {
        return A(t, "ip"), this[S].checkIP(t, getFlags(e));
      }
      checkIssued(t) {
        if (!isX509Certificate(t))
          throw new L("otherCert", "X509Certificate", t);
        return this[S].checkIssued(t[S]);
      }
      checkPrivateKey(t) {
        if (!C(t)) throw new L("pkey", "KeyObject", t);
        if ("private" !== t.type) throw new X("pkey", t);
        return this[S].checkPrivateKey(t[S]);
      }
      verify(t) {
        if (!C(t)) throw new L("pkey", "KeyObject", t);
        if ("public" !== t.type) throw new X("pkey", t);
        return this[S].verify(t[S]);
      }
      toLegacyObject() {
        return (
          (K ??= e("_tls_common").translatePeerCertificate),
          K(this[S].toLegacy())
        );
      }
    }
    (InternalX509Certificate.prototype.constructor = X509Certificate),
      a(InternalX509Certificate.prototype, X509Certificate.prototype),
      (i.exports = {
        X509Certificate: X509Certificate,
        InternalX509Certificate: InternalX509Certificate,
        isX509Certificate: isX509Certificate,
      });
  },
  "internal/debugger/inspect": function (t, e, i, r, s, n) {
    "use strict";
    const {
        ArrayPrototypeForEach: o,
        ArrayPrototypeJoin: c,
        ArrayPrototypeMap: l,
        ArrayPrototypePop: a,
        ArrayPrototypePushApply: h,
        ArrayPrototypeShift: d,
        ArrayPrototypeSlice: p,
        FunctionPrototypeBind: u,
        Number: g,
        Promise: f,
        PromisePrototypeThen: w,
        PromiseResolve: y,
        Proxy: P,
        RegExpPrototypeExec: m,
        RegExpPrototypeSymbolSplit: E,
        StringPrototypeEndsWith: R,
        StringPrototypeSplit: $,
      } = n,
      { spawn: b } = e("child_process"),
      { EventEmitter: _ } = e("events"),
      x = e("net"),
      S = e("util"),
      { setInterval: A, setTimeout: T } = e("timers/promises"),
      { AbortController: v } = e("internal/abort_controller"),
      { 0: k, 1: N } = [
        e("internal/debugger/inspect_client"),
        e("internal/debugger/inspect_repl"),
      ],
      U = S.debuglog("inspect"),
      { ERR_DEBUGGER_STARTUP_ERROR: D } = e("internal/errors").codes;
    const I = /Debugger listening on ws:\/\/\[?(.+?)\]?:(\d+)\//;
    async function runScript(t, e, i, s, n) {
      await (async function portIsFree(t, e, i = 3e3) {
        if (0 === e) return;
        const r = new v(),
          { signal: s } = r;
        T(i).then(() => r.abort());
        const n = A(150);
        for (;;) {
          if ((await n.next(), s.aborted))
            throw new D(`Timeout (${i}) waiting for ${t}:${e} to be free`);
          const r = await new f((i) => {
            const r = x.connect(e, t);
            r.on("error", i),
              r.on("connect", () => {
                r.end(), i();
              });
          });
          if ("ECONNREFUSED" === r?.code) return;
        }
      })(i, s);
      const o = [`--inspect-brk=${s}`, t];
      h(o, e);
      const c = b(r.execPath, o);
      c.stdout.setEncoding("utf8"),
        c.stderr.setEncoding("utf8"),
        c.stdout.on("data", (t) => n(t, "stdout")),
        c.stderr.on("data", (t) => n(t, "stderr"));
      let l = "";
      return new f((t) => {
        c.stderr.on("data", function waitForListenHint(e) {
          l += e;
          const i = m(I, l);
          if (i) {
            const e = i[1],
              r = g(i[2]);
            c.stderr.removeListener("data", waitForListenHint), t([c, r, e]);
          }
        });
      });
    }
    class NodeInspector {
      constructor(t, e, i) {
        (this.options = t),
          (this.stdin = e),
          (this.stdout = i),
          (this.paused = !0),
          (this.child = null),
          t.script
            ? (this._runScript = u(
                runScript,
                null,
                t.script,
                t.scriptArgs,
                t.host,
                t.port,
                u(this.childPrint, this)
              ))
            : (this._runScript = () => y([null, t.port, t.host])),
          (this.client = new k()),
          (this.domainNames = [
            "Debugger",
            "HeapProfiler",
            "Profiler",
            "Runtime",
          ]),
          o(this.domainNames, (t) => {
            this[t] = (function createAgentProxy(t, e) {
              const i = new _();
              return (
                (i.then = (e, i) => {
                  const r = {
                    [S.inspect.custom]: (e, { stylize: i }) =>
                      i(`[Agent ${t}]`, "special"),
                  };
                  return w(y(r), e, i);
                }),
                new P(i, {
                  __proto__: null,
                  get: (i, r) =>
                    r in i
                      ? i[r]
                      : function callVirtualMethod(i) {
                          return e.callMethod(`${t}.${r}`, i);
                        },
                })
              );
            })(t, this.client);
          }),
          (this.handleDebugEvent = (t, e) => {
            const { 0: i, 1: r } = $(t, ".");
            i in this && this[i].emit(r, e);
          }),
          this.client.on("debugEvent", this.handleDebugEvent);
        const s = N(this);
        r.on("exit", () => this.killChild());
        const exitCodeZero = () => r.exit(0);
        r.once("SIGTERM", exitCodeZero),
          r.once("SIGHUP", exitCodeZero),
          (async () => {
            try {
              await this.run();
              const t = await s();
              (this.repl = t),
                this.repl.on("exit", exitCodeZero),
                (this.paused = !1);
            } catch (t) {
              r.nextTick(() => {
                throw t;
              });
            }
          })();
      }
      suspendReplWhile(t) {
        return (
          this.repl && this.repl.pause(),
          this.stdin.pause(),
          (this.paused = !0),
          (async () => {
            try {
              await t(),
                (this.paused = !1),
                this.repl && (this.repl.resume(), this.repl.displayPrompt()),
                this.stdin.resume();
            } catch (t) {
              r.nextTick(() => {
                throw t;
              });
            }
          })()
        );
      }
      killChild() {
        this.client.reset(),
          this.child && (this.child.kill(), (this.child = null));
      }
      async run() {
        this.killChild();
        const { 0: t, 1: e, 2: i } = await this._runScript();
        (this.child = t), this.print(`connecting to ${i}:${e} ..`, !1);
        for (let t = 0; t < 5; t++) {
          U("connection attempt #%d", t), this.stdout.write(".");
          try {
            return (
              await this.client.connect(e, i),
              U("connection established"),
              void this.stdout.write(" ok\n")
            );
          } catch (t) {
            U("connect failed", t), await T(1e3);
          }
        }
        this.stdout.write(" failed to connect, please retry\n"), r.exit(1);
      }
      clearLine() {
        this.stdout.isTTY
          ? (this.stdout.cursorTo(0), this.stdout.clearLine(1))
          : this.stdout.write("\b");
      }
      print(t, e = !1) {
        this.clearLine(), this.stdout.write(e ? `${t}\n` : t);
      }
      #t = { stdout: "", stderr: "" };
      childPrint(t, e) {
        const i = E(/\r\n|\r|\n/g, this.#t[e] + t);
        (this.#t[e] = ""), "" !== i[i.length - 1] && (this.#t[e] = a(i));
        const r = c(
          l(i, (t) => `< ${t}`),
          "\n"
        );
        i.length &&
          (this.print(r, !0), this.paused || this.repl.displayPrompt(!0)),
          R(r, "Waiting for the debugger to disconnect...\n") &&
            this.killChild();
      }
    }
    t.start = function startInspect(
      t = p(r.argv, 2),
      e = r.stdin,
      i = r.stdout
    ) {
      if (t.length < 1) {
        const t = `${r.argv0} ${r.argv[1]}`;
        r.stderr.write(
          `Usage: ${t} script.js\n       ${t} <host>:<port>\n       ${t} --port=<port> Use 0 for random port assignment\n       ${t} -p <pid>\n`
        ),
          r.exit(1);
      }
      const s = (function parseArgv(t) {
          const e = d(t);
          let i = "127.0.0.1",
            s = 9229,
            n = !1,
            o = e,
            c = t;
          const l = m(/^([^:]+):(\d+)$/, e),
            a = m(/^--port=(\d+)$/, e);
          if (l) (i = l[1]), (s = g(l[2])), (n = !0), (o = null);
          else if (a) (s = g(a[1])), (o = t[0]), (c = p(t, 1));
          else if (1 === t.length && null !== m(/^\d+$/, t[0]) && "-p" === e) {
            const e = g(t[0]);
            try {
              r._debugProcess(e);
            } catch (t) {
              throw (
                ("ESRCH" === t.code &&
                  (r.stderr.write(`Target process: ${e} doesn't exist.\n`),
                  r.exit(1)),
                t)
              );
            }
            (o = null), (n = !0);
          }
          return { host: i, port: s, isRemote: n, script: o, scriptArgs: c };
        })(t),
        n = new NodeInspector(s, e, i);
      e.resume(),
        r.on("uncaughtException", function handleUnexpectedError(t) {
          "ERR_DEBUGGER_STARTUP_ERROR" !== t.code
            ? r.stderr.write(
                `There was an internal error in Node.js. Please report this bug.\n${t.message}\n${t.stack}\n`
              )
            : (r.stderr.write(t.message), r.stderr.write("\n")),
            n.child && n.child.kill(),
            r.exit(1);
        });
    };
  },
  "internal/debugger/inspect_client": function (e, t, s, o, n, r) {
    "use strict";
    const {
        ArrayPrototypePush: c,
        ErrorCaptureStackTrace: i,
        FunctionPrototypeBind: a,
        JSONParse: h,
        JSONStringify: d,
        ObjectKeys: l,
        Promise: p,
      } = r,
      u = t("buffer").Buffer,
      _ = t("crypto"),
      { ERR_DEBUGGER_ERROR: f } = t("internal/errors").codes,
      { EventEmitter: k } = t("events"),
      w = t("http"),
      g = t("url"),
      b = t("internal/util/debuglog").debuglog("inspect");
    function unpackError({ code: e, message: t }) {
      const s = new f(`${t}`);
      return (s.code = e), i(s, unpackError), s;
    }
    function decodeFrameHybi17(e) {
      const t = e.length,
        s = { closed: !1, payload: null, rest: e };
      let o = 2;
      if (t - o < 0) return s;
      const n = e[0],
        r = e[1],
        c = 0 != (128 & n),
        i = 0 != (32 & n),
        a = 0 != (16 & n),
        h = 15 & n,
        d = 0 != (128 & r);
      if (0 != (64 & n)) throw new f("Compressed frames not supported");
      if (!c || i || a) throw new f("Only compression extension is supported");
      if (d) throw new f("Masked server frame - not supported");
      let l = !1;
      switch (h) {
        case 8:
          l = !0;
          break;
        case 1:
          break;
        default:
          throw new f(`Unsupported op code ${h}`);
      }
      let p = 127 & r;
      switch (p) {
        case 126:
          (o += 2), (p = (e[2] << 8) + e[3]);
          break;
        case 127:
          (o += 8), (p = 0);
          for (let t = 0; t < 8; ++t) (p <<= 8), (p |= e[2 + t]);
      }
      if (t - o - p < 0) return s;
      const u = o + p;
      return { payload: e.slice(o, u), rest: e.slice(u), closed: l };
    }
    s.exports = class Client extends k {
      constructor() {
        super(),
          (this.handleChunk = a(this._handleChunk, this)),
          (this._port = void 0),
          (this._host = void 0),
          this.reset();
      }
      _handleChunk(e) {
        for (
          this._unprocessed = u.concat([this._unprocessed, e]);
          this._unprocessed.length > 2;

        ) {
          const {
            closed: e,
            payload: t,
            rest: s,
          } = decodeFrameHybi17(this._unprocessed);
          if (((this._unprocessed = s), e)) return void this.reset();
          if (null === t || 0 === t.length) break;
          const o = t.toString();
          b("< %s", o);
          const n = o[o.length - 1];
          if ("{" !== o[0] || "}" !== n)
            throw new f(`Payload does not look like JSON: ${o}`);
          let r;
          try {
            r = h(o);
          } catch (e) {
            throw ((e.string = o), e);
          }
          const { id: c, method: i, params: a, result: d, error: l } = r;
          if (c) {
            const e = this._pending[c];
            e && (delete this._pending[c], e(l, d));
          } else {
            if (!i) throw new f(`Unsupported response: ${o}`);
            this.emit("debugEvent", i, a), this.emit(i, a);
          }
        }
      }
      reset() {
        this._http && this._http.destroy(),
          this._socket && this._socket.destroy(),
          (this._http = null),
          (this._lastId = 0),
          (this._socket = null),
          (this._pending = {}),
          (this._unprocessed = u.alloc(0));
      }
      callMethod(e, t) {
        return new p((s, o) => {
          if (!this._socket)
            return void o(new f("Use `run` to start the app again."));
          const n = { id: ++this._lastId, method: e, params: t };
          this._pending[n.id] = (e, t) => {
            e ? o(unpackError(e)) : s(l(t).length ? t : void 0);
          };
          const r = d(n);
          b("> %s", r),
            this._socket.write(
              (function encodeFrameHybi17(e) {
                const t = e.length;
                let s, o;
                if (t > 65535) {
                  (s = 127), (o = u.alloc(8));
                  let e = t;
                  for (let t = 0; t < 8; ++t) (o[7 - t] = 255 & e), (e >>= 8);
                } else
                  t > 125
                    ? ((s = 126),
                      (o = u.alloc(2)),
                      (o[0] = (65280 & t) >> 8),
                      (o[1] = 255 & t))
                    : ((o = u.alloc(0)), (s = t));
                const n = u.from([129, 128 | s]),
                  r = u.alloc(4),
                  c = u.alloc(t);
                for (let s = 0; s < t; ++s) c[s] = e[s] ^ r[s % 4];
                return u.concat([n, o, r, c]);
              })(u.from(r))
            );
        });
      }
      _fetchJSON(e) {
        return new p((t, s) => {
          const o = w.get({ host: this._host, port: this._port, path: e }),
            n = [];
          o.on("error", s),
            o.on("response", function onResponse(e) {
              e.on("error", s),
                e.on("data", (e) => c(n, e)),
                e.on("end", function parseChunks() {
                  const o = u.concat(n).toString();
                  if (200 === e.statusCode)
                    try {
                      t(h(o));
                    } catch {
                      s(new f(`Response didn't contain JSON: ${o}`));
                    }
                  else s(new f(`Unexpected ${e.statusCode}: ${o}`));
                });
            });
        });
      }
      async connect(e, t) {
        (this._port = e), (this._host = t);
        const s = await this._discoverWebsocketPath();
        return this._connectWebsocket(s);
      }
      async _discoverWebsocketPath() {
        const {
          0: { webSocketDebuggerUrl: e },
        } = await this._fetchJSON("/json");
        return g.parse(e).path;
      }
      _connectWebsocket(e) {
        this.reset();
        const t = _.randomBytes(16).toString("base64");
        b("request WebSocket", t);
        const s = (this._http = w.request({
          host: this._host,
          port: this._port,
          path: e,
          headers: {
            Connection: "Upgrade",
            Upgrade: "websocket",
            "Sec-WebSocket-Key": t,
            "Sec-WebSocket-Version": "13",
          },
        }));
        s.on("error", (e) => {
          this.emit("error", e);
        }),
          s.on("response", (e) => {
            e.statusCode >= 400
              ? (o.stderr.write(`Unexpected HTTP code: ${e.statusCode}\n`),
                e.pipe(o.stderr))
              : e.pipe(o.stderr);
          });
        const handshakeListener = (e, s) => {
          !(function validateHandshake(e, t) {
            const s = e + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
              o = _.createHash("sha1");
            if ((o.update(s), o.digest().toString("base64") !== t))
              throw new f(`WebSocket secret mismatch: ${e} did not match ${t}`);
          })(t, e.headers["sec-websocket-accept"]),
            b("websocket upgrade"),
            (this._socket = s),
            s.on("data", this.handleChunk),
            s.on("close", () => {
              this.emit("close");
            }),
            this.emit("ready");
        };
        return new p((e, t) => {
          this.once("error", t),
            this.once("ready", e),
            s.on("upgrade", handshakeListener),
            s.end();
        });
      }
    };
  },
  "internal/debugger/inspect_repl": function (e, t, n, r, i, o) {
    "use strict";
    const {
        Array: s,
        ArrayFrom: a,
        ArrayPrototypeFilter: c,
        ArrayPrototypeFind: l,
        ArrayPrototypeForEach: u,
        ArrayPrototypeIncludes: p,
        ArrayPrototypeIndexOf: h,
        ArrayPrototypeJoin: d,
        ArrayPrototypeMap: f,
        ArrayPrototypePush: g,
        ArrayPrototypeSlice: b,
        ArrayPrototypeSome: m,
        ArrayPrototypeSplice: v,
        Date: y,
        FunctionPrototypeCall: w,
        JSONStringify: P,
        MathMax: S,
        ObjectAssign: k,
        ObjectDefineProperty: x,
        ObjectKeys: $,
        ObjectValues: C,
        Promise: I,
        PromisePrototypeThen: R,
        PromiseResolve: N,
        ReflectGetOwnPropertyDescriptor: O,
        ReflectOwnKeys: E,
        RegExpPrototypeExec: T,
        SafeMap: B,
        SafePromiseAllReturnArrayLike: A,
        SafePromiseAllReturnVoid: j,
        String: L,
        StringFromCharCode: F,
        StringPrototypeEndsWith: _,
        StringPrototypeIncludes: U,
        StringPrototypeRepeat: G,
        StringPrototypeReplaceAll: z,
        StringPrototypeSlice: D,
        StringPrototypeSplit: W,
        StringPrototypeStartsWith: H,
        StringPrototypeToUpperCase: M,
        StringPrototypeTrim: V,
      } = o,
      { ERR_DEBUGGER_ERROR: q } = t("internal/errors").codes,
      { validateString: J, validateNumber: K } = t("internal/validators"),
      Y = t("fs"),
      Q = t("path"),
      X = t("repl"),
      Z = t("vm"),
      { fileURLToPath: ee } = t("internal/url"),
      {
        customInspectSymbol: te,
        SideEffectFreeRegExpPrototypeSymbolReplace: ne,
      } = t("internal/util"),
      { inspect: re } = t("internal/util/inspect"),
      ie = t("internal/util/debuglog").debuglog("inspect"),
      oe = {
        cont: "c",
        next: "n",
        step: "s",
        out: "o",
        backtrace: "bt",
        setBreakpoint: "sb",
        clearBreakpoint: "cb",
        run: "r",
        exec: "p",
      },
      se = V(
        "\nrun, restart, r       Run the application or reconnect\nkill                  Kill a running application or disconnect\n\ncont, c               Resume execution\nnext, n               Continue to next line in current file\nstep, s               Step into, potentially entering a function\nout, o                Step out, leaving the current function\nbacktrace, bt         Print the current backtrace\nlist                  Print the source around the current line where execution\n                      is currently paused\nsetContextLineNumber  Set which lines to check for context\nsetBreakpoint, sb     Set a breakpoint\nclearBreakpoint, cb   Clear a breakpoint\nbreakpoints           List all known breakpoints\nbreakOnException      Pause execution whenever an exception is thrown\nbreakOnUncaught       Pause execution whenever an exception isn't caught\nbreakOnNone           Don't pause on exceptions (this is the default)\n\nwatch(expr)           Start watching the given expression\nunwatch(expr)         Stop watching an expression\nunwatch(index)        Stop watching an expression at specific index from watch list\nwatchers              Print all watched expressions and their current values\n\nexec(expr), p(expr), exec expr, p expr\n                      Evaluate the expression and print the value\nrepl                  Enter a debug repl that works like exec\n\nscripts               List application scripts that are currently loaded\nscripts(true)         List all scripts (including node-internals)\n\nprofile               Start CPU profiling session.\nprofileEnd            Stop current CPU profiling session.\nprofiles              Array of completed CPU profiling sessions.\nprofiles[n].save(filepath = 'node.cpuprofile')\n                      Save CPU profiling session to disk as JSON.\n\ntakeHeapSnapshot(filepath = 'node.heapsnapshot')\n                      Take a heap snapshot and save to disk as JSON.\n"
      ),
      ae = /^(?:function\*? )?([^(\s]+)\(/;
    const { builtinIds: ce } = i("builtins"),
      le = i("natives");
    function isNativeUrl(e) {
      return (
        (e = ne(/\.js$/, e, "")),
        H(e, "node:internal/") || p(ce, e) || e in le || "bootstrap_node" === e
      );
    }
    function getRelativePath(e) {
      const t = D(Q.join(Q.resolve(), "x"), 0, -1),
        n = H(e, "file://") ? ee(e) : e;
      return H(n, t) ? D(n, t.length) : n;
    }
    function leftPad(e, t, n) {
      const r = e.toString(),
        i = S(2, L(n).length) - r.length;
      return t + G(" ", i) + r;
    }
    function convertResultToError(e) {
      const { className: t, description: n } = e,
        r = new q(
          (function extractErrorMessage(e) {
            if (!e) return "<unknown>";
            const t = T(/^\w+: ([^\n]+)/, e);
            return t?.[1] ?? e;
          })(n)
        );
      return (r.stack = n), x(r, "name", { __proto__: null, value: t }), r;
    }
    class PropertyPreview {
      constructor(e) {
        k(this, e);
      }
      [te](e, t) {
        switch (this.type) {
          case "string":
          case "undefined":
            return re(this.value, t);
          case "number":
          case "boolean":
            return t.stylize(this.value, this.type);
          case "object":
          case "symbol":
            return "date" === this.subtype
              ? re(new y(this.value), t)
              : "array" === this.subtype
              ? t.stylize(this.value, "special")
              : t.stylize(this.value, this.subtype || "special");
          default:
            return this.value;
        }
      }
    }
    class ObjectPreview {
      constructor(e) {
        k(this, e);
      }
      [te](e, t) {
        if ("object" === this.type)
          switch (this.subtype) {
            case "date":
              return re(new y(this.description), t);
            case "null":
              return re(null, t);
            case "regexp":
              return t.stylize(this.description, "regexp");
            case "set": {
              if (!this.entries)
                return `${this.description} ${
                  this.overflow ? "{ ... }" : "{}"
                }`;
              const e = f(this.entries, (e) =>
                re(new ObjectPreview(e.value), t)
              );
              return `${this.description} { ${d(e, ", ")} }`;
            }
            case "map": {
              if (!this.entries)
                return `${this.description} ${
                  this.overflow ? "{ ... }" : "{}"
                }`;
              const e = f(
                this.entries,
                (e) =>
                  `${re(new ObjectPreview(e.key), t)} => ${re(
                    new ObjectPreview(e.value),
                    t
                  )}`
              );
              return `${this.description} { ${d(e, ", ")} }`;
            }
            case "array":
            case void 0: {
              if (0 === this.properties.length)
                return "array" === this.subtype ? "[]" : "{}";
              const e = f(this.properties, (e, t) => {
                const n = re(new PropertyPreview(e));
                return e.name === `${t}` ? n : `${e.name}: ${n}`;
              });
              this.overflow && g(e, "...");
              const t = d(e, ", "),
                n = t.length > 60 ? d(e, ",\n  ") : t;
              return "array" === this.subtype ? `[ ${n} ]` : `{ ${n} }`;
            }
            default:
              return this.description;
          }
        return this.description;
      }
    }
    class RemoteObject {
      constructor(e) {
        k(this, e),
          "number" === this.type &&
            (this.value = this.unserializableValue
              ? +this.unserializableValue
              : +this.value);
      }
      [te](e, t) {
        switch (this.type) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return re(this.value, t);
          case "symbol":
            return t.stylize(this.description, "special");
          case "function": {
            const e = (function extractFunctionName(e) {
                const t = T(ae, e);
                return t ? `: ${t[1]}` : "";
              })(this.description),
              n = `[${this.className}${e}]`;
            return t.stylize(n, "special");
          }
          case "object":
            switch (this.subtype) {
              case "date":
                return re(new y(this.description), t);
              case "null":
                return re(null, t);
              case "regexp":
                return t.stylize(this.description, "regexp");
              case "map":
              case "set": {
                const e = re(new ObjectPreview(this.preview), t);
                return `${this.description} ${e}`;
              }
            }
            return this.preview
              ? re(new ObjectPreview(this.preview), t)
              : this.description;
          default:
            return this.description;
        }
      }
      static fromEvalResult({ result: e, wasThrown: t }) {
        return t ? convertResultToError(e) : new RemoteObject(e);
      }
    }
    class ScopeSnapshot {
      constructor(e, t) {
        k(this, e),
          (this.properties = new B()),
          (this.completionGroup = f(t, (e) => {
            const t = new RemoteObject(e.value);
            return this.properties.set(e.name, t), e.name;
          }));
      }
      [te](e, t) {
        const n = `${M(this.type[0]) + D(this.type, 1)}${
          this.name ? `<${this.name}>` : ""
        } `;
        return ne(/^Map /, re(this.properties, t), n);
      }
    }
    n.exports = function createRepl(e) {
      const { Debugger: t, HeapProfiler: n, Profiler: i, Runtime: o } = e;
      let p;
      const y = { control: [], debug: [] },
        B = [],
        L = [];
      let G,
        H,
        M,
        V,
        ee,
        ae = null,
        ce = "none",
        le = 2;
      function resetOnStart() {
        (H = {}), (M = null), (V = null), ee && ee(), (ee = null);
      }
      resetOnStart();
      const ue = { colors: e.stdout.isTTY };
      function inspect(e) {
        return re(e, ue);
      }
      function print(t, n = !0) {
        const r = "string" == typeof t ? t : inspect(t);
        return e.print(r, n);
      }
      function getCurrentLocation() {
        if (!V) throw new q("Requires execution to be paused");
        return V.location;
      }
      function isCurrentScript(e) {
        return V && getCurrentLocation().scriptId === e.scriptId;
      }
      function formatScripts(e = !1) {
        return d(
          f(
            c(C(H), function isVisible(t) {
              return !!e || !t.isNative || isCurrentScript(t);
            }),
            (e) => {
              const t = isCurrentScript(e),
                { isNative: n, url: r } = e,
                i = `${getRelativePath(r)}${n ? " <native>" : ""}`;
              return `${t ? "*" : " "} ${e.scriptId}: ${i}`;
            }
          ),
          "\n"
        );
      }
      function listScripts(e = !1) {
        print(formatScripts(e));
      }
      listScripts[te] = function listWithoutInternal() {
        return formatScripts();
      };
      const pe = [];
      class Profile {
        constructor(e) {
          this.data = e;
        }
        static createAndRegister({ profile: e }) {
          const t = new Profile(e);
          return g(pe, t), t;
        }
        [te](e, { stylize: t }) {
          const { startTime: n, endTime: r } = this.data;
          return t(`[Profile ${r - n}${F(956)}s]`, "special");
        }
        save(e = "node.cpuprofile") {
          const t = Q.resolve(e),
            n = P(this.data);
          Y.writeFileSync(t, n), print("Saved profile to " + t);
        }
      }
      class SourceSnippet {
        constructor(e, t, n) {
          k(this, e), (this.scriptSource = n), (this.delta = t);
        }
        [te](e, t) {
          const {
              scriptId: n,
              lineNumber: r,
              columnNumber: i,
              delta: o,
              scriptSource: s,
            } = this,
            a = S(1, r - o + 1),
            c = r + o + 1,
            l = W(s, "\n");
          return d(
            f(b(l, a - 1, c), (e, o) => {
              const s = a + o,
                l = s === r + 1,
                p = l
                  ? (function markSourceColumn(e, t, n) {
                      if (!e) return "";
                      const r = D(e, 0, t);
                      let i = D(e, t);
                      return n && (i = ne(/(.+?)([^\w]|$)/, i, "[32m$1[39m$2")), r + i;
                    })(e, i, t.colors)
                  : e;
              let h = !1;
              u(L, ({ location: e }) => {
                e && n === e.scriptId && s === e.lineNumber + 1 && (h = !0);
              });
              let d = " ";
              return l ? (d = ">") : h && (d = "*"), `${leftPad(s, d, c)} ${p}`;
            }),
            "\n"
          );
        }
      }
      async function getSourceSnippet(e, n = 5) {
        const { scriptId: r } = e,
          { scriptSource: i } = await t.getScriptSource({ scriptId: r });
        return new SourceSnippet(e, n, i);
      }
      class CallFrame {
        constructor(e) {
          k(this, e);
        }
        loadScopes() {
          return A(
            c(this.scopeChain, (e) => "global" !== e.type),
            async (e) => {
              const { objectId: t } = e.object,
                { result: n } = await o.getProperties({
                  objectId: t,
                  generatePreview: !0,
                });
              return new ScopeSnapshot(e, n);
            }
          );
        }
        list(e = 5) {
          return getSourceSnippet(this.location, e);
        }
      }
      class Backtrace extends s {
        [te]() {
          return d(
            f(this, (e, t) => {
              const {
                  location: { scriptId: n, lineNumber: r, columnNumber: i },
                  functionName: o,
                } = e,
                s = o || "(anonymous)",
                a = H[n];
              return `#${t} ${s} ${`${
                (a && getRelativePath(a.url)) || "<unknown>"
              }:${r + 1}:${i}`}`;
            }),
            "\n"
          );
        }
        static from(e) {
          return w(a, this, e, (e) =>
            e instanceof CallFrame ? e : new CallFrame(e)
          );
        }
      }
      async function evalInCurrentContext(e) {
        if (".scope" === e) {
          if (!V) throw new q("Requires execution to be paused");
          const e = await V.loadScopes();
          return f(e, (e) => e.completionGroup);
        }
        return R(
          V
            ? t.evaluateOnCallFrame({
                callFrameId: V.callFrameId,
                expression: e,
                objectGroup: "node-inspect",
                generatePreview: !0,
              })
            : o.evaluate({
                expression: e,
                objectGroup: "node-inspect",
                generatePreview: !0,
              }),
          RemoteObject.fromEvalResult
        );
      }
      function controlEval(e, t, n, r) {
        function returnToCallback(t, n) {
          ie("end-eval:", e, t), r(t, n);
        }
        ie("eval:", e);
        try {
          const r = (function prepareControlCode(e) {
              if ("\n" === e) return G;
              const t = T(/^\s*(?:exec|p)\s+([^\n]*)/, e);
              return (G = t ? `exec(${P(t[1])})` : e), G;
            })(e),
            i = Z.runInContext(r, t, n),
            o = i?.then;
          "function" == typeof o
            ? w(o, i, (e) => returnToCallback(null, e), returnToCallback)
            : returnToCallback(null, i);
        } catch (e) {
          returnToCallback(e);
        }
      }
      function debugEval(e, t, n, r) {
        function returnToCallback(t, n) {
          ie("end-eval:", e, t), r(t, n);
        }
        ie("eval:", e),
          R(
            evalInCurrentContext(e),
            (e) => returnToCallback(null, e),
            returnToCallback
          );
      }
      async function formatWatchers(e = !1) {
        if (!B.length) return "";
        const t = B.length - 1,
          n = await A(B, (e) =>
            R(evalInCurrentContext(e), void 0, (e) => `<${e.message}>`)
          ),
          r = f(B, (e, r) => {
            const i = `${leftPad(r, " ", t)}: ${e} =`,
              o = inspect(n[r]);
            return U(o, "\n")
              ? `${i}\n    ${z(o, "\n", "\n    ")}`
              : `${i} ${o}`;
          }),
          i = d(r, "\n");
        return e ? `Watchers:\n${i}\n` : i;
      }
      function list(e = 5) {
        if (!V) throw new q("Requires execution to be paused");
        return V.list(e).then(null, (e) => {
          throw (print("You can't list source code right now"), e);
        });
      }
      function setContextLineNumber(e = 2) {
        if (!V) throw new q("Requires execution to be paused");
        K(e, "delta", 1),
          (le = e),
          print(`The contextLine has been changed to ${e}.`);
      }
      function handleBreakpointResolved({ breakpointId: e, location: t }) {
        const n = H[t.scriptId],
          r = n && n.url;
        r && k(t, { scriptUrl: r });
        m(L, (n) => n.breakpointId === e && (k(n, { location: t }), !0)) ||
          g(L, { breakpointId: e, location: t });
      }
      function listBreakpoints() {
        if (!L.length) return void print("No breakpoints yet");
        print(
          d(
            f(
              L,
              (e, t) =>
                `#${t} ${(function formatLocation(e) {
                  if (!e) return "<unknown location>";
                  const t = H[e.scriptId];
                  return `${getRelativePath(t ? t.url : e.scriptUrl)}:${
                    e.lineNumber + 1
                  }`;
                })(e.location)}`
            ),
            "\n"
          )
        );
      }
      function setBreakpoint(e, n, r, i) {
        function registerBreakpoint({ breakpointId: t, actualLocation: n }) {
          if (
            (handleBreakpointResolved({ breakpointId: t, location: n }),
            n && n.scriptId)
          ) {
            if (!i) return getSourceSnippet(n, 5);
          } else print(`Warning: script '${e}' was not loaded yet.`);
        }
        if (void 0 === e)
          return R(
            t.setBreakpoint({ location: getCurrentLocation(), condition: r }),
            registerBreakpoint
          );
        if (void 0 === n && "number" == typeof e) {
          const n = {
            scriptId: getCurrentLocation().scriptId,
            lineNumber: e - 1,
          };
          return R(
            t.setBreakpoint({ location: n, condition: r }),
            registerBreakpoint
          );
        }
        if ((J(e, "script"), _(e, "()"))) {
          const n = `debug(${e.slice(0, -2)})`,
            r = V
              ? t.evaluateOnCallFrame({
                  callFrameId: V.callFrameId,
                  expression: n,
                  includeCommandLineAPI: !0,
                })
              : o.evaluate({ expression: n, includeCommandLineAPI: !0 });
          return R(r, ({ result: e, wasThrown: t }) => {
            if (t) return convertResultToError(e);
          });
        }
        let s = null,
          a = !1;
        if (
          (H[e]
            ? (s = e)
            : u($(H), (t) => {
                const n = H[t].url;
                n && U(n, e) && (null !== s && (a = !0), (s = t));
              }),
          a)
        )
          return void print("Script name is ambiguous");
        if (n <= 0) return void print("Line should be a positive value");
        if (null !== s) {
          const e = { scriptId: s, lineNumber: n - 1 };
          return R(
            t.setBreakpoint({ location: e, condition: r }),
            registerBreakpoint
          );
        }
        const c = `^(.*[\\/\\\\])?${ne(/([/\\.?*()^${}|[\]])/g, e, "\\$1")}$`;
        return R(
          t.setBreakpointByUrl({
            urlRegex: c,
            lineNumber: n - 1,
            condition: r,
          }),
          (t) => (
            t.location ||
              k(t, {
                actualLocation: { scriptUrl: `.*/${e}$`, lineNumber: n - 1 },
              }),
            registerBreakpoint(t)
          )
        );
      }
      function clearBreakpoint(e, n) {
        const r = l(L, ({ location: t }) => {
          if (!t) return !1;
          const r = H[t.scriptId];
          return !!r && U(r.url, e) && t.lineNumber + 1 === n;
        });
        return r
          ? R(t.removeBreakpoint({ breakpointId: r.breakpointId }), () => {
              const e = h(L, r);
              v(L, e, 1);
            })
          : (print(`Could not find breakpoint at ${e}:${n}`), N());
      }
      function setPauseOnExceptions(e) {
        return R(t.setPauseOnExceptions({ state: e }), () => {
          ce = e;
        });
      }
      function handleResumed() {
        (M = null), (V = null);
      }
      function initializeContext(s) {
        u(e.domainNames, (t) => {
          x(s, t, {
            __proto__: null,
            value: e[t],
            enumerable: !0,
            configurable: !0,
            writeable: !1,
          });
        }),
          (function copyOwnProperties(e, t) {
            u(E(t), (n) => {
              const r = O(t, n);
              x(e, n, r);
            });
          })(s, {
            get help() {
              return print(se);
            },
            get run() {
              return e.run();
            },
            get kill() {
              return e.killChild();
            },
            get restart() {
              return e.run();
            },
            get cont() {
              return handleResumed(), t.resume();
            },
            get next() {
              return handleResumed(), t.stepOver();
            },
            get step() {
              return handleResumed(), t.stepInto();
            },
            get out() {
              return handleResumed(), t.stepOut();
            },
            get pause() {
              return t.pause();
            },
            get backtrace() {
              return M;
            },
            get breakpoints() {
              return listBreakpoints();
            },
            exec: (e) => evalInCurrentContext(e),
            get profile() {
              return i.start();
            },
            get profileEnd() {
              return R(i.stop(), Profile.createAndRegister);
            },
            get profiles() {
              return pe;
            },
            takeHeapSnapshot: (e = "node.heapsnapshot") =>
              ae
                ? (print(
                    "Cannot take heap snapshot because another snapshot is in progress."
                  ),
                  ae)
                : ((ae = new I((t, r) => {
                    const i = Q.resolve(e),
                      o = Y.createWriteStream(i);
                    let s = 0;
                    function onProgress({ done: e, total: t, finished: n }) {
                      n
                        ? print("Heap snapshot prepared.")
                        : print(`Heap snapshot: ${e}/${t}`, !1);
                    }
                    function onChunk({ chunk: e }) {
                      (s += e.length),
                        o.write(e),
                        print(`Writing snapshot: ${s}`, !1);
                    }
                    function teardown() {
                      n.removeListener(
                        "reportHeapSnapshotProgress",
                        onProgress
                      ),
                        n.removeListener("addHeapSnapshotChunk", onChunk);
                    }
                    n.on("reportHeapSnapshotProgress", onProgress),
                      n.on("addHeapSnapshotChunk", onChunk),
                      print("Heap snapshot: 0/0", !1),
                      R(
                        n.takeHeapSnapshot({ reportProgress: !0 }),
                        function onResolve() {
                          o.end(() => {
                            teardown(),
                              print(`Wrote snapshot: ${i}`),
                              (ae = null),
                              t();
                          });
                        },
                        function onReject(e) {
                          teardown(), r(e);
                        }
                      );
                  })),
                  ae),
            get watchers() {
              return (function watchers(e = !1) {
                return R(formatWatchers(e), print);
              })();
            },
            watch(e) {
              J(e, "expression"), g(B, e);
            },
            unwatch(e) {
              const t = h(B, e);
              v(B, -1 !== t ? t : +e, 1);
            },
            get repl() {
              const e = b(p.listeners("SIGINT"));
              p.removeAllListeners("SIGINT");
              const t = p.context;
              return (
                (ee = () => {
                  r.nextTick(() => {
                    u(e, (e) => {
                      p.on("SIGINT", e);
                    });
                  }),
                    (p.eval = controlEval),
                    (y.debug = p.history),
                    (p.history = y.control),
                    (p.context = t),
                    p.setPrompt("debug> "),
                    p.displayPrompt(),
                    p.removeListener("SIGINT", ee),
                    p.removeListener("exit", ee),
                    (ee = null);
                }),
                p.on("SIGINT", ee),
                p.on("exit", ee),
                (p.eval = debugEval),
                (p.context = {}),
                (y.control = p.history),
                (p.history = y.debug),
                p.setPrompt("> "),
                print("Press Ctrl+C to leave debug repl"),
                p.displayPrompt()
              );
            },
            get version() {
              return R(
                o.evaluate({
                  expression: "process.versions.v8",
                  contextId: 1,
                  returnByValue: !0,
                }),
                ({ result: e }) => {
                  print(e.value);
                }
              );
            },
            scripts: listScripts,
            setBreakpoint: setBreakpoint,
            clearBreakpoint: clearBreakpoint,
            setPauseOnExceptions: setPauseOnExceptions,
            get breakOnException() {
              return setPauseOnExceptions("all");
            },
            get breakOnUncaught() {
              return setPauseOnExceptions("uncaught");
            },
            get breakOnNone() {
              return setPauseOnExceptions("none");
            },
            list: list,
            setContextLineNumber: setContextLineNumber,
          }),
          (function aliasProperties(e, t) {
            u($(t), (n) => {
              const r = O(e, n);
              x(e, t[n], r);
            });
          })(s, oe);
      }
      async function initAfterStart() {
        return (
          await o.enable(),
          await i.enable(),
          await i.setSamplingInterval({ interval: 100 }),
          await t.enable(),
          await t.setAsyncCallStackDepth({ maxDepth: 0 }),
          await t.setBlackboxPatterns({ patterns: [] }),
          await t.setPauseOnExceptions({ state: ce }),
          await (function restoreBreakpoints() {
            const e = v(L, 0),
              t = f(
                c(e, ({ location: e }) => !!e.scriptUrl),
                ({ location: e }) =>
                  setBreakpoint(e.scriptUrl, e.lineNumber + 1)
              );
            return t.length
              ? R(j(t), () => {
                  print(`${t.length} breakpoints restored.`);
                })
              : N();
          })(),
          o.runIfWaitingForDebugger()
        );
      }
      return (
        t.on("paused", ({ callFrames: t, reason: n }) => {
          if (
            "1" === r.env.NODE_INSPECT_RESUME_ON_START &&
            "Break on start" === n
          )
            return (
              ie(
                "Paused on start, but NODE_INSPECT_RESUME_ON_START environment variable is set to 1, resuming"
              ),
              void e.client.callMethod("Debugger.resume")
            );
          (M = Backtrace.from(t)), (V = M[0]);
          const { scriptId: i, lineNumber: o } = V.location,
            s = "other" === n ? "break" : n,
            a = H[i],
            c = `${s} in ${a ? getRelativePath(a.url) : "[unknown]"}:${o + 1}`;
          e.suspendReplWhile(() =>
            R(A([formatWatchers(!0), V.list(le)]), ({ 0: e, 1: t }) => {
              const n = e ? `${e}\n${inspect(t)}` : inspect(t);
              print(`${c}\n${n}`);
            })
          );
        }),
        t.on("resumed", handleResumed),
        t.on("breakpointResolved", handleBreakpointResolved),
        t.on("scriptParsed", (e) => {
          const { scriptId: t, url: n } = e;
          n && (H[t] = { isNative: isNativeUrl(n), ...e });
        }),
        i.on("consoleProfileFinished", ({ profile: e }) => {
          Profile.createAndRegister({ profile: e }),
            print(
              `Captured new CPU profile.\nAccess it with profiles[${
                pe.length - 1
              }]`
            );
        }),
        async function startRepl() {
          e.client.on("close", () => {
            resetOnStart();
          }),
            e.client.on("ready", () => {
              initAfterStart();
            }),
            await initAfterStart();
          const t = {
            prompt: "debug> ",
            input: e.stdin,
            output: e.stdout,
            eval: controlEval,
            useGlobal: !1,
            ignoreUndefined: !0,
          };
          return (
            (p = X.start(t)),
            initializeContext(p.context),
            p.on("reset", initializeContext),
            p.defineCommand("interrupt", () => {
              p.emit("SIGINT");
            }),
            p
          );
        }
      );
    };
  },
  "internal/deps/acorn/acorn-walk/dist/walk": function (e, t, n, r, o, i) {
    var s, a;
    (s = this),
      (a = function (e) {
        "use strict";
        function makeTest(e) {
          return "string" == typeof e
            ? function (t) {
                return t === e;
              }
            : e ||
                function () {
                  return !0;
                };
        }
        var t = function Found2(e, t) {
          (this.node = e), (this.state = t);
        };
        function make(e, t) {
          var r = Object.create(t || n);
          for (var o in e) r[o] = e[o];
          return r;
        }
        function skipThrough(e, t, n) {
          n(e, t);
        }
        function ignore(e, t, n) {}
        var n = {};
        (n.Program =
          n.BlockStatement =
          n.StaticBlock =
            function (e, t, n) {
              for (var r = 0, o = e.body; r < o.length; r += 1)
                n(o[r], t, "Statement");
            }),
          (n.Statement = skipThrough),
          (n.EmptyStatement = ignore),
          (n.ExpressionStatement =
            n.ParenthesizedExpression =
            n.ChainExpression =
              function (e, t, n) {
                return n(e.expression, t, "Expression");
              }),
          (n.IfStatement = function (e, t, n) {
            n(e.test, t, "Expression"),
              n(e.consequent, t, "Statement"),
              e.alternate && n(e.alternate, t, "Statement");
          }),
          (n.LabeledStatement = function (e, t, n) {
            return n(e.body, t, "Statement");
          }),
          (n.BreakStatement = n.ContinueStatement = ignore),
          (n.WithStatement = function (e, t, n) {
            n(e.object, t, "Expression"), n(e.body, t, "Statement");
          }),
          (n.SwitchStatement = function (e, t, n) {
            n(e.discriminant, t, "Expression");
            for (var r = 0, o = e.cases; r < o.length; r += 1) {
              var i = o[r];
              i.test && n(i.test, t, "Expression");
              for (var s = 0, a = i.consequent; s < a.length; s += 1)
                n(a[s], t, "Statement");
            }
          }),
          (n.SwitchCase = function (e, t, n) {
            e.test && n(e.test, t, "Expression");
            for (var r = 0, o = e.consequent; r < o.length; r += 1)
              n(o[r], t, "Statement");
          }),
          (n.ReturnStatement =
            n.YieldExpression =
            n.AwaitExpression =
              function (e, t, n) {
                e.argument && n(e.argument, t, "Expression");
              }),
          (n.ThrowStatement = n.SpreadElement =
            function (e, t, n) {
              return n(e.argument, t, "Expression");
            }),
          (n.TryStatement = function (e, t, n) {
            n(e.block, t, "Statement"),
              e.handler && n(e.handler, t),
              e.finalizer && n(e.finalizer, t, "Statement");
          }),
          (n.CatchClause = function (e, t, n) {
            e.param && n(e.param, t, "Pattern"), n(e.body, t, "Statement");
          }),
          (n.WhileStatement = n.DoWhileStatement =
            function (e, t, n) {
              n(e.test, t, "Expression"), n(e.body, t, "Statement");
            }),
          (n.ForStatement = function (e, t, n) {
            e.init && n(e.init, t, "ForInit"),
              e.test && n(e.test, t, "Expression"),
              e.update && n(e.update, t, "Expression"),
              n(e.body, t, "Statement");
          }),
          (n.ForInStatement = n.ForOfStatement =
            function (e, t, n) {
              n(e.left, t, "ForInit"),
                n(e.right, t, "Expression"),
                n(e.body, t, "Statement");
            }),
          (n.ForInit = function (e, t, n) {
            "VariableDeclaration" === e.type ? n(e, t) : n(e, t, "Expression");
          }),
          (n.DebuggerStatement = ignore),
          (n.FunctionDeclaration = function (e, t, n) {
            return n(e, t, "Function");
          }),
          (n.VariableDeclaration = function (e, t, n) {
            for (var r = 0, o = e.declarations; r < o.length; r += 1)
              n(o[r], t);
          }),
          (n.VariableDeclarator = function (e, t, n) {
            n(e.id, t, "Pattern"), e.init && n(e.init, t, "Expression");
          }),
          (n.Function = function (e, t, n) {
            e.id && n(e.id, t, "Pattern");
            for (var r = 0, o = e.params; r < o.length; r += 1)
              n(o[r], t, "Pattern");
            n(e.body, t, e.expression ? "Expression" : "Statement");
          }),
          (n.Pattern = function (e, t, n) {
            "Identifier" === e.type
              ? n(e, t, "VariablePattern")
              : "MemberExpression" === e.type
              ? n(e, t, "MemberPattern")
              : n(e, t);
          }),
          (n.VariablePattern = ignore),
          (n.MemberPattern = skipThrough),
          (n.RestElement = function (e, t, n) {
            return n(e.argument, t, "Pattern");
          }),
          (n.ArrayPattern = function (e, t, n) {
            for (var r = 0, o = e.elements; r < o.length; r += 1) {
              var i = o[r];
              i && n(i, t, "Pattern");
            }
          }),
          (n.ObjectPattern = function (e, t, n) {
            for (var r = 0, o = e.properties; r < o.length; r += 1) {
              var i = o[r];
              "Property" === i.type
                ? (i.computed && n(i.key, t, "Expression"),
                  n(i.value, t, "Pattern"))
                : "RestElement" === i.type && n(i.argument, t, "Pattern");
            }
          }),
          (n.Expression = skipThrough),
          (n.ThisExpression = n.Super = n.MetaProperty = ignore),
          (n.ArrayExpression = function (e, t, n) {
            for (var r = 0, o = e.elements; r < o.length; r += 1) {
              var i = o[r];
              i && n(i, t, "Expression");
            }
          }),
          (n.ObjectExpression = function (e, t, n) {
            for (var r = 0, o = e.properties; r < o.length; r += 1) n(o[r], t);
          }),
          (n.FunctionExpression = n.ArrowFunctionExpression =
            n.FunctionDeclaration),
          (n.SequenceExpression = function (e, t, n) {
            for (var r = 0, o = e.expressions; r < o.length; r += 1)
              n(o[r], t, "Expression");
          }),
          (n.TemplateLiteral = function (e, t, n) {
            for (var r = 0, o = e.quasis; r < o.length; r += 1) n(o[r], t);
            for (var i = 0, s = e.expressions; i < s.length; i += 1)
              n(s[i], t, "Expression");
          }),
          (n.TemplateElement = ignore),
          (n.UnaryExpression = n.UpdateExpression =
            function (e, t, n) {
              n(e.argument, t, "Expression");
            }),
          (n.BinaryExpression = n.LogicalExpression =
            function (e, t, n) {
              n(e.left, t, "Expression"), n(e.right, t, "Expression");
            }),
          (n.AssignmentExpression = n.AssignmentPattern =
            function (e, t, n) {
              n(e.left, t, "Pattern"), n(e.right, t, "Expression");
            }),
          (n.ConditionalExpression = function (e, t, n) {
            n(e.test, t, "Expression"),
              n(e.consequent, t, "Expression"),
              n(e.alternate, t, "Expression");
          }),
          (n.NewExpression = n.CallExpression =
            function (e, t, n) {
              if ((n(e.callee, t, "Expression"), e.arguments))
                for (var r = 0, o = e.arguments; r < o.length; r += 1)
                  n(o[r], t, "Expression");
            }),
          (n.MemberExpression = function (e, t, n) {
            n(e.object, t, "Expression"),
              e.computed && n(e.property, t, "Expression");
          }),
          (n.ExportNamedDeclaration = n.ExportDefaultDeclaration =
            function (e, t, n) {
              e.declaration &&
                n(
                  e.declaration,
                  t,
                  "ExportNamedDeclaration" === e.type || e.declaration.id
                    ? "Statement"
                    : "Expression"
                ),
                e.source && n(e.source, t, "Expression");
            }),
          (n.ExportAllDeclaration = function (e, t, n) {
            e.exported && n(e.exported, t), n(e.source, t, "Expression");
          }),
          (n.ImportDeclaration = function (e, t, n) {
            for (var r = 0, o = e.specifiers; r < o.length; r += 1) n(o[r], t);
            n(e.source, t, "Expression");
          }),
          (n.ImportExpression = function (e, t, n) {
            n(e.source, t, "Expression");
          }),
          (n.ImportSpecifier =
            n.ImportDefaultSpecifier =
            n.ImportNamespaceSpecifier =
            n.Identifier =
            n.PrivateIdentifier =
            n.Literal =
              ignore),
          (n.TaggedTemplateExpression = function (e, t, n) {
            n(e.tag, t, "Expression"), n(e.quasi, t, "Expression");
          }),
          (n.ClassDeclaration = n.ClassExpression =
            function (e, t, n) {
              return n(e, t, "Class");
            }),
          (n.Class = function (e, t, n) {
            e.id && n(e.id, t, "Pattern"),
              e.superClass && n(e.superClass, t, "Expression"),
              n(e.body, t);
          }),
          (n.ClassBody = function (e, t, n) {
            for (var r = 0, o = e.body; r < o.length; r += 1) n(o[r], t);
          }),
          (n.MethodDefinition =
            n.PropertyDefinition =
            n.Property =
              function (e, t, n) {
                e.computed && n(e.key, t, "Expression"),
                  e.value && n(e.value, t, "Expression");
              }),
          (e.ancestor = function ancestor(e, t, r, o, i) {
            var s = [];
            r || (r = n),
              (function c(e, n, o) {
                var i = o || e.type,
                  a = e !== s[s.length - 1];
                a && s.push(e),
                  r[i](e, n, c),
                  t[i] && t[i](e, n || s, s),
                  a && s.pop();
              })(e, o, i);
          }),
          (e.base = n),
          (e.findNodeAfter = function findNodeAfter(e, r, o, i, s) {
            (o = makeTest(o)), i || (i = n);
            try {
              !(function c(e, n, s) {
                if (!(e.end < r)) {
                  var a = s || e.type;
                  if (e.start >= r && o(a, e)) throw new t(e, n);
                  i[a](e, n, c);
                }
              })(e, s);
            } catch (e) {
              if (e instanceof t) return e;
              throw e;
            }
          }),
          (e.findNodeAround = function findNodeAround(e, r, o, i, s) {
            (o = makeTest(o)), i || (i = n);
            try {
              !(function c(e, n, s) {
                var a = s || e.type;
                if (!(e.start > r || e.end < r) && (i[a](e, n, c), o(a, e)))
                  throw new t(e, n);
              })(e, s);
            } catch (e) {
              if (e instanceof t) return e;
              throw e;
            }
          }),
          (e.findNodeAt = function findNodeAt(e, r, o, i, s, a) {
            s || (s = n), (i = makeTest(i));
            try {
              !(function c(e, n, a) {
                var u = a || e.type;
                if (
                  ((null == r || e.start <= r) &&
                    (null == o || e.end >= o) &&
                    s[u](e, n, c),
                  (null == r || e.start === r) &&
                    (null == o || e.end === o) &&
                    i(u, e))
                )
                  throw new t(e, n);
              })(e, a);
            } catch (e) {
              if (e instanceof t) return e;
              throw e;
            }
          }),
          (e.findNodeBefore = function findNodeBefore(e, r, o, i, s) {
            var a;
            return (
              (o = makeTest(o)),
              i || (i = n),
              (function c(e, n, s) {
                if (!(e.start > r)) {
                  var u = s || e.type;
                  e.end <= r &&
                    (!a || a.node.end < e.end) &&
                    o(u, e) &&
                    (a = new t(e, n)),
                    i[u](e, n, c);
                }
              })(e, s),
              a
            );
          }),
          (e.full = function full(e, t, r, o, i) {
            var s;
            r || (r = n),
              (function c(e, n, o) {
                var i = o || e.type;
                r[i](e, n, c), s !== e && (t(e, n, i), (s = e));
              })(e, o, i);
          }),
          (e.fullAncestor = function fullAncestor(e, t, r, o) {
            r || (r = n);
            var i,
              s = [];
            !(function c(e, n, o) {
              var a = o || e.type,
                u = e !== s[s.length - 1];
              u && s.push(e),
                r[a](e, n, c),
                i !== e && (t(e, n || s, s, a), (i = e)),
                u && s.pop();
            })(e, o);
          }),
          (e.make = make),
          (e.recursive = function recursive(e, t, n, r, o) {
            var i = n ? make(n, r || void 0) : r;
            !(function c(e, t, n) {
              i[n || e.type](e, t, c);
            })(e, t, o);
          }),
          (e.simple = function simple(e, t, r, o, i) {
            r || (r = n),
              (function c(e, n, o) {
                var i = o || e.type;
                r[i](e, n, c), t[i] && t[i](e, n);
              })(e, o, i);
          });
      }),
      "object" == typeof e && void 0 !== n
        ? a(e)
        : "function" == typeof define && define.amd
        ? define(["exports"], a)
        : a(
            (((s =
              "undefined" != typeof globalThis ? globalThis : s || self).acorn =
              s.acorn || {}),
            (s.acorn.walk = {}))
          );
  },
  "internal/deps/acorn/acorn/dist/acorn": function (t, e, i, s, r, a) {
    var n, o;
    (n = this),
      (o = function (t) {
        "use strict";
        var e = [
            509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0,
            166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14,
            32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1,
            45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6,
            9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17,
            10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82,
            12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2,
            1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47,
            15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2,
            0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4,
            14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014,
            0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4,
            5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0,
            23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10,
            9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719,
            239,
          ],
          i = [
            0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28,
            4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
            19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2,
            14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
            3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11,
            21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28,
            36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14,
            50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28,
            22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34,
            4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0,
            2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4,
            0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185,
            46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43,
            117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38,
            17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264,
            8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2,
            31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110,
            18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18,
            78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0,
            67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1,
            2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8,
            8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2,
            64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24,
            2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7,
            1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43,
            485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3,
            2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0,
            2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3,
            3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
            42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541,
            1507, 4938, 6, 4191,
          ],
          s =
            "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
          r = {
            3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
            5: "class enum extends super const export import",
            6: "enum",
            strict:
              "implements interface let package private protected public static yield",
            strictBind: "eval arguments",
          },
          a =
            "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
          n = {
            5: a,
            "5module": a + " export import",
            6: a + " const class extends export import super",
          },
          o = /^in(stanceof)?$/,
          h = new RegExp("[" + s + "]"),
          p = new RegExp(
            "[" +
              s +
              "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･]"
          );
        function isInAstralSet(t, e) {
          for (var i = 65536, s = 0; s < e.length; s += 2) {
            if ((i += e[s]) > t) return !1;
            if ((i += e[s + 1]) >= t) return !0;
          }
          return !1;
        }
        function isIdentifierStart(t, e) {
          return t < 65
            ? 36 === t
            : t < 91 ||
                (t < 97
                  ? 95 === t
                  : t < 123 ||
                    (t <= 65535
                      ? t >= 170 && h.test(String.fromCharCode(t))
                      : !1 !== e && isInAstralSet(t, i)));
        }
        function isIdentifierChar(t, s) {
          return t < 48
            ? 36 === t
            : t < 58 ||
                (!(t < 65) &&
                  (t < 91 ||
                    (t < 97
                      ? 95 === t
                      : t < 123 ||
                        (t <= 65535
                          ? t >= 170 && p.test(String.fromCharCode(t))
                          : !1 !== s &&
                            (isInAstralSet(t, i) || isInAstralSet(t, e))))));
        }
        var c = function TokenType2(t, e) {
          void 0 === e && (e = {}),
            (this.label = t),
            (this.keyword = e.keyword),
            (this.beforeExpr = !!e.beforeExpr),
            (this.startsExpr = !!e.startsExpr),
            (this.isLoop = !!e.isLoop),
            (this.isAssign = !!e.isAssign),
            (this.prefix = !!e.prefix),
            (this.postfix = !!e.postfix),
            (this.binop = e.binop || null),
            (this.updateContext = null);
        };
        function binop(t, e) {
          return new c(t, { beforeExpr: !0, binop: e });
        }
        var l = { beforeExpr: !0 },
          u = { startsExpr: !0 },
          d = {};
        function kw(t, e) {
          return (
            void 0 === e && (e = {}), (e.keyword = t), (d[t] = new c(t, e))
          );
        }
        var f = {
            num: new c("num", u),
            regexp: new c("regexp", u),
            string: new c("string", u),
            name: new c("name", u),
            privateId: new c("privateId", u),
            eof: new c("eof"),
            bracketL: new c("[", { beforeExpr: !0, startsExpr: !0 }),
            bracketR: new c("]"),
            braceL: new c("{", { beforeExpr: !0, startsExpr: !0 }),
            braceR: new c("}"),
            parenL: new c("(", { beforeExpr: !0, startsExpr: !0 }),
            parenR: new c(")"),
            comma: new c(",", l),
            semi: new c(";", l),
            colon: new c(":", l),
            dot: new c("."),
            question: new c("?", l),
            questionDot: new c("?."),
            arrow: new c("=>", l),
            template: new c("template"),
            invalidTemplate: new c("invalidTemplate"),
            ellipsis: new c("...", l),
            backQuote: new c("`", u),
            dollarBraceL: new c("${", { beforeExpr: !0, startsExpr: !0 }),
            eq: new c("=", { beforeExpr: !0, isAssign: !0 }),
            assign: new c("_=", { beforeExpr: !0, isAssign: !0 }),
            incDec: new c("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
            prefix: new c("!/~", {
              beforeExpr: !0,
              prefix: !0,
              startsExpr: !0,
            }),
            logicalOR: binop("||", 1),
            logicalAND: binop("&&", 2),
            bitwiseOR: binop("|", 3),
            bitwiseXOR: binop("^", 4),
            bitwiseAND: binop("&", 5),
            equality: binop("==/!=/===/!==", 6),
            relational: binop("</>/<=/>=", 7),
            bitShift: binop("<</>>/>>>", 8),
            plusMin: new c("+/-", {
              beforeExpr: !0,
              binop: 9,
              prefix: !0,
              startsExpr: !0,
            }),
            modulo: binop("%", 10),
            star: binop("*", 10),
            slash: binop("/", 10),
            starstar: new c("**", { beforeExpr: !0 }),
            coalesce: binop("??", 1),
            _break: kw("break"),
            _case: kw("case", l),
            _catch: kw("catch"),
            _continue: kw("continue"),
            _debugger: kw("debugger"),
            _default: kw("default", l),
            _do: kw("do", { isLoop: !0, beforeExpr: !0 }),
            _else: kw("else", l),
            _finally: kw("finally"),
            _for: kw("for", { isLoop: !0 }),
            _function: kw("function", u),
            _if: kw("if"),
            _return: kw("return", l),
            _switch: kw("switch"),
            _throw: kw("throw", l),
            _try: kw("try"),
            _var: kw("var"),
            _const: kw("const"),
            _while: kw("while", { isLoop: !0 }),
            _with: kw("with"),
            _new: kw("new", { beforeExpr: !0, startsExpr: !0 }),
            _this: kw("this", u),
            _super: kw("super", u),
            _class: kw("class", u),
            _extends: kw("extends", l),
            _export: kw("export"),
            _import: kw("import", u),
            _null: kw("null", u),
            _true: kw("true", u),
            _false: kw("false", u),
            _in: kw("in", { beforeExpr: !0, binop: 7 }),
            _instanceof: kw("instanceof", { beforeExpr: !0, binop: 7 }),
            _typeof: kw("typeof", {
              beforeExpr: !0,
              prefix: !0,
              startsExpr: !0,
            }),
            _void: kw("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
            _delete: kw("delete", {
              beforeExpr: !0,
              prefix: !0,
              startsExpr: !0,
            }),
          },
          m = /\r\n?|\n|\u2028|\u2029/,
          g = new RegExp(m.source, "g");
        function isNewLine(t) {
          return 10 === t || 13 === t || 8232 === t || 8233 === t;
        }
        function nextLineBreak(t, e, i) {
          void 0 === i && (i = t.length);
          for (var s = e; s < i; s++) {
            var r = t.charCodeAt(s);
            if (isNewLine(r))
              return s < i - 1 && 13 === r && 10 === t.charCodeAt(s + 1)
                ? s + 2
                : s + 1;
          }
          return -1;
        }
        var x = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
          v = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
          y = Object.prototype,
          k = y.hasOwnProperty,
          b = y.toString,
          _ =
            Object.hasOwn ||
            function (t, e) {
              return k.call(t, e);
            },
          S =
            Array.isArray ||
            function (t) {
              return "[object Array]" === b.call(t);
            },
          C = Object.create(null);
        function wordsRegexp(t) {
          return (
            C[t] || (C[t] = new RegExp("^(?:" + t.replace(/ /g, "|") + ")$"))
          );
        }
        function codePointToString(t) {
          return t <= 65535
            ? String.fromCharCode(t)
            : ((t -= 65536),
              String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)));
        }
        var w =
            /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
          E = function Position2(t, e) {
            (this.line = t), (this.column = e);
          };
        E.prototype.offset = function offset(t) {
          return new E(this.line, this.column + t);
        };
        var I = function SourceLocation2(t, e, i) {
          (this.start = e),
            (this.end = i),
            null !== t.sourceFile && (this.source = t.sourceFile);
        };
        function getLineInfo(t, e) {
          for (var i = 1, s = 0; ; ) {
            var r = nextLineBreak(t, s, e);
            if (r < 0) return new E(i, e - s);
            ++i, (s = r);
          }
        }
        var A = {
            ecmaVersion: null,
            sourceType: "script",
            onInsertedSemicolon: null,
            onTrailingComma: null,
            allowReserved: null,
            allowReturnOutsideFunction: !1,
            allowImportExportEverywhere: !1,
            allowAwaitOutsideFunction: null,
            allowSuperOutsideMethod: null,
            allowHashBang: !1,
            checkPrivateFields: !0,
            locations: !1,
            onToken: null,
            onComment: null,
            ranges: !1,
            program: null,
            sourceFile: null,
            directSourceFile: null,
            preserveParens: !1,
          },
          P = !1;
        function getOptions(t) {
          var e = {};
          for (var i in A) e[i] = t && _(t, i) ? t[i] : A[i];
          if (
            ("latest" === e.ecmaVersion
              ? (e.ecmaVersion = 1e8)
              : null == e.ecmaVersion
              ? (!P &&
                  "object" == typeof console &&
                  console.warn &&
                  ((P = !0),
                  console.warn(
                    "Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future."
                  )),
                (e.ecmaVersion = 11))
              : e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009),
            null == e.allowReserved && (e.allowReserved = e.ecmaVersion < 5),
            (t && null != t.allowHashBang) ||
              (e.allowHashBang = e.ecmaVersion >= 14),
            S(e.onToken))
          ) {
            var s = e.onToken;
            e.onToken = function (t) {
              return s.push(t);
            };
          }
          return (
            S(e.onComment) &&
              (e.onComment = (function pushComment(t, e) {
                return function (i, s, r, a, n, o) {
                  var h = {
                    type: i ? "Block" : "Line",
                    value: s,
                    start: r,
                    end: a,
                  };
                  t.locations && (h.loc = new I(this, n, o)),
                    t.ranges && (h.range = [r, a]),
                    e.push(h);
                };
              })(e, e.onComment)),
            e
          );
        }
        var N = 256;
        function functionFlags(t, e) {
          return 2 | (t ? 4 : 0) | (e ? 8 : 0);
        }
        var T = function Parser2(t, e, i) {
            (this.options = t = getOptions(t)),
              (this.sourceFile = t.sourceFile),
              (this.keywords = wordsRegexp(
                n[
                  t.ecmaVersion >= 6
                    ? 6
                    : "module" === t.sourceType
                    ? "5module"
                    : 5
                ]
              ));
            var s = "";
            !0 !== t.allowReserved &&
              ((s = r[t.ecmaVersion >= 6 ? 6 : 5 === t.ecmaVersion ? 5 : 3]),
              "module" === t.sourceType && (s += " await")),
              (this.reservedWords = wordsRegexp(s));
            var a = (s ? s + " " : "") + r.strict;
            (this.reservedWordsStrict = wordsRegexp(a)),
              (this.reservedWordsStrictBind = wordsRegexp(
                a + " " + r.strictBind
              )),
              (this.input = String(e)),
              (this.containsEsc = !1),
              i
                ? ((this.pos = i),
                  (this.lineStart = this.input.lastIndexOf("\n", i - 1) + 1),
                  (this.curLine = this.input
                    .slice(0, this.lineStart)
                    .split(m).length))
                : ((this.pos = this.lineStart = 0), (this.curLine = 1)),
              (this.type = f.eof),
              (this.value = null),
              (this.start = this.end = this.pos),
              (this.startLoc = this.endLoc = this.curPosition()),
              (this.lastTokEndLoc = this.lastTokStartLoc = null),
              (this.lastTokStart = this.lastTokEnd = this.pos),
              (this.context = this.initialContext()),
              (this.exprAllowed = !0),
              (this.inModule = "module" === t.sourceType),
              (this.strict = this.inModule || this.strictDirective(this.pos)),
              (this.potentialArrowAt = -1),
              (this.potentialArrowInForAwait = !1),
              (this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
              (this.labels = []),
              (this.undefinedExports = Object.create(null)),
              0 === this.pos &&
                t.allowHashBang &&
                "#!" === this.input.slice(0, 2) &&
                this.skipLineComment(2),
              (this.scopeStack = []),
              this.enterScope(1),
              (this.regexpState = null),
              (this.privateNameStack = []);
          },
          V = {
            inFunction: { configurable: !0 },
            inGenerator: { configurable: !0 },
            inAsync: { configurable: !0 },
            canAwait: { configurable: !0 },
            allowSuper: { configurable: !0 },
            allowDirectSuper: { configurable: !0 },
            treatFunctionsAsVar: { configurable: !0 },
            allowNewDotTarget: { configurable: !0 },
            inClassStaticBlock: { configurable: !0 },
          };
        (T.prototype.parse = function parse2() {
          var t = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(t);
        }),
          (V.inFunction.get = function () {
            return (2 & this.currentVarScope().flags) > 0;
          }),
          (V.inGenerator.get = function () {
            return (
              (8 & this.currentVarScope().flags) > 0 &&
              !this.currentVarScope().inClassFieldInit
            );
          }),
          (V.inAsync.get = function () {
            return (
              (4 & this.currentVarScope().flags) > 0 &&
              !this.currentVarScope().inClassFieldInit
            );
          }),
          (V.canAwait.get = function () {
            for (var t = this.scopeStack.length - 1; t >= 0; t--) {
              var e = this.scopeStack[t];
              if (e.inClassFieldInit || e.flags & N) return !1;
              if (2 & e.flags) return (4 & e.flags) > 0;
            }
            return (
              (this.inModule && this.options.ecmaVersion >= 13) ||
              this.options.allowAwaitOutsideFunction
            );
          }),
          (V.allowSuper.get = function () {
            var t = this.currentThisScope(),
              e = t.flags,
              i = t.inClassFieldInit;
            return (64 & e) > 0 || i || this.options.allowSuperOutsideMethod;
          }),
          (V.allowDirectSuper.get = function () {
            return (128 & this.currentThisScope().flags) > 0;
          }),
          (V.treatFunctionsAsVar.get = function () {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }),
          (V.allowNewDotTarget.get = function () {
            var t = this.currentThisScope(),
              e = t.flags,
              i = t.inClassFieldInit;
            return (258 & e) > 0 || i;
          }),
          (V.inClassStaticBlock.get = function () {
            return (this.currentVarScope().flags & N) > 0;
          }),
          (T.extend = function extend() {
            for (var t = [], e = arguments.length; e--; ) t[e] = arguments[e];
            for (var i = this, s = 0; s < t.length; s++) i = t[s](i);
            return i;
          }),
          (T.parse = function parse2(t, e) {
            return new this(e, t).parse();
          }),
          (T.parseExpressionAt = function parseExpressionAt2(t, e, i) {
            var s = new this(i, t, e);
            return s.nextToken(), s.parseExpression();
          }),
          (T.tokenizer = function tokenizer2(t, e) {
            return new this(e, t);
          }),
          Object.defineProperties(T.prototype, V);
        var L = T.prototype,
          R = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
        (L.strictDirective = function (t) {
          if (this.options.ecmaVersion < 5) return !1;
          for (;;) {
            (v.lastIndex = t), (t += v.exec(this.input)[0].length);
            var e = R.exec(this.input.slice(t));
            if (!e) return !1;
            if ("use strict" === (e[1] || e[2])) {
              v.lastIndex = t + e[0].length;
              var i = v.exec(this.input),
                s = i.index + i[0].length,
                r = this.input.charAt(s);
              return (
                ";" === r ||
                "}" === r ||
                (m.test(i[0]) &&
                  !(
                    /[(`.[+\-/*%<>=,?^&]/.test(r) ||
                    ("!" === r && "=" === this.input.charAt(s + 1))
                  ))
              );
            }
            (t += e[0].length),
              (v.lastIndex = t),
              (t += v.exec(this.input)[0].length),
              ";" === this.input[t] && t++;
          }
        }),
          (L.eat = function (t) {
            return this.type === t && (this.next(), !0);
          }),
          (L.isContextual = function (t) {
            return (
              this.type === f.name && this.value === t && !this.containsEsc
            );
          }),
          (L.eatContextual = function (t) {
            return !!this.isContextual(t) && (this.next(), !0);
          }),
          (L.expectContextual = function (t) {
            this.eatContextual(t) || this.unexpected();
          }),
          (L.canInsertSemicolon = function () {
            return (
              this.type === f.eof ||
              this.type === f.braceR ||
              m.test(this.input.slice(this.lastTokEnd, this.start))
            );
          }),
          (L.insertSemicolon = function () {
            if (this.canInsertSemicolon())
              return (
                this.options.onInsertedSemicolon &&
                  this.options.onInsertedSemicolon(
                    this.lastTokEnd,
                    this.lastTokEndLoc
                  ),
                !0
              );
          }),
          (L.semicolon = function () {
            this.eat(f.semi) || this.insertSemicolon() || this.unexpected();
          }),
          (L.afterTrailingComma = function (t, e) {
            if (this.type === t)
              return (
                this.options.onTrailingComma &&
                  this.options.onTrailingComma(
                    this.lastTokStart,
                    this.lastTokStartLoc
                  ),
                e || this.next(),
                !0
              );
          }),
          (L.expect = function (t) {
            this.eat(t) || this.unexpected();
          }),
          (L.unexpected = function (t) {
            this.raise(null != t ? t : this.start, "Unexpected token");
          });
        var D = function DestructuringErrors2() {
          this.shorthandAssign =
            this.trailingComma =
            this.parenthesizedAssign =
            this.parenthesizedBind =
            this.doubleProto =
              -1;
        };
        (L.checkPatternErrors = function (t, e) {
          if (t) {
            t.trailingComma > -1 &&
              this.raiseRecoverable(
                t.trailingComma,
                "Comma is not permitted after the rest element"
              );
            var i = e ? t.parenthesizedAssign : t.parenthesizedBind;
            i > -1 &&
              this.raiseRecoverable(
                i,
                e ? "Assigning to rvalue" : "Parenthesized pattern"
              );
          }
        }),
          (L.checkExpressionErrors = function (t, e) {
            if (!t) return !1;
            var i = t.shorthandAssign,
              s = t.doubleProto;
            if (!e) return i >= 0 || s >= 0;
            i >= 0 &&
              this.raise(
                i,
                "Shorthand property assignments are valid only in destructuring patterns"
              ),
              s >= 0 &&
                this.raiseRecoverable(s, "Redefinition of __proto__ property");
          }),
          (L.checkYieldAwaitInDefaultParams = function () {
            this.yieldPos &&
              (!this.awaitPos || this.yieldPos < this.awaitPos) &&
              this.raise(
                this.yieldPos,
                "Yield expression cannot be a default value"
              ),
              this.awaitPos &&
                this.raise(
                  this.awaitPos,
                  "Await expression cannot be a default value"
                );
          }),
          (L.isSimpleAssignTarget = function (t) {
            return "ParenthesizedExpression" === t.type
              ? this.isSimpleAssignTarget(t.expression)
              : "Identifier" === t.type || "MemberExpression" === t.type;
          });
        var O = T.prototype;
        O.parseTopLevel = function (t) {
          var e = Object.create(null);
          for (t.body || (t.body = []); this.type !== f.eof; ) {
            var i = this.parseStatement(null, !0, e);
            t.body.push(i);
          }
          if (this.inModule)
            for (
              var s = 0, r = Object.keys(this.undefinedExports);
              s < r.length;
              s += 1
            ) {
              var a = r[s];
              this.raiseRecoverable(
                this.undefinedExports[a].start,
                "Export '" + a + "' is not defined"
              );
            }
          return (
            this.adaptDirectivePrologue(t.body),
            this.next(),
            (t.sourceType = this.options.sourceType),
            this.finishNode(t, "Program")
          );
        };
        var B = { kind: "loop" },
          M = { kind: "switch" };
        (O.isLet = function (t) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
            return !1;
          v.lastIndex = this.pos;
          var e = v.exec(this.input),
            i = this.pos + e[0].length,
            s = this.input.charCodeAt(i);
          if (91 === s || 92 === s) return !0;
          if (t) return !1;
          if (123 === s || (s > 55295 && s < 56320)) return !0;
          if (isIdentifierStart(s, !0)) {
            for (
              var r = i + 1;
              isIdentifierChar((s = this.input.charCodeAt(r)), !0);

            )
              ++r;
            if (92 === s || (s > 55295 && s < 56320)) return !0;
            var a = this.input.slice(i, r);
            if (!o.test(a)) return !0;
          }
          return !1;
        }),
          (O.isAsyncFunction = function () {
            if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
              return !1;
            v.lastIndex = this.pos;
            var t,
              e = v.exec(this.input),
              i = this.pos + e[0].length;
            return !(
              m.test(this.input.slice(this.pos, i)) ||
              "function" !== this.input.slice(i, i + 8) ||
              (i + 8 !== this.input.length &&
                (isIdentifierChar((t = this.input.charCodeAt(i + 8))) ||
                  (t > 55295 && t < 56320)))
            );
          }),
          (O.parseStatement = function (t, e, i) {
            var s,
              r = this.type,
              a = this.startNode();
            switch ((this.isLet(t) && ((r = f._var), (s = "let")), r)) {
              case f._break:
              case f._continue:
                return this.parseBreakContinueStatement(a, r.keyword);
              case f._debugger:
                return this.parseDebuggerStatement(a);
              case f._do:
                return this.parseDoStatement(a);
              case f._for:
                return this.parseForStatement(a);
              case f._function:
                return (
                  t &&
                    (this.strict || ("if" !== t && "label" !== t)) &&
                    this.options.ecmaVersion >= 6 &&
                    this.unexpected(),
                  this.parseFunctionStatement(a, !1, !t)
                );
              case f._class:
                return t && this.unexpected(), this.parseClass(a, !0);
              case f._if:
                return this.parseIfStatement(a);
              case f._return:
                return this.parseReturnStatement(a);
              case f._switch:
                return this.parseSwitchStatement(a);
              case f._throw:
                return this.parseThrowStatement(a);
              case f._try:
                return this.parseTryStatement(a);
              case f._const:
              case f._var:
                return (
                  (s = s || this.value),
                  t && "var" !== s && this.unexpected(),
                  this.parseVarStatement(a, s)
                );
              case f._while:
                return this.parseWhileStatement(a);
              case f._with:
                return this.parseWithStatement(a);
              case f.braceL:
                return this.parseBlock(!0, a);
              case f.semi:
                return this.parseEmptyStatement(a);
              case f._export:
              case f._import:
                if (this.options.ecmaVersion > 10 && r === f._import) {
                  v.lastIndex = this.pos;
                  var n = v.exec(this.input),
                    o = this.pos + n[0].length,
                    h = this.input.charCodeAt(o);
                  if (40 === h || 46 === h)
                    return this.parseExpressionStatement(
                      a,
                      this.parseExpression()
                    );
                }
                return (
                  this.options.allowImportExportEverywhere ||
                    (e ||
                      this.raise(
                        this.start,
                        "'import' and 'export' may only appear at the top level"
                      ),
                    this.inModule ||
                      this.raise(
                        this.start,
                        "'import' and 'export' may appear only with 'sourceType: module'"
                      )),
                  r === f._import ? this.parseImport(a) : this.parseExport(a, i)
                );
              default:
                if (this.isAsyncFunction())
                  return (
                    t && this.unexpected(),
                    this.next(),
                    this.parseFunctionStatement(a, !0, !t)
                  );
                var p = this.value,
                  c = this.parseExpression();
                return r === f.name &&
                  "Identifier" === c.type &&
                  this.eat(f.colon)
                  ? this.parseLabeledStatement(a, p, c, t)
                  : this.parseExpressionStatement(a, c);
            }
          }),
          (O.parseBreakContinueStatement = function (t, e) {
            var i = "break" === e;
            this.next(),
              this.eat(f.semi) || this.insertSemicolon()
                ? (t.label = null)
                : this.type !== f.name
                ? this.unexpected()
                : ((t.label = this.parseIdent()), this.semicolon());
            for (var s = 0; s < this.labels.length; ++s) {
              var r = this.labels[s];
              if (null == t.label || r.name === t.label.name) {
                if (null != r.kind && (i || "loop" === r.kind)) break;
                if (t.label && i) break;
              }
            }
            return (
              s === this.labels.length &&
                this.raise(t.start, "Unsyntactic " + e),
              this.finishNode(t, i ? "BreakStatement" : "ContinueStatement")
            );
          }),
          (O.parseDebuggerStatement = function (t) {
            return (
              this.next(),
              this.semicolon(),
              this.finishNode(t, "DebuggerStatement")
            );
          }),
          (O.parseDoStatement = function (t) {
            return (
              this.next(),
              this.labels.push(B),
              (t.body = this.parseStatement("do")),
              this.labels.pop(),
              this.expect(f._while),
              (t.test = this.parseParenExpression()),
              this.options.ecmaVersion >= 6
                ? this.eat(f.semi)
                : this.semicolon(),
              this.finishNode(t, "DoWhileStatement")
            );
          }),
          (O.parseForStatement = function (t) {
            this.next();
            var e =
              this.options.ecmaVersion >= 9 &&
              this.canAwait &&
              this.eatContextual("await")
                ? this.lastTokStart
                : -1;
            if (
              (this.labels.push(B),
              this.enterScope(0),
              this.expect(f.parenL),
              this.type === f.semi)
            )
              return e > -1 && this.unexpected(e), this.parseFor(t, null);
            var i = this.isLet();
            if (this.type === f._var || this.type === f._const || i) {
              var s = this.startNode(),
                r = i ? "let" : this.value;
              return (
                this.next(),
                this.parseVar(s, !0, r),
                this.finishNode(s, "VariableDeclaration"),
                (this.type === f._in ||
                  (this.options.ecmaVersion >= 6 && this.isContextual("of"))) &&
                1 === s.declarations.length
                  ? (this.options.ecmaVersion >= 9 &&
                      (this.type === f._in
                        ? e > -1 && this.unexpected(e)
                        : (t.await = e > -1)),
                    this.parseForIn(t, s))
                  : (e > -1 && this.unexpected(e), this.parseFor(t, s))
              );
            }
            var a = this.isContextual("let"),
              n = !1,
              o = new D(),
              h = this.parseExpression(!(e > -1) || "await", o);
            return this.type === f._in ||
              (n = this.options.ecmaVersion >= 6 && this.isContextual("of"))
              ? (this.options.ecmaVersion >= 9 &&
                  (this.type === f._in
                    ? e > -1 && this.unexpected(e)
                    : (t.await = e > -1)),
                a &&
                  n &&
                  this.raise(
                    h.start,
                    "The left-hand side of a for-of loop may not start with 'let'."
                  ),
                this.toAssignable(h, !1, o),
                this.checkLValPattern(h),
                this.parseForIn(t, h))
              : (this.checkExpressionErrors(o, !0),
                e > -1 && this.unexpected(e),
                this.parseFor(t, h));
          }),
          (O.parseFunctionStatement = function (t, e, i) {
            return this.next(), this.parseFunction(t, U | (i ? 0 : q), !1, e);
          }),
          (O.parseIfStatement = function (t) {
            return (
              this.next(),
              (t.test = this.parseParenExpression()),
              (t.consequent = this.parseStatement("if")),
              (t.alternate = this.eat(f._else)
                ? this.parseStatement("if")
                : null),
              this.finishNode(t, "IfStatement")
            );
          }),
          (O.parseReturnStatement = function (t) {
            return (
              this.inFunction ||
                this.options.allowReturnOutsideFunction ||
                this.raise(this.start, "'return' outside of function"),
              this.next(),
              this.eat(f.semi) || this.insertSemicolon()
                ? (t.argument = null)
                : ((t.argument = this.parseExpression()), this.semicolon()),
              this.finishNode(t, "ReturnStatement")
            );
          }),
          (O.parseSwitchStatement = function (t) {
            var e;
            this.next(),
              (t.discriminant = this.parseParenExpression()),
              (t.cases = []),
              this.expect(f.braceL),
              this.labels.push(M),
              this.enterScope(0);
            for (var i = !1; this.type !== f.braceR; )
              if (this.type === f._case || this.type === f._default) {
                var s = this.type === f._case;
                e && this.finishNode(e, "SwitchCase"),
                  t.cases.push((e = this.startNode())),
                  (e.consequent = []),
                  this.next(),
                  s
                    ? (e.test = this.parseExpression())
                    : (i &&
                        this.raiseRecoverable(
                          this.lastTokStart,
                          "Multiple default clauses"
                        ),
                      (i = !0),
                      (e.test = null)),
                  this.expect(f.colon);
              } else
                e || this.unexpected(),
                  e.consequent.push(this.parseStatement(null));
            return (
              this.exitScope(),
              e && this.finishNode(e, "SwitchCase"),
              this.next(),
              this.labels.pop(),
              this.finishNode(t, "SwitchStatement")
            );
          }),
          (O.parseThrowStatement = function (t) {
            return (
              this.next(),
              m.test(this.input.slice(this.lastTokEnd, this.start)) &&
                this.raise(this.lastTokEnd, "Illegal newline after throw"),
              (t.argument = this.parseExpression()),
              this.semicolon(),
              this.finishNode(t, "ThrowStatement")
            );
          });
        var F = [];
        (O.parseCatchClauseParam = function () {
          var t = this.parseBindingAtom(),
            e = "Identifier" === t.type;
          return (
            this.enterScope(e ? 32 : 0),
            this.checkLValPattern(t, e ? 4 : 2),
            this.expect(f.parenR),
            t
          );
        }),
          (O.parseTryStatement = function (t) {
            if (
              (this.next(),
              (t.block = this.parseBlock()),
              (t.handler = null),
              this.type === f._catch)
            ) {
              var e = this.startNode();
              this.next(),
                this.eat(f.parenL)
                  ? (e.param = this.parseCatchClauseParam())
                  : (this.options.ecmaVersion < 10 && this.unexpected(),
                    (e.param = null),
                    this.enterScope(0)),
                (e.body = this.parseBlock(!1)),
                this.exitScope(),
                (t.handler = this.finishNode(e, "CatchClause"));
            }
            return (
              (t.finalizer = this.eat(f._finally) ? this.parseBlock() : null),
              t.handler ||
                t.finalizer ||
                this.raise(t.start, "Missing catch or finally clause"),
              this.finishNode(t, "TryStatement")
            );
          }),
          (O.parseVarStatement = function (t, e, i) {
            return (
              this.next(),
              this.parseVar(t, !1, e, i),
              this.semicolon(),
              this.finishNode(t, "VariableDeclaration")
            );
          }),
          (O.parseWhileStatement = function (t) {
            return (
              this.next(),
              (t.test = this.parseParenExpression()),
              this.labels.push(B),
              (t.body = this.parseStatement("while")),
              this.labels.pop(),
              this.finishNode(t, "WhileStatement")
            );
          }),
          (O.parseWithStatement = function (t) {
            return (
              this.strict && this.raise(this.start, "'with' in strict mode"),
              this.next(),
              (t.object = this.parseParenExpression()),
              (t.body = this.parseStatement("with")),
              this.finishNode(t, "WithStatement")
            );
          }),
          (O.parseEmptyStatement = function (t) {
            return this.next(), this.finishNode(t, "EmptyStatement");
          }),
          (O.parseLabeledStatement = function (t, e, i, s) {
            for (var r = 0, a = this.labels; r < a.length; r += 1)
              a[r].name === e &&
                this.raise(i.start, "Label '" + e + "' is already declared");
            for (
              var n = this.type.isLoop
                  ? "loop"
                  : this.type === f._switch
                  ? "switch"
                  : null,
                o = this.labels.length - 1;
              o >= 0;
              o--
            ) {
              var h = this.labels[o];
              if (h.statementStart !== t.start) break;
              (h.statementStart = this.start), (h.kind = n);
            }
            return (
              this.labels.push({
                name: e,
                kind: n,
                statementStart: this.start,
              }),
              (t.body = this.parseStatement(
                s ? (-1 === s.indexOf("label") ? s + "label" : s) : "label"
              )),
              this.labels.pop(),
              (t.label = i),
              this.finishNode(t, "LabeledStatement")
            );
          }),
          (O.parseExpressionStatement = function (t, e) {
            return (
              (t.expression = e),
              this.semicolon(),
              this.finishNode(t, "ExpressionStatement")
            );
          }),
          (O.parseBlock = function (t, e, i) {
            for (
              void 0 === t && (t = !0),
                void 0 === e && (e = this.startNode()),
                e.body = [],
                this.expect(f.braceL),
                t && this.enterScope(0);
              this.type !== f.braceR;

            ) {
              var s = this.parseStatement(null);
              e.body.push(s);
            }
            return (
              i && (this.strict = !1),
              this.next(),
              t && this.exitScope(),
              this.finishNode(e, "BlockStatement")
            );
          }),
          (O.parseFor = function (t, e) {
            return (
              (t.init = e),
              this.expect(f.semi),
              (t.test = this.type === f.semi ? null : this.parseExpression()),
              this.expect(f.semi),
              (t.update =
                this.type === f.parenR ? null : this.parseExpression()),
              this.expect(f.parenR),
              (t.body = this.parseStatement("for")),
              this.exitScope(),
              this.labels.pop(),
              this.finishNode(t, "ForStatement")
            );
          }),
          (O.parseForIn = function (t, e) {
            var i = this.type === f._in;
            return (
              this.next(),
              "VariableDeclaration" === e.type &&
                null != e.declarations[0].init &&
                (!i ||
                  this.options.ecmaVersion < 8 ||
                  this.strict ||
                  "var" !== e.kind ||
                  "Identifier" !== e.declarations[0].id.type) &&
                this.raise(
                  e.start,
                  (i ? "for-in" : "for-of") +
                    " loop variable declaration may not have an initializer"
                ),
              (t.left = e),
              (t.right = i ? this.parseExpression() : this.parseMaybeAssign()),
              this.expect(f.parenR),
              (t.body = this.parseStatement("for")),
              this.exitScope(),
              this.labels.pop(),
              this.finishNode(t, i ? "ForInStatement" : "ForOfStatement")
            );
          }),
          (O.parseVar = function (t, e, i, s) {
            for (t.declarations = [], t.kind = i; ; ) {
              var r = this.startNode();
              if (
                (this.parseVarId(r, i),
                this.eat(f.eq)
                  ? (r.init = this.parseMaybeAssign(e))
                  : s ||
                    "const" !== i ||
                    this.type === f._in ||
                    (this.options.ecmaVersion >= 6 && this.isContextual("of"))
                  ? s ||
                    "Identifier" === r.id.type ||
                    (e && (this.type === f._in || this.isContextual("of")))
                    ? (r.init = null)
                    : this.raise(
                        this.lastTokEnd,
                        "Complex binding patterns require an initialization value"
                      )
                  : this.unexpected(),
                t.declarations.push(this.finishNode(r, "VariableDeclarator")),
                !this.eat(f.comma))
              )
                break;
            }
            return t;
          }),
          (O.parseVarId = function (t, e) {
            (t.id = this.parseBindingAtom()),
              this.checkLValPattern(t.id, "var" === e ? 1 : 2, !1);
          });
        var U = 1,
          q = 2;
        function isPrivateNameConflicted(t, e) {
          var i = e.key.name,
            s = t[i],
            r = "true";
          return (
            "MethodDefinition" !== e.type ||
              ("get" !== e.kind && "set" !== e.kind) ||
              (r = (e.static ? "s" : "i") + e.kind),
            ("iget" === s && "iset" === r) ||
            ("iset" === s && "iget" === r) ||
            ("sget" === s && "sset" === r) ||
            ("sset" === s && "sget" === r)
              ? ((t[i] = "true"), !1)
              : !!s || ((t[i] = r), !1)
          );
        }
        function checkKeyName(t, e) {
          var i = t.computed,
            s = t.key;
          return (
            !i &&
            (("Identifier" === s.type && s.name === e) ||
              ("Literal" === s.type && s.value === e))
          );
        }
        (O.parseFunction = function (t, e, i, s, r) {
          this.initFunction(t),
            (this.options.ecmaVersion >= 9 ||
              (this.options.ecmaVersion >= 6 && !s)) &&
              (this.type === f.star && e & q && this.unexpected(),
              (t.generator = this.eat(f.star))),
            this.options.ecmaVersion >= 8 && (t.async = !!s),
            e & U &&
              ((t.id =
                4 & e && this.type !== f.name ? null : this.parseIdent()),
              !t.id ||
                e & q ||
                this.checkLValSimple(
                  t.id,
                  this.strict || t.generator || t.async
                    ? this.treatFunctionsAsVar
                      ? 1
                      : 2
                    : 3
                ));
          var a = this.yieldPos,
            n = this.awaitPos,
            o = this.awaitIdentPos;
          return (
            (this.yieldPos = 0),
            (this.awaitPos = 0),
            (this.awaitIdentPos = 0),
            this.enterScope(functionFlags(t.async, t.generator)),
            e & U || (t.id = this.type === f.name ? this.parseIdent() : null),
            this.parseFunctionParams(t),
            this.parseFunctionBody(t, i, !1, r),
            (this.yieldPos = a),
            (this.awaitPos = n),
            (this.awaitIdentPos = o),
            this.finishNode(
              t,
              e & U ? "FunctionDeclaration" : "FunctionExpression"
            )
          );
        }),
          (O.parseFunctionParams = function (t) {
            this.expect(f.parenL),
              (t.params = this.parseBindingList(
                f.parenR,
                !1,
                this.options.ecmaVersion >= 8
              )),
              this.checkYieldAwaitInDefaultParams();
          }),
          (O.parseClass = function (t, e) {
            this.next();
            var i = this.strict;
            (this.strict = !0),
              this.parseClassId(t, e),
              this.parseClassSuper(t);
            var s = this.enterClassBody(),
              r = this.startNode(),
              a = !1;
            for (r.body = [], this.expect(f.braceL); this.type !== f.braceR; ) {
              var n = this.parseClassElement(null !== t.superClass);
              n &&
                (r.body.push(n),
                "MethodDefinition" === n.type && "constructor" === n.kind
                  ? (a &&
                      this.raiseRecoverable(
                        n.start,
                        "Duplicate constructor in the same class"
                      ),
                    (a = !0))
                  : n.key &&
                    "PrivateIdentifier" === n.key.type &&
                    isPrivateNameConflicted(s, n) &&
                    this.raiseRecoverable(
                      n.key.start,
                      "Identifier '#" +
                        n.key.name +
                        "' has already been declared"
                    ));
            }
            return (
              (this.strict = i),
              this.next(),
              (t.body = this.finishNode(r, "ClassBody")),
              this.exitClassBody(),
              this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression")
            );
          }),
          (O.parseClassElement = function (t) {
            if (this.eat(f.semi)) return null;
            var e = this.options.ecmaVersion,
              i = this.startNode(),
              s = "",
              r = !1,
              a = !1,
              n = "method",
              o = !1;
            if (this.eatContextual("static")) {
              if (e >= 13 && this.eat(f.braceL))
                return this.parseClassStaticBlock(i), i;
              this.isClassElementNameStart() || this.type === f.star
                ? (o = !0)
                : (s = "static");
            }
            if (
              ((i.static = o),
              !s &&
                e >= 8 &&
                this.eatContextual("async") &&
                ((!this.isClassElementNameStart() && this.type !== f.star) ||
                this.canInsertSemicolon()
                  ? (s = "async")
                  : (a = !0)),
              !s && (e >= 9 || !a) && this.eat(f.star) && (r = !0),
              !s && !a && !r)
            ) {
              var h = this.value;
              (this.eatContextual("get") || this.eatContextual("set")) &&
                (this.isClassElementNameStart() ? (n = h) : (s = h));
            }
            if (
              (s
                ? ((i.computed = !1),
                  (i.key = this.startNodeAt(
                    this.lastTokStart,
                    this.lastTokStartLoc
                  )),
                  (i.key.name = s),
                  this.finishNode(i.key, "Identifier"))
                : this.parseClassElementName(i),
              e < 13 || this.type === f.parenL || "method" !== n || r || a)
            ) {
              var p = !i.static && checkKeyName(i, "constructor"),
                c = p && t;
              p &&
                "method" !== n &&
                this.raise(
                  i.key.start,
                  "Constructor can't have get/set modifier"
                ),
                (i.kind = p ? "constructor" : n),
                this.parseClassMethod(i, r, a, c);
            } else this.parseClassField(i);
            return i;
          }),
          (O.isClassElementNameStart = function () {
            return (
              this.type === f.name ||
              this.type === f.privateId ||
              this.type === f.num ||
              this.type === f.string ||
              this.type === f.bracketL ||
              this.type.keyword
            );
          }),
          (O.parseClassElementName = function (t) {
            this.type === f.privateId
              ? ("constructor" === this.value &&
                  this.raise(
                    this.start,
                    "Classes can't have an element named '#constructor'"
                  ),
                (t.computed = !1),
                (t.key = this.parsePrivateIdent()))
              : this.parsePropertyName(t);
          }),
          (O.parseClassMethod = function (t, e, i, s) {
            var r = t.key;
            "constructor" === t.kind
              ? (e && this.raise(r.start, "Constructor can't be a generator"),
                i &&
                  this.raise(r.start, "Constructor can't be an async method"))
              : t.static &&
                checkKeyName(t, "prototype") &&
                this.raise(
                  r.start,
                  "Classes may not have a static property named prototype"
                );
            var a = (t.value = this.parseMethod(e, i, s));
            return (
              "get" === t.kind &&
                0 !== a.params.length &&
                this.raiseRecoverable(a.start, "getter should have no params"),
              "set" === t.kind &&
                1 !== a.params.length &&
                this.raiseRecoverable(
                  a.start,
                  "setter should have exactly one param"
                ),
              "set" === t.kind &&
                "RestElement" === a.params[0].type &&
                this.raiseRecoverable(
                  a.params[0].start,
                  "Setter cannot use rest params"
                ),
              this.finishNode(t, "MethodDefinition")
            );
          }),
          (O.parseClassField = function (t) {
            if (
              (checkKeyName(t, "constructor")
                ? this.raise(
                    t.key.start,
                    "Classes can't have a field named 'constructor'"
                  )
                : t.static &&
                  checkKeyName(t, "prototype") &&
                  this.raise(
                    t.key.start,
                    "Classes can't have a static field named 'prototype'"
                  ),
              this.eat(f.eq))
            ) {
              var e = this.currentThisScope(),
                i = e.inClassFieldInit;
              (e.inClassFieldInit = !0),
                (t.value = this.parseMaybeAssign()),
                (e.inClassFieldInit = i);
            } else t.value = null;
            return this.semicolon(), this.finishNode(t, "PropertyDefinition");
          }),
          (O.parseClassStaticBlock = function (t) {
            t.body = [];
            var e = this.labels;
            for (
              this.labels = [], this.enterScope(320);
              this.type !== f.braceR;

            ) {
              var i = this.parseStatement(null);
              t.body.push(i);
            }
            return (
              this.next(),
              this.exitScope(),
              (this.labels = e),
              this.finishNode(t, "StaticBlock")
            );
          }),
          (O.parseClassId = function (t, e) {
            this.type === f.name
              ? ((t.id = this.parseIdent()),
                e && this.checkLValSimple(t.id, 2, !1))
              : (!0 === e && this.unexpected(), (t.id = null));
          }),
          (O.parseClassSuper = function (t) {
            t.superClass = this.eat(f._extends)
              ? this.parseExprSubscripts(null, !1)
              : null;
          }),
          (O.enterClassBody = function () {
            var t = { declared: Object.create(null), used: [] };
            return this.privateNameStack.push(t), t.declared;
          }),
          (O.exitClassBody = function () {
            var t = this.privateNameStack.pop(),
              e = t.declared,
              i = t.used;
            if (this.options.checkPrivateFields)
              for (
                var s = this.privateNameStack.length,
                  r = 0 === s ? null : this.privateNameStack[s - 1],
                  a = 0;
                a < i.length;
                ++a
              ) {
                var n = i[a];
                _(e, n.name) ||
                  (r
                    ? r.used.push(n)
                    : this.raiseRecoverable(
                        n.start,
                        "Private field '#" +
                          n.name +
                          "' must be declared in an enclosing class"
                      ));
              }
          }),
          (O.parseExportAllDeclaration = function (t, e) {
            return (
              this.options.ecmaVersion >= 11 &&
                (this.eatContextual("as")
                  ? ((t.exported = this.parseModuleExportName()),
                    this.checkExport(e, t.exported, this.lastTokStart))
                  : (t.exported = null)),
              this.expectContextual("from"),
              this.type !== f.string && this.unexpected(),
              (t.source = this.parseExprAtom()),
              this.semicolon(),
              this.finishNode(t, "ExportAllDeclaration")
            );
          }),
          (O.parseExport = function (t, e) {
            if ((this.next(), this.eat(f.star)))
              return this.parseExportAllDeclaration(t, e);
            if (this.eat(f._default))
              return (
                this.checkExport(e, "default", this.lastTokStart),
                (t.declaration = this.parseExportDefaultDeclaration()),
                this.finishNode(t, "ExportDefaultDeclaration")
              );
            if (this.shouldParseExportStatement())
              (t.declaration = this.parseExportDeclaration(t)),
                "VariableDeclaration" === t.declaration.type
                  ? this.checkVariableExport(e, t.declaration.declarations)
                  : this.checkExport(
                      e,
                      t.declaration.id,
                      t.declaration.id.start
                    ),
                (t.specifiers = []),
                (t.source = null);
            else {
              if (
                ((t.declaration = null),
                (t.specifiers = this.parseExportSpecifiers(e)),
                this.eatContextual("from"))
              )
                this.type !== f.string && this.unexpected(),
                  (t.source = this.parseExprAtom());
              else {
                for (var i = 0, s = t.specifiers; i < s.length; i += 1) {
                  var r = s[i];
                  this.checkUnreserved(r.local),
                    this.checkLocalExport(r.local),
                    "Literal" === r.local.type &&
                      this.raise(
                        r.local.start,
                        "A string literal cannot be used as an exported binding without `from`."
                      );
                }
                t.source = null;
              }
              this.semicolon();
            }
            return this.finishNode(t, "ExportNamedDeclaration");
          }),
          (O.parseExportDeclaration = function (t) {
            return this.parseStatement(null);
          }),
          (O.parseExportDefaultDeclaration = function () {
            var t;
            if (this.type === f._function || (t = this.isAsyncFunction())) {
              var e = this.startNode();
              return (
                this.next(),
                t && this.next(),
                this.parseFunction(e, 4 | U, !1, t)
              );
            }
            if (this.type === f._class) {
              var i = this.startNode();
              return this.parseClass(i, "nullableID");
            }
            var s = this.parseMaybeAssign();
            return this.semicolon(), s;
          }),
          (O.checkExport = function (t, e, i) {
            t &&
              ("string" != typeof e &&
                (e = "Identifier" === e.type ? e.name : e.value),
              _(t, e) &&
                this.raiseRecoverable(i, "Duplicate export '" + e + "'"),
              (t[e] = !0));
          }),
          (O.checkPatternExport = function (t, e) {
            var i = e.type;
            if ("Identifier" === i) this.checkExport(t, e, e.start);
            else if ("ObjectPattern" === i)
              for (var s = 0, r = e.properties; s < r.length; s += 1) {
                var a = r[s];
                this.checkPatternExport(t, a);
              }
            else if ("ArrayPattern" === i)
              for (var n = 0, o = e.elements; n < o.length; n += 1) {
                var h = o[n];
                h && this.checkPatternExport(t, h);
              }
            else
              "Property" === i
                ? this.checkPatternExport(t, e.value)
                : "AssignmentPattern" === i
                ? this.checkPatternExport(t, e.left)
                : "RestElement" === i && this.checkPatternExport(t, e.argument);
          }),
          (O.checkVariableExport = function (t, e) {
            if (t)
              for (var i = 0, s = e; i < s.length; i += 1) {
                var r = s[i];
                this.checkPatternExport(t, r.id);
              }
          }),
          (O.shouldParseExportStatement = function () {
            return (
              "var" === this.type.keyword ||
              "const" === this.type.keyword ||
              "class" === this.type.keyword ||
              "function" === this.type.keyword ||
              this.isLet() ||
              this.isAsyncFunction()
            );
          }),
          (O.parseExportSpecifier = function (t) {
            var e = this.startNode();
            return (
              (e.local = this.parseModuleExportName()),
              (e.exported = this.eatContextual("as")
                ? this.parseModuleExportName()
                : e.local),
              this.checkExport(t, e.exported, e.exported.start),
              this.finishNode(e, "ExportSpecifier")
            );
          }),
          (O.parseExportSpecifiers = function (t) {
            var e = [],
              i = !0;
            for (this.expect(f.braceL); !this.eat(f.braceR); ) {
              if (i) i = !1;
              else if (
                (this.expect(f.comma), this.afterTrailingComma(f.braceR))
              )
                break;
              e.push(this.parseExportSpecifier(t));
            }
            return e;
          }),
          (O.parseImport = function (t) {
            return (
              this.next(),
              this.type === f.string
                ? ((t.specifiers = F), (t.source = this.parseExprAtom()))
                : ((t.specifiers = this.parseImportSpecifiers()),
                  this.expectContextual("from"),
                  (t.source =
                    this.type === f.string
                      ? this.parseExprAtom()
                      : this.unexpected())),
              this.semicolon(),
              this.finishNode(t, "ImportDeclaration")
            );
          }),
          (O.parseImportSpecifier = function () {
            var t = this.startNode();
            return (
              (t.imported = this.parseModuleExportName()),
              this.eatContextual("as")
                ? (t.local = this.parseIdent())
                : (this.checkUnreserved(t.imported), (t.local = t.imported)),
              this.checkLValSimple(t.local, 2),
              this.finishNode(t, "ImportSpecifier")
            );
          }),
          (O.parseImportDefaultSpecifier = function () {
            var t = this.startNode();
            return (
              (t.local = this.parseIdent()),
              this.checkLValSimple(t.local, 2),
              this.finishNode(t, "ImportDefaultSpecifier")
            );
          }),
          (O.parseImportNamespaceSpecifier = function () {
            var t = this.startNode();
            return (
              this.next(),
              this.expectContextual("as"),
              (t.local = this.parseIdent()),
              this.checkLValSimple(t.local, 2),
              this.finishNode(t, "ImportNamespaceSpecifier")
            );
          }),
          (O.parseImportSpecifiers = function () {
            var t = [],
              e = !0;
            if (
              this.type === f.name &&
              (t.push(this.parseImportDefaultSpecifier()), !this.eat(f.comma))
            )
              return t;
            if (this.type === f.star)
              return t.push(this.parseImportNamespaceSpecifier()), t;
            for (this.expect(f.braceL); !this.eat(f.braceR); ) {
              if (e) e = !1;
              else if (
                (this.expect(f.comma), this.afterTrailingComma(f.braceR))
              )
                break;
              t.push(this.parseImportSpecifier());
            }
            return t;
          }),
          (O.parseModuleExportName = function () {
            if (this.options.ecmaVersion >= 13 && this.type === f.string) {
              var t = this.parseLiteral(this.value);
              return (
                w.test(t.value) &&
                  this.raise(
                    t.start,
                    "An export name cannot include a lone surrogate."
                  ),
                t
              );
            }
            return this.parseIdent(!0);
          }),
          (O.adaptDirectivePrologue = function (t) {
            for (
              var e = 0;
              e < t.length && this.isDirectiveCandidate(t[e]);
              ++e
            )
              t[e].directive = t[e].expression.raw.slice(1, -1);
          }),
          (O.isDirectiveCandidate = function (t) {
            return (
              this.options.ecmaVersion >= 5 &&
              "ExpressionStatement" === t.type &&
              "Literal" === t.expression.type &&
              "string" == typeof t.expression.value &&
              ('"' === this.input[t.start] || "'" === this.input[t.start])
            );
          });
        var j = T.prototype;
        (j.toAssignable = function (t, e, i) {
          if (this.options.ecmaVersion >= 6 && t)
            switch (t.type) {
              case "Identifier":
                this.inAsync &&
                  "await" === t.name &&
                  this.raise(
                    t.start,
                    "Cannot use 'await' as identifier inside an async function"
                  );
                break;
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                (t.type = "ObjectPattern"), i && this.checkPatternErrors(i, !0);
                for (var s = 0, r = t.properties; s < r.length; s += 1) {
                  var a = r[s];
                  this.toAssignable(a, e),
                    "RestElement" !== a.type ||
                      ("ArrayPattern" !== a.argument.type &&
                        "ObjectPattern" !== a.argument.type) ||
                      this.raise(a.argument.start, "Unexpected token");
                }
                break;
              case "Property":
                "init" !== t.kind &&
                  this.raise(
                    t.key.start,
                    "Object pattern can't contain getter or setter"
                  ),
                  this.toAssignable(t.value, e);
                break;
              case "ArrayExpression":
                (t.type = "ArrayPattern"),
                  i && this.checkPatternErrors(i, !0),
                  this.toAssignableList(t.elements, e);
                break;
              case "SpreadElement":
                (t.type = "RestElement"),
                  this.toAssignable(t.argument, e),
                  "AssignmentPattern" === t.argument.type &&
                    this.raise(
                      t.argument.start,
                      "Rest elements cannot have a default value"
                    );
                break;
              case "AssignmentExpression":
                "=" !== t.operator &&
                  this.raise(
                    t.left.end,
                    "Only '=' operator can be used for specifying default value."
                  ),
                  (t.type = "AssignmentPattern"),
                  delete t.operator,
                  this.toAssignable(t.left, e);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(t.expression, e, i);
                break;
              case "ChainExpression":
                this.raiseRecoverable(
                  t.start,
                  "Optional chaining cannot appear in left-hand side"
                );
                break;
              case "MemberExpression":
                if (!e) break;
              default:
                this.raise(t.start, "Assigning to rvalue");
            }
          else i && this.checkPatternErrors(i, !0);
          return t;
        }),
          (j.toAssignableList = function (t, e) {
            for (var i = t.length, s = 0; s < i; s++) {
              var r = t[s];
              r && this.toAssignable(r, e);
            }
            if (i) {
              var a = t[i - 1];
              6 === this.options.ecmaVersion &&
                e &&
                a &&
                "RestElement" === a.type &&
                "Identifier" !== a.argument.type &&
                this.unexpected(a.argument.start);
            }
            return t;
          }),
          (j.parseSpread = function (t) {
            var e = this.startNode();
            return (
              this.next(),
              (e.argument = this.parseMaybeAssign(!1, t)),
              this.finishNode(e, "SpreadElement")
            );
          }),
          (j.parseRestBinding = function () {
            var t = this.startNode();
            return (
              this.next(),
              6 === this.options.ecmaVersion &&
                this.type !== f.name &&
                this.unexpected(),
              (t.argument = this.parseBindingAtom()),
              this.finishNode(t, "RestElement")
            );
          }),
          (j.parseBindingAtom = function () {
            if (this.options.ecmaVersion >= 6)
              switch (this.type) {
                case f.bracketL:
                  var t = this.startNode();
                  return (
                    this.next(),
                    (t.elements = this.parseBindingList(f.bracketR, !0, !0)),
                    this.finishNode(t, "ArrayPattern")
                  );
                case f.braceL:
                  return this.parseObj(!0);
              }
            return this.parseIdent();
          }),
          (j.parseBindingList = function (t, e, i, s) {
            for (var r = [], a = !0; !this.eat(t); )
              if (
                (a ? (a = !1) : this.expect(f.comma),
                e && this.type === f.comma)
              )
                r.push(null);
              else {
                if (i && this.afterTrailingComma(t)) break;
                if (this.type === f.ellipsis) {
                  var n = this.parseRestBinding();
                  this.parseBindingListItem(n),
                    r.push(n),
                    this.type === f.comma &&
                      this.raiseRecoverable(
                        this.start,
                        "Comma is not permitted after the rest element"
                      ),
                    this.expect(t);
                  break;
                }
                r.push(this.parseAssignableListItem(s));
              }
            return r;
          }),
          (j.parseAssignableListItem = function (t) {
            var e = this.parseMaybeDefault(this.start, this.startLoc);
            return this.parseBindingListItem(e), e;
          }),
          (j.parseBindingListItem = function (t) {
            return t;
          }),
          (j.parseMaybeDefault = function (t, e, i) {
            if (
              ((i = i || this.parseBindingAtom()),
              this.options.ecmaVersion < 6 || !this.eat(f.eq))
            )
              return i;
            var s = this.startNodeAt(t, e);
            return (
              (s.left = i),
              (s.right = this.parseMaybeAssign()),
              this.finishNode(s, "AssignmentPattern")
            );
          }),
          (j.checkLValSimple = function (t, e, i) {
            void 0 === e && (e = 0);
            var s = 0 !== e;
            switch (t.type) {
              case "Identifier":
                this.strict &&
                  this.reservedWordsStrictBind.test(t.name) &&
                  this.raiseRecoverable(
                    t.start,
                    (s ? "Binding " : "Assigning to ") +
                      t.name +
                      " in strict mode"
                  ),
                  s &&
                    (2 === e &&
                      "let" === t.name &&
                      this.raiseRecoverable(
                        t.start,
                        "let is disallowed as a lexically bound name"
                      ),
                    i &&
                      (_(i, t.name) &&
                        this.raiseRecoverable(t.start, "Argument name clash"),
                      (i[t.name] = !0)),
                    5 !== e && this.declareName(t.name, e, t.start));
                break;
              case "ChainExpression":
                this.raiseRecoverable(
                  t.start,
                  "Optional chaining cannot appear in left-hand side"
                );
                break;
              case "MemberExpression":
                s &&
                  this.raiseRecoverable(t.start, "Binding member expression");
                break;
              case "ParenthesizedExpression":
                return (
                  s &&
                    this.raiseRecoverable(
                      t.start,
                      "Binding parenthesized expression"
                    ),
                  this.checkLValSimple(t.expression, e, i)
                );
              default:
                this.raise(
                  t.start,
                  (s ? "Binding" : "Assigning to") + " rvalue"
                );
            }
          }),
          (j.checkLValPattern = function (t, e, i) {
            switch ((void 0 === e && (e = 0), t.type)) {
              case "ObjectPattern":
                for (var s = 0, r = t.properties; s < r.length; s += 1) {
                  var a = r[s];
                  this.checkLValInnerPattern(a, e, i);
                }
                break;
              case "ArrayPattern":
                for (var n = 0, o = t.elements; n < o.length; n += 1) {
                  var h = o[n];
                  h && this.checkLValInnerPattern(h, e, i);
                }
                break;
              default:
                this.checkLValSimple(t, e, i);
            }
          }),
          (j.checkLValInnerPattern = function (t, e, i) {
            switch ((void 0 === e && (e = 0), t.type)) {
              case "Property":
                this.checkLValInnerPattern(t.value, e, i);
                break;
              case "AssignmentPattern":
                this.checkLValPattern(t.left, e, i);
                break;
              case "RestElement":
                this.checkLValPattern(t.argument, e, i);
                break;
              default:
                this.checkLValPattern(t, e, i);
            }
          });
        var G = function TokContext2(t, e, i, s, r) {
            (this.token = t),
              (this.isExpr = !!e),
              (this.preserveSpace = !!i),
              (this.override = s),
              (this.generator = !!r);
          },
          H = {
            b_stat: new G("{", !1),
            b_expr: new G("{", !0),
            b_tmpl: new G("${", !1),
            p_stat: new G("(", !1),
            p_expr: new G("(", !0),
            q_tmpl: new G("`", !0, !0, function (t) {
              return t.tryReadTemplateToken();
            }),
            f_stat: new G("function", !1),
            f_expr: new G("function", !0),
            f_expr_gen: new G("function", !0, !1, null, !0),
            f_gen: new G("function", !1, !1, null, !0),
          },
          W = T.prototype;
        (W.initialContext = function () {
          return [H.b_stat];
        }),
          (W.curContext = function () {
            return this.context[this.context.length - 1];
          }),
          (W.braceIsBlock = function (t) {
            var e = this.curContext();
            return (
              e === H.f_expr ||
              e === H.f_stat ||
              (t !== f.colon || (e !== H.b_stat && e !== H.b_expr)
                ? t === f._return || (t === f.name && this.exprAllowed)
                  ? m.test(this.input.slice(this.lastTokEnd, this.start))
                  : t === f._else ||
                    t === f.semi ||
                    t === f.eof ||
                    t === f.parenR ||
                    t === f.arrow ||
                    (t === f.braceL
                      ? e === H.b_stat
                      : t !== f._var &&
                        t !== f._const &&
                        t !== f.name &&
                        !this.exprAllowed)
                : !e.isExpr)
            );
          }),
          (W.inGeneratorContext = function () {
            for (var t = this.context.length - 1; t >= 1; t--) {
              var e = this.context[t];
              if ("function" === e.token) return e.generator;
            }
            return !1;
          }),
          (W.updateContext = function (t) {
            var e,
              i = this.type;
            i.keyword && t === f.dot
              ? (this.exprAllowed = !1)
              : (e = i.updateContext)
              ? e.call(this, t)
              : (this.exprAllowed = i.beforeExpr);
          }),
          (W.overrideContext = function (t) {
            this.curContext() !== t &&
              (this.context[this.context.length - 1] = t);
          }),
          (f.parenR.updateContext = f.braceR.updateContext =
            function () {
              if (1 !== this.context.length) {
                var t = this.context.pop();
                t === H.b_stat &&
                  "function" === this.curContext().token &&
                  (t = this.context.pop()),
                  (this.exprAllowed = !t.isExpr);
              } else this.exprAllowed = !0;
            }),
          (f.braceL.updateContext = function (t) {
            this.context.push(this.braceIsBlock(t) ? H.b_stat : H.b_expr),
              (this.exprAllowed = !0);
          }),
          (f.dollarBraceL.updateContext = function () {
            this.context.push(H.b_tmpl), (this.exprAllowed = !0);
          }),
          (f.parenL.updateContext = function (t) {
            var e =
              t === f._if || t === f._for || t === f._with || t === f._while;
            this.context.push(e ? H.p_stat : H.p_expr), (this.exprAllowed = !0);
          }),
          (f.incDec.updateContext = function () {}),
          (f._function.updateContext = f._class.updateContext =
            function (t) {
              !t.beforeExpr ||
              t === f._else ||
              (t === f.semi && this.curContext() !== H.p_stat) ||
              (t === f._return &&
                m.test(this.input.slice(this.lastTokEnd, this.start))) ||
              ((t === f.colon || t === f.braceL) &&
                this.curContext() === H.b_stat)
                ? this.context.push(H.f_stat)
                : this.context.push(H.f_expr),
                (this.exprAllowed = !1);
            }),
          (f.colon.updateContext = function () {
            "function" === this.curContext().token && this.context.pop(),
              (this.exprAllowed = !0);
          }),
          (f.backQuote.updateContext = function () {
            this.curContext() === H.q_tmpl
              ? this.context.pop()
              : this.context.push(H.q_tmpl),
              (this.exprAllowed = !1);
          }),
          (f.star.updateContext = function (t) {
            if (t === f._function) {
              var e = this.context.length - 1;
              this.context[e] === H.f_expr
                ? (this.context[e] = H.f_expr_gen)
                : (this.context[e] = H.f_gen);
            }
            this.exprAllowed = !0;
          }),
          (f.name.updateContext = function (t) {
            var e = !1;
            this.options.ecmaVersion >= 6 &&
              t !== f.dot &&
              (("of" === this.value && !this.exprAllowed) ||
                ("yield" === this.value && this.inGeneratorContext())) &&
              (e = !0),
              (this.exprAllowed = e);
          });
        var z = T.prototype;
        function isPrivateFieldAccess(t) {
          return (
            ("MemberExpression" === t.type &&
              "PrivateIdentifier" === t.property.type) ||
            ("ChainExpression" === t.type && isPrivateFieldAccess(t.expression))
          );
        }
        (z.checkPropClash = function (t, e, i) {
          if (
            !(
              (this.options.ecmaVersion >= 9 && "SpreadElement" === t.type) ||
              (this.options.ecmaVersion >= 6 &&
                (t.computed || t.method || t.shorthand))
            )
          ) {
            var s,
              r = t.key;
            switch (r.type) {
              case "Identifier":
                s = r.name;
                break;
              case "Literal":
                s = String(r.value);
                break;
              default:
                return;
            }
            var a = t.kind;
            if (this.options.ecmaVersion >= 6)
              "__proto__" === s &&
                "init" === a &&
                (e.proto &&
                  (i
                    ? i.doubleProto < 0 && (i.doubleProto = r.start)
                    : this.raiseRecoverable(
                        r.start,
                        "Redefinition of __proto__ property"
                      )),
                (e.proto = !0));
            else {
              var n = e[(s = "$" + s)];
              n
                ? ("init" === a
                    ? (this.strict && n.init) || n.get || n.set
                    : n.init || n[a]) &&
                  this.raiseRecoverable(r.start, "Redefinition of property")
                : (n = e[s] = { init: !1, get: !1, set: !1 }),
                (n[a] = !0);
            }
          }
        }),
          (z.parseExpression = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseMaybeAssign(t, e);
            if (this.type === f.comma) {
              var a = this.startNodeAt(i, s);
              for (a.expressions = [r]; this.eat(f.comma); )
                a.expressions.push(this.parseMaybeAssign(t, e));
              return this.finishNode(a, "SequenceExpression");
            }
            return r;
          }),
          (z.parseMaybeAssign = function (t, e, i) {
            if (this.isContextual("yield")) {
              if (this.inGenerator) return this.parseYield(t);
              this.exprAllowed = !1;
            }
            var s = !1,
              r = -1,
              a = -1,
              n = -1;
            e
              ? ((r = e.parenthesizedAssign),
                (a = e.trailingComma),
                (n = e.doubleProto),
                (e.parenthesizedAssign = e.trailingComma = -1))
              : ((e = new D()), (s = !0));
            var o = this.start,
              h = this.startLoc;
            (this.type !== f.parenL && this.type !== f.name) ||
              ((this.potentialArrowAt = this.start),
              (this.potentialArrowInForAwait = "await" === t));
            var p = this.parseMaybeConditional(t, e);
            if ((i && (p = i.call(this, p, o, h)), this.type.isAssign)) {
              var c = this.startNodeAt(o, h);
              return (
                (c.operator = this.value),
                this.type === f.eq && (p = this.toAssignable(p, !1, e)),
                s ||
                  (e.parenthesizedAssign =
                    e.trailingComma =
                    e.doubleProto =
                      -1),
                e.shorthandAssign >= p.start && (e.shorthandAssign = -1),
                this.type === f.eq
                  ? this.checkLValPattern(p)
                  : this.checkLValSimple(p),
                (c.left = p),
                this.next(),
                (c.right = this.parseMaybeAssign(t)),
                n > -1 && (e.doubleProto = n),
                this.finishNode(c, "AssignmentExpression")
              );
            }
            return (
              s && this.checkExpressionErrors(e, !0),
              r > -1 && (e.parenthesizedAssign = r),
              a > -1 && (e.trailingComma = a),
              p
            );
          }),
          (z.parseMaybeConditional = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseExprOps(t, e);
            if (this.checkExpressionErrors(e)) return r;
            if (this.eat(f.question)) {
              var a = this.startNodeAt(i, s);
              return (
                (a.test = r),
                (a.consequent = this.parseMaybeAssign()),
                this.expect(f.colon),
                (a.alternate = this.parseMaybeAssign(t)),
                this.finishNode(a, "ConditionalExpression")
              );
            }
            return r;
          }),
          (z.parseExprOps = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseMaybeUnary(e, !1, !1, t);
            return this.checkExpressionErrors(e) ||
              (r.start === i && "ArrowFunctionExpression" === r.type)
              ? r
              : this.parseExprOp(r, i, s, -1, t);
          }),
          (z.parseExprOp = function (t, e, i, s, r) {
            var a = this.type.binop;
            if (null != a && (!r || this.type !== f._in) && a > s) {
              var n = this.type === f.logicalOR || this.type === f.logicalAND,
                o = this.type === f.coalesce;
              o && (a = f.logicalAND.binop);
              var h = this.value;
              this.next();
              var p = this.start,
                c = this.startLoc,
                l = this.parseExprOp(
                  this.parseMaybeUnary(null, !1, !1, r),
                  p,
                  c,
                  a,
                  r
                ),
                u = this.buildBinary(e, i, t, l, h, n || o);
              return (
                ((n && this.type === f.coalesce) ||
                  (o &&
                    (this.type === f.logicalOR ||
                      this.type === f.logicalAND))) &&
                  this.raiseRecoverable(
                    this.start,
                    "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"
                  ),
                this.parseExprOp(u, e, i, s, r)
              );
            }
            return t;
          }),
          (z.buildBinary = function (t, e, i, s, r, a) {
            "PrivateIdentifier" === s.type &&
              this.raise(
                s.start,
                "Private identifier can only be left side of binary expression"
              );
            var n = this.startNodeAt(t, e);
            return (
              (n.left = i),
              (n.operator = r),
              (n.right = s),
              this.finishNode(n, a ? "LogicalExpression" : "BinaryExpression")
            );
          }),
          (z.parseMaybeUnary = function (t, e, i, s) {
            var r,
              a = this.start,
              n = this.startLoc;
            if (this.isContextual("await") && this.canAwait)
              (r = this.parseAwait(s)), (e = !0);
            else if (this.type.prefix) {
              var o = this.startNode(),
                h = this.type === f.incDec;
              (o.operator = this.value),
                (o.prefix = !0),
                this.next(),
                (o.argument = this.parseMaybeUnary(null, !0, h, s)),
                this.checkExpressionErrors(t, !0),
                h
                  ? this.checkLValSimple(o.argument)
                  : this.strict &&
                    "delete" === o.operator &&
                    "Identifier" === o.argument.type
                  ? this.raiseRecoverable(
                      o.start,
                      "Deleting local variable in strict mode"
                    )
                  : "delete" === o.operator && isPrivateFieldAccess(o.argument)
                  ? this.raiseRecoverable(
                      o.start,
                      "Private fields can not be deleted"
                    )
                  : (e = !0),
                (r = this.finishNode(
                  o,
                  h ? "UpdateExpression" : "UnaryExpression"
                ));
            } else if (e || this.type !== f.privateId) {
              if (
                ((r = this.parseExprSubscripts(t, s)),
                this.checkExpressionErrors(t))
              )
                return r;
              for (; this.type.postfix && !this.canInsertSemicolon(); ) {
                var p = this.startNodeAt(a, n);
                (p.operator = this.value),
                  (p.prefix = !1),
                  (p.argument = r),
                  this.checkLValSimple(r),
                  this.next(),
                  (r = this.finishNode(p, "UpdateExpression"));
              }
            } else
              (s || 0 === this.privateNameStack.length) &&
                this.options.checkPrivateFields &&
                this.unexpected(),
                (r = this.parsePrivateIdent()),
                this.type !== f._in && this.unexpected();
            return i || !this.eat(f.starstar)
              ? r
              : e
              ? void this.unexpected(this.lastTokStart)
              : this.buildBinary(
                  a,
                  n,
                  r,
                  this.parseMaybeUnary(null, !1, !1, s),
                  "**",
                  !1
                );
          }),
          (z.parseExprSubscripts = function (t, e) {
            var i = this.start,
              s = this.startLoc,
              r = this.parseExprAtom(t, e);
            if (
              "ArrowFunctionExpression" === r.type &&
              ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)
            )
              return r;
            var a = this.parseSubscripts(r, i, s, !1, e);
            return (
              t &&
                "MemberExpression" === a.type &&
                (t.parenthesizedAssign >= a.start &&
                  (t.parenthesizedAssign = -1),
                t.parenthesizedBind >= a.start && (t.parenthesizedBind = -1),
                t.trailingComma >= a.start && (t.trailingComma = -1)),
              a
            );
          }),
          (z.parseSubscripts = function (t, e, i, s, r) {
            for (
              var a =
                  this.options.ecmaVersion >= 8 &&
                  "Identifier" === t.type &&
                  "async" === t.name &&
                  this.lastTokEnd === t.end &&
                  !this.canInsertSemicolon() &&
                  t.end - t.start == 5 &&
                  this.potentialArrowAt === t.start,
                n = !1;
              ;

            ) {
              var o = this.parseSubscript(t, e, i, s, a, n, r);
              if (
                (o.optional && (n = !0),
                o === t || "ArrowFunctionExpression" === o.type)
              ) {
                if (n) {
                  var h = this.startNodeAt(e, i);
                  (h.expression = o),
                    (o = this.finishNode(h, "ChainExpression"));
                }
                return o;
              }
              t = o;
            }
          }),
          (z.shouldParseAsyncArrow = function () {
            return !this.canInsertSemicolon() && this.eat(f.arrow);
          }),
          (z.parseSubscriptAsyncArrow = function (t, e, i, s) {
            return this.parseArrowExpression(this.startNodeAt(t, e), i, !0, s);
          }),
          (z.parseSubscript = function (t, e, i, s, r, a, n) {
            var o = this.options.ecmaVersion >= 11,
              h = o && this.eat(f.questionDot);
            s &&
              h &&
              this.raise(
                this.lastTokStart,
                "Optional chaining cannot appear in the callee of new expressions"
              );
            var p = this.eat(f.bracketL);
            if (
              p ||
              (h && this.type !== f.parenL && this.type !== f.backQuote) ||
              this.eat(f.dot)
            ) {
              var c = this.startNodeAt(e, i);
              (c.object = t),
                p
                  ? ((c.property = this.parseExpression()),
                    this.expect(f.bracketR))
                  : this.type === f.privateId && "Super" !== t.type
                  ? (c.property = this.parsePrivateIdent())
                  : (c.property = this.parseIdent(
                      "never" !== this.options.allowReserved
                    )),
                (c.computed = !!p),
                o && (c.optional = h),
                (t = this.finishNode(c, "MemberExpression"));
            } else if (!s && this.eat(f.parenL)) {
              var l = new D(),
                u = this.yieldPos,
                d = this.awaitPos,
                m = this.awaitIdentPos;
              (this.yieldPos = 0),
                (this.awaitPos = 0),
                (this.awaitIdentPos = 0);
              var g = this.parseExprList(
                f.parenR,
                this.options.ecmaVersion >= 8,
                !1,
                l
              );
              if (r && !h && this.shouldParseAsyncArrow())
                return (
                  this.checkPatternErrors(l, !1),
                  this.checkYieldAwaitInDefaultParams(),
                  this.awaitIdentPos > 0 &&
                    this.raise(
                      this.awaitIdentPos,
                      "Cannot use 'await' as identifier inside an async function"
                    ),
                  (this.yieldPos = u),
                  (this.awaitPos = d),
                  (this.awaitIdentPos = m),
                  this.parseSubscriptAsyncArrow(e, i, g, n)
                );
              this.checkExpressionErrors(l, !0),
                (this.yieldPos = u || this.yieldPos),
                (this.awaitPos = d || this.awaitPos),
                (this.awaitIdentPos = m || this.awaitIdentPos);
              var x = this.startNodeAt(e, i);
              (x.callee = t),
                (x.arguments = g),
                o && (x.optional = h),
                (t = this.finishNode(x, "CallExpression"));
            } else if (this.type === f.backQuote) {
              (h || a) &&
                this.raise(
                  this.start,
                  "Optional chaining cannot appear in the tag of tagged template expressions"
                );
              var v = this.startNodeAt(e, i);
              (v.tag = t),
                (v.quasi = this.parseTemplate({ isTagged: !0 })),
                (t = this.finishNode(v, "TaggedTemplateExpression"));
            }
            return t;
          }),
          (z.parseExprAtom = function (t, e, i) {
            this.type === f.slash && this.readRegexp();
            var s,
              r = this.potentialArrowAt === this.start;
            switch (this.type) {
              case f._super:
                return (
                  this.allowSuper ||
                    this.raise(this.start, "'super' keyword outside a method"),
                  (s = this.startNode()),
                  this.next(),
                  this.type !== f.parenL ||
                    this.allowDirectSuper ||
                    this.raise(
                      s.start,
                      "super() call outside constructor of a subclass"
                    ),
                  this.type !== f.dot &&
                    this.type !== f.bracketL &&
                    this.type !== f.parenL &&
                    this.unexpected(),
                  this.finishNode(s, "Super")
                );
              case f._this:
                return (
                  (s = this.startNode()),
                  this.next(),
                  this.finishNode(s, "ThisExpression")
                );
              case f.name:
                var a = this.start,
                  n = this.startLoc,
                  o = this.containsEsc,
                  h = this.parseIdent(!1);
                if (
                  this.options.ecmaVersion >= 8 &&
                  !o &&
                  "async" === h.name &&
                  !this.canInsertSemicolon() &&
                  this.eat(f._function)
                )
                  return (
                    this.overrideContext(H.f_expr),
                    this.parseFunction(this.startNodeAt(a, n), 0, !1, !0, e)
                  );
                if (r && !this.canInsertSemicolon()) {
                  if (this.eat(f.arrow))
                    return this.parseArrowExpression(
                      this.startNodeAt(a, n),
                      [h],
                      !1,
                      e
                    );
                  if (
                    this.options.ecmaVersion >= 8 &&
                    "async" === h.name &&
                    this.type === f.name &&
                    !o &&
                    (!this.potentialArrowInForAwait ||
                      "of" !== this.value ||
                      this.containsEsc)
                  )
                    return (
                      (h = this.parseIdent(!1)),
                      (!this.canInsertSemicolon() && this.eat(f.arrow)) ||
                        this.unexpected(),
                      this.parseArrowExpression(
                        this.startNodeAt(a, n),
                        [h],
                        !0,
                        e
                      )
                    );
                }
                return h;
              case f.regexp:
                var p = this.value;
                return (
                  ((s = this.parseLiteral(p.value)).regex = {
                    pattern: p.pattern,
                    flags: p.flags,
                  }),
                  s
                );
              case f.num:
              case f.string:
                return this.parseLiteral(this.value);
              case f._null:
              case f._true:
              case f._false:
                return (
                  ((s = this.startNode()).value =
                    this.type === f._null ? null : this.type === f._true),
                  (s.raw = this.type.keyword),
                  this.next(),
                  this.finishNode(s, "Literal")
                );
              case f.parenL:
                var c = this.start,
                  l = this.parseParenAndDistinguishExpression(r, e);
                return (
                  t &&
                    (t.parenthesizedAssign < 0 &&
                      !this.isSimpleAssignTarget(l) &&
                      (t.parenthesizedAssign = c),
                    t.parenthesizedBind < 0 && (t.parenthesizedBind = c)),
                  l
                );
              case f.bracketL:
                return (
                  (s = this.startNode()),
                  this.next(),
                  (s.elements = this.parseExprList(f.bracketR, !0, !0, t)),
                  this.finishNode(s, "ArrayExpression")
                );
              case f.braceL:
                return this.overrideContext(H.b_expr), this.parseObj(!1, t);
              case f._function:
                return (
                  (s = this.startNode()), this.next(), this.parseFunction(s, 0)
                );
              case f._class:
                return this.parseClass(this.startNode(), !1);
              case f._new:
                return this.parseNew();
              case f.backQuote:
                return this.parseTemplate();
              case f._import:
                return this.options.ecmaVersion >= 11
                  ? this.parseExprImport(i)
                  : this.unexpected();
              default:
                return this.parseExprAtomDefault();
            }
          }),
          (z.parseExprAtomDefault = function () {
            this.unexpected();
          }),
          (z.parseExprImport = function (t) {
            var e = this.startNode();
            if (
              (this.containsEsc &&
                this.raiseRecoverable(
                  this.start,
                  "Escape sequence in keyword import"
                ),
              this.next(),
              this.type === f.parenL && !t)
            )
              return this.parseDynamicImport(e);
            if (this.type === f.dot) {
              var i = this.startNodeAt(e.start, e.loc && e.loc.start);
              return (
                (i.name = "import"),
                (e.meta = this.finishNode(i, "Identifier")),
                this.parseImportMeta(e)
              );
            }
            this.unexpected();
          }),
          (z.parseDynamicImport = function (t) {
            if (
              (this.next(),
              (t.source = this.parseMaybeAssign()),
              !this.eat(f.parenR))
            ) {
              var e = this.start;
              this.eat(f.comma) && this.eat(f.parenR)
                ? this.raiseRecoverable(
                    e,
                    "Trailing comma is not allowed in import()"
                  )
                : this.unexpected(e);
            }
            return this.finishNode(t, "ImportExpression");
          }),
          (z.parseImportMeta = function (t) {
            this.next();
            var e = this.containsEsc;
            return (
              (t.property = this.parseIdent(!0)),
              "meta" !== t.property.name &&
                this.raiseRecoverable(
                  t.property.start,
                  "The only valid meta property for import is 'import.meta'"
                ),
              e &&
                this.raiseRecoverable(
                  t.start,
                  "'import.meta' must not contain escaped characters"
                ),
              "module" === this.options.sourceType ||
                this.options.allowImportExportEverywhere ||
                this.raiseRecoverable(
                  t.start,
                  "Cannot use 'import.meta' outside a module"
                ),
              this.finishNode(t, "MetaProperty")
            );
          }),
          (z.parseLiteral = function (t) {
            var e = this.startNode();
            return (
              (e.value = t),
              (e.raw = this.input.slice(this.start, this.end)),
              110 === e.raw.charCodeAt(e.raw.length - 1) &&
                (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")),
              this.next(),
              this.finishNode(e, "Literal")
            );
          }),
          (z.parseParenExpression = function () {
            this.expect(f.parenL);
            var t = this.parseExpression();
            return this.expect(f.parenR), t;
          }),
          (z.shouldParseArrow = function (t) {
            return !this.canInsertSemicolon();
          }),
          (z.parseParenAndDistinguishExpression = function (t, e) {
            var i,
              s = this.start,
              r = this.startLoc,
              a = this.options.ecmaVersion >= 8;
            if (this.options.ecmaVersion >= 6) {
              this.next();
              var n,
                o = this.start,
                h = this.startLoc,
                p = [],
                c = !0,
                l = !1,
                u = new D(),
                d = this.yieldPos,
                m = this.awaitPos;
              for (
                this.yieldPos = 0, this.awaitPos = 0;
                this.type !== f.parenR;

              ) {
                if (
                  (c ? (c = !1) : this.expect(f.comma),
                  a && this.afterTrailingComma(f.parenR, !0))
                ) {
                  l = !0;
                  break;
                }
                if (this.type === f.ellipsis) {
                  (n = this.start),
                    p.push(this.parseParenItem(this.parseRestBinding())),
                    this.type === f.comma &&
                      this.raiseRecoverable(
                        this.start,
                        "Comma is not permitted after the rest element"
                      );
                  break;
                }
                p.push(this.parseMaybeAssign(!1, u, this.parseParenItem));
              }
              var g = this.lastTokEnd,
                x = this.lastTokEndLoc;
              if (
                (this.expect(f.parenR),
                t && this.shouldParseArrow(p) && this.eat(f.arrow))
              )
                return (
                  this.checkPatternErrors(u, !1),
                  this.checkYieldAwaitInDefaultParams(),
                  (this.yieldPos = d),
                  (this.awaitPos = m),
                  this.parseParenArrowList(s, r, p, e)
                );
              (p.length && !l) || this.unexpected(this.lastTokStart),
                n && this.unexpected(n),
                this.checkExpressionErrors(u, !0),
                (this.yieldPos = d || this.yieldPos),
                (this.awaitPos = m || this.awaitPos),
                p.length > 1
                  ? (((i = this.startNodeAt(o, h)).expressions = p),
                    this.finishNodeAt(i, "SequenceExpression", g, x))
                  : (i = p[0]);
            } else i = this.parseParenExpression();
            if (this.options.preserveParens) {
              var v = this.startNodeAt(s, r);
              return (
                (v.expression = i),
                this.finishNode(v, "ParenthesizedExpression")
              );
            }
            return i;
          }),
          (z.parseParenItem = function (t) {
            return t;
          }),
          (z.parseParenArrowList = function (t, e, i, s) {
            return this.parseArrowExpression(this.startNodeAt(t, e), i, !1, s);
          });
        var K = [];
        (z.parseNew = function () {
          this.containsEsc &&
            this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var t = this.startNode();
          if (
            (this.next(), this.options.ecmaVersion >= 6 && this.type === f.dot)
          ) {
            var e = this.startNodeAt(t.start, t.loc && t.loc.start);
            (e.name = "new"),
              (t.meta = this.finishNode(e, "Identifier")),
              this.next();
            var i = this.containsEsc;
            return (
              (t.property = this.parseIdent(!0)),
              "target" !== t.property.name &&
                this.raiseRecoverable(
                  t.property.start,
                  "The only valid meta property for new is 'new.target'"
                ),
              i &&
                this.raiseRecoverable(
                  t.start,
                  "'new.target' must not contain escaped characters"
                ),
              this.allowNewDotTarget ||
                this.raiseRecoverable(
                  t.start,
                  "'new.target' can only be used in functions and class static block"
                ),
              this.finishNode(t, "MetaProperty")
            );
          }
          var s = this.start,
            r = this.startLoc;
          return (
            (t.callee = this.parseSubscripts(
              this.parseExprAtom(null, !1, !0),
              s,
              r,
              !0,
              !1
            )),
            this.eat(f.parenL)
              ? (t.arguments = this.parseExprList(
                  f.parenR,
                  this.options.ecmaVersion >= 8,
                  !1
                ))
              : (t.arguments = K),
            this.finishNode(t, "NewExpression")
          );
        }),
          (z.parseTemplateElement = function (t) {
            var e = t.isTagged,
              i = this.startNode();
            return (
              this.type === f.invalidTemplate
                ? (e ||
                    this.raiseRecoverable(
                      this.start,
                      "Bad escape sequence in untagged template literal"
                    ),
                  (i.value = { raw: this.value, cooked: null }))
                : (i.value = {
                    raw: this.input
                      .slice(this.start, this.end)
                      .replace(/\r\n?/g, "\n"),
                    cooked: this.value,
                  }),
              this.next(),
              (i.tail = this.type === f.backQuote),
              this.finishNode(i, "TemplateElement")
            );
          }),
          (z.parseTemplate = function (t) {
            void 0 === t && (t = {});
            var e = t.isTagged;
            void 0 === e && (e = !1);
            var i = this.startNode();
            this.next(), (i.expressions = []);
            var s = this.parseTemplateElement({ isTagged: e });
            for (i.quasis = [s]; !s.tail; )
              this.type === f.eof &&
                this.raise(this.pos, "Unterminated template literal"),
                this.expect(f.dollarBraceL),
                i.expressions.push(this.parseExpression()),
                this.expect(f.braceR),
                i.quasis.push((s = this.parseTemplateElement({ isTagged: e })));
            return this.next(), this.finishNode(i, "TemplateLiteral");
          }),
          (z.isAsyncProp = function (t) {
            return (
              !t.computed &&
              "Identifier" === t.key.type &&
              "async" === t.key.name &&
              (this.type === f.name ||
                this.type === f.num ||
                this.type === f.string ||
                this.type === f.bracketL ||
                this.type.keyword ||
                (this.options.ecmaVersion >= 9 && this.type === f.star)) &&
              !m.test(this.input.slice(this.lastTokEnd, this.start))
            );
          }),
          (z.parseObj = function (t, e) {
            var i = this.startNode(),
              s = !0,
              r = {};
            for (i.properties = [], this.next(); !this.eat(f.braceR); ) {
              if (s) s = !1;
              else if (
                (this.expect(f.comma),
                this.options.ecmaVersion >= 5 &&
                  this.afterTrailingComma(f.braceR))
              )
                break;
              var a = this.parseProperty(t, e);
              t || this.checkPropClash(a, r, e), i.properties.push(a);
            }
            return this.finishNode(i, t ? "ObjectPattern" : "ObjectExpression");
          }),
          (z.parseProperty = function (t, e) {
            var i,
              s,
              r,
              a,
              n = this.startNode();
            if (this.options.ecmaVersion >= 9 && this.eat(f.ellipsis))
              return t
                ? ((n.argument = this.parseIdent(!1)),
                  this.type === f.comma &&
                    this.raiseRecoverable(
                      this.start,
                      "Comma is not permitted after the rest element"
                    ),
                  this.finishNode(n, "RestElement"))
                : ((n.argument = this.parseMaybeAssign(!1, e)),
                  this.type === f.comma &&
                    e &&
                    e.trailingComma < 0 &&
                    (e.trailingComma = this.start),
                  this.finishNode(n, "SpreadElement"));
            this.options.ecmaVersion >= 6 &&
              ((n.method = !1),
              (n.shorthand = !1),
              (t || e) && ((r = this.start), (a = this.startLoc)),
              t || (i = this.eat(f.star)));
            var o = this.containsEsc;
            return (
              this.parsePropertyName(n),
              !t &&
              !o &&
              this.options.ecmaVersion >= 8 &&
              !i &&
              this.isAsyncProp(n)
                ? ((s = !0),
                  (i = this.options.ecmaVersion >= 9 && this.eat(f.star)),
                  this.parsePropertyName(n))
                : (s = !1),
              this.parsePropertyValue(n, t, i, s, r, a, e, o),
              this.finishNode(n, "Property")
            );
          }),
          (z.parseGetterSetter = function (t) {
            (t.kind = t.key.name),
              this.parsePropertyName(t),
              (t.value = this.parseMethod(!1));
            var e = "get" === t.kind ? 0 : 1;
            if (t.value.params.length !== e) {
              var i = t.value.start;
              "get" === t.kind
                ? this.raiseRecoverable(i, "getter should have no params")
                : this.raiseRecoverable(
                    i,
                    "setter should have exactly one param"
                  );
            } else
              "set" === t.kind &&
                "RestElement" === t.value.params[0].type &&
                this.raiseRecoverable(
                  t.value.params[0].start,
                  "Setter cannot use rest params"
                );
          }),
          (z.parsePropertyValue = function (t, e, i, s, r, a, n, o) {
            (i || s) && this.type === f.colon && this.unexpected(),
              this.eat(f.colon)
                ? ((t.value = e
                    ? this.parseMaybeDefault(this.start, this.startLoc)
                    : this.parseMaybeAssign(!1, n)),
                  (t.kind = "init"))
                : this.options.ecmaVersion >= 6 && this.type === f.parenL
                ? (e && this.unexpected(),
                  (t.kind = "init"),
                  (t.method = !0),
                  (t.value = this.parseMethod(i, s)))
                : e ||
                  o ||
                  !(this.options.ecmaVersion >= 5) ||
                  t.computed ||
                  "Identifier" !== t.key.type ||
                  ("get" !== t.key.name && "set" !== t.key.name) ||
                  this.type === f.comma ||
                  this.type === f.braceR ||
                  this.type === f.eq
                ? this.options.ecmaVersion >= 6 &&
                  !t.computed &&
                  "Identifier" === t.key.type
                  ? ((i || s) && this.unexpected(),
                    this.checkUnreserved(t.key),
                    "await" !== t.key.name ||
                      this.awaitIdentPos ||
                      (this.awaitIdentPos = r),
                    (t.kind = "init"),
                    e
                      ? (t.value = this.parseMaybeDefault(
                          r,
                          a,
                          this.copyNode(t.key)
                        ))
                      : this.type === f.eq && n
                      ? (n.shorthandAssign < 0 &&
                          (n.shorthandAssign = this.start),
                        (t.value = this.parseMaybeDefault(
                          r,
                          a,
                          this.copyNode(t.key)
                        )))
                      : (t.value = this.copyNode(t.key)),
                    (t.shorthand = !0))
                  : this.unexpected()
                : ((i || s) && this.unexpected(), this.parseGetterSetter(t));
          }),
          (z.parsePropertyName = function (t) {
            if (this.options.ecmaVersion >= 6) {
              if (this.eat(f.bracketL))
                return (
                  (t.computed = !0),
                  (t.key = this.parseMaybeAssign()),
                  this.expect(f.bracketR),
                  t.key
                );
              t.computed = !1;
            }
            return (t.key =
              this.type === f.num || this.type === f.string
                ? this.parseExprAtom()
                : this.parseIdent("never" !== this.options.allowReserved));
          }),
          (z.initFunction = function (t) {
            (t.id = null),
              this.options.ecmaVersion >= 6 &&
                (t.generator = t.expression = !1),
              this.options.ecmaVersion >= 8 && (t.async = !1);
          }),
          (z.parseMethod = function (t, e, i) {
            var s = this.startNode(),
              r = this.yieldPos,
              a = this.awaitPos,
              n = this.awaitIdentPos;
            return (
              this.initFunction(s),
              this.options.ecmaVersion >= 6 && (s.generator = t),
              this.options.ecmaVersion >= 8 && (s.async = !!e),
              (this.yieldPos = 0),
              (this.awaitPos = 0),
              (this.awaitIdentPos = 0),
              this.enterScope(
                64 | functionFlags(e, s.generator) | (i ? 128 : 0)
              ),
              this.expect(f.parenL),
              (s.params = this.parseBindingList(
                f.parenR,
                !1,
                this.options.ecmaVersion >= 8
              )),
              this.checkYieldAwaitInDefaultParams(),
              this.parseFunctionBody(s, !1, !0, !1),
              (this.yieldPos = r),
              (this.awaitPos = a),
              (this.awaitIdentPos = n),
              this.finishNode(s, "FunctionExpression")
            );
          }),
          (z.parseArrowExpression = function (t, e, i, s) {
            var r = this.yieldPos,
              a = this.awaitPos,
              n = this.awaitIdentPos;
            return (
              this.enterScope(16 | functionFlags(i, !1)),
              this.initFunction(t),
              this.options.ecmaVersion >= 8 && (t.async = !!i),
              (this.yieldPos = 0),
              (this.awaitPos = 0),
              (this.awaitIdentPos = 0),
              (t.params = this.toAssignableList(e, !0)),
              this.parseFunctionBody(t, !0, !1, s),
              (this.yieldPos = r),
              (this.awaitPos = a),
              (this.awaitIdentPos = n),
              this.finishNode(t, "ArrowFunctionExpression")
            );
          }),
          (z.parseFunctionBody = function (t, e, i, s) {
            var r = e && this.type !== f.braceL,
              a = this.strict,
              n = !1;
            if (r)
              (t.body = this.parseMaybeAssign(s)),
                (t.expression = !0),
                this.checkParams(t, !1);
            else {
              var o =
                this.options.ecmaVersion >= 7 &&
                !this.isSimpleParamList(t.params);
              (a && !o) ||
                ((n = this.strictDirective(this.end)) &&
                  o &&
                  this.raiseRecoverable(
                    t.start,
                    "Illegal 'use strict' directive in function with non-simple parameter list"
                  ));
              var h = this.labels;
              (this.labels = []),
                n && (this.strict = !0),
                this.checkParams(
                  t,
                  !a && !n && !e && !i && this.isSimpleParamList(t.params)
                ),
                this.strict && t.id && this.checkLValSimple(t.id, 5),
                (t.body = this.parseBlock(!1, void 0, n && !a)),
                (t.expression = !1),
                this.adaptDirectivePrologue(t.body.body),
                (this.labels = h);
            }
            this.exitScope();
          }),
          (z.isSimpleParamList = function (t) {
            for (var e = 0, i = t; e < i.length; e += 1)
              if ("Identifier" !== i[e].type) return !1;
            return !0;
          }),
          (z.checkParams = function (t, e) {
            for (
              var i = Object.create(null), s = 0, r = t.params;
              s < r.length;
              s += 1
            ) {
              var a = r[s];
              this.checkLValInnerPattern(a, 1, e ? null : i);
            }
          }),
          (z.parseExprList = function (t, e, i, s) {
            for (var r = [], a = !0; !this.eat(t); ) {
              if (a) a = !1;
              else if ((this.expect(f.comma), e && this.afterTrailingComma(t)))
                break;
              var n = void 0;
              i && this.type === f.comma
                ? (n = null)
                : this.type === f.ellipsis
                ? ((n = this.parseSpread(s)),
                  s &&
                    this.type === f.comma &&
                    s.trailingComma < 0 &&
                    (s.trailingComma = this.start))
                : (n = this.parseMaybeAssign(!1, s)),
                r.push(n);
            }
            return r;
          }),
          (z.checkUnreserved = function (t) {
            var e = t.start,
              i = t.end,
              s = t.name;
            this.inGenerator &&
              "yield" === s &&
              this.raiseRecoverable(
                e,
                "Cannot use 'yield' as identifier inside a generator"
              ),
              this.inAsync &&
                "await" === s &&
                this.raiseRecoverable(
                  e,
                  "Cannot use 'await' as identifier inside an async function"
                ),
              this.currentThisScope().inClassFieldInit &&
                "arguments" === s &&
                this.raiseRecoverable(
                  e,
                  "Cannot use 'arguments' in class field initializer"
                ),
              !this.inClassStaticBlock ||
                ("arguments" !== s && "await" !== s) ||
                this.raise(
                  e,
                  "Cannot use " + s + " in class static initialization block"
                ),
              this.keywords.test(s) &&
                this.raise(e, "Unexpected keyword '" + s + "'"),
              (this.options.ecmaVersion < 6 &&
                -1 !== this.input.slice(e, i).indexOf("\\")) ||
                ((this.strict
                  ? this.reservedWordsStrict
                  : this.reservedWords
                ).test(s) &&
                  (this.inAsync ||
                    "await" !== s ||
                    this.raiseRecoverable(
                      e,
                      "Cannot use keyword 'await' outside an async function"
                    ),
                  this.raiseRecoverable(
                    e,
                    "The keyword '" + s + "' is reserved"
                  )));
          }),
          (z.parseIdent = function (t) {
            var e = this.parseIdentNode();
            return (
              this.next(!!t),
              this.finishNode(e, "Identifier"),
              t ||
                (this.checkUnreserved(e),
                "await" !== e.name ||
                  this.awaitIdentPos ||
                  (this.awaitIdentPos = e.start)),
              e
            );
          }),
          (z.parseIdentNode = function () {
            var t = this.startNode();
            return (
              this.type === f.name
                ? (t.name = this.value)
                : this.type.keyword
                ? ((t.name = this.type.keyword),
                  ("class" !== t.name && "function" !== t.name) ||
                    (this.lastTokEnd === this.lastTokStart + 1 &&
                      46 === this.input.charCodeAt(this.lastTokStart)) ||
                    this.context.pop(),
                  (this.type = f.name))
                : this.unexpected(),
              t
            );
          }),
          (z.parsePrivateIdent = function () {
            var t = this.startNode();
            return (
              this.type === f.privateId
                ? (t.name = this.value)
                : this.unexpected(),
              this.next(),
              this.finishNode(t, "PrivateIdentifier"),
              this.options.checkPrivateFields &&
                (0 === this.privateNameStack.length
                  ? this.raise(
                      t.start,
                      "Private field '#" +
                        t.name +
                        "' must be declared in an enclosing class"
                    )
                  : this.privateNameStack[
                      this.privateNameStack.length - 1
                    ].used.push(t)),
              t
            );
          }),
          (z.parseYield = function (t) {
            this.yieldPos || (this.yieldPos = this.start);
            var e = this.startNode();
            return (
              this.next(),
              this.type === f.semi ||
              this.canInsertSemicolon() ||
              (this.type !== f.star && !this.type.startsExpr)
                ? ((e.delegate = !1), (e.argument = null))
                : ((e.delegate = this.eat(f.star)),
                  (e.argument = this.parseMaybeAssign(t))),
              this.finishNode(e, "YieldExpression")
            );
          }),
          (z.parseAwait = function (t) {
            this.awaitPos || (this.awaitPos = this.start);
            var e = this.startNode();
            return (
              this.next(),
              (e.argument = this.parseMaybeUnary(null, !0, !1, t)),
              this.finishNode(e, "AwaitExpression")
            );
          });
        var Q = T.prototype;
        (Q.raise = function (t, e) {
          var i = getLineInfo(this.input, t);
          e += " (" + i.line + ":" + i.column + ")";
          var s = new SyntaxError(e);
          throw ((s.pos = t), (s.loc = i), (s.raisedAt = this.pos), s);
        }),
          (Q.raiseRecoverable = Q.raise),
          (Q.curPosition = function () {
            if (this.options.locations)
              return new E(this.curLine, this.pos - this.lineStart);
          });
        var Y = T.prototype,
          X = function Scope2(t) {
            (this.flags = t),
              (this.var = []),
              (this.lexical = []),
              (this.functions = []),
              (this.inClassFieldInit = !1);
          };
        (Y.enterScope = function (t) {
          this.scopeStack.push(new X(t));
        }),
          (Y.exitScope = function () {
            this.scopeStack.pop();
          }),
          (Y.treatFunctionsAsVarInScope = function (t) {
            return 2 & t.flags || (!this.inModule && 1 & t.flags);
          }),
          (Y.declareName = function (t, e, i) {
            var s = !1;
            if (2 === e) {
              var r = this.currentScope();
              (s =
                r.lexical.indexOf(t) > -1 ||
                r.functions.indexOf(t) > -1 ||
                r.var.indexOf(t) > -1),
                r.lexical.push(t),
                this.inModule && 1 & r.flags && delete this.undefinedExports[t];
            } else if (4 === e) this.currentScope().lexical.push(t);
            else if (3 === e) {
              var a = this.currentScope();
              (s = this.treatFunctionsAsVar
                ? a.lexical.indexOf(t) > -1
                : a.lexical.indexOf(t) > -1 || a.var.indexOf(t) > -1),
                a.functions.push(t);
            } else
              for (var n = this.scopeStack.length - 1; n >= 0; --n) {
                var o = this.scopeStack[n];
                if (
                  (o.lexical.indexOf(t) > -1 &&
                    !(32 & o.flags && o.lexical[0] === t)) ||
                  (!this.treatFunctionsAsVarInScope(o) &&
                    o.functions.indexOf(t) > -1)
                ) {
                  s = !0;
                  break;
                }
                if (
                  (o.var.push(t),
                  this.inModule &&
                    1 & o.flags &&
                    delete this.undefinedExports[t],
                  259 & o.flags)
                )
                  break;
              }
            s &&
              this.raiseRecoverable(
                i,
                "Identifier '" + t + "' has already been declared"
              );
          }),
          (Y.checkLocalExport = function (t) {
            -1 === this.scopeStack[0].lexical.indexOf(t.name) &&
              -1 === this.scopeStack[0].var.indexOf(t.name) &&
              (this.undefinedExports[t.name] = t);
          }),
          (Y.currentScope = function () {
            return this.scopeStack[this.scopeStack.length - 1];
          }),
          (Y.currentVarScope = function () {
            for (var t = this.scopeStack.length - 1; ; t--) {
              var e = this.scopeStack[t];
              if (259 & e.flags) return e;
            }
          }),
          (Y.currentThisScope = function () {
            for (var t = this.scopeStack.length - 1; ; t--) {
              var e = this.scopeStack[t];
              if (259 & e.flags && !(16 & e.flags)) return e;
            }
          });
        var Z = function Node2(t, e, i) {
            (this.type = ""),
              (this.start = e),
              (this.end = 0),
              t.options.locations && (this.loc = new I(t, i)),
              t.options.directSourceFile &&
                (this.sourceFile = t.options.directSourceFile),
              t.options.ranges && (this.range = [e, 0]);
          },
          $ = T.prototype;
        function finishNodeAt(t, e, i, s) {
          return (
            (t.type = e),
            (t.end = i),
            this.options.locations && (t.loc.end = s),
            this.options.ranges && (t.range[1] = i),
            t
          );
        }
        ($.startNode = function () {
          return new Z(this, this.start, this.startLoc);
        }),
          ($.startNodeAt = function (t, e) {
            return new Z(this, t, e);
          }),
          ($.finishNode = function (t, e) {
            return finishNodeAt.call(
              this,
              t,
              e,
              this.lastTokEnd,
              this.lastTokEndLoc
            );
          }),
          ($.finishNodeAt = function (t, e, i, s) {
            return finishNodeAt.call(this, t, e, i, s);
          }),
          ($.copyNode = function (t) {
            var e = new Z(this, t.start, this.startLoc);
            for (var i in t) e[i] = t[i];
            return e;
          });
        for (
          var J,
            tt,
            et =
              "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
            it = et + " Extended_Pictographic",
            st = it + " EBase EComp EMod EPres ExtPict",
            rt = { 9: et, 10: it, 11: it, 12: st, 13: st, 14: st },
            nt = {
              9: "",
              10: "",
              11: "",
              12: "",
              13: "",
              14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji",
            },
            ot =
              "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
            ht =
              "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
            pt =
              ht +
              " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
            ct =
              pt +
              " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",
            lt =
              ct +
              " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",
            ut =
              lt +
              " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",
            dt = {
              9: ht,
              10: pt,
              11: ct,
              12: lt,
              13: ut,
              14:
                ut +
                " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz",
            },
            ft = {},
            mt = 0,
            gt = [9, 10, 11, 12, 13, 14];
          mt < gt.length;
          mt += 1
        )
          (tt = void 0),
            ((tt = ft[(J = gt[mt])] =
              {
                binary: wordsRegexp(rt[J] + " " + ot),
                binaryOfStrings: wordsRegexp(nt[J]),
                nonBinary: {
                  General_Category: wordsRegexp(ot),
                  Script: wordsRegexp(dt[J]),
                },
              }).nonBinary.Script_Extensions = tt.nonBinary.Script),
            (tt.nonBinary.gc = tt.nonBinary.General_Category),
            (tt.nonBinary.sc = tt.nonBinary.Script),
            (tt.nonBinary.scx = tt.nonBinary.Script_Extensions);
        var xt = T.prototype,
          vt = function RegExpValidationState2(t) {
            (this.parser = t),
              (this.validFlags =
                "gim" +
                (t.options.ecmaVersion >= 6 ? "uy" : "") +
                (t.options.ecmaVersion >= 9 ? "s" : "") +
                (t.options.ecmaVersion >= 13 ? "d" : "") +
                (t.options.ecmaVersion >= 15 ? "v" : "")),
              (this.unicodeProperties =
                ft[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion]),
              (this.source = ""),
              (this.flags = ""),
              (this.start = 0),
              (this.switchU = !1),
              (this.switchV = !1),
              (this.switchN = !1),
              (this.pos = 0),
              (this.lastIntValue = 0),
              (this.lastStringValue = ""),
              (this.lastAssertionIsQuantifiable = !1),
              (this.numCapturingParens = 0),
              (this.maxBackReference = 0),
              (this.groupNames = []),
              (this.backReferenceNames = []);
          };
        function isSyntaxCharacter(t) {
          return (
            36 === t ||
            (t >= 40 && t <= 43) ||
            46 === t ||
            63 === t ||
            (t >= 91 && t <= 94) ||
            (t >= 123 && t <= 125)
          );
        }
        function isControlLetter(t) {
          return (t >= 65 && t <= 90) || (t >= 97 && t <= 122);
        }
        function isUnicodePropertyNameCharacter(t) {
          return isControlLetter(t) || 95 === t;
        }
        function isUnicodePropertyValueCharacter(t) {
          return isUnicodePropertyNameCharacter(t) || isDecimalDigit(t);
        }
        function isDecimalDigit(t) {
          return t >= 48 && t <= 57;
        }
        function isHexDigit(t) {
          return (
            (t >= 48 && t <= 57) ||
            (t >= 65 && t <= 70) ||
            (t >= 97 && t <= 102)
          );
        }
        function hexToInt(t) {
          return t >= 65 && t <= 70
            ? t - 65 + 10
            : t >= 97 && t <= 102
            ? t - 97 + 10
            : t - 48;
        }
        function isOctalDigit(t) {
          return t >= 48 && t <= 55;
        }
        (vt.prototype.reset = function reset(t, e, i) {
          var s = -1 !== i.indexOf("v"),
            r = -1 !== i.indexOf("u");
          (this.start = 0 | t),
            (this.source = e + ""),
            (this.flags = i),
            s && this.parser.options.ecmaVersion >= 15
              ? ((this.switchU = !0), (this.switchV = !0), (this.switchN = !0))
              : ((this.switchU = r && this.parser.options.ecmaVersion >= 6),
                (this.switchV = !1),
                (this.switchN = r && this.parser.options.ecmaVersion >= 9));
        }),
          (vt.prototype.raise = function raise(t) {
            this.parser.raiseRecoverable(
              this.start,
              "Invalid regular expression: /" + this.source + "/: " + t
            );
          }),
          (vt.prototype.at = function at(t, e) {
            void 0 === e && (e = !1);
            var i = this.source,
              s = i.length;
            if (t >= s) return -1;
            var r = i.charCodeAt(t);
            if ((!e && !this.switchU) || r <= 55295 || r >= 57344 || t + 1 >= s)
              return r;
            var a = i.charCodeAt(t + 1);
            return a >= 56320 && a <= 57343 ? (r << 10) + a - 56613888 : r;
          }),
          (vt.prototype.nextIndex = function nextIndex(t, e) {
            void 0 === e && (e = !1);
            var i = this.source,
              s = i.length;
            if (t >= s) return s;
            var r,
              a = i.charCodeAt(t);
            return (!e && !this.switchU) ||
              a <= 55295 ||
              a >= 57344 ||
              t + 1 >= s ||
              (r = i.charCodeAt(t + 1)) < 56320 ||
              r > 57343
              ? t + 1
              : t + 2;
          }),
          (vt.prototype.current = function current(t) {
            return void 0 === t && (t = !1), this.at(this.pos, t);
          }),
          (vt.prototype.lookahead = function lookahead(t) {
            return (
              void 0 === t && (t = !1), this.at(this.nextIndex(this.pos, t), t)
            );
          }),
          (vt.prototype.advance = function advance(t) {
            void 0 === t && (t = !1), (this.pos = this.nextIndex(this.pos, t));
          }),
          (vt.prototype.eat = function eat(t, e) {
            return (
              void 0 === e && (e = !1),
              this.current(e) === t && (this.advance(e), !0)
            );
          }),
          (vt.prototype.eatChars = function eatChars(t, e) {
            void 0 === e && (e = !1);
            for (var i = this.pos, s = 0, r = t; s < r.length; s += 1) {
              var a = r[s],
                n = this.at(i, e);
              if (-1 === n || n !== a) return !1;
              i = this.nextIndex(i, e);
            }
            return (this.pos = i), !0;
          }),
          (xt.validateRegExpFlags = function (t) {
            for (
              var e = t.validFlags, i = t.flags, s = !1, r = !1, a = 0;
              a < i.length;
              a++
            ) {
              var n = i.charAt(a);
              -1 === e.indexOf(n) &&
                this.raise(t.start, "Invalid regular expression flag"),
                i.indexOf(n, a + 1) > -1 &&
                  this.raise(t.start, "Duplicate regular expression flag"),
                "u" === n && (s = !0),
                "v" === n && (r = !0);
            }
            this.options.ecmaVersion >= 15 &&
              s &&
              r &&
              this.raise(t.start, "Invalid regular expression flag");
          }),
          (xt.validateRegExpPattern = function (t) {
            this.regexp_pattern(t),
              !t.switchN &&
                this.options.ecmaVersion >= 9 &&
                t.groupNames.length > 0 &&
                ((t.switchN = !0), this.regexp_pattern(t));
          }),
          (xt.regexp_pattern = function (t) {
            (t.pos = 0),
              (t.lastIntValue = 0),
              (t.lastStringValue = ""),
              (t.lastAssertionIsQuantifiable = !1),
              (t.numCapturingParens = 0),
              (t.maxBackReference = 0),
              (t.groupNames.length = 0),
              (t.backReferenceNames.length = 0),
              this.regexp_disjunction(t),
              t.pos !== t.source.length &&
                (t.eat(41) && t.raise("Unmatched ')'"),
                (t.eat(93) || t.eat(125)) &&
                  t.raise("Lone quantifier brackets")),
              t.maxBackReference > t.numCapturingParens &&
                t.raise("Invalid escape");
            for (var e = 0, i = t.backReferenceNames; e < i.length; e += 1) {
              var s = i[e];
              -1 === t.groupNames.indexOf(s) &&
                t.raise("Invalid named capture referenced");
            }
          }),
          (xt.regexp_disjunction = function (t) {
            for (this.regexp_alternative(t); t.eat(124); )
              this.regexp_alternative(t);
            this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"),
              t.eat(123) && t.raise("Lone quantifier brackets");
          }),
          (xt.regexp_alternative = function (t) {
            for (; t.pos < t.source.length && this.regexp_eatTerm(t); );
          }),
          (xt.regexp_eatTerm = function (t) {
            return this.regexp_eatAssertion(t)
              ? (t.lastAssertionIsQuantifiable &&
                  this.regexp_eatQuantifier(t) &&
                  t.switchU &&
                  t.raise("Invalid quantifier"),
                !0)
              : !!(t.switchU
                  ? this.regexp_eatAtom(t)
                  : this.regexp_eatExtendedAtom(t)) &&
                  (this.regexp_eatQuantifier(t), !0);
          }),
          (xt.regexp_eatAssertion = function (t) {
            var e = t.pos;
            if (((t.lastAssertionIsQuantifiable = !1), t.eat(94) || t.eat(36)))
              return !0;
            if (t.eat(92)) {
              if (t.eat(66) || t.eat(98)) return !0;
              t.pos = e;
            }
            if (t.eat(40) && t.eat(63)) {
              var i = !1;
              if (
                (this.options.ecmaVersion >= 9 && (i = t.eat(60)),
                t.eat(61) || t.eat(33))
              )
                return (
                  this.regexp_disjunction(t),
                  t.eat(41) || t.raise("Unterminated group"),
                  (t.lastAssertionIsQuantifiable = !i),
                  !0
                );
            }
            return (t.pos = e), !1;
          }),
          (xt.regexp_eatQuantifier = function (t, e) {
            return (
              void 0 === e && (e = !1),
              !!this.regexp_eatQuantifierPrefix(t, e) && (t.eat(63), !0)
            );
          }),
          (xt.regexp_eatQuantifierPrefix = function (t, e) {
            return (
              t.eat(42) ||
              t.eat(43) ||
              t.eat(63) ||
              this.regexp_eatBracedQuantifier(t, e)
            );
          }),
          (xt.regexp_eatBracedQuantifier = function (t, e) {
            var i = t.pos;
            if (t.eat(123)) {
              var s = 0,
                r = -1;
              if (
                this.regexp_eatDecimalDigits(t) &&
                ((s = t.lastIntValue),
                t.eat(44) &&
                  this.regexp_eatDecimalDigits(t) &&
                  (r = t.lastIntValue),
                t.eat(125))
              )
                return (
                  -1 !== r &&
                    r < s &&
                    !e &&
                    t.raise("numbers out of order in {} quantifier"),
                  !0
                );
              t.switchU && !e && t.raise("Incomplete quantifier"), (t.pos = i);
            }
            return !1;
          }),
          (xt.regexp_eatAtom = function (t) {
            return (
              this.regexp_eatPatternCharacters(t) ||
              t.eat(46) ||
              this.regexp_eatReverseSolidusAtomEscape(t) ||
              this.regexp_eatCharacterClass(t) ||
              this.regexp_eatUncapturingGroup(t) ||
              this.regexp_eatCapturingGroup(t)
            );
          }),
          (xt.regexp_eatReverseSolidusAtomEscape = function (t) {
            var e = t.pos;
            if (t.eat(92)) {
              if (this.regexp_eatAtomEscape(t)) return !0;
              t.pos = e;
            }
            return !1;
          }),
          (xt.regexp_eatUncapturingGroup = function (t) {
            var e = t.pos;
            if (t.eat(40)) {
              if (t.eat(63) && t.eat(58)) {
                if ((this.regexp_disjunction(t), t.eat(41))) return !0;
                t.raise("Unterminated group");
              }
              t.pos = e;
            }
            return !1;
          }),
          (xt.regexp_eatCapturingGroup = function (t) {
            if (t.eat(40)) {
              if (
                (this.options.ecmaVersion >= 9
                  ? this.regexp_groupSpecifier(t)
                  : 63 === t.current() && t.raise("Invalid group"),
                this.regexp_disjunction(t),
                t.eat(41))
              )
                return (t.numCapturingParens += 1), !0;
              t.raise("Unterminated group");
            }
            return !1;
          }),
          (xt.regexp_eatExtendedAtom = function (t) {
            return (
              t.eat(46) ||
              this.regexp_eatReverseSolidusAtomEscape(t) ||
              this.regexp_eatCharacterClass(t) ||
              this.regexp_eatUncapturingGroup(t) ||
              this.regexp_eatCapturingGroup(t) ||
              this.regexp_eatInvalidBracedQuantifier(t) ||
              this.regexp_eatExtendedPatternCharacter(t)
            );
          }),
          (xt.regexp_eatInvalidBracedQuantifier = function (t) {
            return (
              this.regexp_eatBracedQuantifier(t, !0) &&
                t.raise("Nothing to repeat"),
              !1
            );
          }),
          (xt.regexp_eatSyntaxCharacter = function (t) {
            var e = t.current();
            return (
              !!isSyntaxCharacter(e) && ((t.lastIntValue = e), t.advance(), !0)
            );
          }),
          (xt.regexp_eatPatternCharacters = function (t) {
            for (
              var e = t.pos, i = 0;
              -1 !== (i = t.current()) && !isSyntaxCharacter(i);

            )
              t.advance();
            return t.pos !== e;
          }),
          (xt.regexp_eatExtendedPatternCharacter = function (t) {
            var e = t.current();
            return !(
              -1 === e ||
              36 === e ||
              (e >= 40 && e <= 43) ||
              46 === e ||
              63 === e ||
              91 === e ||
              94 === e ||
              124 === e ||
              (t.advance(), 0)
            );
          }),
          (xt.regexp_groupSpecifier = function (t) {
            if (t.eat(63)) {
              if (this.regexp_eatGroupName(t))
                return (
                  -1 !== t.groupNames.indexOf(t.lastStringValue) &&
                    t.raise("Duplicate capture group name"),
                  void t.groupNames.push(t.lastStringValue)
                );
              t.raise("Invalid group");
            }
          }),
          (xt.regexp_eatGroupName = function (t) {
            if (((t.lastStringValue = ""), t.eat(60))) {
              if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62))
                return !0;
              t.raise("Invalid capture group name");
            }
            return !1;
          }),
          (xt.regexp_eatRegExpIdentifierName = function (t) {
            if (
              ((t.lastStringValue = ""),
              this.regexp_eatRegExpIdentifierStart(t))
            ) {
              for (
                t.lastStringValue += codePointToString(t.lastIntValue);
                this.regexp_eatRegExpIdentifierPart(t);

              )
                t.lastStringValue += codePointToString(t.lastIntValue);
              return !0;
            }
            return !1;
          }),
          (xt.regexp_eatRegExpIdentifierStart = function (t) {
            var e = t.pos,
              i = this.options.ecmaVersion >= 11,
              s = t.current(i);
            return (
              t.advance(i),
              92 === s &&
                this.regexp_eatRegExpUnicodeEscapeSequence(t, i) &&
                (s = t.lastIntValue),
              (function isRegExpIdentifierStart(t) {
                return isIdentifierStart(t, !0) || 36 === t || 95 === t;
              })(s)
                ? ((t.lastIntValue = s), !0)
                : ((t.pos = e), !1)
            );
          }),
          (xt.regexp_eatRegExpIdentifierPart = function (t) {
            var e = t.pos,
              i = this.options.ecmaVersion >= 11,
              s = t.current(i);
            return (
              t.advance(i),
              92 === s &&
                this.regexp_eatRegExpUnicodeEscapeSequence(t, i) &&
                (s = t.lastIntValue),
              (function isRegExpIdentifierPart(t) {
                return (
                  isIdentifierChar(t, !0) ||
                  36 === t ||
                  95 === t ||
                  8204 === t ||
                  8205 === t
                );
              })(s)
                ? ((t.lastIntValue = s), !0)
                : ((t.pos = e), !1)
            );
          }),
          (xt.regexp_eatAtomEscape = function (t) {
            return (
              !!(
                this.regexp_eatBackReference(t) ||
                this.regexp_eatCharacterClassEscape(t) ||
                this.regexp_eatCharacterEscape(t) ||
                (t.switchN && this.regexp_eatKGroupName(t))
              ) ||
              (t.switchU &&
                (99 === t.current() && t.raise("Invalid unicode escape"),
                t.raise("Invalid escape")),
              !1)
            );
          }),
          (xt.regexp_eatBackReference = function (t) {
            var e = t.pos;
            if (this.regexp_eatDecimalEscape(t)) {
              var i = t.lastIntValue;
              if (t.switchU)
                return i > t.maxBackReference && (t.maxBackReference = i), !0;
              if (i <= t.numCapturingParens) return !0;
              t.pos = e;
            }
            return !1;
          }),
          (xt.regexp_eatKGroupName = function (t) {
            if (t.eat(107)) {
              if (this.regexp_eatGroupName(t))
                return t.backReferenceNames.push(t.lastStringValue), !0;
              t.raise("Invalid named reference");
            }
            return !1;
          }),
          (xt.regexp_eatCharacterEscape = function (t) {
            return (
              this.regexp_eatControlEscape(t) ||
              this.regexp_eatCControlLetter(t) ||
              this.regexp_eatZero(t) ||
              this.regexp_eatHexEscapeSequence(t) ||
              this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) ||
              (!t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t)) ||
              this.regexp_eatIdentityEscape(t)
            );
          }),
          (xt.regexp_eatCControlLetter = function (t) {
            var e = t.pos;
            if (t.eat(99)) {
              if (this.regexp_eatControlLetter(t)) return !0;
              t.pos = e;
            }
            return !1;
          }),
          (xt.regexp_eatZero = function (t) {
            return (
              48 === t.current() &&
              !isDecimalDigit(t.lookahead()) &&
              ((t.lastIntValue = 0), t.advance(), !0)
            );
          }),
          (xt.regexp_eatControlEscape = function (t) {
            var e = t.current();
            return 116 === e
              ? ((t.lastIntValue = 9), t.advance(), !0)
              : 110 === e
              ? ((t.lastIntValue = 10), t.advance(), !0)
              : 118 === e
              ? ((t.lastIntValue = 11), t.advance(), !0)
              : 102 === e
              ? ((t.lastIntValue = 12), t.advance(), !0)
              : 114 === e && ((t.lastIntValue = 13), t.advance(), !0);
          }),
          (xt.regexp_eatControlLetter = function (t) {
            var e = t.current();
            return (
              !!isControlLetter(e) &&
              ((t.lastIntValue = e % 32), t.advance(), !0)
            );
          }),
          (xt.regexp_eatRegExpUnicodeEscapeSequence = function (t, e) {
            void 0 === e && (e = !1);
            var i = t.pos,
              s = e || t.switchU;
            if (t.eat(117)) {
              if (this.regexp_eatFixedHexDigits(t, 4)) {
                var r = t.lastIntValue;
                if (s && r >= 55296 && r <= 56319) {
                  var a = t.pos;
                  if (
                    t.eat(92) &&
                    t.eat(117) &&
                    this.regexp_eatFixedHexDigits(t, 4)
                  ) {
                    var n = t.lastIntValue;
                    if (n >= 56320 && n <= 57343)
                      return (
                        (t.lastIntValue =
                          1024 * (r - 55296) + (n - 56320) + 65536),
                        !0
                      );
                  }
                  (t.pos = a), (t.lastIntValue = r);
                }
                return !0;
              }
              if (
                s &&
                t.eat(123) &&
                this.regexp_eatHexDigits(t) &&
                t.eat(125) &&
                (function isValidUnicode(t) {
                  return t >= 0 && t <= 1114111;
                })(t.lastIntValue)
              )
                return !0;
              s && t.raise("Invalid unicode escape"), (t.pos = i);
            }
            return !1;
          }),
          (xt.regexp_eatIdentityEscape = function (t) {
            if (t.switchU)
              return (
                !!this.regexp_eatSyntaxCharacter(t) ||
                (!!t.eat(47) && ((t.lastIntValue = 47), !0))
              );
            var e = t.current();
            return !(
              99 === e ||
              (t.switchN && 107 === e) ||
              ((t.lastIntValue = e), t.advance(), 0)
            );
          }),
          (xt.regexp_eatDecimalEscape = function (t) {
            t.lastIntValue = 0;
            var e = t.current();
            if (e >= 49 && e <= 57) {
              do {
                (t.lastIntValue = 10 * t.lastIntValue + (e - 48)), t.advance();
              } while ((e = t.current()) >= 48 && e <= 57);
              return !0;
            }
            return !1;
          }),
          (xt.regexp_eatCharacterClassEscape = function (t) {
            var e = t.current();
            if (
              (function isCharacterClassEscape(t) {
                return (
                  100 === t ||
                  68 === t ||
                  115 === t ||
                  83 === t ||
                  119 === t ||
                  87 === t
                );
              })(e)
            )
              return (t.lastIntValue = -1), t.advance(), 1;
            var i = !1;
            if (
              t.switchU &&
              this.options.ecmaVersion >= 9 &&
              ((i = 80 === e) || 112 === e)
            ) {
              var s;
              if (
                ((t.lastIntValue = -1),
                t.advance(),
                t.eat(123) &&
                  (s = this.regexp_eatUnicodePropertyValueExpression(t)) &&
                  t.eat(125))
              )
                return i && 2 === s && t.raise("Invalid property name"), s;
              t.raise("Invalid property name");
            }
            return 0;
          }),
          (xt.regexp_eatUnicodePropertyValueExpression = function (t) {
            var e = t.pos;
            if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
              var i = t.lastStringValue;
              if (this.regexp_eatUnicodePropertyValue(t)) {
                var s = t.lastStringValue;
                return (
                  this.regexp_validateUnicodePropertyNameAndValue(t, i, s), 1
                );
              }
            }
            if (
              ((t.pos = e), this.regexp_eatLoneUnicodePropertyNameOrValue(t))
            ) {
              var r = t.lastStringValue;
              return this.regexp_validateUnicodePropertyNameOrValue(t, r);
            }
            return 0;
          }),
          (xt.regexp_validateUnicodePropertyNameAndValue = function (t, e, i) {
            _(t.unicodeProperties.nonBinary, e) ||
              t.raise("Invalid property name"),
              t.unicodeProperties.nonBinary[e].test(i) ||
                t.raise("Invalid property value");
          }),
          (xt.regexp_validateUnicodePropertyNameOrValue = function (t, e) {
            return t.unicodeProperties.binary.test(e)
              ? 1
              : t.switchV && t.unicodeProperties.binaryOfStrings.test(e)
              ? 2
              : void t.raise("Invalid property name");
          }),
          (xt.regexp_eatUnicodePropertyName = function (t) {
            var e = 0;
            for (
              t.lastStringValue = "";
              isUnicodePropertyNameCharacter((e = t.current()));

            )
              (t.lastStringValue += codePointToString(e)), t.advance();
            return "" !== t.lastStringValue;
          }),
          (xt.regexp_eatUnicodePropertyValue = function (t) {
            var e = 0;
            for (
              t.lastStringValue = "";
              isUnicodePropertyValueCharacter((e = t.current()));

            )
              (t.lastStringValue += codePointToString(e)), t.advance();
            return "" !== t.lastStringValue;
          }),
          (xt.regexp_eatLoneUnicodePropertyNameOrValue = function (t) {
            return this.regexp_eatUnicodePropertyValue(t);
          }),
          (xt.regexp_eatCharacterClass = function (t) {
            if (t.eat(91)) {
              var e = t.eat(94),
                i = this.regexp_classContents(t);
              return (
                t.eat(93) || t.raise("Unterminated character class"),
                e &&
                  2 === i &&
                  t.raise("Negated character class may contain strings"),
                !0
              );
            }
            return !1;
          }),
          (xt.regexp_classContents = function (t) {
            return 93 === t.current()
              ? 1
              : t.switchV
              ? this.regexp_classSetExpression(t)
              : (this.regexp_nonEmptyClassRanges(t), 1);
          }),
          (xt.regexp_nonEmptyClassRanges = function (t) {
            for (; this.regexp_eatClassAtom(t); ) {
              var e = t.lastIntValue;
              if (t.eat(45) && this.regexp_eatClassAtom(t)) {
                var i = t.lastIntValue;
                !t.switchU ||
                  (-1 !== e && -1 !== i) ||
                  t.raise("Invalid character class"),
                  -1 !== e &&
                    -1 !== i &&
                    e > i &&
                    t.raise("Range out of order in character class");
              }
            }
          }),
          (xt.regexp_eatClassAtom = function (t) {
            var e = t.pos;
            if (t.eat(92)) {
              if (this.regexp_eatClassEscape(t)) return !0;
              if (t.switchU) {
                var i = t.current();
                (99 === i || isOctalDigit(i)) &&
                  t.raise("Invalid class escape"),
                  t.raise("Invalid escape");
              }
              t.pos = e;
            }
            var s = t.current();
            return 93 !== s && ((t.lastIntValue = s), t.advance(), !0);
          }),
          (xt.regexp_eatClassEscape = function (t) {
            var e = t.pos;
            if (t.eat(98)) return (t.lastIntValue = 8), !0;
            if (t.switchU && t.eat(45)) return (t.lastIntValue = 45), !0;
            if (!t.switchU && t.eat(99)) {
              if (this.regexp_eatClassControlLetter(t)) return !0;
              t.pos = e;
            }
            return (
              this.regexp_eatCharacterClassEscape(t) ||
              this.regexp_eatCharacterEscape(t)
            );
          }),
          (xt.regexp_classSetExpression = function (t) {
            var e,
              i = 1;
            if (this.regexp_eatClassSetRange(t));
            else if ((e = this.regexp_eatClassSetOperand(t))) {
              2 === e && (i = 2);
              for (var s = t.pos; t.eatChars([38, 38]); )
                38 !== t.current() && (e = this.regexp_eatClassSetOperand(t))
                  ? 2 !== e && (i = 1)
                  : t.raise("Invalid character in character class");
              if (s !== t.pos) return i;
              for (; t.eatChars([45, 45]); )
                this.regexp_eatClassSetOperand(t) ||
                  t.raise("Invalid character in character class");
              if (s !== t.pos) return i;
            } else t.raise("Invalid character in character class");
            for (;;)
              if (!this.regexp_eatClassSetRange(t)) {
                if (!(e = this.regexp_eatClassSetOperand(t))) return i;
                2 === e && (i = 2);
              }
          }),
          (xt.regexp_eatClassSetRange = function (t) {
            var e = t.pos;
            if (this.regexp_eatClassSetCharacter(t)) {
              var i = t.lastIntValue;
              if (t.eat(45) && this.regexp_eatClassSetCharacter(t)) {
                var s = t.lastIntValue;
                return (
                  -1 !== i &&
                    -1 !== s &&
                    i > s &&
                    t.raise("Range out of order in character class"),
                  !0
                );
              }
              t.pos = e;
            }
            return !1;
          }),
          (xt.regexp_eatClassSetOperand = function (t) {
            return this.regexp_eatClassSetCharacter(t)
              ? 1
              : this.regexp_eatClassStringDisjunction(t) ||
                  this.regexp_eatNestedClass(t);
          }),
          (xt.regexp_eatNestedClass = function (t) {
            var e = t.pos;
            if (t.eat(91)) {
              var i = t.eat(94),
                s = this.regexp_classContents(t);
              if (t.eat(93))
                return (
                  i &&
                    2 === s &&
                    t.raise("Negated character class may contain strings"),
                  s
                );
              t.pos = e;
            }
            if (t.eat(92)) {
              var r = this.regexp_eatCharacterClassEscape(t);
              if (r) return r;
              t.pos = e;
            }
            return null;
          }),
          (xt.regexp_eatClassStringDisjunction = function (t) {
            var e = t.pos;
            if (t.eatChars([92, 113])) {
              if (t.eat(123)) {
                var i = this.regexp_classStringDisjunctionContents(t);
                if (t.eat(125)) return i;
              } else t.raise("Invalid escape");
              t.pos = e;
            }
            return null;
          }),
          (xt.regexp_classStringDisjunctionContents = function (t) {
            for (var e = this.regexp_classString(t); t.eat(124); )
              2 === this.regexp_classString(t) && (e = 2);
            return e;
          }),
          (xt.regexp_classString = function (t) {
            for (var e = 0; this.regexp_eatClassSetCharacter(t); ) e++;
            return 1 === e ? 1 : 2;
          }),
          (xt.regexp_eatClassSetCharacter = function (t) {
            var e = t.pos;
            if (t.eat(92))
              return !(
                !this.regexp_eatCharacterEscape(t) &&
                !this.regexp_eatClassSetReservedPunctuator(t) &&
                (t.eat(98) ? ((t.lastIntValue = 8), 0) : ((t.pos = e), 1))
              );
            var i = t.current();
            return !(
              i < 0 ||
              (i === t.lookahead() &&
                (function isClassSetReservedDoublePunctuatorCharacter(t) {
                  return (
                    33 === t ||
                    (t >= 35 && t <= 38) ||
                    (t >= 42 && t <= 44) ||
                    46 === t ||
                    (t >= 58 && t <= 64) ||
                    94 === t ||
                    96 === t ||
                    126 === t
                  );
                })(i)) ||
              (function isClassSetSyntaxCharacter(t) {
                return (
                  40 === t ||
                  41 === t ||
                  45 === t ||
                  47 === t ||
                  (t >= 91 && t <= 93) ||
                  (t >= 123 && t <= 125)
                );
              })(i) ||
              (t.advance(), (t.lastIntValue = i), 0)
            );
          }),
          (xt.regexp_eatClassSetReservedPunctuator = function (t) {
            var e = t.current();
            return (
              !!(function isClassSetReservedPunctuator(t) {
                return (
                  33 === t ||
                  35 === t ||
                  37 === t ||
                  38 === t ||
                  44 === t ||
                  45 === t ||
                  (t >= 58 && t <= 62) ||
                  64 === t ||
                  96 === t ||
                  126 === t
                );
              })(e) && ((t.lastIntValue = e), t.advance(), !0)
            );
          }),
          (xt.regexp_eatClassControlLetter = function (t) {
            var e = t.current();
            return !(
              (!isDecimalDigit(e) && 95 !== e) ||
              ((t.lastIntValue = e % 32), t.advance(), 0)
            );
          }),
          (xt.regexp_eatHexEscapeSequence = function (t) {
            var e = t.pos;
            if (t.eat(120)) {
              if (this.regexp_eatFixedHexDigits(t, 2)) return !0;
              t.switchU && t.raise("Invalid escape"), (t.pos = e);
            }
            return !1;
          }),
          (xt.regexp_eatDecimalDigits = function (t) {
            var e = t.pos,
              i = 0;
            for (t.lastIntValue = 0; isDecimalDigit((i = t.current())); )
              (t.lastIntValue = 10 * t.lastIntValue + (i - 48)), t.advance();
            return t.pos !== e;
          }),
          (xt.regexp_eatHexDigits = function (t) {
            var e = t.pos,
              i = 0;
            for (t.lastIntValue = 0; isHexDigit((i = t.current())); )
              (t.lastIntValue = 16 * t.lastIntValue + hexToInt(i)), t.advance();
            return t.pos !== e;
          }),
          (xt.regexp_eatLegacyOctalEscapeSequence = function (t) {
            if (this.regexp_eatOctalDigit(t)) {
              var e = t.lastIntValue;
              if (this.regexp_eatOctalDigit(t)) {
                var i = t.lastIntValue;
                e <= 3 && this.regexp_eatOctalDigit(t)
                  ? (t.lastIntValue = 64 * e + 8 * i + t.lastIntValue)
                  : (t.lastIntValue = 8 * e + i);
              } else t.lastIntValue = e;
              return !0;
            }
            return !1;
          }),
          (xt.regexp_eatOctalDigit = function (t) {
            var e = t.current();
            return isOctalDigit(e)
              ? ((t.lastIntValue = e - 48), t.advance(), !0)
              : ((t.lastIntValue = 0), !1);
          }),
          (xt.regexp_eatFixedHexDigits = function (t, e) {
            var i = t.pos;
            t.lastIntValue = 0;
            for (var s = 0; s < e; ++s) {
              var r = t.current();
              if (!isHexDigit(r)) return (t.pos = i), !1;
              (t.lastIntValue = 16 * t.lastIntValue + hexToInt(r)), t.advance();
            }
            return !0;
          });
        var yt = function Token2(t) {
            (this.type = t.type),
              (this.value = t.value),
              (this.start = t.start),
              (this.end = t.end),
              t.options.locations &&
                (this.loc = new I(t, t.startLoc, t.endLoc)),
              t.options.ranges && (this.range = [t.start, t.end]);
          },
          kt = T.prototype;
        function stringToBigInt(t) {
          return "function" != typeof BigInt
            ? null
            : BigInt(t.replace(/_/g, ""));
        }
        (kt.next = function (t) {
          !t &&
            this.type.keyword &&
            this.containsEsc &&
            this.raiseRecoverable(
              this.start,
              "Escape sequence in keyword " + this.type.keyword
            ),
            this.options.onToken && this.options.onToken(new yt(this)),
            (this.lastTokEnd = this.end),
            (this.lastTokStart = this.start),
            (this.lastTokEndLoc = this.endLoc),
            (this.lastTokStartLoc = this.startLoc),
            this.nextToken();
        }),
          (kt.getToken = function () {
            return this.next(), new yt(this);
          }),
          "undefined" != typeof Symbol &&
            (kt[Symbol.iterator] = function () {
              var t = this;
              return {
                next: function () {
                  var e = t.getToken();
                  return { done: e.type === f.eof, value: e };
                },
              };
            }),
          (kt.nextToken = function () {
            var t = this.curContext();
            return (
              (t && t.preserveSpace) || this.skipSpace(),
              (this.start = this.pos),
              this.options.locations && (this.startLoc = this.curPosition()),
              this.pos >= this.input.length
                ? this.finishToken(f.eof)
                : t.override
                ? t.override(this)
                : void this.readToken(this.fullCharCodeAtPos())
            );
          }),
          (kt.readToken = function (t) {
            return isIdentifierStart(t, this.options.ecmaVersion >= 6) ||
              92 === t
              ? this.readWord()
              : this.getTokenFromCode(t);
          }),
          (kt.fullCharCodeAtPos = function () {
            var t = this.input.charCodeAt(this.pos);
            if (t <= 55295 || t >= 56320) return t;
            var e = this.input.charCodeAt(this.pos + 1);
            return e <= 56319 || e >= 57344 ? t : (t << 10) + e - 56613888;
          }),
          (kt.skipBlockComment = function () {
            var t = this.options.onComment && this.curPosition(),
              e = this.pos,
              i = this.input.indexOf("*/", (this.pos += 2));
            if (
              (-1 === i && this.raise(this.pos - 2, "Unterminated comment"),
              (this.pos = i + 2),
              this.options.locations)
            )
              for (
                var s = void 0, r = e;
                (s = nextLineBreak(this.input, r, this.pos)) > -1;

              )
                ++this.curLine, (r = this.lineStart = s);
            this.options.onComment &&
              this.options.onComment(
                !0,
                this.input.slice(e + 2, i),
                e,
                this.pos,
                t,
                this.curPosition()
              );
          }),
          (kt.skipLineComment = function (t) {
            for (
              var e = this.pos,
                i = this.options.onComment && this.curPosition(),
                s = this.input.charCodeAt((this.pos += t));
              this.pos < this.input.length && !isNewLine(s);

            )
              s = this.input.charCodeAt(++this.pos);
            this.options.onComment &&
              this.options.onComment(
                !1,
                this.input.slice(e + t, this.pos),
                e,
                this.pos,
                i,
                this.curPosition()
              );
          }),
          (kt.skipSpace = function () {
            t: for (; this.pos < this.input.length; ) {
              var t = this.input.charCodeAt(this.pos);
              switch (t) {
                case 32:
                case 160:
                  ++this.pos;
                  break;
                case 13:
                  10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.pos,
                    this.options.locations &&
                      (++this.curLine, (this.lineStart = this.pos));
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.pos + 1)) {
                    case 42:
                      this.skipBlockComment();
                      break;
                    case 47:
                      this.skipLineComment(2);
                      break;
                    default:
                      break t;
                  }
                  break;
                default:
                  if (
                    !(
                      (t > 8 && t < 14) ||
                      (t >= 5760 && x.test(String.fromCharCode(t)))
                    )
                  )
                    break t;
                  ++this.pos;
              }
            }
          }),
          (kt.finishToken = function (t, e) {
            (this.end = this.pos),
              this.options.locations && (this.endLoc = this.curPosition());
            var i = this.type;
            (this.type = t), (this.value = e), this.updateContext(i);
          }),
          (kt.readToken_dot = function () {
            var t = this.input.charCodeAt(this.pos + 1);
            if (t >= 48 && t <= 57) return this.readNumber(!0);
            var e = this.input.charCodeAt(this.pos + 2);
            return this.options.ecmaVersion >= 6 && 46 === t && 46 === e
              ? ((this.pos += 3), this.finishToken(f.ellipsis))
              : (++this.pos, this.finishToken(f.dot));
          }),
          (kt.readToken_slash = function () {
            var t = this.input.charCodeAt(this.pos + 1);
            return this.exprAllowed
              ? (++this.pos, this.readRegexp())
              : 61 === t
              ? this.finishOp(f.assign, 2)
              : this.finishOp(f.slash, 1);
          }),
          (kt.readToken_mult_modulo_exp = function (t) {
            var e = this.input.charCodeAt(this.pos + 1),
              i = 1,
              s = 42 === t ? f.star : f.modulo;
            return (
              this.options.ecmaVersion >= 7 &&
                42 === t &&
                42 === e &&
                (++i,
                (s = f.starstar),
                (e = this.input.charCodeAt(this.pos + 2))),
              61 === e ? this.finishOp(f.assign, i + 1) : this.finishOp(s, i)
            );
          }),
          (kt.readToken_pipe_amp = function (t) {
            var e = this.input.charCodeAt(this.pos + 1);
            return e === t
              ? this.options.ecmaVersion >= 12 &&
                61 === this.input.charCodeAt(this.pos + 2)
                ? this.finishOp(f.assign, 3)
                : this.finishOp(124 === t ? f.logicalOR : f.logicalAND, 2)
              : 61 === e
              ? this.finishOp(f.assign, 2)
              : this.finishOp(124 === t ? f.bitwiseOR : f.bitwiseAND, 1);
          }),
          (kt.readToken_caret = function () {
            return 61 === this.input.charCodeAt(this.pos + 1)
              ? this.finishOp(f.assign, 2)
              : this.finishOp(f.bitwiseXOR, 1);
          }),
          (kt.readToken_plus_min = function (t) {
            var e = this.input.charCodeAt(this.pos + 1);
            return e === t
              ? 45 !== e ||
                this.inModule ||
                62 !== this.input.charCodeAt(this.pos + 2) ||
                (0 !== this.lastTokEnd &&
                  !m.test(this.input.slice(this.lastTokEnd, this.pos)))
                ? this.finishOp(f.incDec, 2)
                : (this.skipLineComment(3), this.skipSpace(), this.nextToken())
              : 61 === e
              ? this.finishOp(f.assign, 2)
              : this.finishOp(f.plusMin, 1);
          }),
          (kt.readToken_lt_gt = function (t) {
            var e = this.input.charCodeAt(this.pos + 1),
              i = 1;
            return e === t
              ? ((i =
                  62 === t && 62 === this.input.charCodeAt(this.pos + 2)
                    ? 3
                    : 2),
                61 === this.input.charCodeAt(this.pos + i)
                  ? this.finishOp(f.assign, i + 1)
                  : this.finishOp(f.bitShift, i))
              : 33 !== e ||
                60 !== t ||
                this.inModule ||
                45 !== this.input.charCodeAt(this.pos + 2) ||
                45 !== this.input.charCodeAt(this.pos + 3)
              ? (61 === e && (i = 2), this.finishOp(f.relational, i))
              : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
          }),
          (kt.readToken_eq_excl = function (t) {
            var e = this.input.charCodeAt(this.pos + 1);
            return 61 === e
              ? this.finishOp(
                  f.equality,
                  61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2
                )
              : 61 === t && 62 === e && this.options.ecmaVersion >= 6
              ? ((this.pos += 2), this.finishToken(f.arrow))
              : this.finishOp(61 === t ? f.eq : f.prefix, 1);
          }),
          (kt.readToken_question = function () {
            var t = this.options.ecmaVersion;
            if (t >= 11) {
              var e = this.input.charCodeAt(this.pos + 1);
              if (46 === e) {
                var i = this.input.charCodeAt(this.pos + 2);
                if (i < 48 || i > 57) return this.finishOp(f.questionDot, 2);
              }
              if (63 === e)
                return t >= 12 && 61 === this.input.charCodeAt(this.pos + 2)
                  ? this.finishOp(f.assign, 3)
                  : this.finishOp(f.coalesce, 2);
            }
            return this.finishOp(f.question, 1);
          }),
          (kt.readToken_numberSign = function () {
            var t = 35;
            if (
              this.options.ecmaVersion >= 13 &&
              (++this.pos,
              isIdentifierStart((t = this.fullCharCodeAtPos()), !0) || 92 === t)
            )
              return this.finishToken(f.privateId, this.readWord1());
            this.raise(
              this.pos,
              "Unexpected character '" + codePointToString(t) + "'"
            );
          }),
          (kt.getTokenFromCode = function (t) {
            switch (t) {
              case 46:
                return this.readToken_dot();
              case 40:
                return ++this.pos, this.finishToken(f.parenL);
              case 41:
                return ++this.pos, this.finishToken(f.parenR);
              case 59:
                return ++this.pos, this.finishToken(f.semi);
              case 44:
                return ++this.pos, this.finishToken(f.comma);
              case 91:
                return ++this.pos, this.finishToken(f.bracketL);
              case 93:
                return ++this.pos, this.finishToken(f.bracketR);
              case 123:
                return ++this.pos, this.finishToken(f.braceL);
              case 125:
                return ++this.pos, this.finishToken(f.braceR);
              case 58:
                return ++this.pos, this.finishToken(f.colon);
              case 96:
                if (this.options.ecmaVersion < 6) break;
                return ++this.pos, this.finishToken(f.backQuote);
              case 48:
                var e = this.input.charCodeAt(this.pos + 1);
                if (120 === e || 88 === e) return this.readRadixNumber(16);
                if (this.options.ecmaVersion >= 6) {
                  if (111 === e || 79 === e) return this.readRadixNumber(8);
                  if (98 === e || 66 === e) return this.readRadixNumber(2);
                }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return this.readNumber(!1);
              case 34:
              case 39:
                return this.readString(t);
              case 47:
                return this.readToken_slash();
              case 37:
              case 42:
                return this.readToken_mult_modulo_exp(t);
              case 124:
              case 38:
                return this.readToken_pipe_amp(t);
              case 94:
                return this.readToken_caret();
              case 43:
              case 45:
                return this.readToken_plus_min(t);
              case 60:
              case 62:
                return this.readToken_lt_gt(t);
              case 61:
              case 33:
                return this.readToken_eq_excl(t);
              case 63:
                return this.readToken_question();
              case 126:
                return this.finishOp(f.prefix, 1);
              case 35:
                return this.readToken_numberSign();
            }
            this.raise(
              this.pos,
              "Unexpected character '" + codePointToString(t) + "'"
            );
          }),
          (kt.finishOp = function (t, e) {
            var i = this.input.slice(this.pos, this.pos + e);
            return (this.pos += e), this.finishToken(t, i);
          }),
          (kt.readRegexp = function () {
            for (var t, e, i = this.pos; ; ) {
              this.pos >= this.input.length &&
                this.raise(i, "Unterminated regular expression");
              var s = this.input.charAt(this.pos);
              if (
                (m.test(s) && this.raise(i, "Unterminated regular expression"),
                t)
              )
                t = !1;
              else {
                if ("[" === s) e = !0;
                else if ("]" === s && e) e = !1;
                else if ("/" === s && !e) break;
                t = "\\" === s;
              }
              ++this.pos;
            }
            var r = this.input.slice(i, this.pos);
            ++this.pos;
            var a = this.pos,
              n = this.readWord1();
            this.containsEsc && this.unexpected(a);
            var o = this.regexpState || (this.regexpState = new vt(this));
            o.reset(i, r, n),
              this.validateRegExpFlags(o),
              this.validateRegExpPattern(o);
            var h = null;
            try {
              h = new RegExp(r, n);
            } catch (t) {}
            return this.finishToken(f.regexp, {
              pattern: r,
              flags: n,
              value: h,
            });
          }),
          (kt.readInt = function (t, e, i) {
            for (
              var s = this.options.ecmaVersion >= 12 && void 0 === e,
                r = i && 48 === this.input.charCodeAt(this.pos),
                a = this.pos,
                n = 0,
                o = 0,
                h = 0,
                p = null == e ? 1 / 0 : e;
              h < p;
              ++h, ++this.pos
            ) {
              var c = this.input.charCodeAt(this.pos),
                l = void 0;
              if (s && 95 === c)
                r &&
                  this.raiseRecoverable(
                    this.pos,
                    "Numeric separator is not allowed in legacy octal numeric literals"
                  ),
                  95 === o &&
                    this.raiseRecoverable(
                      this.pos,
                      "Numeric separator must be exactly one underscore"
                    ),
                  0 === h &&
                    this.raiseRecoverable(
                      this.pos,
                      "Numeric separator is not allowed at the first of digits"
                    ),
                  (o = c);
              else {
                if (
                  (l =
                    c >= 97
                      ? c - 97 + 10
                      : c >= 65
                      ? c - 65 + 10
                      : c >= 48 && c <= 57
                      ? c - 48
                      : 1 / 0) >= t
                )
                  break;
                (o = c), (n = n * t + l);
              }
            }
            return (
              s &&
                95 === o &&
                this.raiseRecoverable(
                  this.pos - 1,
                  "Numeric separator is not allowed at the last of digits"
                ),
              this.pos === a || (null != e && this.pos - a !== e) ? null : n
            );
          }),
          (kt.readRadixNumber = function (t) {
            var e = this.pos;
            this.pos += 2;
            var i = this.readInt(t);
            return (
              null == i &&
                this.raise(this.start + 2, "Expected number in radix " + t),
              this.options.ecmaVersion >= 11 &&
              110 === this.input.charCodeAt(this.pos)
                ? ((i = stringToBigInt(this.input.slice(e, this.pos))),
                  ++this.pos)
                : isIdentifierStart(this.fullCharCodeAtPos()) &&
                  this.raise(this.pos, "Identifier directly after number"),
              this.finishToken(f.num, i)
            );
          }),
          (kt.readNumber = function (t) {
            var e = this.pos;
            t ||
              null !== this.readInt(10, void 0, !0) ||
              this.raise(e, "Invalid number");
            var i = this.pos - e >= 2 && 48 === this.input.charCodeAt(e);
            i && this.strict && this.raise(e, "Invalid number");
            var s = this.input.charCodeAt(this.pos);
            if (!i && !t && this.options.ecmaVersion >= 11 && 110 === s) {
              var r = stringToBigInt(this.input.slice(e, this.pos));
              return (
                ++this.pos,
                isIdentifierStart(this.fullCharCodeAtPos()) &&
                  this.raise(this.pos, "Identifier directly after number"),
                this.finishToken(f.num, r)
              );
            }
            i && /[89]/.test(this.input.slice(e, this.pos)) && (i = !1),
              46 !== s ||
                i ||
                (++this.pos,
                this.readInt(10),
                (s = this.input.charCodeAt(this.pos))),
              (69 !== s && 101 !== s) ||
                i ||
                ((43 !== (s = this.input.charCodeAt(++this.pos)) && 45 !== s) ||
                  ++this.pos,
                null === this.readInt(10) && this.raise(e, "Invalid number")),
              isIdentifierStart(this.fullCharCodeAtPos()) &&
                this.raise(this.pos, "Identifier directly after number");
            var a = (function stringToNumber(t, e) {
              return e ? parseInt(t, 8) : parseFloat(t.replace(/_/g, ""));
            })(this.input.slice(e, this.pos), i);
            return this.finishToken(f.num, a);
          }),
          (kt.readCodePoint = function () {
            var t;
            if (123 === this.input.charCodeAt(this.pos)) {
              this.options.ecmaVersion < 6 && this.unexpected();
              var e = ++this.pos;
              (t = this.readHexChar(
                this.input.indexOf("}", this.pos) - this.pos
              )),
                ++this.pos,
                t > 1114111 &&
                  this.invalidStringToken(e, "Code point out of bounds");
            } else t = this.readHexChar(4);
            return t;
          }),
          (kt.readString = function (t) {
            for (var e = "", i = ++this.pos; ; ) {
              this.pos >= this.input.length &&
                this.raise(this.start, "Unterminated string constant");
              var s = this.input.charCodeAt(this.pos);
              if (s === t) break;
              92 === s
                ? ((e += this.input.slice(i, this.pos)),
                  (e += this.readEscapedChar(!1)),
                  (i = this.pos))
                : 8232 === s || 8233 === s
                ? (this.options.ecmaVersion < 10 &&
                    this.raise(this.start, "Unterminated string constant"),
                  ++this.pos,
                  this.options.locations &&
                    (this.curLine++, (this.lineStart = this.pos)))
                : (isNewLine(s) &&
                    this.raise(this.start, "Unterminated string constant"),
                  ++this.pos);
            }
            return (
              (e += this.input.slice(i, this.pos++)),
              this.finishToken(f.string, e)
            );
          });
        var bt = {};
        (kt.tryReadTemplateToken = function () {
          this.inTemplateElement = !0;
          try {
            this.readTmplToken();
          } catch (t) {
            if (t !== bt) throw t;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = !1;
        }),
          (kt.invalidStringToken = function (t, e) {
            if (this.inTemplateElement && this.options.ecmaVersion >= 9)
              throw bt;
            this.raise(t, e);
          }),
          (kt.readTmplToken = function () {
            for (var t = "", e = this.pos; ; ) {
              this.pos >= this.input.length &&
                this.raise(this.start, "Unterminated template");
              var i = this.input.charCodeAt(this.pos);
              if (
                96 === i ||
                (36 === i && 123 === this.input.charCodeAt(this.pos + 1))
              )
                return this.pos !== this.start ||
                  (this.type !== f.template && this.type !== f.invalidTemplate)
                  ? ((t += this.input.slice(e, this.pos)),
                    this.finishToken(f.template, t))
                  : 36 === i
                  ? ((this.pos += 2), this.finishToken(f.dollarBraceL))
                  : (++this.pos, this.finishToken(f.backQuote));
              if (92 === i)
                (t += this.input.slice(e, this.pos)),
                  (t += this.readEscapedChar(!0)),
                  (e = this.pos);
              else if (isNewLine(i)) {
                switch (((t += this.input.slice(e, this.pos)), ++this.pos, i)) {
                  case 13:
                    10 === this.input.charCodeAt(this.pos) && ++this.pos;
                  case 10:
                    t += "\n";
                    break;
                  default:
                    t += String.fromCharCode(i);
                }
                this.options.locations &&
                  (++this.curLine, (this.lineStart = this.pos)),
                  (e = this.pos);
              } else ++this.pos;
            }
          }),
          (kt.readInvalidTemplateToken = function () {
            for (; this.pos < this.input.length; this.pos++)
              switch (this.input[this.pos]) {
                case "\\":
                  ++this.pos;
                  break;
                case "$":
                  if ("{" !== this.input[this.pos + 1]) break;
                case "`":
                  return this.finishToken(
                    f.invalidTemplate,
                    this.input.slice(this.start, this.pos)
                  );
              }
            this.raise(this.start, "Unterminated template");
          }),
          (kt.readEscapedChar = function (t) {
            var e = this.input.charCodeAt(++this.pos);
            switch ((++this.pos, e)) {
              case 110:
                return "\n";
              case 114:
                return "\r";
              case 120:
                return String.fromCharCode(this.readHexChar(2));
              case 117:
                return codePointToString(this.readCodePoint());
              case 116:
                return "\t";
              case 98:
                return "\b";
              case 118:
                return "\v";
              case 102:
                return "\f";
              case 13:
                10 === this.input.charCodeAt(this.pos) && ++this.pos;
              case 10:
                return (
                  this.options.locations &&
                    ((this.lineStart = this.pos), ++this.curLine),
                  ""
                );
              case 56:
              case 57:
                if (
                  (this.strict &&
                    this.invalidStringToken(
                      this.pos - 1,
                      "Invalid escape sequence"
                    ),
                  t)
                ) {
                  var i = this.pos - 1;
                  this.invalidStringToken(
                    i,
                    "Invalid escape sequence in template string"
                  );
                }
              default:
                if (e >= 48 && e <= 55) {
                  var s = this.input
                      .substr(this.pos - 1, 3)
                      .match(/^[0-7]+/)[0],
                    r = parseInt(s, 8);
                  return (
                    r > 255 && ((s = s.slice(0, -1)), (r = parseInt(s, 8))),
                    (this.pos += s.length - 1),
                    (e = this.input.charCodeAt(this.pos)),
                    ("0" === s && 56 !== e && 57 !== e) ||
                      (!this.strict && !t) ||
                      this.invalidStringToken(
                        this.pos - 1 - s.length,
                        t
                          ? "Octal literal in template string"
                          : "Octal literal in strict mode"
                      ),
                    String.fromCharCode(r)
                  );
                }
                return isNewLine(e) ? "" : String.fromCharCode(e);
            }
          }),
          (kt.readHexChar = function (t) {
            var e = this.pos,
              i = this.readInt(16, t);
            return (
              null === i &&
                this.invalidStringToken(e, "Bad character escape sequence"),
              i
            );
          }),
          (kt.readWord1 = function () {
            this.containsEsc = !1;
            for (
              var t = "",
                e = !0,
                i = this.pos,
                s = this.options.ecmaVersion >= 6;
              this.pos < this.input.length;

            ) {
              var r = this.fullCharCodeAtPos();
              if (isIdentifierChar(r, s)) this.pos += r <= 65535 ? 1 : 2;
              else {
                if (92 !== r) break;
                (this.containsEsc = !0), (t += this.input.slice(i, this.pos));
                var a = this.pos;
                117 !== this.input.charCodeAt(++this.pos) &&
                  this.invalidStringToken(
                    this.pos,
                    "Expecting Unicode escape sequence \\uXXXX"
                  ),
                  ++this.pos;
                var n = this.readCodePoint();
                (e ? isIdentifierStart : isIdentifierChar)(n, s) ||
                  this.invalidStringToken(a, "Invalid Unicode escape"),
                  (t += codePointToString(n)),
                  (i = this.pos);
              }
              e = !1;
            }
            return t + this.input.slice(i, this.pos);
          }),
          (kt.readWord = function () {
            var t = this.readWord1(),
              e = f.name;
            return this.keywords.test(t) && (e = d[t]), this.finishToken(e, t);
          });
        var _t = "8.11.3";
        (T.acorn = {
          Parser: T,
          version: _t,
          defaultOptions: A,
          Position: E,
          SourceLocation: I,
          getLineInfo: getLineInfo,
          Node: Z,
          TokenType: c,
          tokTypes: f,
          keywordTypes: d,
          TokContext: G,
          tokContexts: H,
          isIdentifierChar: isIdentifierChar,
          isIdentifierStart: isIdentifierStart,
          Token: yt,
          isNewLine: isNewLine,
          lineBreak: m,
          lineBreakG: g,
          nonASCIIwhitespace: x,
        }),
          (t.Node = Z),
          (t.Parser = T),
          (t.Position = E),
          (t.SourceLocation = I),
          (t.TokContext = G),
          (t.Token = yt),
          (t.TokenType = c),
          (t.defaultOptions = A),
          (t.getLineInfo = getLineInfo),
          (t.isIdentifierChar = isIdentifierChar),
          (t.isIdentifierStart = isIdentifierStart),
          (t.isNewLine = isNewLine),
          (t.keywordTypes = d),
          (t.lineBreak = m),
          (t.lineBreakG = g),
          (t.nonASCIIwhitespace = x),
          (t.parse = function parse(t, e) {
            return T.parse(t, e);
          }),
          (t.parseExpressionAt = function parseExpressionAt(t, e, i) {
            return T.parseExpressionAt(t, e, i);
          }),
          (t.tokContexts = H),
          (t.tokTypes = f),
          (t.tokenizer = function tokenizer(t, e) {
            return T.tokenizer(t, e);
          }),
          (t.version = _t);
      }),
      "object" == typeof t && void 0 !== i
        ? o(t)
        : "function" == typeof define && define.amd
        ? define(["exports"], o)
        : o(
            ((n =
              "undefined" != typeof globalThis ? globalThis : n || self).acorn =
              {})
          );
  },
  "internal/deps/cjs-module-lexer/dist/lexer": function (A, Q, g, I, D, N) {
    "use strict";
    let k;
    (A.parse = function parse(A, Q = "@") {
      if (!k) throw new Error("Not initialized");
      const g = A.length + 1,
        I =
          (k.__heap_base.value || k.__heap_base) +
          4 * g -
          k.memory.buffer.byteLength;
      I > 0 && k.memory.grow(Math.ceil(I / 65536));
      const D = k.sa(g);
      if (
        ((w ? C : E)(A, new Uint16Array(k.memory.buffer, D, g)),
        !k.parseCJS(D, A.length, 0, 0, 0))
      )
        throw Object.assign(
          new Error(
            `Parse error ${Q}${k.e()}:${A.slice(0, k.e()).split("\n").length}:${
              k.e() - A.lastIndexOf("\n", k.e() - 1)
            }`
          ),
          { idx: k.e() }
        );
      let N = new Set(),
        o = new Set(),
        J = new Set();
      for (; k.rre(); ) {
        const Q = B(A.slice(k.res(), k.ree()));
        Q && o.add(Q);
      }
      for (; k.ru(); ) J.add(B(A.slice(k.us(), k.ue())));
      for (; k.re(); ) {
        let Q = B(A.slice(k.es(), k.ee()));
        void 0 === Q || J.has(Q) || N.add(Q);
      }
      return { exports: [...N], reexports: [...o] };
    }),
      (A.init = function init() {
        return (
          o ||
          (o = (async () => {
            const A = await WebAssembly.compile(
              ((Q =
                "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EBENACACLwEAQS5HDQELQQAgAkESajYCvKABAkAgAi8BEiIDQdMARw0AIAIvARRB9ABHDQEgAi8BFkHhAEcNASACLwEYQfIARw0BQQAgAkEaajYCvKABIAIvARohAwsgA0H//wNxQShHDQBBACgCsKABQQAoAoxANgIAQQBBATsBhkBBAEEAKAK8oAEiAkECajYCvKABIAIvAQJB8gBHDQBBAhAQGgtBAEEAKAK8oAE2AoxADAELAkAgAkEEakHtAEHwAEHvAEHyAEH0ABATRQ0AIAAQEUUNABAkQQAoArygASEAC0EAIAA2AoxAC0EAKALAoAEhA0EAKAK8oAEhAgwACwsgAgv3AQEEf0EAIQECQEEAKAK8oAEiAkECakHlAEHxAEH1AEHpAEHyAEHlABAmRQ0AQQAhAUEAIAJBDmo2ArygAQJAECdBKEcNAEEAQQAoArygAUECajYCvKABECchA0EAKAK8oAEhBAJAIANBJ0YNACADQSJHDQELIAMQHEEAQQAoArygAUECaiIDNgK8oAEQJ0EpRw0AAkAgAEF/aiIBQQFLDQACQAJAIAEOAgEAAQsgBCADQQAoAqAfEQAAQQEPCyAEIANBACgCoB8RAABBAQ8LQQAoArSgASAENgIAQQAoArSgASADNgIEQQEPC0EAIAI2ArygAQsgAQsdAAJAQQAoApgfIABHDQBBAQ8LIABBfmovAQAQJQv+AgEEf0EAKAKYHyEBAkADQCAAQX5qIQIgAC8BACIDQSBHDQEgACABSyEEIAIhACAEDQALCwJAIANBPUcNAAJAA0AgAkF+aiEAIAIvAQBBIEcNASACIAFLIQQgACECIAQNAAsLIABBAmohAiAAQQRqIQNBACEEAkADQCACECghACACIAFNDQEgAEUNASAAQdwARg0CIAAQKUUNASACQX5BfCAAQYCABEkbaiECIAAQKiEEDAALCyAEQQFxRQ0AIAIvAQBBIEcNAEEAKAK0oAEiBEEAKAKwH0YNACAEIAM2AgwgBCACQQJqNgIIIAJBfmohAEEgIQICQANAIABBAmogAU0NASACQf//A3FBIEcNASAALwEAIQIgAEF+aiEADAALCyACQf//A3FBjn9qIgJBAksNAAJAAkACQCACDgMAAwEACyAAQfYAQeEAECsNAQwCCyAAQewAQeUAECsNACAAQeMAQe8AQe4AQfMAECxFDQELQQAgBEEQajYCtKABCws/AQF/QQAhBgJAIAAvAQAgAUcNACAALwECIAJHDQAgAC8BBCADRw0AIAAvAQYgBEcNACAALwEIIAVGIQYLIAYLpCYBCH9BAEEAKAK8oAEiAUEMajYCvKABIAFBCmohAQJAECdBLkcNAEEAQQAoArygAUECajYCvKABAkACQBAnIgJB5ABHDQBBACgCvKABIgBBAmpB5QBB5gBB6QBB7gBB5QBB0ABB8gBB7wBB8ABB5QBB8gBB9ABB+QAQL0UNAkEAIABBHGo2ArygASAAQRpqIQEQJ0EoRw0CQQBBACgCvKABQQJqNgK8oAEQJxAwRQ0CECdBLEcNAkEAQQAoArygAUECajYCvKABAkAQJyIAQSdGDQAgAEEiRw0DC0EAKAK8oAEhAiAAEBxBAEEAKAK8oAFBAmoiADYCvKABECdBLEcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygAQJAECciA0HlAEcNAEEAKAK8oAEiA0ECakHuAEH1AEHtAEHlAEHyAEHhAEHiAEHsAEHlABAxRQ0CQQAgA0EUajYCvKABECdBOkcNAkEAQQAoArygAUECajYCvKABECdB9ABHDQJBACgCvKABIgMvAQJB8gBHDQIgAy8BBEH1AEcNAiADLwEGQeUARw0CQQAgA0EIajYCvKABECdBLEcNAkEAQQAoArygAUECajYCvKABECchAwsCQCADQecARg0AIANB9gBHDQJBACgCvKABIgMvAQJB4QBHDQIgAy8BBEHsAEcNAiADLwEGQfUARw0CIAMvAQhB5QBHDQJBACADQQpqNgK8oAEQJ0E6Rw0CIAIgAEEAKAKcHxEAAEEAIAE2ArygAQ8LQQAoArygASIDLwECQeUARw0BIAMvAQRB9ABHDQFBACADQQZqNgK8oAECQBAnIgNBOkcNAEEAQQAoArygAUECajYCvKABECdB5gBHDQJBACgCvKABIgNBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNAkEAIANBEGoiAzYCvKABAkAQJyIEQShGDQAgA0EAKAK8oAFGDQMgBBAtRQ0DCxAnIQMLIANBKEcNAUEAQQAoArygAUECajYCvKABECdBKUcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygARAnQfIARw0BQQAoArygASIDQQJqQeUAQfQAQfUAQfIAQe4AEBNFDQFBACADQQxqNgK8oAEQJxAtRQ0BAkACQAJAECciA0HbAEYNACADQS5HDQJBAEEAKAK8oAFBAmo2ArygARAnEC0NAQwEC0EAQQAoArygAUECajYCvKABAkAQJyIDQSdGDQAgA0EiRw0ECyADEBxBAEEAKAK8oAFBAmo2ArygARAnQd0ARw0DQQBBACgCvKABQQJqNgK8oAELECchAwsCQCADQTtHDQBBAEEAKAK8oAFBAmo2ArygARAnIQMLIANB/QBHDQFBAEEAKAK8oAFBAmo2ArygAQJAECciA0EsRw0AQQBBACgCvKABQQJqNgK8oAEQJyEDCyADQf0ARw0BQQBBACgCvKABQQJqNgK8oAEQJ0EpRw0BIAIgAEEAKAKcHxEAAA8LIAJB6wBHDQEgAEUNAUEAKAK8oAEiAC8BAkHlAEcNASAALwEEQfkARw0BIAAvAQZB8wBHDQEgAEEGaiEBQQAgAEEIajYCvKABECdBKEcNAUEAQQAoArygAUECajYCvKABECchAEEAKAK8oAEhAiAAEC1FDQFBACgCvKABIQAQJ0EpRw0BQQBBACgCvKABIgFBAmo2ArygARAnQS5HDQFBAEEAKAK8oAFBAmo2ArygARAnQeYARw0BQQAoArygASIDQQJqQe8AQfIAQcUAQeEAQeMAQegAECZFDQFBACADQQ5qNgK8oAEQJyEDQQAoArygASIEQX5qIQEgA0EoRw0BQQAgBEECajYCvKABECdB5gBHDQFBACgCvKABIgNBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNAUEAIANBEGo2ArygARAnQShHDQFBAEEAKAK8oAFBAmo2ArygARAnIQNBACgCvKABIQQgAxAtRQ0BQQAoArygASEDECdBKUcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygARAnQekARw0BQQAoArygASIFLwECQeYARw0BQQAgBUEEajYCvKABECdBKEcNAUEAQQAoArygAUECajYCvKABECcaQQAoArygASIFIAQgAyAEayIDEEENASAAIAJrIgZBAXUhB0EAIAUgA0EBdSIIQQF0ajYCvKAB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ASADLwEGQQpGGyEBDAALC0EAIAE2ArygARAdDwtBACABNgK8oAELOAEBf0EAQQE6APAfQQAoArygASEAQQBBACgCwKABQQJqNgK8oAFBACAAQQAoApgfa0EBdTYC7B8LzgEBBX9BACgCvKABIQBBACgCwKABIQEDQCAAIgJBAmohAAJAAkAgAiABTw0AIAAvAQAiA0Gkf2oiBEEETQ0BIANBJEcNAiACLwEEQfsARw0CQQBBAC8BhEAiAEEBajsBhEBBACgCoGAgAEEBdGpBAC8BiEA7AQBBACACQQRqNgK8oAFBAEEALwGGQEEBaiIAOwGIQEEAIAA7AYZADwtBACAANgK8oAEQHQ8LAkACQCAEDgUBAgICAAELQQAgADYCvKABDwsgAkEEaiEADAALC7YCAQJ/QQBBACgCvKABIgFBDmo2ArygAQJAAkACQBAnIgJB2wBGDQAgAkE9Rg0BIAJBLkcNAkEAQQAoArygAUECajYCvKABECchAkEAKAK8oAEhACACEC1FDQJBACgCvKABIQIQJ0E9Rw0CIAAgAkEAKAKcHxEAAA8LQQBBACgCvKABQQJqNgK8oAECQBAnIgJBJ0YNACACQSJHDQILQQAoArygASEAIAIQHEEAQQAoArygAUECaiICNgK8oAEQJ0HdAEcNAUEAQQAoArygAUECajYCvKABECdBPUcNASAAIAJBACgCnB8RAAAMAQsgAEUNAEEAKAKoHxEBAEEAQQAoArygAUECajYCvKABAkAQJyICQfIARg0AIAJB+wBHDQEQLg8LQQEQEBoLQQAgAUEMajYCvKABCzYBAn9BAEEAKAK8oAFBDGoiADYCvKABECchAQJAAkBBACgCvKABIABHDQAgARA/RQ0BCxAdCwtsAQF/QQBBACgCvKABIgBBDGo2ArygAQJAECdBLkcNAEEAQQAoArygAUECajYCvKABECdB5QBHDQBBACgCvKABQQJqQfgAQfAAQe8AQfIAQfQAQfMAECZFDQBBARAfDwtBACAAQQpqNgK8oAEL6QEBAX9BACEXAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRw0AIAAvAQ4gCEcNACAALwEQIAlHDQAgAC8BEiAKRw0AIAAvARQgC0cN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ACAALwEUIAtHDQAgAC8BFiAMRw0AIAAvARggDUYhDgsgDguoAQECf0EAIQFBACgCvKABIQICQAJAIABB7QBHDQAgAkECakHvAEHkAEH1AEHsAEHlABATRQ0BQQAgAkEMajYCvKABAkAQJ0EuRg0AQQAhAQwCC0EAQQAoArygAUECajYCvKABECchAAsgAEHlAEcNAEEAKAK8oAEiAEEOaiACIABBAmpB+ABB8ABB7wBB8gBB9ABB8wAQJiIBGyECC0EAIAI2ArygASABC2cBAX9BACEKAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRw0AIAAvAQ4gCEcNACAALwEQIAlGIQoLIAoLcQEBf0EAIQsCQCAALwEAIAFHDQAgAC8BAiACRw0AIAAvAQQgA0cNACAALwEGIARHDQAgAC8BCCAFRw0AIAAvAQogBkcNACAALwEMIAdHDQAgAC8BDiAIRw0AIAAvARAgCUcNACAALwESIApGIQsLIAsLgwQBAn9BACECAkAQJ0HPAEcNAEEAIQJBACgCvKABIgNBAmpB4gBB6gBB5QBB4wBB9AAQE0UNAEEAIQJBACADQQxqNgK8oAEQJ0EuRw0AQQBBACgCvKABQQJqNgK8oAECQBAnIgNB8ABHDQBBACECQQAoArygASIDQQJqQfIAQe8AQfQAQe8AQfQAQfkAQfAAQeUAED1FDQFBACECQQAgA0ESajYCvKABECdBLkcNAUEAQQAoArygAUECajYCvKABECchAwtBACECIANB6ABHDQBBACECQQAoArygASIDQQJqQeEAQfMAQc8AQfcAQe4AQdAAQfIAQe8AQfAAQeUAQfIAQfQAQfkAEC9FDQBBACECQQAgA0EcajYCvKABECdBLkcNAEEAIQJBAEEAKAK8oAFBAmo2ArygARAnQeMARw0AQQAhAkEAKAK8oAEiAy8BAkHhAEcNACADLwEEQewARw0AIAMvAQZB7ABHDQBBACECQQAgA0EIajYCvKABECdBKEcNAEEAIQJBAEEAKAK8oAFBAmo2ArygARAnEC1FDQAQJ0EsRw0AQQAhAkEAQQAoArygAUECajYCvKABECcaQQAoArygASIDIAAgAUEBdCIBEEENAEEAIQJBACAD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"),
              "undefined" != typeof window && "function" == typeof atob
                ? Uint8Array.from(atob(Q), (A) => A.charCodeAt(0))
                : Buffer.from(Q, "base64"))
            );
            var Q;
            const { exports: g } = await WebAssembly.instantiate(A);
            k = g;
          })())
        );
      });
    const w = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
    function B(A) {
      if ('"' !== A[0] && "'" !== A[0]) return A;
      try {
        const Q = (0, eval)(A);
        for (let A = 0; A < Q.length; A++) {
          const g = 64512 & Q.charCodeAt(A);
          if (!(g < 55296)) {
            if (55296 !== g) return;
            if (56320 != (64512 & Q.charCodeAt(++A))) return;
          }
        }
        return Q;
      } catch {}
    }
    function E(A, Q) {
      const g = A.length;
      let I = 0;
      for (; I < g; ) {
        const g = A.charCodeAt(I);
        Q[I++] = ((255 & g) << 8) | (g >>> 8);
      }
    }
    function C(A, Q) {
      const g = A.length;
      let I = 0;
      for (; I < g; ) Q[I] = A.charCodeAt(I++);
    }
    let o;
  },
  "internal/deps/cjs-module-lexer/lexer": function (e, t, r, i, c, a) {
    let s, n, o, h, m, f, d, p, W, u, l, b, k, w, C, A, g;
    function resetState() {
      (h = 0),
        (m = -1),
        (f = -1),
        (d = !1),
        (p = new Array(1024)),
        (W = 0),
        (u = new Array(1024)),
        (l = new Array(1024)),
        (b = !1),
        (k = Object.create(null)),
        (w = null),
        (C = new Set()),
        (A = new Set()),
        (g = new Set());
    }
    const y = 0,
      P = 1,
      x = 2;
    function decode(e) {
      if ('"' !== e[0] && "'" !== e[0]) return e;
      try {
        const t = (0, eval)(e);
        for (let e = 0; e < t.length; e++) {
          const r = 64512 & t.charCodeAt(e);
          if (!(r < 55296)) {
            if (55296 !== r) return;
            if (56320 != (64512 & t.charCodeAt(++e))) return;
          }
        }
        return t;
      } catch {}
    }
    function tryBacktrackAddStarExportBinding(e) {
      for (; 32 === s.charCodeAt(e) && e >= 0; ) e--;
      if (61 === s.charCodeAt(e)) {
        for (e--; 32 === s.charCodeAt(e) && e >= 0; ) e--;
        let t;
        const r = e;
        let i = !1;
        for (; (t = codePointAtLast(e)) && e >= 0; ) {
          if (92 === t) return;
          if (!isIdentifierChar(t, !0)) break;
          (i = isIdentifierStart(t, !0)), (e -= codePointLen(t));
        }
        if (i && 32 === s.charCodeAt(e)) {
          const t = s.slice(e + 1, r + 1);
          for (; 32 === s.charCodeAt(e) && e >= 0; ) e--;
          switch (s.charCodeAt(e)) {
            case 114:
              if (!s.startsWith("va", e - 2)) return;
              break;
            case 116:
              if (!s.startsWith("le", e - 2) && !s.startsWith("cons", e - 4))
                return;
              break;
            default:
              return;
          }
          k[t] = w;
        }
      }
    }
    function tryParseObjectHasOwnProperty(e) {
      if (
        ((ch = commentWhitespace()), 79 !== ch || !s.startsWith("bject", n + 1))
      )
        return !1;
      if (((n += 6), (ch = commentWhitespace()), 46 !== ch)) return !1;
      if ((n++, (ch = commentWhitespace()), 112 === ch)) {
        if (!s.startsWith("rototype", n + 1)) return !1;
        if (((n += 9), (ch = commentWhitespace()), 46 !== ch)) return !1;
        n++, (ch = commentWhitespace());
      }
      return (
        !(104 !== ch || !s.startsWith("asOwnProperty", n + 1)) &&
        ((n += 14),
        (ch = commentWhitespace()),
        46 === ch &&
          (n++,
          (ch = commentWhitespace()),
          !(99 !== ch || !s.startsWith("all", n + 1)) &&
            ((n += 4),
            (ch = commentWhitespace()),
            40 === ch &&
              (n++,
              (ch = commentWhitespace()),
              !!identifier() &&
                ((ch = commentWhitespace()),
                44 === ch &&
                  (n++,
                  (ch = commentWhitespace()),
                  !!s.startsWith(e, n) &&
                    ((n += e.length),
                    (ch = commentWhitespace()),
                    41 === ch && (n++, !0))))))))
      );
    }
    function tryParseObjectDefineOrKeys(e) {
      n += 6;
      let t = n - 1,
        r = commentWhitespace();
      if (46 === r)
        if (
          (n++,
          (r = commentWhitespace()),
          100 === r && s.startsWith("efineProperty", n + 1))
        ) {
          let e;
          for (
            ;
            (n += 14),
              (t = n - 1),
              (r = commentWhitespace()),
              40 === r &&
                (n++,
                (r = commentWhitespace()),
                readExportsOrModuleDotExports(r)) &&
                ((r = commentWhitespace()), 44 === r) &&
                (n++, (r = commentWhitespace()), 39 === r || 34 === r);

          ) {
            const i = n;
            if (
              (stringLiteral(r),
              (e = s.slice(i, ++n)),
              (r = commentWhitespace()),
              44 !== r)
            )
              break;
            if ((n++, (r = commentWhitespace()), 123 !== r)) break;
            if ((n++, (r = commentWhitespace()), 101 === r)) {
              if (!s.startsWith("numerable", n + 1)) break;
              if (((n += 10), (r = commentWhitespace()), 58 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                116 !== r || !s.startsWith("rue", n + 1))
              )
                break;
              if (((n += 4), (r = commentWhitespace()), 44 !== r)) break;
              n++, (r = commentWhitespace());
            }
            if (118 === r) {
              if (!s.startsWith("alue", n + 1)) break;
              if (((n += 5), (r = commentWhitespace()), 58 !== r)) break;
              return C.add(decode(e)), void (n = t);
            }
            if (103 === r) {
              if (!s.startsWith("et", n + 1)) break;
              if (((n += 3), (r = commentWhitespace()), 58 === r)) {
                if ((n++, (r = commentWhitespace()), 102 !== r)) break;
                if (!s.startsWith("unction", n + 1)) break;
                n += 8;
                let e = n;
                if (
                  ((r = commentWhitespace()),
                  40 !== r && (e === n || !identifier()))
                )
                  break;
                r = commentWhitespace();
              }
              if (40 !== r) break;
              if ((n++, (r = commentWhitespace()), 41 !== r)) break;
              if ((n++, (r = commentWhitespace()), 123 !== r)) break;
              if ((n++, (r = commentWhitespace()), 114 !== r)) break;
              if (!s.startsWith("eturn", n + 1)) break;
              if (((n += 6), (r = commentWhitespace()), !identifier())) break;
              if (((r = commentWhitespace()), 46 === r)) {
                if ((n++, commentWhitespace(), !identifier())) break;
                r = commentWhitespace();
              } else if (91 === r) {
                if ((n++, (r = commentWhitespace()), 39 !== r && 34 !== r))
                  break;
                if (
                  (stringLiteral(r), n++, (r = commentWhitespace()), 93 !== r)
                )
                  break;
                n++, (r = commentWhitespace());
              }
              if ((59 === r && (n++, (r = commentWhitespace())), 125 !== r))
                break;
              if (
                (n++,
                (r = commentWhitespace()),
                44 === r && (n++, (r = commentWhitespace())),
                125 !== r)
              )
                break;
              if ((n++, (r = commentWhitespace()), 41 !== r)) break;
              return void C.add(decode(e));
            }
            break;
          }
          e && A.add(decode(e));
        } else if (e && 107 === r && s.startsWith("eys", n + 1))
          for (; (n += 4), (t = n - 1), (r = commentWhitespace()), 40 === r; ) {
            n++, (r = commentWhitespace());
            const e = n;
            if (!identifier()) break;
            const i = s.slice(e, n);
            if (((r = commentWhitespace()), 41 !== r)) break;
            if (((t = n++), (r = commentWhitespace()), 46 !== r)) break;
            if (
              (n++,
              (r = commentWhitespace()),
              102 !== r || !s.startsWith("orEach", n + 1))
            )
              break;
            if (((n += 7), (r = commentWhitespace()), (t = n - 1), 40 !== r))
              break;
            if (
              (n++,
              (r = commentWhitespace()),
              102 !== r || !s.startsWith("unction", n + 1))
            )
              break;
            if (((n += 8), (r = commentWhitespace()), 40 !== r)) break;
            n++, (r = commentWhitespace());
            const c = n;
            if (!identifier()) break;
            const a = s.slice(c, n);
            if (((r = commentWhitespace()), 41 !== r)) break;
            if ((n++, (r = commentWhitespace()), 123 !== r)) break;
            if (
              (n++,
              (r = commentWhitespace()),
              105 !== r || 102 !== s.charCodeAt(n + 1))
            )
              break;
            if (((n += 2), (r = commentWhitespace()), 40 !== r)) break;
            if ((n++, (r = commentWhitespace()), !s.startsWith(a, n))) break;
            if (((n += a.length), (r = commentWhitespace()), 61 === r)) {
              if (!s.startsWith("==", n + 1)) break;
              if (((n += 3), (r = commentWhitespace()), 34 !== r && 39 !== r))
                break;
              let e = r;
              if (!s.startsWith("default", n + 1)) break;
              if (((n += 8), (r = commentWhitespace()), r !== e)) break;
              if (
                ((n += 1),
                (r = commentWhitespace()),
                124 !== r || 124 !== s.charCodeAt(n + 1))
              )
                break;
              if (
                ((n += 2),
                (r = commentWhitespace()),
                s.slice(n, n + a.length) !== a)
              )
                break;
              if (
                ((n += a.length),
                (r = commentWhitespace()),
                61 !== r || "==" !== s.slice(n + 1, n + 3))
              )
                break;
              if (((n += 3), (r = commentWhitespace()), 34 !== r && 39 !== r))
                break;
              if (((e = r), !s.startsWith("__esModule", n + 1))) break;
              if (((n += 11), (r = commentWhitespace()), r !== e)) break;
              if (((n += 1), (r = commentWhitespace()), 41 !== r)) break;
              if (
                ((n += 1),
                (r = commentWhitespace()),
                114 !== r || !s.startsWith("eturn", n + 1))
              )
                break;
              if (
                ((n += 6),
                (r = commentWhitespace()),
                59 === r && n++,
                (r = commentWhitespace()),
                105 === r && 102 === s.charCodeAt(n + 1))
              ) {
                let e = !0;
                if (((n += 2), (r = commentWhitespace()), 40 !== r)) break;
                n++;
                const t = n;
                if (tryParseObjectHasOwnProperty(a)) {
                  if (((r = commentWhitespace()), 41 !== r)) break;
                  if (
                    (n++,
                    (r = commentWhitespace()),
                    114 !== r || !s.startsWith("eturn", n + 1))
                  )
                    break;
                  if (
                    ((n += 6),
                    (r = commentWhitespace()),
                    59 === r && n++,
                    (r = commentWhitespace()),
                    105 === r && 102 === s.charCodeAt(n + 1))
                  ) {
                    if (((n += 2), (r = commentWhitespace()), 40 !== r)) break;
                    n++;
                  } else e = !1;
                } else n = t;
                if (e) {
                  if (!s.startsWith(a, n)) break;
                  if (
                    ((n += a.length),
                    (r = commentWhitespace()),
                    105 !== r || !s.startsWith("n ", n + 1))
                  )
                    break;
                  if (
                    ((n += 3),
                    (r = commentWhitespace()),
                    !readExportsOrModuleDotExports(r))
                  )
                    break;
                  if (
                    ((r = commentWhitespace()),
                    38 !== r || 38 !== s.charCodeAt(n + 1))
                  )
                    break;
                  if (
                    ((n += 2),
                    (r = commentWhitespace()),
                    !readExportsOrModuleDotExports(r))
                  )
                    break;
                  if (((r = commentWhitespace()), 91 !== r)) break;
                  if ((n++, (r = commentWhitespace()), !s.startsWith(a, n)))
                    break;
                  if (((n += a.length), (r = commentWhitespace()), 93 !== r))
                    break;
                  if (
                    (n++,
                    (r = commentWhitespace()),
                    61 !== r || !s.startsWith("==", n + 1))
                  )
                    break;
                  if (
                    ((n += 3), (r = commentWhitespace()), !s.startsWith(i, n))
                  )
                    break;
                  if (((n += i.length), (r = commentWhitespace()), 91 !== r))
                    break;
                  if ((n++, (r = commentWhitespace()), !s.startsWith(a, n)))
                    break;
                  if (((n += a.length), (r = commentWhitespace()), 93 !== r))
                    break;
                  if ((n++, (r = commentWhitespace()), 41 !== r)) break;
                  if (
                    (n++,
                    (r = commentWhitespace()),
                    114 !== r || !s.startsWith("eturn", n + 1))
                  )
                    break;
                  (n += 6),
                    (r = commentWhitespace()),
                    59 === r && n++,
                    (r = commentWhitespace());
                }
              }
            } else {
              if (33 !== r) break;
              {
                if (!s.startsWith("==", n + 1)) break;
                if (((n += 3), (r = commentWhitespace()), 34 !== r && 39 !== r))
                  break;
                const e = r;
                if (!s.startsWith("default", n + 1)) break;
                if (((n += 8), (r = commentWhitespace()), r !== e)) break;
                if (((n += 1), (r = commentWhitespace()), 38 === r)) {
                  if (38 !== s.charCodeAt(n + 1)) break;
                  if (((n += 2), (r = commentWhitespace()), 33 !== r)) break;
                  if (
                    ((n += 1),
                    (r = commentWhitespace()),
                    79 === r &&
                      s.startsWith("bject", n + 1) &&
                      "." === s[n + 6])
                  ) {
                    if (!tryParseObjectHasOwnProperty(a)) break;
                  } else {
                    if (!identifier()) break;
                    if (((r = commentWhitespace()), 46 !== r)) break;
                    if (
                      (n++,
                      (r = commentWhitespace()),
                      104 !== r || !s.startsWith("asOwnProperty", n + 1))
                    )
                      break;
                    if (((n += 14), (r = commentWhitespace()), 40 !== r)) break;
                    if (
                      ((n += 1), (r = commentWhitespace()), !s.startsWith(a, n))
                    )
                      break;
                    if (((n += a.length), (r = commentWhitespace()), 41 !== r))
                      break;
                    n += 1;
                  }
                  r = commentWhitespace();
                }
                if (41 !== r) break;
                (n += 1), (r = commentWhitespace());
              }
            }
            if (readExportsOrModuleDotExports(r)) {
              if (((r = commentWhitespace()), 91 !== r)) break;
              if (
                (n++, (r = commentWhitespace()), s.slice(n, n + a.length) !== a)
              )
                break;
              if (((n += a.length), (r = commentWhitespace()), 93 !== r)) break;
              if ((n++, (r = commentWhitespace()), 61 !== r)) break;
              if (
                (n++, (r = commentWhitespace()), s.slice(n, n + i.length) !== i)
              )
                break;
              if (((n += i.length), (r = commentWhitespace()), 91 !== r)) break;
              if (
                (n++, (r = commentWhitespace()), s.slice(n, n + a.length) !== a)
              )
                break;
              if (((n += a.length), (r = commentWhitespace()), 93 !== r)) break;
              n++,
                (r = commentWhitespace()),
                59 === r && (n++, (r = commentWhitespace()));
            } else {
              if (79 !== r) break;
              if ("bject" !== s.slice(n + 1, n + 6)) break;
              if (((n += 6), (r = commentWhitespace()), 46 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                100 !== r || !s.startsWith("efineProperty", n + 1))
              )
                break;
              if (((n += 14), (r = commentWhitespace()), 40 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                !readExportsOrModuleDotExports(r))
              )
                break;
              if (((r = commentWhitespace()), 44 !== r)) break;
              if ((n++, (r = commentWhitespace()), !s.startsWith(a, n))) break;
              if (((n += a.length), (r = commentWhitespace()), 44 !== r)) break;
              if ((n++, (r = commentWhitespace()), 123 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                101 !== r || !s.startsWith("numerable", n + 1))
              )
                break;
              if (((n += 10), (r = commentWhitespace()), 58 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                116 !== r && !s.startsWith("rue", n + 1))
              )
                break;
              if (((n += 4), (r = commentWhitespace()), 44 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                103 !== r || !s.startsWith("et", n + 1))
              )
                break;
              if (((n += 3), (r = commentWhitespace()), 58 === r)) {
                if ((n++, (r = commentWhitespace()), 102 !== r)) break;
                if (!s.startsWith("unction", n + 1)) break;
                n += 8;
                let e = n;
                if (
                  ((r = commentWhitespace()),
                  40 !== r && (e === n || !identifier()))
                )
                  break;
                r = commentWhitespace();
              }
              if (40 !== r) break;
              if ((n++, (r = commentWhitespace()), 41 !== r)) break;
              if ((n++, (r = commentWhitespace()), 123 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                114 !== r || !s.startsWith("eturn", n + 1))
              )
                break;
              if (((n += 6), (r = commentWhitespace()), !s.startsWith(i, n)))
                break;
              if (((n += i.length), (r = commentWhitespace()), 91 !== r)) break;
              if ((n++, (r = commentWhitespace()), !s.startsWith(a, n))) break;
              if (((n += a.length), (r = commentWhitespace()), 93 !== r)) break;
              if (
                (n++,
                (r = commentWhitespace()),
                59 === r && (n++, (r = commentWhitespace())),
                125 !== r)
              )
                break;
              if (
                (n++,
                (r = commentWhitespace()),
                44 === r && (n++, (r = commentWhitespace())),
                125 !== r)
              )
                break;
              if ((n++, (r = commentWhitespace()), 41 !== r)) break;
              n++,
                (r = commentWhitespace()),
                59 === r && (n++, (r = commentWhitespace()));
            }
            if (125 !== r) break;
            if ((n++, (r = commentWhitespace()), 41 !== r)) break;
            const o = k[i];
            return o ? (g.add(decode(o)), void (n = t)) : void 0;
          }
      n = t;
    }
    function readExportsOrModuleDotExports(e) {
      const t = n;
      if (109 === e && s.startsWith("odule", n + 1)) {
        if (((n += 6), 46 !== (e = commentWhitespace()))) return (n = t), !1;
        n++, (e = commentWhitespace());
      }
      return 101 === e && s.startsWith("xports", n + 1)
        ? ((n += 7), !0)
        : ((n = t), !1);
    }
    function tryParseModuleExportsDotAssign() {
      n += 6;
      const e = n - 1;
      let t = commentWhitespace();
      46 === t &&
      (n++,
      (t = commentWhitespace()),
      101 === t && s.startsWith("xports", n + 1))
        ? tryParseExportsDotAssign(!0)
        : (n = e);
    }
    function tryParseExportsDotAssign(e) {
      n += 7;
      const t = n - 1;
      let r = commentWhitespace();
      switch (r) {
        case 46: {
          n++, (r = commentWhitespace());
          const e = n;
          if (identifier()) {
            const t = n;
            if (((r = commentWhitespace()), 61 === r))
              return void C.add(decode(s.slice(e, t)));
          }
          break;
        }
        case 91:
          if ((n++, (r = commentWhitespace()), 39 === r || 34 === r)) {
            const e = n;
            stringLiteral(r);
            const t = ++n;
            if (((r = commentWhitespace()), 93 !== r)) break;
            if ((n++, (r = commentWhitespace()), 61 !== r)) break;
            C.add(decode(s.slice(e, t)));
          }
          break;
        case 61:
          if (e) {
            if (
              (g.size && (g = new Set()),
              n++,
              (r = commentWhitespace()),
              123 === r)
            )
              return void (function tryParseLiteralExports() {
                const e = n - 1;
                for (; n++ < o; ) {
                  let t = commentWhitespace();
                  const r = n;
                  if (identifier()) {
                    const i = n;
                    if (((t = commentWhitespace()), 58 === t)) {
                      if ((n++, (t = commentWhitespace()), !identifier()))
                        return void (n = e);
                      t = s.charCodeAt(n);
                    }
                    C.add(decode(s.slice(r, i)));
                  } else if (46 === t && s.startsWith("..", n + 1)) {
                    if (
                      ((n += 3), 114 === s.charCodeAt(n) && tryParseRequire(P))
                    )
                      n++;
                    else if (!identifier()) return void (n = e);
                    t = commentWhitespace();
                  } else {
                    if (39 !== t && 34 !== t) return void (n = e);
                    {
                      const r = n;
                      stringLiteral(t);
                      const i = ++n;
                      if (((t = commentWhitespace()), 58 === t)) {
                        if ((n++, (t = commentWhitespace()), !identifier()))
                          return void (n = e);
                        (t = s.charCodeAt(n)), C.add(decode(s.slice(r, i)));
                      }
                    }
                  }
                  if (125 === t) return;
                  if (44 !== t) return void (n = e);
                }
              })();
            114 === r && tryParseRequire(P);
          }
      }
      n = t;
    }
    function tryParseRequire(e) {
      const t = n;
      if (s.startsWith("equire", n + 1)) {
        n += 7;
        let r = commentWhitespace();
        if (40 === r) {
          n++, (r = commentWhitespace());
          const t = n;
          if (39 === r || 34 === r) {
            stringLiteral(r);
            const i = ++n;
            if (((r = commentWhitespace()), 41 === r))
              switch (e) {
                case P:
                case x:
                  return g.add(decode(s.slice(t, i))), !0;
                default:
                  return (w = decode(s.slice(t, i))), !0;
              }
          }
        }
        n = t;
      }
      return !1;
    }
    let E =
        "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
      S =
        "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
    const O = new RegExp("[" + E + "]"),
      v = new RegExp("[" + E + S + "]");
    E = S = null;
    const K = [
        0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
        48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
        5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1,
        4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
        65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
        11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
        11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3,
        0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0,
        2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0,
        19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42,
        3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0,
        3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11,
        39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29,
        113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0,
        80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30,
        114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
        65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395,
        2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3,
        2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4,
        6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2,
        30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8,
        0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0,
        2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0,
        3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421,
        42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938,
      ],
      D = [
        509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
        1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10,
        54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83,
        11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3,
        6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83,
        16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3,
        3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10,
        10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2,
        6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6,
        26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9,
        7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2,
        14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6,
        110, 6, 6, 9, 4759, 9, 787719, 239,
      ];
    function isInAstralSet(e, t) {
      let r = 65536;
      for (let i = 0; i < t.length; i += 2) {
        if (((r += t[i]), r > e)) return !1;
        if (((r += t[i + 1]), r >= e)) return !0;
      }
    }
    function isIdentifierStart(e, t) {
      return e < 65
        ? 36 === e
        : e < 91 ||
            (e < 97
              ? 95 === e
              : e < 123 ||
                (e <= 65535
                  ? e >= 170 && O.test(String.fromCharCode(e))
                  : !1 !== t && isInAstralSet(e, K)));
    }
    function isIdentifierChar(e, t) {
      return e < 48
        ? 36 === e
        : e < 58 ||
            (!(e < 65) &&
              (e < 91 ||
                (e < 97
                  ? 95 === e
                  : e < 123 ||
                    (e <= 65535
                      ? e >= 170 && v.test(String.fromCharCode(e))
                      : !1 !== t &&
                        (isInAstralSet(e, K) || isInAstralSet(e, D))))));
    }
    function identifier() {
      let e = s.codePointAt(n);
      if (!isIdentifierStart(e, !0) || "\\" === e) return !1;
      for (n += codePointLen(e); (e = s.codePointAt(n)); ) {
        if (!isIdentifierChar(e, !0)) {
          if ("\\" === e) return !1;
          break;
        }
        n += codePointLen(e);
      }
      return !0;
    }
    function codePointLen(e) {
      return e < 65536 ? 1 : 2;
    }
    function codePointAtLast(e) {
      const t = s.charCodeAt(e);
      return 56320 == (64512 & t)
        ? 65536 + (((1023 & s.charCodeAt(e - 1)) << 10) | (1023 & t))
        : t;
    }
    function throwIfImportStatement() {
      const e = n;
      n += 6;
      switch (commentWhitespace()) {
        case 40:
          return void (u[h++] = e);
        case 46:
          throw new Error("Unexpected import.meta in CJS module.");
        default:
          if (n === e + 6) break;
        case 34:
        case 39:
        case 123:
        case 42:
          if (0 !== h) return void n--;
          throw new Error("Unexpected import statement in CJS module.");
      }
    }
    function throwIfExportStatement() {
      n += 6;
      const e = n,
        t = commentWhitespace();
      if (n !== e || isPunctuator(t))
        throw new Error("Unexpected export statement in CJS module.");
    }
    function commentWhitespace() {
      let e;
      do {
        if (((e = s.charCodeAt(n)), 47 === e)) {
          const t = s.charCodeAt(n + 1);
          if (47 === t) lineComment();
          else {
            if (42 !== t) return e;
            blockComment();
          }
        } else if (!isBrOrWs(e)) return e;
      } while (n++ < o);
      return e;
    }
    function templateString() {
      for (; n++ < o; ) {
        const e = s.charCodeAt(n);
        if (36 === e && 123 === s.charCodeAt(n + 1))
          return n++, (p[W++] = m), void (m = ++h);
        if (96 === e) return;
        92 === e && n++;
      }
      syntaxError();
    }
    function blockComment() {
      for (n++; n++ < o; ) {
        if (42 === s.charCodeAt(n) && 47 === s.charCodeAt(n + 1))
          return void n++;
      }
    }
    function lineComment() {
      for (; n++ < o; ) {
        const e = s.charCodeAt(n);
        if (10 === e || 13 === e) return;
      }
    }
    function stringLiteral(e) {
      for (; n++ < o; ) {
        let r = s.charCodeAt(n);
        if (r === e) return;
        if (92 === r)
          (r = s.charCodeAt(++n)),
            13 === r && 10 === s.charCodeAt(n + 1) && n++;
        else if (13 === (t = r) || 10 === t) break;
      }
      var t;
      throw new Error("Unterminated string.");
    }
    function regexCharacterClass() {
      for (; n++ < o; ) {
        let e = s.charCodeAt(n);
        if (93 === e) return e;
        if (92 === e) n++;
        else if (10 === e || 13 === e) break;
      }
      throw new Error("Syntax error reading regular expression class.");
    }
    function regularExpression() {
      for (; n++ < o; ) {
        let e = s.charCodeAt(n);
        if (47 === e) return;
        if (91 === e) e = regexCharacterClass();
        else if (92 === e) n++;
        else if (10 === e || 13 === e) break;
      }
      throw new Error("Syntax error reading regular expression.");
    }
    function isBrOrWs(e) {
      return (e > 8 && e < 14) || 32 === e || 160 === e;
    }
    function isBrOrWsOrPunctuatorNotDot(e) {
      return (
        (e > 8 && e < 14) ||
        32 === e ||
        160 === e ||
        (isPunctuator(e) && 46 !== e)
      );
    }
    function keywordStart(e) {
      return 0 === e || isBrOrWsOrPunctuatorNotDot(s.charCodeAt(e - 1));
    }
    function readPrecedingKeyword(e, t) {
      return (
        !(e < t.length - 1) &&
        s.startsWith(t, e - t.length + 1) &&
        (0 === e || isBrOrWsOrPunctuatorNotDot(s.charCodeAt(e - t.length)))
      );
    }
    function readPrecedingKeyword1(e, t) {
      return (
        s.charCodeAt(e) === t &&
        (0 === e || isBrOrWsOrPunctuatorNotDot(s.charCodeAt(e - 1)))
      );
    }
    function isExpressionKeyword(e) {
      switch (s.charCodeAt(e)) {
        case 100:
          switch (s.charCodeAt(e - 1)) {
            case 105:
              return readPrecedingKeyword(e - 2, "vo");
            case 108:
              return readPrecedingKeyword(e - 2, "yie");
            default:
              return !1;
          }
        case 101:
          switch (s.charCodeAt(e - 1)) {
            case 115:
              switch (s.charCodeAt(e - 2)) {
                case 108:
                  return readPrecedingKeyword1(e - 3, 101);
                case 97:
                  return readPrecedingKeyword1(e - 3, 99);
                default:
                  return !1;
              }
            case 116:
              return readPrecedingKeyword(e - 2, "dele");
            default:
              return !1;
          }
        case 102:
          if (111 !== s.charCodeAt(e - 1) || 101 !== s.charCodeAt(e - 2))
            return !1;
          switch (s.charCodeAt(e - 3)) {
            case 99:
              return readPrecedingKeyword(e - 4, "instan");
            case 112:
              return readPrecedingKeyword(e - 4, "ty");
            default:
              return !1;
          }
        case 110:
          return (
            readPrecedingKeyword1(e - 1, 105) ||
            readPrecedingKeyword(e - 1, "retur")
          );
        case 111:
          return readPrecedingKeyword1(e - 1, 100);
        case 114:
          return readPrecedingKeyword(e - 1, "debugge");
        case 116:
          return readPrecedingKeyword(e - 1, "awai");
        case 119:
          switch (s.charCodeAt(e - 1)) {
            case 101:
              return readPrecedingKeyword1(e - 2, 110);
            case 111:
              return readPrecedingKeyword(e - 2, "thr");
            default:
              return !1;
          }
      }
      return !1;
    }
    function isParenKeyword(e) {
      return (
        (101 === s.charCodeAt(e) && s.startsWith("whil", e - 4)) ||
        (114 === s.charCodeAt(e) && s.startsWith("fo", e - 2)) ||
        (105 === s.charCodeAt(e - 1) && 102 === s.charCodeAt(e))
      );
    }
    function isPunctuator(e) {
      return (
        33 === e ||
        37 === e ||
        38 === e ||
        (e > 39 && e < 48) ||
        (e > 57 && e < 64) ||
        91 === e ||
        93 === e ||
        94 === e ||
        (e > 122 && e < 127)
      );
    }
    function isExpressionPunctuator(e) {
      return (
        33 === e ||
        37 === e ||
        38 === e ||
        (e > 39 && e < 47 && 41 !== e) ||
        (e > 57 && e < 64) ||
        91 === e ||
        94 === e ||
        (e > 122 && e < 127 && 125 !== e)
      );
    }
    function isExpressionTerminator(e) {
      switch (s.charCodeAt(e)) {
        case 62:
          return 61 === s.charCodeAt(e - 1);
        case 59:
        case 41:
          return !0;
        case 104:
          return s.startsWith("catc", e - 4);
        case 121:
          return s.startsWith("finall", e - 6);
        case 101:
          return s.startsWith("els", e - 3);
      }
      return !1;
    }
    const I = Promise.resolve();
    (r.exports.init = () => I),
      (r.exports.parse = function parseCJS(e, t = "@") {
        resetState();
        try {
          !(function parseSource(e) {
            (s = e), (n = -1), (o = s.length - 1);
            let t = 0;
            if (35 === s.charCodeAt(0) && 33 === s.charCodeAt(1)) {
              if (2 === s.length) return !0;
              for (
                n += 2;
                n++ < o && ((t = s.charCodeAt(n)), 10 !== t && 13 !== t);

              );
            }
            for (; n++ < o; )
              if (((t = s.charCodeAt(n)), !(32 === t || (t < 14 && t > 8)))) {
                if (0 === h)
                  switch (t) {
                    case 105:
                      s.startsWith("mport", n + 1) &&
                        keywordStart(n) &&
                        throwIfImportStatement(),
                        (f = n);
                      continue;
                    case 114:
                      const e = n;
                      tryParseRequire(y) &&
                        keywordStart(e) &&
                        tryBacktrackAddStarExportBinding(e - 1),
                        (f = n);
                      continue;
                    case 95:
                      if (
                        s.startsWith("interopRequireWildcard", n + 1) &&
                        (keywordStart(n) || 46 === s.charCodeAt(n - 1))
                      ) {
                        const e = n;
                        (n += 23),
                          40 === s.charCodeAt(n) &&
                            (n++,
                            (u[h++] = f),
                            tryParseRequire(y) &&
                              keywordStart(e) &&
                              tryBacktrackAddStarExportBinding(e - 1));
                      } else
                        s.startsWith("_export", n + 1) &&
                          (keywordStart(n) || 46 === s.charCodeAt(n - 1)) &&
                          ((n += 8),
                          s.startsWith("Star", n) && (n += 4),
                          40 === s.charCodeAt(n) &&
                            ((u[h++] = f),
                            114 === s.charCodeAt(++n) && tryParseRequire(x)));
                      f = n;
                      continue;
                  }
                switch (t) {
                  case 101:
                    s.startsWith("xport", n + 1) &&
                      keywordStart(n) &&
                      (115 === s.charCodeAt(n + 6)
                        ? tryParseExportsDotAssign(!1)
                        : 0 === h && throwIfExportStatement());
                    break;
                  case 99:
                    keywordStart(n) &&
                      s.startsWith("lass", n + 1) &&
                      isBrOrWs(s.charCodeAt(n + 5)) &&
                      (b = !0);
                    break;
                  case 109:
                    s.startsWith("odule", n + 1) &&
                      keywordStart(n) &&
                      tryParseModuleExportsDotAssign();
                    break;
                  case 79:
                    s.startsWith("bject", n + 1) &&
                      keywordStart(n) &&
                      tryParseObjectDefineOrKeys(0 === h);
                    break;
                  case 40:
                    u[h++] = f;
                    break;
                  case 41:
                    if (0 === h) throw new Error("Unexpected closing bracket.");
                    h--;
                    break;
                  case 123:
                    (l[h] = b), (b = !1), (u[h++] = f);
                    break;
                  case 125:
                    if (0 === h) throw new Error("Unexpected closing brace.");
                    if (h-- === m) (m = p[--W]), templateString();
                    else if (-1 !== m && h < m)
                      throw new Error("Unexpected closing brace.");
                    break;
                  case 60:
                    break;
                  case 39:
                  case 34:
                    stringLiteral(t);
                    break;
                  case 47: {
                    const e = s.charCodeAt(n + 1);
                    if (47 === e) {
                      lineComment();
                      continue;
                    }
                    if (42 === e) {
                      blockComment();
                      continue;
                    }
                    {
                      const e = s.charCodeAt(f);
                      (isExpressionPunctuator(e) &&
                        !(
                          46 === e &&
                          s.charCodeAt(f - 1) >= 48 &&
                          s.charCodeAt(f - 1) <= 57
                        ) &&
                        (43 !== e || 43 !== s.charCodeAt(f - 1)) &&
                        (45 !== e || 45 !== s.charCodeAt(f - 1))) ||
                      (41 === e && isParenKeyword(u[h])) ||
                      (125 === e && (isExpressionTerminator(u[h]) || l[h])) ||
                      (47 === e && d) ||
                      isExpressionKeyword(f) ||
                      !e
                        ? (regularExpression(), (d = !1))
                        : (d = !0);
                    }
                    break;
                  }
                  case 96:
                    templateString();
                }
                f = n;
              }
            if (-1 !== m) throw new Error("Unterminated template.");
            if (h) throw new Error("Unterminated braces.");
          })(e);
        } catch (r) {
          throw (
            ((r.message += `\n  at ${t}:${e.slice(0, n).split("\n").length}:${
              n - e.lastIndexOf("\n", n - 1)
            }`),
            (r.loc = n),
            r)
          );
        }
        const r = {
          exports: [...C].filter((e) => void 0 !== e && !A.has(e)),
          reexports: [...g].filter((e) => void 0 !== e),
        };
        return resetState(), r;
      });
  },
  "internal/deps/minimatch/index": function (t, e, s, i, n, r) {
    "use strict";
    var a = Object.defineProperty,
      o = Object.getOwnPropertyNames,
      __commonJS = (t, e) =>
        function __require() {
          return (
            e || (0, t[o(t)[0]])((e = { exports: {} }).exports, e), e.exports
          );
        },
      __publicField = (t, e, s) => (
        ((t, e, s) => {
          e in t
            ? a(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: s,
              })
            : (t[e] = s);
        })(t, "symbol" != typeof e ? e + "" : e, s),
        s
      ),
      __accessCheck = (t, e, s) => {
        if (!e.has(t)) throw TypeError("Cannot " + s);
      },
      __privateGet = (t, e, s) => (
        __accessCheck(t, e, "read from private field"), s ? s.call(t) : e.get(t)
      ),
      __privateAdd = (t, e, s) => {
        if (e.has(t))
          throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, s);
      },
      __privateSet = (t, e, s, i) => (
        __accessCheck(t, e, "write to private field"),
        i ? i.call(t, s) : e.set(t, s),
        s
      ),
      __privateMethod = (t, e, s) => (
        __accessCheck(t, e, "access private method"), s
      ),
      h = __commonJS({
        "node_modules/balanced-match/index.js"(t, e) {
          function balanced(t, e, s) {
            t instanceof RegExp && (t = maybeMatch(t, s)),
              e instanceof RegExp && (e = maybeMatch(e, s));
            var i = range(t, e, s);
            return (
              i && {
                start: i[0],
                end: i[1],
                pre: s.slice(0, i[0]),
                body: s.slice(i[0] + t.length, i[1]),
                post: s.slice(i[1] + e.length),
              }
            );
          }
          function maybeMatch(t, e) {
            var s = e.match(t);
            return s ? s[0] : null;
          }
          function range(t, e, s) {
            var i,
              n,
              r,
              a,
              o,
              h = s.indexOf(t),
              p = s.indexOf(e, h + 1),
              l = h;
            if (h >= 0 && p > 0) {
              if (t === e) return [h, p];
              for (i = [], r = s.length; l >= 0 && !o; )
                l == h
                  ? (i.push(l), (h = s.indexOf(t, l + 1)))
                  : 1 == i.length
                  ? (o = [i.pop(), p])
                  : ((n = i.pop()) < r && ((r = n), (a = p)),
                    (p = s.indexOf(e, l + 1))),
                  (l = h < p && h >= 0 ? h : p);
              i.length && (o = [r, a]);
            }
            return o;
          }
          (e.exports = balanced), (balanced.range = range);
        },
      }),
      p = __commonJS({
        "node_modules/brace-expansion/index.js"(t, e) {
          var s = h();
          e.exports = function expandTop(t) {
            if (!t) return [];
            "{}" === t.substr(0, 2) && (t = "\\{\\}" + t.substr(2));
            return expand(
              (function escapeBraces(t) {
                return t
                  .split("\\\\")
                  .join(i)
                  .split("\\{")
                  .join(n)
                  .split("\\}")
                  .join(r)
                  .split("\\,")
                  .join(a)
                  .split("\\.")
                  .join(o);
              })(t),
              !0
            ).map(unescapeBraces);
          };
          var i = "\0SLASH" + Math.random() + "\0",
            n = "\0OPEN" + Math.random() + "\0",
            r = "\0CLOSE" + Math.random() + "\0",
            a = "\0COMMA" + Math.random() + "\0",
            o = "\0PERIOD" + Math.random() + "\0";
          function numeric(t) {
            return parseInt(t, 10) == t ? parseInt(t, 10) : t.charCodeAt(0);
          }
          function unescapeBraces(t) {
            return t
              .split(i)
              .join("\\")
              .split(n)
              .join("{")
              .split(r)
              .join("}")
              .split(a)
              .join(",")
              .split(o)
              .join(".");
          }
          function parseCommaParts(t) {
            if (!t) return [""];
            var e = [],
              i = s("{", "}", t);
            if (!i) return t.split(",");
            var n = i.pre,
              r = i.body,
              a = i.post,
              o = n.split(",");
            o[o.length - 1] += "{" + r + "}";
            var h = parseCommaParts(a);
            return (
              a.length && ((o[o.length - 1] += h.shift()), o.push.apply(o, h)),
              e.push.apply(e, o),
              e
            );
          }
          function embrace(t) {
            return "{" + t + "}";
          }
          function isPadded(t) {
            return /^-?0\d/.test(t);
          }
          function lte(t, e) {
            return t <= e;
          }
          function gte(t, e) {
            return t >= e;
          }
          function expand(t, e) {
            var i = [],
              n = s("{", "}", t);
            if (!n) return [t];
            var a = n.pre,
              o = n.post.length ? expand(n.post, !1) : [""];
            if (/\$$/.test(n.pre))
              for (var h = 0; h < o.length; h++) {
                var p = a + "{" + n.body + "}" + o[h];
                i.push(p);
              }
            else {
              var l,
                c,
                u = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(n.body),
                f = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(n.body),
                d = u || f,
                g = n.body.indexOf(",") >= 0;
              if (!d && !g)
                return n.post.match(/,.*\}/)
                  ? expand((t = n.pre + "{" + n.body + r + n.post))
                  : [t];
              if (d) l = n.body.split(/\.\./);
              else if (
                1 === (l = parseCommaParts(n.body)).length &&
                1 === (l = expand(l[0], !1).map(embrace)).length
              )
                return o.map(function (t) {
                  return n.pre + l[0] + t;
                });
              if (d) {
                var m = numeric(l[0]),
                  b = numeric(l[1]),
                  w = Math.max(l[0].length, l[1].length),
                  y = 3 == l.length ? Math.abs(numeric(l[2])) : 1,
                  v = lte;
                b < m && ((y *= -1), (v = gte));
                var S = l.some(isPadded);
                c = [];
                for (var O = m; v(O, b); O += y) {
                  var x;
                  if (f) "\\" === (x = String.fromCharCode(O)) && (x = "");
                  else if (((x = String(O)), S)) {
                    var M = w - x.length;
                    if (M > 0) {
                      var A = new Array(M + 1).join("0");
                      x = O < 0 ? "-" + A + x.slice(1) : A + x;
                    }
                  }
                  c.push(x);
                }
              } else {
                c = [];
                for (var j = 0; j < l.length; j++)
                  c.push.apply(c, expand(l[j], !1));
              }
              for (j = 0; j < c.length; j++)
                for (h = 0; h < o.length; h++) {
                  p = a + c[j] + o[h];
                  (!e || d || p) && i.push(p);
                }
            }
            return i;
          }
        },
      }),
      l = __commonJS({
        "dist/cjs/assert-valid-pattern.js"(t) {
          Object.defineProperty(t, "__esModule", { value: !0 }),
            (t.assertValidPattern = void 0);
          t.assertValidPattern = (t) => {
            if ("string" != typeof t) throw new TypeError("invalid pattern");
            if (t.length > 65536) throw new TypeError("pattern is too long");
          };
        },
      }),
      c = __commonJS({
        "dist/cjs/brace-expressions.js"(t) {
          Object.defineProperty(t, "__esModule", { value: !0 }),
            (t.parseClass = void 0);
          var e = {
              "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
              "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
              "[:ascii:]": ["\\x00-\\x7f", !1],
              "[:blank:]": ["\\p{Zs}\\t", !0],
              "[:cntrl:]": ["\\p{Cc}", !0],
              "[:digit:]": ["\\p{Nd}", !0],
              "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
              "[:lower:]": ["\\p{Ll}", !0],
              "[:print:]": ["\\p{C}", !0],
              "[:punct:]": ["\\p{P}", !0],
              "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
              "[:upper:]": ["\\p{Lu}", !0],
              "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
              "[:xdigit:]": ["A-Fa-f0-9", !1],
            },
            braceEscape = (t) => t.replace(/[[\]\\-]/g, "\\$&"),
            rangesToString = (t) => t.join("");
          t.parseClass = (t, s) => {
            const i = s;
            if ("[" !== t.charAt(i))
              throw new Error("not in a brace expression");
            const n = [],
              r = [];
            let a = i + 1,
              o = !1,
              h = !1,
              p = !1,
              l = !1,
              c = i,
              u = "";
            t: for (; a < t.length; ) {
              const s = t.charAt(a);
              if (("!" !== s && "^" !== s) || a !== i + 1) {
                if ("]" === s && o && !p) {
                  c = a + 1;
                  break;
                }
                if (((o = !0), "\\" !== s || p)) {
                  if ("[" === s && !p)
                    for (const [s, [o, p, l]] of Object.entries(e))
                      if (t.startsWith(s, a)) {
                        if (u) return ["$.", !1, t.length - i, !0];
                        (a += s.length),
                          l ? r.push(o) : n.push(o),
                          (h = h || p);
                        continue t;
                      }
                  (p = !1),
                    u
                      ? (s > u
                          ? n.push(braceEscape(u) + "-" + braceEscape(s))
                          : s === u && n.push(braceEscape(s)),
                        (u = ""),
                        a++)
                      : t.startsWith("-]", a + 1)
                      ? (n.push(braceEscape(s + "-")), (a += 2))
                      : t.startsWith("-", a + 1)
                      ? ((u = s), (a += 2))
                      : (n.push(braceEscape(s)), a++);
                } else (p = !0), a++;
              } else (l = !0), a++;
            }
            if (c < a) return ["", !1, 0, !1];
            if (!n.length && !r.length) return ["$.", !1, t.length - i, !0];
            if (0 === r.length && 1 === n.length && /^\\?.$/.test(n[0]) && !l) {
              const t = 2 === n[0].length ? n[0].slice(-1) : n[0];
              return [
                ((f = t), f.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")),
                !1,
                c - i,
                !1,
              ];
            }
            var f;
            const d = "[" + (l ? "^" : "") + rangesToString(n) + "]",
              g = "[" + (l ? "" : "^") + rangesToString(r) + "]";
            return [
              n.length && r.length ? "(" + d + "|" + g + ")" : n.length ? d : g,
              h,
              c - i,
              !0,
            ];
          };
        },
      }),
      u = __commonJS({
        "dist/cjs/unescape.js"(t) {
          Object.defineProperty(t, "__esModule", { value: !0 }),
            (t.unescape = void 0);
          t.unescape = (t, { windowsPathsNoEscape: e = !1 } = {}) =>
            e
              ? t.replace(/\[([^\/\\])\]/g, "$1")
              : t
                  .replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2")
                  .replace(/\\([^\/])/g, "$1");
        },
      }),
      f = __commonJS({
        "dist/cjs/ast.js"(t) {
          Object.defineProperty(t, "__esModule", { value: !0 }),
            (t.AST = void 0);
          var e,
            s,
            i,
            n,
            r,
            a,
            o,
            h,
            p,
            l,
            f,
            d,
            g,
            m,
            b,
            w,
            y,
            v,
            S,
            O = c(),
            x = u(),
            M = new Set(["!", "?", "+", "*", "@"]),
            isExtglobType = (t) => M.has(t),
            A = "(?!\\.)",
            j = new Set(["[", "."]),
            P = new Set(["..", "."]),
            E = new Set("().*{}+?[]^$\\!"),
            W = "[^/]",
            R = W + "*?",
            T = W + "+?",
            $ = class {
              constructor(t, c, u = {}) {
                __privateAdd(this, d),
                  __privateAdd(this, w),
                  __publicField(this, "type"),
                  __privateAdd(this, e, void 0),
                  __privateAdd(this, s, void 0),
                  __privateAdd(this, i, !1),
                  __privateAdd(this, n, []),
                  __privateAdd(this, r, void 0),
                  __privateAdd(this, a, void 0),
                  __privateAdd(this, o, void 0),
                  __privateAdd(this, h, !1),
                  __privateAdd(this, p, void 0),
                  __privateAdd(this, l, void 0),
                  __privateAdd(this, f, !1),
                  (this.type = t),
                  t && __privateSet(this, s, !0),
                  __privateSet(this, r, c),
                  __privateSet(
                    this,
                    e,
                    __privateGet(this, r)
                      ? __privateGet(__privateGet(this, r), e)
                      : this
                  ),
                  __privateSet(
                    this,
                    p,
                    __privateGet(this, e) === this
                      ? u
                      : __privateGet(__privateGet(this, e), p)
                  ),
                  __privateSet(
                    this,
                    o,
                    __privateGet(this, e) === this
                      ? []
                      : __privateGet(__privateGet(this, e), o)
                  ),
                  "!" !== t ||
                    __privateGet(__privateGet(this, e), h) ||
                    __privateGet(this, o).push(this),
                  __privateSet(
                    this,
                    a,
                    __privateGet(this, r)
                      ? __privateGet(__privateGet(this, r), n).length
                      : 0
                  );
              }
              get hasMagic() {
                if (void 0 !== __privateGet(this, s))
                  return __privateGet(this, s);
                for (const t of __privateGet(this, n))
                  if ("string" != typeof t && (t.type || t.hasMagic))
                    return __privateSet(this, s, !0);
                return __privateGet(this, s);
              }
              toString() {
                return void 0 !== __privateGet(this, l)
                  ? __privateGet(this, l)
                  : this.type
                  ? __privateSet(
                      this,
                      l,
                      this.type +
                        "(" +
                        __privateGet(this, n)
                          .map((t) => String(t))
                          .join("|") +
                        ")"
                    )
                  : __privateSet(
                      this,
                      l,
                      __privateGet(this, n)
                        .map((t) => String(t))
                        .join("")
                    );
              }
              push(...t) {
                for (const e of t)
                  if ("" !== e) {
                    if (
                      "string" != typeof e &&
                      !(e instanceof $ && __privateGet(e, r) === this)
                    )
                      throw new Error("invalid part: " + e);
                    __privateGet(this, n).push(e);
                  }
              }
              toJSON() {
                const t =
                  null === this.type
                    ? __privateGet(this, n)
                        .slice()
                        .map((t) => ("string" == typeof t ? t : t.toJSON()))
                    : [
                        this.type,
                        ...__privateGet(this, n).map((t) => t.toJSON()),
                      ];
                return (
                  this.isStart() && !this.type && t.unshift([]),
                  this.isEnd() &&
                    (this === __privateGet(this, e) ||
                      (__privateGet(__privateGet(this, e), h) &&
                        "!" === __privateGet(this, r)?.type)) &&
                    t.push({}),
                  t
                );
              }
              isStart() {
                if (__privateGet(this, e) === this) return !0;
                if (!__privateGet(this, r)?.isStart()) return !1;
                if (0 === __privateGet(this, a)) return !0;
                const t = __privateGet(this, r);
                for (let e = 0; e < __privateGet(this, a); e++) {
                  const s = __privateGet(t, n)[e];
                  if (!(s instanceof $ && "!" === s.type)) return !1;
                }
                return !0;
              }
              isEnd() {
                if (__privateGet(this, e) === this) return !0;
                if ("!" === __privateGet(this, r)?.type) return !0;
                if (!__privateGet(this, r)?.isEnd()) return !1;
                if (!this.type) return __privateGet(this, r)?.isEnd();
                const t = __privateGet(this, r)
                  ? __privateGet(__privateGet(this, r), n).length
                  : 0;
                return __privateGet(this, a) === t - 1;
              }
              copyIn(t) {
                "string" == typeof t ? this.push(t) : this.push(t.clone(this));
              }
              clone(t) {
                const e = new $(this.type, t);
                for (const t of __privateGet(this, n)) e.copyIn(t);
                return e;
              }
              static fromGlob(t, e = {}) {
                var s;
                const i = new $(null, void 0, e);
                return __privateMethod((s = $), m, b).call(s, t, i, 0, e), i;
              }
              toMMPattern() {
                if (this !== __privateGet(this, e))
                  return __privateGet(this, e).toMMPattern();
                const t = this.toString(),
                  [i, n, r, a] = this.toRegExpSource();
                if (
                  !(
                    r ||
                    __privateGet(this, s) ||
                    (__privateGet(this, p).nocase &&
                      !__privateGet(this, p).nocaseMagicOnly &&
                      t.toUpperCase() !== t.toLowerCase())
                  )
                )
                  return n;
                const o =
                  (__privateGet(this, p).nocase ? "i" : "") + (a ? "u" : "");
                return Object.assign(new RegExp(`^${i}$`, o), {
                  _src: i,
                  _glob: t,
                });
              }
              toRegExpSource(t) {
                const a = t ?? !!__privateGet(this, p).dot;
                if (
                  (__privateGet(this, e) === this &&
                    __privateMethod(this, d, g).call(this),
                  !this.type)
                ) {
                  const o = this.isStart() && this.isEnd(),
                    p = __privateGet(this, n)
                      .map((e) => {
                        var n;
                        const [r, a, h, p] =
                          "string" == typeof e
                            ? __privateMethod((n = $), v, S).call(
                                n,
                                e,
                                __privateGet(this, s),
                                o
                              )
                            : e.toRegExpSource(t);
                        return (
                          __privateSet(this, s, __privateGet(this, s) || h),
                          __privateSet(this, i, __privateGet(this, i) || p),
                          r
                        );
                      })
                      .join("");
                  let l = "";
                  if (
                    this.isStart() &&
                    "string" == typeof __privateGet(this, n)[0]
                  ) {
                    if (
                      !(
                        1 === __privateGet(this, n).length &&
                        P.has(__privateGet(this, n)[0])
                      )
                    ) {
                      const e = j,
                        s =
                          (a && e.has(p.charAt(0))) ||
                          (p.startsWith("\\.") && e.has(p.charAt(2))) ||
                          (p.startsWith("\\.\\.") && e.has(p.charAt(4))),
                        i = !a && !t && e.has(p.charAt(0));
                      l = s ? "(?!(?:^|/)\\.\\.?(?:$|/))" : i ? A : "";
                    }
                  }
                  let c = "";
                  this.isEnd() &&
                    __privateGet(__privateGet(this, e), h) &&
                    "!" === __privateGet(this, r)?.type &&
                    (c = "(?:$|\\/)");
                  return [
                    l + p + c,
                    (0, x.unescape)(p),
                    __privateSet(this, s, !!__privateGet(this, s)),
                    __privateGet(this, i),
                  ];
                }
                const o = "*" === this.type || "+" === this.type,
                  l = "!" === this.type ? "(?:(?!(?:" : "(?:";
                let c = __privateMethod(this, w, y).call(this, a);
                if (this.isStart() && this.isEnd() && !c && "!" !== this.type) {
                  const t = this.toString();
                  return (
                    __privateSet(this, n, [t]),
                    (this.type = null),
                    __privateSet(this, s, void 0),
                    [t, (0, x.unescape)(this.toString()), !1, !1]
                  );
                }
                let u =
                  !o || t || a
                    ? ""
                    : __privateMethod(this, w, y).call(this, !0);
                u === c && (u = ""), u && (c = `(?:${c})(?:${u})*?`);
                let m = "";
                if ("!" === this.type && __privateGet(this, f))
                  m = (this.isStart() && !a ? A : "") + T;
                else {
                  m =
                    l +
                    c +
                    ("!" === this.type
                      ? "))" + (!this.isStart() || a || t ? "" : A) + R + ")"
                      : "@" === this.type
                      ? ")"
                      : "?" === this.type
                      ? ")?"
                      : "+" === this.type && u
                      ? ")"
                      : "*" === this.type && u
                      ? ")?"
                      : `)${this.type}`);
                }
                return [
                  m,
                  (0, x.unescape)(c),
                  __privateSet(this, s, !!__privateGet(this, s)),
                  __privateGet(this, i),
                ];
              }
            },
            L = $;
          (e = new WeakMap()),
            (s = new WeakMap()),
            (i = new WeakMap()),
            (n = new WeakMap()),
            (r = new WeakMap()),
            (a = new WeakMap()),
            (o = new WeakMap()),
            (h = new WeakMap()),
            (p = new WeakMap()),
            (l = new WeakMap()),
            (f = new WeakMap()),
            (d = new WeakSet()),
            (g = function () {
              if (this !== __privateGet(this, e))
                throw new Error("should only call on root");
              if (__privateGet(this, h)) return this;
              let t;
              for (
                this.toString(), __privateSet(this, h, !0);
                (t = __privateGet(this, o).pop());

              ) {
                if ("!" !== t.type) continue;
                let e = t,
                  s = __privateGet(e, r);
                for (; s; ) {
                  for (
                    let i = __privateGet(e, a) + 1;
                    !s.type && i < __privateGet(s, n).length;
                    i++
                  )
                    for (const e of __privateGet(t, n)) {
                      if ("string" == typeof e)
                        throw new Error("string part in extglob AST??");
                      e.copyIn(__privateGet(s, n)[i]);
                    }
                  (e = s), (s = __privateGet(e, r));
                }
              }
              return this;
            }),
            (m = new WeakSet()),
            (b = function (t, e, i, r) {
              var a, o;
              let h = !1,
                p = !1,
                l = -1,
                c = !1;
              if (null === e.type) {
                let s = i,
                  n = "";
                for (; s < t.length; ) {
                  const i = t.charAt(s++);
                  if (h || "\\" === i) (h = !h), (n += i);
                  else if (p)
                    s === l + 1
                      ? ("^" !== i && "!" !== i) || (c = !0)
                      : "]" !== i || (s === l + 2 && c) || (p = !1),
                      (n += i);
                  else if ("[" !== i)
                    if (r.noext || !isExtglobType(i) || "(" !== t.charAt(s))
                      n += i;
                    else {
                      e.push(n), (n = "");
                      const o = new $(i, e);
                      (s = __privateMethod((a = $), m, b).call(a, t, o, s, r)),
                        e.push(o);
                    }
                  else (p = !0), (l = s), (c = !1), (n += i);
                }
                return e.push(n), s;
              }
              let u = i + 1,
                d = new $(null, e);
              const g = [];
              let w = "";
              for (; u < t.length; ) {
                const s = t.charAt(u++);
                if (h || "\\" === s) (h = !h), (w += s);
                else if (p)
                  u === l + 1
                    ? ("^" !== s && "!" !== s) || (c = !0)
                    : "]" !== s || (u === l + 2 && c) || (p = !1),
                    (w += s);
                else if ("[" !== s)
                  if (isExtglobType(s) && "(" === t.charAt(u)) {
                    d.push(w), (w = "");
                    const e = new $(s, d);
                    d.push(e),
                      (u = __privateMethod((o = $), m, b).call(o, t, e, u, r));
                  } else if ("|" !== s) {
                    if (")" === s)
                      return (
                        "" === w &&
                          0 === __privateGet(e, n).length &&
                          __privateSet(e, f, !0),
                        d.push(w),
                        (w = ""),
                        e.push(...g, d),
                        u
                      );
                    w += s;
                  } else d.push(w), (w = ""), g.push(d), (d = new $(null, e));
                else (p = !0), (l = u), (c = !1), (w += s);
              }
              return (
                (e.type = null),
                __privateSet(e, s, void 0),
                __privateSet(e, n, [t.substring(i - 1)]),
                u
              );
            }),
            (w = new WeakSet()),
            (y = function (t) {
              return __privateGet(this, n)
                .map((e) => {
                  if ("string" == typeof e)
                    throw new Error("string type in extglob ast??");
                  const [s, n, r, a] = e.toRegExpSource(t);
                  return __privateSet(this, i, __privateGet(this, i) || a), s;
                })
                .filter((t) => !(this.isStart() && this.isEnd() && !t))
                .join("|");
            }),
            (v = new WeakSet()),
            (S = function (t, e, s = !1) {
              let i = !1,
                n = "",
                r = !1;
              for (let a = 0; a < t.length; a++) {
                const o = t.charAt(a);
                if (i) (i = !1), (n += (E.has(o) ? "\\" : "") + o);
                else if ("\\" !== o) {
                  if ("[" === o) {
                    const [s, i, o, h] = (0, O.parseClass)(t, a);
                    if (o) {
                      (n += s), (r = r || i), (a += o - 1), (e = e || h);
                      continue;
                    }
                  }
                  "*" !== o
                    ? "?" !== o
                      ? (n += o.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"))
                      : ((n += W), (e = !0))
                    : ((n += s && "*" === t ? T : R), (e = !0));
                } else a === t.length - 1 ? (n += "\\\\") : (i = !0);
              }
              return [n, (0, x.unescape)(t), !!e, r];
            }),
            __privateAdd(L, m),
            __privateAdd(L, v),
            (t.AST = L);
        },
      }),
      d = __commonJS({
        "dist/cjs/escape.js"(t) {
          Object.defineProperty(t, "__esModule", { value: !0 }),
            (t.escape = void 0);
          t.escape = (t, { windowsPathsNoEscape: e = !1 } = {}) =>
            e
              ? t.replace(/[?*()[\]]/g, "[$&]")
              : t.replace(/[?*()[\]\\]/g, "\\$&");
        },
      }),
      g =
        (t && t.__importDefault) ||
        function (t) {
          return t && t.__esModule ? t : { default: t };
        };
    Object.defineProperty(t, "__esModule", { value: !0 }),
      (t.unescape =
        t.escape =
        t.AST =
        t.Minimatch =
        t.match =
        t.makeRe =
        t.braceExpand =
        t.defaults =
        t.filter =
        t.GLOBSTAR =
        t.sep =
        t.minimatch =
          void 0);
    var m = g(p()),
      b = l(),
      w = f(),
      y = d(),
      v = u();
    t.minimatch = (t, e, s = {}) => (
      (0, b.assertValidPattern)(e),
      !(!s.nocomment && "#" === e.charAt(0)) && new R(e, s).match(t)
    );
    var S = /^\*+([^+@!?\*\[\(]*)$/,
      starDotExtTest = (t) => (e) => !e.startsWith(".") && e.endsWith(t),
      starDotExtTestDot = (t) => (e) => e.endsWith(t),
      starDotExtTestNocase = (t) => (
        (t = t.toLowerCase()),
        (e) => !e.startsWith(".") && e.toLowerCase().endsWith(t)
      ),
      starDotExtTestNocaseDot = (t) => (
        (t = t.toLowerCase()), (e) => e.toLowerCase().endsWith(t)
      ),
      O = /^\*+\.\*+$/,
      starDotStarTest = (t) => !t.startsWith(".") && t.includes("."),
      starDotStarTestDot = (t) => "." !== t && ".." !== t && t.includes("."),
      x = /^\.\*+$/,
      dotStarTest = (t) => "." !== t && ".." !== t && t.startsWith("."),
      M = /^\*+$/,
      starTest = (t) => 0 !== t.length && !t.startsWith("."),
      starTestDot = (t) => 0 !== t.length && "." !== t && ".." !== t,
      A = /^\?+([^+@!?\*\[\(]*)?$/,
      qmarksTestNocase = ([t, e = ""]) => {
        const s = qmarksTestNoExt([t]);
        return e
          ? ((e = e.toLowerCase()), (t) => s(t) && t.toLowerCase().endsWith(e))
          : s;
      },
      qmarksTestNocaseDot = ([t, e = ""]) => {
        const s = qmarksTestNoExtDot([t]);
        return e
          ? ((e = e.toLowerCase()), (t) => s(t) && t.toLowerCase().endsWith(e))
          : s;
      },
      qmarksTestDot = ([t, e = ""]) => {
        const s = qmarksTestNoExtDot([t]);
        return e ? (t) => s(t) && t.endsWith(e) : s;
      },
      qmarksTest = ([t, e = ""]) => {
        const s = qmarksTestNoExt([t]);
        return e ? (t) => s(t) && t.endsWith(e) : s;
      },
      qmarksTestNoExt = ([t]) => {
        const e = t.length;
        return (t) => t.length === e && !t.startsWith(".");
      },
      qmarksTestNoExtDot = ([t]) => {
        const e = t.length;
        return (t) => t.length === e && "." !== t && ".." !== t;
      },
      j =
        "object" == typeof i && i
          ? ("object" == typeof i.env &&
              i.env &&
              i.env.__MINIMATCH_TESTING_PLATFORM__) ||
            i.platform
          : "posix",
      P = { sep: "\\" },
      E = { sep: "/" };
    (t.sep = "win32" === j ? P.sep : E.sep),
      (t.minimatch.sep = t.sep),
      (t.GLOBSTAR = Symbol("globstar **")),
      (t.minimatch.GLOBSTAR = t.GLOBSTAR);
    (t.filter =
      (e, s = {}) =>
      (i) =>
        (0, t.minimatch)(i, e, s)),
      (t.minimatch.filter = t.filter);
    var ext = (t, e = {}) => Object.assign({}, t, e);
    (t.defaults = (e) => {
      if (!e || "object" != typeof e || !Object.keys(e).length)
        return t.minimatch;
      const s = t.minimatch;
      return Object.assign((t, i, n = {}) => s(t, i, ext(e, n)), {
        Minimatch: class Minimatch extends s.Minimatch {
          constructor(t, s = {}) {
            super(t, ext(e, s));
          }
          static defaults(t) {
            return s.defaults(ext(e, t)).Minimatch;
          }
        },
        AST: class AST extends s.AST {
          constructor(t, s, i = {}) {
            super(t, s, ext(e, i));
          }
          static fromGlob(t, i = {}) {
            return s.AST.fromGlob(t, ext(e, i));
          }
        },
        unescape: (t, i = {}) => s.unescape(t, ext(e, i)),
        escape: (t, i = {}) => s.escape(t, ext(e, i)),
        filter: (t, i = {}) => s.filter(t, ext(e, i)),
        defaults: (t) => s.defaults(ext(e, t)),
        makeRe: (t, i = {}) => s.makeRe(t, ext(e, i)),
        braceExpand: (t, i = {}) => s.braceExpand(t, ext(e, i)),
        match: (t, i, n = {}) => s.match(t, i, ext(e, n)),
        sep: s.sep,
        GLOBSTAR: t.GLOBSTAR,
      });
    }),
      (t.minimatch.defaults = t.defaults);
    (t.braceExpand = (t, e = {}) => (
      (0, b.assertValidPattern)(t),
      e.nobrace || !/\{(?:(?!\{).)*\}/.test(t) ? [t] : (0, m.default)(t)
    )),
      (t.minimatch.braceExpand = t.braceExpand);
    (t.makeRe = (t, e = {}) => new R(t, e).makeRe()),
      (t.minimatch.makeRe = t.makeRe);
    (t.match = (t, e, s = {}) => {
      const i = new R(e, s);
      return (
        (t = t.filter((t) => i.match(t))),
        i.options.nonull && !t.length && t.push(e),
        t
      );
    }),
      (t.minimatch.match = t.match);
    var W = /[?*]|[+@!]\(.*?\)|\[|\]/,
      R = class {
        options;
        set;
        pattern;
        windowsPathsNoEscape;
        nonegate;
        negate;
        comment;
        empty;
        preserveMultipleSlashes;
        partial;
        globSet;
        globParts;
        nocase;
        isWindows;
        platform;
        windowsNoMagicRoot;
        regexp;
        constructor(t, e = {}) {
          (0, b.assertValidPattern)(t),
            (e = e || {}),
            (this.options = e),
            (this.pattern = t),
            (this.platform = e.platform || j),
            (this.isWindows = "win32" === this.platform),
            (this.windowsPathsNoEscape =
              !!e.windowsPathsNoEscape || !1 === e.allowWindowsEscape),
            this.windowsPathsNoEscape &&
              (this.pattern = this.pattern.replace(/\\/g, "/")),
            (this.preserveMultipleSlashes = !!e.preserveMultipleSlashes),
            (this.regexp = null),
            (this.negate = !1),
            (this.nonegate = !!e.nonegate),
            (this.comment = !1),
            (this.empty = !1),
            (this.partial = !!e.partial),
            (this.nocase = !!this.options.nocase),
            (this.windowsNoMagicRoot =
              void 0 !== e.windowsNoMagicRoot
                ? e.windowsNoMagicRoot
                : !(!this.isWindows || !this.nocase)),
            (this.globSet = []),
            (this.globParts = []),
            (this.set = []),
            this.make();
        }
        hasMagic() {
          if (this.options.magicalBraces && this.set.length > 1) return !0;
          for (const t of this.set)
            for (const e of t) if ("string" != typeof e) return !0;
          return !1;
        }
        debug(...t) {}
        make() {
          const t = this.pattern,
            e = this.options;
          if (!e.nocomment && "#" === t.charAt(0))
            return void (this.comment = !0);
          if (!t) return void (this.empty = !0);
          this.parseNegate(),
            (this.globSet = [...new Set(this.braceExpand())]),
            e.debug && (this.debug = (...t) => console.error(...t)),
            this.debug(this.pattern, this.globSet);
          const s = this.globSet.map((t) => this.slashSplit(t));
          (this.globParts = this.preprocess(s)),
            this.debug(this.pattern, this.globParts);
          let i = this.globParts.map((t, e, s) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
              const e = !(
                  "" !== t[0] ||
                  "" !== t[1] ||
                  ("?" !== t[2] && W.test(t[2])) ||
                  W.test(t[3])
                ),
                s = /^[a-z]:/i.test(t[0]);
              if (e)
                return [
                  ...t.slice(0, 4),
                  ...t.slice(4).map((t) => this.parse(t)),
                ];
              if (s) return [t[0], ...t.slice(1).map((t) => this.parse(t))];
            }
            return t.map((t) => this.parse(t));
          });
          if (
            (this.debug(this.pattern, i),
            (this.set = i.filter((t) => -1 === t.indexOf(!1))),
            this.isWindows)
          )
            for (let t = 0; t < this.set.length; t++) {
              const e = this.set[t];
              "" === e[0] &&
                "" === e[1] &&
                "?" === this.globParts[t][2] &&
                "string" == typeof e[3] &&
                /^[a-z]:$/i.test(e[3]) &&
                (e[2] = "?");
            }
          this.debug(this.pattern, this.set);
        }
        preprocess(t) {
          if (this.options.noglobstar)
            for (let e = 0; e < t.length; e++)
              for (let s = 0; s < t[e].length; s++)
                "**" === t[e][s] && (t[e][s] = "*");
          const { optimizationLevel: e = 1 } = this.options;
          return (
            e >= 2
              ? ((t = this.firstPhasePreProcess(t)),
                (t = this.secondPhasePreProcess(t)))
              : (t =
                  e >= 1
                    ? this.levelOneOptimize(t)
                    : this.adjascentGlobstarOptimize(t)),
            t
          );
        }
        adjascentGlobstarOptimize(t) {
          return t.map((t) => {
            let e = -1;
            for (; -1 !== (e = t.indexOf("**", e + 1)); ) {
              let s = e;
              for (; "**" === t[s + 1]; ) s++;
              s !== e && t.splice(e, s - e);
            }
            return t;
          });
        }
        levelOneOptimize(t) {
          return t.map((t) =>
            0 ===
            (t = t.reduce((t, e) => {
              const s = t[t.length - 1];
              return "**" === e && "**" === s
                ? t
                : ".." === e && s && ".." !== s && "." !== s && "**" !== s
                ? (t.pop(), t)
                : (t.push(e), t);
            }, [])).length
              ? [""]
              : t
          );
        }
        levelTwoFileOptimize(t) {
          Array.isArray(t) || (t = this.slashSplit(t));
          let e = !1;
          do {
            if (((e = !1), !this.preserveMultipleSlashes)) {
              for (let s = 1; s < t.length - 1; s++) {
                const i = t[s];
                (1 === s && "" === i && "" === t[0]) ||
                  ("." !== i && "" !== i) ||
                  ((e = !0), t.splice(s, 1), s--);
              }
              "." !== t[0] ||
                2 !== t.length ||
                ("." !== t[1] && "" !== t[1]) ||
                ((e = !0), t.pop());
            }
            let s = 0;
            for (; -1 !== (s = t.indexOf("..", s + 1)); ) {
              const i = t[s - 1];
              i &&
                "." !== i &&
                ".." !== i &&
                "**" !== i &&
                ((e = !0), t.splice(s - 1, 2), (s -= 2));
            }
          } while (e);
          return 0 === t.length ? [""] : t;
        }
        firstPhasePreProcess(t) {
          let e = !1;
          do {
            e = !1;
            for (let s of t) {
              let i = -1;
              for (; -1 !== (i = s.indexOf("**", i + 1)); ) {
                let n = i;
                for (; "**" === s[n + 1]; ) n++;
                n > i && s.splice(i + 1, n - i);
                let r = s[i + 1];
                const a = s[i + 2],
                  o = s[i + 3];
                if (".." !== r) continue;
                if (
                  !a ||
                  "." === a ||
                  ".." === a ||
                  !o ||
                  "." === o ||
                  ".." === o
                )
                  continue;
                (e = !0), s.splice(i, 1);
                const h = s.slice(0);
                (h[i] = "**"), t.push(h), i--;
              }
              if (!this.preserveMultipleSlashes) {
                for (let t = 1; t < s.length - 1; t++) {
                  const i = s[t];
                  (1 === t && "" === i && "" === s[0]) ||
                    ("." !== i && "" !== i) ||
                    ((e = !0), s.splice(t, 1), t--);
                }
                "." !== s[0] ||
                  2 !== s.length ||
                  ("." !== s[1] && "" !== s[1]) ||
                  ((e = !0), s.pop());
              }
              let n = 0;
              for (; -1 !== (n = s.indexOf("..", n + 1)); ) {
                const t = s[n - 1];
                if (t && "." !== t && ".." !== t && "**" !== t) {
                  e = !0;
                  const t = 1 === n && "**" === s[n + 1] ? ["."] : [];
                  s.splice(n - 1, 2, ...t),
                    0 === s.length && s.push(""),
                    (n -= 2);
                }
              }
            }
          } while (e);
          return t;
        }
        secondPhasePreProcess(t) {
          for (let e = 0; e < t.length - 1; e++)
            for (let s = e + 1; s < t.length; s++) {
              const i = this.partsMatch(
                t[e],
                t[s],
                !this.preserveMultipleSlashes
              );
              i && ((t[e] = i), (t[s] = []));
            }
          return t.filter((t) => t.length);
        }
        partsMatch(t, e, s = !1) {
          let i = 0,
            n = 0,
            r = [],
            a = "";
          for (; i < t.length && n < e.length; )
            if (t[i] === e[n]) r.push("b" === a ? e[n] : t[i]), i++, n++;
            else if (s && "**" === t[i] && e[n] === t[i + 1]) r.push(t[i]), i++;
            else if (s && "**" === e[n] && t[i] === e[n + 1]) r.push(e[n]), n++;
            else if (
              "*" !== t[i] ||
              !e[n] ||
              (!this.options.dot && e[n].startsWith(".")) ||
              "**" === e[n]
            ) {
              if (
                "*" !== e[n] ||
                !t[i] ||
                (!this.options.dot && t[i].startsWith(".")) ||
                "**" === t[i]
              )
                return !1;
              if ("a" === a) return !1;
              (a = "b"), r.push(e[n]), i++, n++;
            } else {
              if ("b" === a) return !1;
              (a = "a"), r.push(t[i]), i++, n++;
            }
          return t.length === e.length && r;
        }
        parseNegate() {
          if (this.nonegate) return;
          const t = this.pattern;
          let e = !1,
            s = 0;
          for (let i = 0; i < t.length && "!" === t.charAt(i); i++)
            (e = !e), s++;
          s && (this.pattern = t.slice(s)), (this.negate = e);
        }
        matchOne(e, s, i = !1) {
          const n = this.options;
          if (this.isWindows) {
            const t = "string" == typeof e[0] && /^[a-z]:$/i.test(e[0]),
              i =
                !t &&
                "" === e[0] &&
                "" === e[1] &&
                "?" === e[2] &&
                /^[a-z]:$/i.test(e[3]),
              n = "string" == typeof s[0] && /^[a-z]:$/i.test(s[0]),
              r = i ? 3 : t ? 0 : void 0,
              a =
                !n &&
                "" === s[0] &&
                "" === s[1] &&
                "?" === s[2] &&
                "string" == typeof s[3] &&
                /^[a-z]:$/i.test(s[3])
                  ? 3
                  : n
                  ? 0
                  : void 0;
            if ("number" == typeof r && "number" == typeof a) {
              const [t, i] = [e[r], s[a]];
              t.toLowerCase() === i.toLowerCase() &&
                ((s[a] = t),
                a > r ? (s = s.slice(a)) : r > a && (e = e.slice(r)));
            }
          }
          const { optimizationLevel: r = 1 } = this.options;
          r >= 2 && (e = this.levelTwoFileOptimize(e)),
            this.debug("matchOne", this, { file: e, pattern: s }),
            this.debug("matchOne", e.length, s.length);
          for (
            var a = 0, o = 0, h = e.length, p = s.length;
            a < h && o < p;
            a++, o++
          ) {
            this.debug("matchOne loop");
            var l = s[o],
              c = e[a];
            if ((this.debug(s, l, c), !1 === l)) return !1;
            if (l === t.GLOBSTAR) {
              this.debug("GLOBSTAR", [s, l, c]);
              var u = a,
                f = o + 1;
              if (f === p) {
                for (this.debug("** at the end"); a < h; a++)
                  if (
                    "." === e[a] ||
                    ".." === e[a] ||
                    (!n.dot && "." === e[a].charAt(0))
                  )
                    return !1;
                return !0;
              }
              for (; u < h; ) {
                var d = e[u];
                if (
                  (this.debug("\nglobstar while", e, u, s, f, d),
                  this.matchOne(e.slice(u), s.slice(f), i))
                )
                  return this.debug("globstar found match!", u, h, d), !0;
                if (
                  "." === d ||
                  ".." === d ||
                  (!n.dot && "." === d.charAt(0))
                ) {
                  this.debug("dot detected!", e, u, s, f);
                  break;
                }
                this.debug("globstar swallow a segment, and continue"), u++;
              }
              return !(
                !i ||
                (this.debug("\n>>> no match, partial?", e, u, s, f), u !== h)
              );
            }
            let r;
            if (
              ("string" == typeof l
                ? ((r = c === l), this.debug("string match", l, c, r))
                : ((r = l.test(c)), this.debug("pattern match", l, c, r)),
              !r)
            )
              return !1;
          }
          if (a === h && o === p) return !0;
          if (a === h) return i;
          if (o === p) return a === h - 1 && "" === e[a];
          throw new Error("wtf?");
        }
        braceExpand() {
          return (0, t.braceExpand)(this.pattern, this.options);
        }
        parse(e) {
          (0, b.assertValidPattern)(e);
          const s = this.options;
          if ("**" === e) return t.GLOBSTAR;
          if ("" === e) return "";
          let i,
            n = null;
          (i = e.match(M))
            ? (n = s.dot ? starTestDot : starTest)
            : (i = e.match(S))
            ? (n = (
                s.nocase
                  ? s.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                  : s.dot
                  ? starDotExtTestDot
                  : starDotExtTest
              )(i[1]))
            : (i = e.match(A))
            ? (n = (
                s.nocase
                  ? s.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                  : s.dot
                  ? qmarksTestDot
                  : qmarksTest
              )(i))
            : (i = e.match(O))
            ? (n = s.dot ? starDotStarTestDot : starDotStarTest)
            : (i = e.match(x)) && (n = dotStarTest);
          const r = w.AST.fromGlob(e, this.options).toMMPattern();
          return n ? Object.assign(r, { test: n }) : r;
        }
        makeRe() {
          if (this.regexp || !1 === this.regexp) return this.regexp;
          const e = this.set;
          if (!e.length) return (this.regexp = !1), this.regexp;
          const s = this.options,
            i = s.noglobstar
              ? "[^/]*?"
              : s.dot
              ? "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?"
              : "(?:(?!(?:\\/|^)\\.).)*?",
            n = new Set(s.nocase ? ["i"] : []);
          let r = e
            .map((e) => {
              const s = e.map((e) => {
                if (e instanceof RegExp)
                  for (const t of e.flags.split("")) n.add(t);
                return "string" == typeof e
                  ? e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
                  : e === t.GLOBSTAR
                  ? t.GLOBSTAR
                  : e._src;
              });
              return (
                s.forEach((e, n) => {
                  const r = s[n + 1],
                    a = s[n - 1];
                  e === t.GLOBSTAR &&
                    a !== t.GLOBSTAR &&
                    (void 0 === a
                      ? void 0 !== r && r !== t.GLOBSTAR
                        ? (s[n + 1] = "(?:\\/|" + i + "\\/)?" + r)
                        : (s[n] = i)
                      : void 0 === r
                      ? (s[n - 1] = a + "(?:\\/|" + i + ")?")
                      : r !== t.GLOBSTAR &&
                        ((s[n - 1] = a + "(?:\\/|\\/" + i + "\\/)" + r),
                        (s[n + 1] = t.GLOBSTAR)));
                }),
                s.filter((e) => e !== t.GLOBSTAR).join("/")
              );
            })
            .join("|");
          const [a, o] = e.length > 1 ? ["(?:", ")"] : ["", ""];
          (r = "^" + a + r + o + "$"), this.negate && (r = "^(?!" + r + ").+$");
          try {
            this.regexp = new RegExp(r, [...n].join(""));
          } catch (t) {
            this.regexp = !1;
          }
          return this.regexp;
        }
        slashSplit(t) {
          return this.preserveMultipleSlashes
            ? t.split("/")
            : this.isWindows && /^\/\/[^\/]+/.test(t)
            ? ["", ...t.split(/\/+/)]
            : t.split(/\/+/);
        }
        match(t, e = this.partial) {
          if ((this.debug("match", t, this.pattern), this.comment)) return !1;
          if (this.empty) return "" === t;
          if ("/" === t && e) return !0;
          const s = this.options;
          this.isWindows && (t = t.split("\\").join("/"));
          const i = this.slashSplit(t);
          this.debug(this.pattern, "split", i);
          const n = this.set;
          this.debug(this.pattern, "set", n);
          let r = i[i.length - 1];
          if (!r) for (let t = i.length - 2; !r && t >= 0; t--) r = i[t];
          for (let t = 0; t < n.length; t++) {
            const a = n[t];
            let o = i;
            s.matchBase && 1 === a.length && (o = [r]);
            if (this.matchOne(o, a, e)) return !!s.flipNegate || !this.negate;
          }
          return !s.flipNegate && this.negate;
        }
        static defaults(e) {
          return t.minimatch.defaults(e).Minimatch;
        }
      };
    t.Minimatch = R;
    var T = f();
    Object.defineProperty(t, "AST", {
      enumerable: !0,
      get: function () {
        return T.AST;
      },
    });
    var $ = d();
    Object.defineProperty(t, "escape", {
      enumerable: !0,
      get: function () {
        return $.escape;
      },
    });
    var L = u();
    Object.defineProperty(t, "unescape", {
      enumerable: !0,
      get: function () {
        return L.unescape;
      },
    }),
      (t.minimatch.AST = w.AST),
      (t.minimatch.Minimatch = R),
      (t.minimatch.escape = y.escape),
      (t.minimatch.unescape = v.unescape);
  },
  "internal/deps/undici/undici": function (A, e, t, r, E, Q) {
    "use strict";
    var o = Object.defineProperty,
      s = Object.getOwnPropertyNames,
      __name = (A, e) => o(A, "name", { value: e, configurable: !0 }),
      __commonJS = (A, e) =>
        function __require() {
          return (
            e || (0, A[s(A)[0]])((e = { exports: {} }).exports, e), e.exports
          );
        },
      i = __commonJS({
        "lib/core/symbols.js"(A, e) {
          e.exports = {
            kClose: Symbol("close"),
            kDestroy: Symbol("destroy"),
            kDispatch: Symbol("dispatch"),
            kUrl: Symbol("url"),
            kWriting: Symbol("writing"),
            kResuming: Symbol("resuming"),
            kQueue: Symbol("queue"),
            kConnect: Symbol("connect"),
            kConnecting: Symbol("connecting"),
            kHeadersList: Symbol("headers list"),
            kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
            kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
            kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
            kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
            kKeepAlive: Symbol("keep alive"),
            kHeadersTimeout: Symbol("headers timeout"),
            kBodyTimeout: Symbol("body timeout"),
            kServerName: Symbol("server name"),
            kLocalAddress: Symbol("local address"),
            kHost: Symbol("host"),
            kNoRef: Symbol("no ref"),
            kBodyUsed: Symbol("used"),
            kRunning: Symbol("running"),
            kBlocking: Symbol("blocking"),
            kPending: Symbol("pending"),
            kSize: Symbol("size"),
            kBusy: Symbol("busy"),
            kQueued: Symbol("queued"),
            kFree: Symbol("free"),
            kConnected: Symbol("connected"),
            kClosed: Symbol("closed"),
            kNeedDrain: Symbol("need drain"),
            kReset: Symbol("reset"),
            kDestroyed: Symbol.for("nodejs.stream.destroyed"),
            kMaxHeadersSize: Symbol("max headers size"),
            kRunningIdx: Symbol("running index"),
            kPendingIdx: Symbol("pending index"),
            kError: Symbol("error"),
            kClients: Symbol("clients"),
            kClient: Symbol("client"),
            kParser: Symbol("parser"),
            kOnDestroyed: Symbol("destroy callbacks"),
            kPipelining: Symbol("pipelining"),
            kSocket: Symbol("socket"),
            kHostHeader: Symbol("host header"),
            kConnector: Symbol("connector"),
            kStrictContentLength: Symbol("strict content length"),
            kMaxRedirections: Symbol("maxRedirections"),
            kMaxRequests: Symbol("maxRequestsPerClient"),
            kProxy: Symbol("proxy agent options"),
            kCounter: Symbol("socket request counter"),
            kInterceptors: Symbol("dispatch interceptors"),
            kMaxResponseSize: Symbol("max response size"),
            kHTTP2Session: Symbol("http2Session"),
            kHTTP2SessionState: Symbol("http2Session state"),
            kHTTP2BuildRequest: Symbol("http2 build request"),
            kHTTP1BuildRequest: Symbol("http1 build request"),
            kHTTP2CopyHeaders: Symbol("http2 copy headers"),
            kHTTPConnVersion: Symbol("http connection version"),
            kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
            kConstruct: Symbol("constructable"),
          };
        },
      }),
      g = __commonJS({
        "lib/fetch/symbols.js"(A, e) {
          e.exports = {
            kUrl: Symbol("url"),
            kHeaders: Symbol("headers"),
            kSignal: Symbol("signal"),
            kState: Symbol("state"),
            kGuard: Symbol("guard"),
            kRealm: Symbol("realm"),
          };
        },
      }),
      B = __commonJS({
        "lib/core/errors.js"(A, e) {
          var t = class extends Error {
              static {
                __name(this, "UndiciError");
              }
              constructor(A) {
                super(A), (this.name = "UndiciError"), (this.code = "UND_ERR");
              }
            },
            r = class _ConnectTimeoutError extends t {
              static {
                __name(this, "ConnectTimeoutError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _ConnectTimeoutError),
                  (this.name = "ConnectTimeoutError"),
                  (this.message = A || "Connect Timeout Error"),
                  (this.code = "UND_ERR_CONNECT_TIMEOUT");
              }
            },
            E = class _HeadersTimeoutError extends t {
              static {
                __name(this, "HeadersTimeoutError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _HeadersTimeoutError),
                  (this.name = "HeadersTimeoutError"),
                  (this.message = A || "Headers Timeout Error"),
                  (this.code = "UND_ERR_HEADERS_TIMEOUT");
              }
            },
            Q = class _HeadersOverflowError extends t {
              static {
                __name(this, "HeadersOverflowError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _HeadersOverflowError),
                  (this.name = "HeadersOverflowError"),
                  (this.message = A || "Headers Overflow Error"),
                  (this.code = "UND_ERR_HEADERS_OVERFLOW");
              }
            },
            o = class _BodyTimeoutError extends t {
              static {
                __name(this, "BodyTimeoutError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _BodyTimeoutError),
                  (this.name = "BodyTimeoutError"),
                  (this.message = A || "Body Timeout Error"),
                  (this.code = "UND_ERR_BODY_TIMEOUT");
              }
            },
            s = class _ResponseStatusCodeError extends t {
              static {
                __name(this, "ResponseStatusCodeError");
              }
              constructor(A, e, t, r) {
                super(A),
                  Error.captureStackTrace(this, _ResponseStatusCodeError),
                  (this.name = "ResponseStatusCodeError"),
                  (this.message = A || "Response Status Code Error"),
                  (this.code = "UND_ERR_RESPONSE_STATUS_CODE"),
                  (this.body = r),
                  (this.status = e),
                  (this.statusCode = e),
                  (this.headers = t);
              }
            },
            i = class _InvalidArgumentError extends t {
              static {
                __name(this, "InvalidArgumentError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _InvalidArgumentError),
                  (this.name = "InvalidArgumentError"),
                  (this.message = A || "Invalid Argument Error"),
                  (this.code = "UND_ERR_INVALID_ARG");
              }
            },
            g = class _InvalidReturnValueError extends t {
              static {
                __name(this, "InvalidReturnValueError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _InvalidReturnValueError),
                  (this.name = "InvalidReturnValueError"),
                  (this.message = A || "Invalid Return Value Error"),
                  (this.code = "UND_ERR_INVALID_RETURN_VALUE");
              }
            },
            B = class _RequestAbortedError extends t {
              static {
                __name(this, "RequestAbortedError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _RequestAbortedError),
                  (this.name = "AbortError"),
                  (this.message = A || "Request aborted"),
                  (this.code = "UND_ERR_ABORTED");
              }
            },
            C = class _InformationalError extends t {
              static {
                __name(this, "InformationalError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _InformationalError),
                  (this.name = "InformationalError"),
                  (this.message = A || "Request information"),
                  (this.code = "UND_ERR_INFO");
              }
            },
            I = class _RequestContentLengthMismatchError extends t {
              static {
                __name(this, "RequestContentLengthMismatchError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(
                    this,
                    _RequestContentLengthMismatchError
                  ),
                  (this.name = "RequestContentLengthMismatchError"),
                  (this.message =
                    A ||
                    "Request body length does not match content-length header"),
                  (this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH");
              }
            },
            n = class _ResponseContentLengthMismatchError extends t {
              static {
                __name(this, "ResponseContentLengthMismatchError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(
                    this,
                    _ResponseContentLengthMismatchError
                  ),
                  (this.name = "ResponseContentLengthMismatchError"),
                  (this.message =
                    A ||
                    "Response body length does not match content-length header"),
                  (this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH");
              }
            },
            a = class _ClientDestroyedError extends t {
              static {
                __name(this, "ClientDestroyedError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _ClientDestroyedError),
                  (this.name = "ClientDestroyedError"),
                  (this.message = A || "The client is destroyed"),
                  (this.code = "UND_ERR_DESTROYED");
              }
            },
            h = class _ClientClosedError extends t {
              static {
                __name(this, "ClientClosedError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _ClientClosedError),
                  (this.name = "ClientClosedError"),
                  (this.message = A || "The client is closed"),
                  (this.code = "UND_ERR_CLOSED");
              }
            },
            c = class _SocketError extends t {
              static {
                __name(this, "SocketError");
              }
              constructor(A, e) {
                super(A),
                  Error.captureStackTrace(this, _SocketError),
                  (this.name = "SocketError"),
                  (this.message = A || "Socket error"),
                  (this.code = "UND_ERR_SOCKET"),
                  (this.socket = e);
              }
            },
            l = class _NotSupportedError extends t {
              static {
                __name(this, "NotSupportedError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _NotSupportedError),
                  (this.name = "NotSupportedError"),
                  (this.message = A || "Not supported error"),
                  (this.code = "UND_ERR_NOT_SUPPORTED");
              }
            },
            d = class extends t {
              static {
                __name(this, "BalancedPoolMissingUpstreamError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, l),
                  (this.name = "MissingUpstreamError"),
                  (this.message =
                    A || "No upstream has been added to the BalancedPool"),
                  (this.code = "UND_ERR_BPL_MISSING_UPSTREAM");
              }
            },
            u = class _HTTPParserError extends Error {
              static {
                __name(this, "HTTPParserError");
              }
              constructor(A, e, t) {
                super(A),
                  Error.captureStackTrace(this, _HTTPParserError),
                  (this.name = "HTTPParserError"),
                  (this.code = e ? `HPE_${e}` : void 0),
                  (this.data = t ? t.toString() : void 0);
              }
            },
            D = class _ResponseExceededMaxSizeError extends t {
              static {
                __name(this, "ResponseExceededMaxSizeError");
              }
              constructor(A) {
                super(A),
                  Error.captureStackTrace(this, _ResponseExceededMaxSizeError),
                  (this.name = "ResponseExceededMaxSizeError"),
                  (this.message = A || "Response content exceeded max size"),
                  (this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE");
              }
            },
            R = class _RequestRetryError extends t {
              static {
                __name(this, "RequestRetryError");
              }
              constructor(A, e, { headers: t, data: r }) {
                super(A),
                  Error.captureStackTrace(this, _RequestRetryError),
                  (this.name = "RequestRetryError"),
                  (this.message = A || "Request retry error"),
                  (this.code = "UND_ERR_REQ_RETRY"),
                  (this.statusCode = e),
                  (this.data = r),
                  (this.headers = t);
              }
            };
          e.exports = {
            HTTPParserError: u,
            UndiciError: t,
            HeadersTimeoutError: E,
            HeadersOverflowError: Q,
            BodyTimeoutError: o,
            RequestContentLengthMismatchError: I,
            ConnectTimeoutError: r,
            ResponseStatusCodeError: s,
            InvalidArgumentError: i,
            InvalidReturnValueError: g,
            RequestAbortedError: B,
            ClientDestroyedError: a,
            ClientClosedError: h,
            InformationalError: C,
            SocketError: c,
            NotSupportedError: l,
            ResponseContentLengthMismatchError: n,
            BalancedPoolMissingUpstreamError: d,
            ResponseExceededMaxSizeError: D,
            RequestRetryError: R,
          };
        },
      }),
      C = __commonJS({
        "lib/core/constants.js"(A, e) {
          var t = {},
            r = [
              "Accept",
              "Accept-Encoding",
              "Accept-Language",
              "Accept-Ranges",
              "Access-Control-Allow-Credentials",
              "Access-Control-Allow-Headers",
              "Access-Control-Allow-Methods",
              "Access-Control-Allow-Origin",
              "Access-Control-Expose-Headers",
              "Access-Control-Max-Age",
              "Access-Control-Request-Headers",
              "Access-Control-Request-Method",
              "Age",
              "Allow",
              "Alt-Svc",
              "Alt-Used",
              "Authorization",
              "Cache-Control",
              "Clear-Site-Data",
              "Connection",
              "Content-Disposition",
              "Content-Encoding",
              "Content-Language",
              "Content-Length",
              "Content-Location",
              "Content-Range",
              "Content-Security-Policy",
              "Content-Security-Policy-Report-Only",
              "Content-Type",
              "Cookie",
              "Cross-Origin-Embedder-Policy",
              "Cross-Origin-Opener-Policy",
              "Cross-Origin-Resource-Policy",
              "Date",
              "Device-Memory",
              "Downlink",
              "ECT",
              "ETag",
              "Expect",
              "Expect-CT",
              "Expires",
              "Forwarded",
              "From",
              "Host",
              "If-Match",
              "If-Modified-Since",
              "If-None-Match",
              "If-Range",
              "If-Unmodified-Since",
              "Keep-Alive",
              "Last-Modified",
              "Link",
              "Location",
              "Max-Forwards",
              "Origin",
              "Permissions-Policy",
              "Pragma",
              "Proxy-Authenticate",
              "Proxy-Authorization",
              "RTT",
              "Range",
              "Referer",
              "Referrer-Policy",
              "Refresh",
              "Retry-After",
              "Sec-WebSocket-Accept",
              "Sec-WebSocket-Extensions",
              "Sec-WebSocket-Key",
              "Sec-WebSocket-Protocol",
              "Sec-WebSocket-Version",
              "Server",
              "Server-Timing",
              "Service-Worker-Allowed",
              "Service-Worker-Navigation-Preload",
              "Set-Cookie",
              "SourceMap",
              "Strict-Transport-Security",
              "Supports-Loading-Mode",
              "TE",
              "Timing-Allow-Origin",
              "Trailer",
              "Transfer-Encoding",
              "Upgrade",
              "Upgrade-Insecure-Requests",
              "User-Agent",
              "Vary",
              "Via",
              "WWW-Authenticate",
              "X-Content-Type-Options",
              "X-DNS-Prefetch-Control",
              "X-Frame-Options",
              "X-Permitted-Cross-Domain-Policies",
              "X-Powered-By",
              "X-Requested-With",
              "X-XSS-Protection",
            ];
          for (let A = 0; A < r.length; ++A) {
            const e = r[A],
              E = e.toLowerCase();
            t[e] = t[E] = E;
          }
          Object.setPrototypeOf(t, null),
            (e.exports = {
              wellknownHeaderNames: r,
              headerNameLowerCasedRecord: t,
            });
        },
      }),
      I = __commonJS({
        "lib/core/util.js"(A, t) {
          var E = e("assert"),
            { kDestroyed: Q, kBodyUsed: o } = i(),
            { IncomingMessage: s } = e("http"),
            g = e("stream"),
            I = e("net"),
            { InvalidArgumentError: n } = B(),
            { Blob: a } = e("buffer"),
            h = e("util"),
            { stringify: c } = e("querystring"),
            { headerNameLowerCasedRecord: l } = C(),
            [d, u] = r.versions.node.split(".").map((A) => Number(A));
          function nop() {}
          function isStream(A) {
            return (
              A &&
              "object" == typeof A &&
              "function" == typeof A.pipe &&
              "function" == typeof A.on
            );
          }
          function isBlobLike(A) {
            return (
              (a && A instanceof a) ||
              (A &&
                "object" == typeof A &&
                ("function" == typeof A.stream ||
                  "function" == typeof A.arrayBuffer) &&
                /^(Blob|File)$/.test(A[Symbol.toStringTag]))
            );
          }
          function buildURL(A, e) {
            if (A.includes("?") || A.includes("#"))
              throw new Error(
                'Query params cannot be passed when url already contains "?" or "#".'
              );
            const t = c(e);
            return t && (A += "?" + t), A;
          }
          function parseURL(A) {
            if ("string" == typeof A) {
              if (((A = new URL(A)), !/^https?:/.test(A.origin || A.protocol)))
                throw new n(
                  "Invalid URL protocol: the URL must start with `http:` or `https:`."
                );
              return A;
            }
            if (!A || "object" != typeof A)
              throw new n(
                "Invalid URL: The URL argument must be a non-null object."
              );
            if (!/^https?:/.test(A.origin || A.protocol))
              throw new n(
                "Invalid URL protocol: the URL must start with `http:` or `https:`."
              );
            if (!(A instanceof URL)) {
              if (
                null != A.port &&
                "" !== A.port &&
                !Number.isFinite(parseInt(A.port))
              )
                throw new n(
                  "Invalid URL: port must be a valid integer or a string representation of an integer."
                );
              if (null != A.path && "string" != typeof A.path)
                throw new n(
                  "Invalid URL path: the path must be a string or null/undefined."
                );
              if (null != A.pathname && "string" != typeof A.pathname)
                throw new n(
                  "Invalid URL pathname: the pathname must be a string or null/undefined."
                );
              if (null != A.hostname && "string" != typeof A.hostname)
                throw new n(
                  "Invalid URL hostname: the hostname must be a string or null/undefined."
                );
              if (null != A.origin && "string" != typeof A.origin)
                throw new n(
                  "Invalid URL origin: the origin must be a string or null/undefined."
                );
              const e =
                null != A.port ? A.port : "https:" === A.protocol ? 443 : 80;
              let t =
                  null != A.origin
                    ? A.origin
                    : `${A.protocol}//${A.hostname}:${e}`,
                r =
                  null != A.path
                    ? A.path
                    : `${A.pathname || ""}${A.search || ""}`;
              t.endsWith("/") && (t = t.substring(0, t.length - 1)),
                r && !r.startsWith("/") && (r = `/${r}`),
                (A = new URL(t + r));
            }
            return A;
          }
          function parseOrigin(A) {
            if ("/" !== (A = parseURL(A)).pathname || A.search || A.hash)
              throw new n("invalid url");
            return A;
          }
          function getHostname(A) {
            if ("[" === A[0]) {
              const e = A.indexOf("]");
              return E(-1 !== e), A.substring(1, e);
            }
            const e = A.indexOf(":");
            return -1 === e ? A : A.substring(0, e);
          }
          function getServerName(A) {
            if (!A) return null;
            E.strictEqual(typeof A, "string");
            const e = getHostname(A);
            return I.isIP(e) ? "" : e;
          }
          function deepClone(A) {
            return JSON.parse(JSON.stringify(A));
          }
          function isAsyncIterable(A) {
            return !(null == A || "function" != typeof A[Symbol.asyncIterator]);
          }
          function isIterable(A) {
            return !(
              null == A ||
              ("function" != typeof A[Symbol.iterator] &&
                "function" != typeof A[Symbol.asyncIterator])
            );
          }
          function bodyLength(A) {
            if (null == A) return 0;
            if (isStream(A)) {
              const e = A._readableState;
              return e &&
                !1 === e.objectMode &&
                !0 === e.ended &&
                Number.isFinite(e.length)
                ? e.length
                : null;
            }
            return isBlobLike(A)
              ? null != A.size
                ? A.size
                : null
              : isBuffer(A)
              ? A.byteLength
              : null;
          }
          function isDestroyed(A) {
            return !A || !(!A.destroyed && !A[Q]);
          }
          function isReadableAborted(A) {
            const e = A && A._readableState;
            return isDestroyed(A) && e && !e.endEmitted;
          }
          function destroy(A, e) {
            null != A &&
              isStream(A) &&
              !isDestroyed(A) &&
              ("function" == typeof A.destroy
                ? (Object.getPrototypeOf(A).constructor === s &&
                    (A.socket = null),
                  A.destroy(e))
                : e &&
                  r.nextTick(
                    (A, e) => {
                      A.emit("error", e);
                    },
                    A,
                    e
                  ),
              !0 !== A.destroyed && (A[Q] = !0));
          }
          __name(nop, "nop"),
            __name(isStream, "isStream"),
            __name(isBlobLike, "isBlobLike"),
            __name(buildURL, "buildURL"),
            __name(parseURL, "parseURL"),
            __name(parseOrigin, "parseOrigin"),
            __name(getHostname, "getHostname"),
            __name(getServerName, "getServerName"),
            __name(deepClone, "deepClone"),
            __name(isAsyncIterable, "isAsyncIterable"),
            __name(isIterable, "isIterable"),
            __name(bodyLength, "bodyLength"),
            __name(isDestroyed, "isDestroyed"),
            __name(isReadableAborted, "isReadableAborted"),
            __name(destroy, "destroy");
          var D,
            R = /timeout=(\d+)/;
          function parseKeepAliveTimeout(A) {
            const e = A.toString().match(R);
            return e ? 1e3 * parseInt(e[1], 10) : null;
          }
          function headerNameToString(A) {
            return l[A] || A.toLowerCase();
          }
          function parseHeaders(A, e = {}) {
            if (!Array.isArray(A)) return A;
            for (let t = 0; t < A.length; t += 2) {
              const r = A[t].toString().toLowerCase();
              let E = e[r];
              E
                ? (Array.isArray(E) || ((E = [E]), (e[r] = E)),
                  E.push(A[t + 1].toString("utf8")))
                : Array.isArray(A[t + 1])
                ? (e[r] = A[t + 1].map((A) => A.toString("utf8")))
                : (e[r] = A[t + 1].toString("utf8"));
            }
            return (
              "content-length" in e &&
                "content-disposition" in e &&
                (e["content-disposition"] = Buffer.from(
                  e["content-disposition"]
                ).toString("latin1")),
              e
            );
          }
          function parseRawHeaders(A) {
            const e = [];
            let t = !1,
              r = -1;
            for (let E = 0; E < A.length; E += 2) {
              const Q = A[E + 0].toString(),
                o = A[E + 1].toString("utf8");
              14 !== Q.length ||
              ("content-length" !== Q && "content-length" !== Q.toLowerCase())
                ? 19 !== Q.length ||
                  ("content-disposition" !== Q &&
                    "content-disposition" !== Q.toLowerCase())
                  ? e.push(Q, o)
                  : (r = e.push(Q, o) - 1)
                : (e.push(Q, o), (t = !0));
            }
            return (
              t && -1 !== r && (e[r] = Buffer.from(e[r]).toString("latin1")), e
            );
          }
          function isBuffer(A) {
            return A instanceof Uint8Array || Buffer.isBuffer(A);
          }
          function validateHandler(A, e, t) {
            if (!A || "object" != typeof A)
              throw new n("handler must be an object");
            if ("function" != typeof A.onConnect)
              throw new n("invalid onConnect method");
            if ("function" != typeof A.onError)
              throw new n("invalid onError method");
            if ("function" != typeof A.onBodySent && void 0 !== A.onBodySent)
              throw new n("invalid onBodySent method");
            if (t || "CONNECT" === e) {
              if ("function" != typeof A.onUpgrade)
                throw new n("invalid onUpgrade method");
            } else {
              if ("function" != typeof A.onHeaders)
                throw new n("invalid onHeaders method");
              if ("function" != typeof A.onData)
                throw new n("invalid onData method");
              if ("function" != typeof A.onComplete)
                throw new n("invalid onComplete method");
            }
          }
          function isDisturbed(A) {
            return !(
              !A ||
              !(g.isDisturbed
                ? g.isDisturbed(A) || A[o]
                : A[o] ||
                  A.readableDidRead ||
                  (A._readableState && A._readableState.dataEmitted) ||
                  isReadableAborted(A))
            );
          }
          function isErrored(A) {
            return !(
              !A ||
              !(g.isErrored
                ? g.isErrored(A)
                : /state: 'errored'/.test(h.inspect(A)))
            );
          }
          function isReadable(A) {
            return !(
              !A ||
              !(g.isReadable
                ? g.isReadable(A)
                : /state: 'readable'/.test(h.inspect(A)))
            );
          }
          function getSocketInfo(A) {
            return {
              localAddress: A.localAddress,
              localPort: A.localPort,
              remoteAddress: A.remoteAddress,
              remotePort: A.remotePort,
              remoteFamily: A.remoteFamily,
              timeout: A.timeout,
              bytesWritten: A.bytesWritten,
              bytesRead: A.bytesRead,
            };
          }
          async function* convertIterableToBuffer(A) {
            for await (const e of A)
              yield Buffer.isBuffer(e) ? e : Buffer.from(e);
          }
          function ReadableStreamFrom(A) {
            if ((D || (D = e("stream/web").ReadableStream), D.from))
              return D.from(convertIterableToBuffer(A));
            let t;
            return new D(
              {
                async start() {
                  t = A[Symbol.asyncIterator]();
                },
                async pull(A) {
                  const { done: e, value: r } = await t.next();
                  if (e)
                    queueMicrotask(() => {
                      A.close();
                    });
                  else {
                    const e = Buffer.isBuffer(r) ? r : Buffer.from(r);
                    A.enqueue(new Uint8Array(e));
                  }
                  return A.desiredSize > 0;
                },
                async cancel(A) {
                  await t.return();
                },
              },
              0
            );
          }
          function isFormDataLike(A) {
            return (
              A &&
              "object" == typeof A &&
              "function" == typeof A.append &&
              "function" == typeof A.delete &&
              "function" == typeof A.get &&
              "function" == typeof A.getAll &&
              "function" == typeof A.has &&
              "function" == typeof A.set &&
              "FormData" === A[Symbol.toStringTag]
            );
          }
          function throwIfAborted(A) {
            if (A)
              if ("function" == typeof A.throwIfAborted) A.throwIfAborted();
              else if (A.aborted) {
                const A = new Error("The operation was aborted");
                throw ((A.name = "AbortError"), A);
              }
          }
          function addAbortListener(A, e) {
            return "addEventListener" in A
              ? (A.addEventListener("abort", e, { once: !0 }),
                () => A.removeEventListener("abort", e))
              : (A.addListener("abort", e), () => A.removeListener("abort", e));
          }
          __name(parseKeepAliveTimeout, "parseKeepAliveTimeout"),
            __name(headerNameToString, "headerNameToString"),
            __name(parseHeaders, "parseHeaders"),
            __name(parseRawHeaders, "parseRawHeaders"),
            __name(isBuffer, "isBuffer"),
            __name(validateHandler, "validateHandler"),
            __name(isDisturbed, "isDisturbed"),
            __name(isErrored, "isErrored"),
            __name(isReadable, "isReadable"),
            __name(getSocketInfo, "getSocketInfo"),
            __name(convertIterableToBuffer, "convertIterableToBuffer"),
            __name(ReadableStreamFrom, "ReadableStreamFrom"),
            __name(isFormDataLike, "isFormDataLike"),
            __name(throwIfAborted, "throwIfAborted"),
            __name(addAbortListener, "addAbortListener");
          var y = !!String.prototype.toWellFormed;
          function toUSVString(A) {
            return y
              ? `${A}`.toWellFormed()
              : h.toUSVString
              ? h.toUSVString(A)
              : `${A}`;
          }
          function parseRangeHeader(A) {
            if (null == A || "" === A)
              return { start: 0, end: null, size: null };
            const e = A ? A.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
            return e
              ? {
                  start: parseInt(e[1]),
                  end: e[2] ? parseInt(e[2]) : null,
                  size: e[3] ? parseInt(e[3]) : null,
                }
              : null;
          }
          __name(toUSVString, "toUSVString"),
            __name(parseRangeHeader, "parseRangeHeader");
          var f = Object.create(null);
          (f.enumerable = !0),
            (t.exports = {
              kEnumerableProperty: f,
              nop: nop,
              isDisturbed: isDisturbed,
              isErrored: isErrored,
              isReadable: isReadable,
              toUSVString: toUSVString,
              isReadableAborted: isReadableAborted,
              isBlobLike: isBlobLike,
              parseOrigin: parseOrigin,
              parseURL: parseURL,
              getServerName: getServerName,
              isStream: isStream,
              isIterable: isIterable,
              isAsyncIterable: isAsyncIterable,
              isDestroyed: isDestroyed,
              headerNameToString: headerNameToString,
              parseRawHeaders: parseRawHeaders,
              parseHeaders: parseHeaders,
              parseKeepAliveTimeout: parseKeepAliveTimeout,
              destroy: destroy,
              bodyLength: bodyLength,
              deepClone: deepClone,
              ReadableStreamFrom: ReadableStreamFrom,
              isBuffer: isBuffer,
              validateHandler: validateHandler,
              getSocketInfo: getSocketInfo,
              isFormDataLike: isFormDataLike,
              buildURL: buildURL,
              throwIfAborted: throwIfAborted,
              addAbortListener: addAbortListener,
              parseRangeHeader: parseRangeHeader,
              nodeMajor: d,
              nodeMinor: u,
              nodeHasAutoSelectFamily: d > 18 || (18 === d && u >= 13),
              safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
            });
        },
      }),
      n = __commonJS({
        "lib/fetch/constants.js"(A, t) {
          var r,
            { MessageChannel: E, receiveMessageOnPort: Q } =
              e("worker_threads"),
            o = ["GET", "HEAD", "POST"],
            s = new Set(o),
            i = [301, 302, 303, 307, 308],
            g = new Set(i),
            B = [
              "1",
              "7",
              "9",
              "11",
              "13",
              "15",
              "17",
              "19",
              "20",
              "21",
              "22",
              "23",
              "25",
              "37",
              "42",
              "43",
              "53",
              "69",
              "77",
              "79",
              "87",
              "95",
              "101",
              "102",
              "103",
              "104",
              "109",
              "110",
              "111",
              "113",
              "115",
              "117",
              "119",
              "123",
              "135",
              "137",
              "139",
              "143",
              "161",
              "179",
              "389",
              "427",
              "465",
              "512",
              "513",
              "514",
              "515",
              "526",
              "530",
              "531",
              "532",
              "540",
              "548",
              "554",
              "556",
              "563",
              "587",
              "601",
              "636",
              "989",
              "990",
              "993",
              "995",
              "1719",
              "1720",
              "1723",
              "2049",
              "3659",
              "4045",
              "5060",
              "5061",
              "6000",
              "6566",
              "6665",
              "6666",
              "6667",
              "6668",
              "6669",
              "6697",
              "10080",
            ],
            C = new Set(B),
            I = [
              "",
              "no-referrer",
              "no-referrer-when-downgrade",
              "same-origin",
              "origin",
              "strict-origin",
              "origin-when-cross-origin",
              "strict-origin-when-cross-origin",
              "unsafe-url",
            ],
            n = new Set(I),
            a = ["GET", "HEAD", "OPTIONS", "TRACE"],
            h = new Set(a),
            c = ["CONNECT", "TRACE", "TRACK"],
            l = new Set(c),
            d = [
              "audio",
              "audioworklet",
              "font",
              "image",
              "manifest",
              "paintworklet",
              "script",
              "style",
              "track",
              "video",
              "xslt",
              "",
            ],
            u = new Set(d),
            D =
              globalThis.DOMException ??
              (() => {
                try {
                  atob("~");
                } catch (A) {
                  return Object.getPrototypeOf(A).constructor;
                }
              })(),
            R =
              globalThis.structuredClone ??
              __name(function structuredClone2(A, e = void 0) {
                if (0 === arguments.length)
                  throw new TypeError("missing argument");
                return (
                  r || (r = new E()),
                  r.port1.unref(),
                  r.port2.unref(),
                  r.port1.postMessage(A, e?.transfer),
                  Q(r.port2).message
                );
              }, "structuredClone");
          t.exports = {
            DOMException: D,
            structuredClone: R,
            subresource: d,
            forbiddenMethods: c,
            requestBodyHeader: [
              "content-encoding",
              "content-language",
              "content-location",
              "content-type",
              "content-length",
            ],
            referrerPolicy: I,
            requestRedirect: ["follow", "manual", "error"],
            requestMode: ["navigate", "same-origin", "no-cors", "cors"],
            requestCredentials: ["omit", "same-origin", "include"],
            requestCache: [
              "default",
              "no-store",
              "reload",
              "no-cache",
              "force-cache",
              "only-if-cached",
            ],
            redirectStatus: i,
            corsSafeListedMethods: o,
            nullBodyStatus: [101, 204, 205, 304],
            safeMethods: a,
            badPorts: B,
            requestDuplex: ["half"],
            subresourceSet: u,
            badPortsSet: C,
            redirectStatusSet: g,
            corsSafeListedMethodsSet: s,
            safeMethodsSet: h,
            forbiddenMethodsSet: l,
            referrerPolicySet: n,
          };
        },
      }),
      a = __commonJS({
        "lib/fetch/global.js"(A, e) {
          var t = Symbol.for("undici.globalOrigin.1");
          function getGlobalOrigin() {
            return globalThis[t];
          }
          function setGlobalOrigin(A) {
            if (void 0 === A)
              return void Object.defineProperty(globalThis, t, {
                value: void 0,
                writable: !0,
                enumerable: !1,
                configurable: !1,
              });
            const e = new URL(A);
            if ("http:" !== e.protocol && "https:" !== e.protocol)
              throw new TypeError(
                `Only http & https urls are allowed, received ${e.protocol}`
              );
            Object.defineProperty(globalThis, t, {
              value: e,
              writable: !0,
              enumerable: !1,
              configurable: !1,
            });
          }
          __name(getGlobalOrigin, "getGlobalOrigin"),
            __name(setGlobalOrigin, "setGlobalOrigin"),
            (e.exports = {
              getGlobalOrigin: getGlobalOrigin,
              setGlobalOrigin: setGlobalOrigin,
            });
        },
      }),
      h = __commonJS({
        "lib/fetch/util.js"(A, t) {
          var r,
            {
              redirectStatusSet: E,
              referrerPolicySet: Q,
              badPortsSet: o,
            } = n(),
            { getGlobalOrigin: s } = a(),
            { performance: i } = e("perf_hooks"),
            { isBlobLike: g, toUSVString: B, ReadableStreamFrom: C } = I(),
            h = e("assert"),
            { isUint8Array: c } = e("util/types"),
            l = [];
          try {
            r = e("crypto");
            const A = ["sha256", "sha384", "sha512"];
            l = r.getHashes().filter((e) => A.includes(e));
          } catch {}
          function responseURL(A) {
            const e = A.urlList,
              t = e.length;
            return 0 === t ? null : e[t - 1].toString();
          }
          function responseLocationURL(A, e) {
            if (!E.has(A.status)) return null;
            let t = A.headersList.get("location");
            return (
              null !== t &&
                isValidHeaderValue(t) &&
                (t = new URL(t, responseURL(A))),
              t && !t.hash && (t.hash = e),
              t
            );
          }
          function requestCurrentURL(A) {
            return A.urlList[A.urlList.length - 1];
          }
          function requestBadPort(A) {
            const e = requestCurrentURL(A);
            return urlIsHttpHttpsScheme(e) && o.has(e.port)
              ? "blocked"
              : "allowed";
          }
          function isErrorLike(A) {
            return (
              A instanceof Error ||
              "Error" === A?.constructor?.name ||
              "DOMException" === A?.constructor?.name
            );
          }
          function isValidReasonPhrase(A) {
            for (let e = 0; e < A.length; ++e) {
              const t = A.charCodeAt(e);
              if (!(9 === t || (t >= 32 && t <= 126) || (t >= 128 && t <= 255)))
                return !1;
            }
            return !0;
          }
          function isTokenCharCode(A) {
            switch (A) {
              case 34:
              case 40:
              case 41:
              case 44:
              case 47:
              case 58:
              case 59:
              case 60:
              case 61:
              case 62:
              case 63:
              case 64:
              case 91:
              case 92:
              case 93:
              case 123:
              case 125:
                return !1;
              default:
                return A >= 33 && A <= 126;
            }
          }
          function isValidHTTPToken(A) {
            if (0 === A.length) return !1;
            for (let e = 0; e < A.length; ++e)
              if (!isTokenCharCode(A.charCodeAt(e))) return !1;
            return !0;
          }
          function isValidHeaderName(A) {
            return isValidHTTPToken(A);
          }
          function isValidHeaderValue(A) {
            return (
              !(
                A.startsWith("\t") ||
                A.startsWith(" ") ||
                A.endsWith("\t") ||
                A.endsWith(" ")
              ) && !(A.includes("\0") || A.includes("\r") || A.includes("\n"))
            );
          }
          function setRequestReferrerPolicyOnRedirect(A, e) {
            const { headersList: t } = e,
              r = (t.get("referrer-policy") ?? "").split(",");
            let E = "";
            if (r.length > 0)
              for (let A = r.length; 0 !== A; A--) {
                const e = r[A - 1].trim();
                if (Q.has(e)) {
                  E = e;
                  break;
                }
              }
            "" !== E && (A.referrerPolicy = E);
          }
          function crossOriginResourcePolicyCheck() {
            return "allowed";
          }
          function corsCheck() {
            return "success";
          }
          function TAOCheck() {
            return "success";
          }
          function appendFetchMetadata(A) {
            let e = null;
            (e = A.mode), A.headersList.set("sec-fetch-mode", e);
          }
          function appendRequestOriginHeader(A) {
            let e = A.origin;
            if ("cors" === A.responseTainting || "websocket" === A.mode)
              e && A.headersList.append("origin", e);
            else if ("GET" !== A.method && "HEAD" !== A.method) {
              switch (A.referrerPolicy) {
                case "no-referrer":
                  e = null;
                  break;
                case "no-referrer-when-downgrade":
                case "strict-origin":
                case "strict-origin-when-cross-origin":
                  A.origin &&
                    urlHasHttpsScheme(A.origin) &&
                    !urlHasHttpsScheme(requestCurrentURL(A)) &&
                    (e = null);
                  break;
                case "same-origin":
                  sameOrigin(A, requestCurrentURL(A)) || (e = null);
              }
              e && A.headersList.append("origin", e);
            }
          }
          function coarsenedSharedCurrentTime(A) {
            return i.now();
          }
          function createOpaqueTimingInfo(A) {
            return {
              startTime: A.startTime ?? 0,
              redirectStartTime: 0,
              redirectEndTime: 0,
              postRedirectStartTime: A.startTime ?? 0,
              finalServiceWorkerStartTime: 0,
              finalNetworkResponseStartTime: 0,
              finalNetworkRequestStartTime: 0,
              endTime: 0,
              encodedBodySize: 0,
              decodedBodySize: 0,
              finalConnectionTimingInfo: null,
            };
          }
          function makePolicyContainer() {
            return { referrerPolicy: "strict-origin-when-cross-origin" };
          }
          function clonePolicyContainer(A) {
            return { referrerPolicy: A.referrerPolicy };
          }
          function determineRequestsReferrer(A) {
            const e = A.referrerPolicy;
            h(e);
            let t = null;
            if ("client" === A.referrer) {
              const A = s();
              if (!A || "null" === A.origin) return "no-referrer";
              t = new URL(A);
            } else A.referrer instanceof URL && (t = A.referrer);
            let r = stripURLForReferrer(t);
            const E = stripURLForReferrer(t, !0);
            r.toString().length > 4096 && (r = E);
            const Q = sameOrigin(A, r),
              o =
                isURLPotentiallyTrustworthy(r) &&
                !isURLPotentiallyTrustworthy(A.url);
            switch (e) {
              case "origin":
                return null != E ? E : stripURLForReferrer(t, !0);
              case "unsafe-url":
                return r;
              case "same-origin":
                return Q ? E : "no-referrer";
              case "origin-when-cross-origin":
                return Q ? r : E;
              case "strict-origin-when-cross-origin": {
                const e = requestCurrentURL(A);
                return sameOrigin(r, e)
                  ? r
                  : isURLPotentiallyTrustworthy(r) &&
                    !isURLPotentiallyTrustworthy(e)
                  ? "no-referrer"
                  : E;
              }
              default:
                return o ? "no-referrer" : E;
            }
          }
          function stripURLForReferrer(A, e) {
            return (
              h(A instanceof URL),
              "file:" === A.protocol ||
              "about:" === A.protocol ||
              "blank:" === A.protocol
                ? "no-referrer"
                : ((A.username = ""),
                  (A.password = ""),
                  (A.hash = ""),
                  e && ((A.pathname = ""), (A.search = "")),
                  A)
            );
          }
          function isURLPotentiallyTrustworthy(A) {
            return (
              A instanceof URL &&
              ("about:blank" === A.href ||
                "about:srcdoc" === A.href ||
                "data:" === A.protocol ||
                "file:" === A.protocol ||
                isOriginPotentiallyTrustworthy(A.origin))
            );
            function isOriginPotentiallyTrustworthy(A) {
              if (null == A || "null" === A) return !1;
              const e = new URL(A);
              return (
                "https:" === e.protocol ||
                "wss:" === e.protocol ||
                !!(
                  /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(
                    e.hostname
                  ) ||
                  "localhost" === e.hostname ||
                  e.hostname.includes("localhost.") ||
                  e.hostname.endsWith(".localhost")
                )
              );
            }
          }
          function bytesMatch(A, e) {
            if (void 0 === r) return !0;
            const t = parseMetadata(e);
            if ("no metadata" === t) return !0;
            if (0 === t.length) return !0;
            const E = filterMetadataListByAlgorithm(t, getStrongestMetadata(t));
            for (const e of E) {
              const t = e.algo,
                E = e.hash;
              let Q = r.createHash(t).update(A).digest("base64");
              if (
                ("=" === Q[Q.length - 1] &&
                  (Q =
                    "=" === Q[Q.length - 2] ? Q.slice(0, -2) : Q.slice(0, -1)),
                compareBase64Mixed(Q, E))
              )
                return !0;
            }
            return !1;
          }
          __name(responseURL, "responseURL"),
            __name(responseLocationURL, "responseLocationURL"),
            __name(requestCurrentURL, "requestCurrentURL"),
            __name(requestBadPort, "requestBadPort"),
            __name(isErrorLike, "isErrorLike"),
            __name(isValidReasonPhrase, "isValidReasonPhrase"),
            __name(isTokenCharCode, "isTokenCharCode"),
            __name(isValidHTTPToken, "isValidHTTPToken"),
            __name(isValidHeaderName, "isValidHeaderName"),
            __name(isValidHeaderValue, "isValidHeaderValue"),
            __name(
              setRequestReferrerPolicyOnRedirect,
              "setRequestReferrerPolicyOnRedirect"
            ),
            __name(
              crossOriginResourcePolicyCheck,
              "crossOriginResourcePolicyCheck"
            ),
            __name(corsCheck, "corsCheck"),
            __name(TAOCheck, "TAOCheck"),
            __name(appendFetchMetadata, "appendFetchMetadata"),
            __name(appendRequestOriginHeader, "appendRequestOriginHeader"),
            __name(coarsenedSharedCurrentTime, "coarsenedSharedCurrentTime"),
            __name(createOpaqueTimingInfo, "createOpaqueTimingInfo"),
            __name(makePolicyContainer, "makePolicyContainer"),
            __name(clonePolicyContainer, "clonePolicyContainer"),
            __name(determineRequestsReferrer, "determineRequestsReferrer"),
            __name(stripURLForReferrer, "stripURLForReferrer"),
            __name(isURLPotentiallyTrustworthy, "isURLPotentiallyTrustworthy"),
            __name(bytesMatch, "bytesMatch");
          var d =
            /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
          function parseMetadata(A) {
            const e = [];
            let t = !0;
            for (const r of A.split(" ")) {
              t = !1;
              const A = d.exec(r);
              if (null === A || void 0 === A.groups || void 0 === A.groups.algo)
                continue;
              const E = A.groups.algo.toLowerCase();
              l.includes(E) && e.push(A.groups);
            }
            return !0 === t ? "no metadata" : e;
          }
          function getStrongestMetadata(A) {
            let e = A[0].algo;
            if ("5" === e[3]) return e;
            for (let t = 1; t < A.length; ++t) {
              const r = A[t];
              if ("5" === r.algo[3]) {
                e = "sha512";
                break;
              }
              "3" !== e[3] && "3" === r.algo[3] && (e = "sha384");
            }
            return e;
          }
          function filterMetadataListByAlgorithm(A, e) {
            if (1 === A.length) return A;
            let t = 0;
            for (let r = 0; r < A.length; ++r)
              A[r].algo === e && (A[t++] = A[r]);
            return (A.length = t), A;
          }
          function compareBase64Mixed(A, e) {
            if (A.length !== e.length) return !1;
            for (let t = 0; t < A.length; ++t)
              if (A[t] !== e[t]) {
                if (
                  ("+" === A[t] && "-" === e[t]) ||
                  ("/" === A[t] && "_" === e[t])
                )
                  continue;
                return !1;
              }
            return !0;
          }
          function tryUpgradeRequestToAPotentiallyTrustworthyURL(A) {}
          function sameOrigin(A, e) {
            return (
              (A.origin === e.origin && "null" === A.origin) ||
              (A.protocol === e.protocol &&
                A.hostname === e.hostname &&
                A.port === e.port)
            );
          }
          function createDeferredPromise() {
            let A, e;
            return {
              promise: new Promise((t, r) => {
                (A = t), (e = r);
              }),
              resolve: A,
              reject: e,
            };
          }
          function isAborted(A) {
            return "aborted" === A.controller.state;
          }
          function isCancelled(A) {
            return (
              "aborted" === A.controller.state ||
              "terminated" === A.controller.state
            );
          }
          __name(parseMetadata, "parseMetadata"),
            __name(getStrongestMetadata, "getStrongestMetadata"),
            __name(
              filterMetadataListByAlgorithm,
              "filterMetadataListByAlgorithm"
            ),
            __name(compareBase64Mixed, "compareBase64Mixed"),
            __name(
              tryUpgradeRequestToAPotentiallyTrustworthyURL,
              "tryUpgradeRequestToAPotentiallyTrustworthyURL"
            ),
            __name(sameOrigin, "sameOrigin"),
            __name(createDeferredPromise, "createDeferredPromise"),
            __name(isAborted, "isAborted"),
            __name(isCancelled, "isCancelled");
          var u = {
            delete: "DELETE",
            DELETE: "DELETE",
            get: "GET",
            GET: "GET",
            head: "HEAD",
            HEAD: "HEAD",
            options: "OPTIONS",
            OPTIONS: "OPTIONS",
            post: "POST",
            POST: "POST",
            put: "PUT",
            PUT: "PUT",
          };
          function normalizeMethod(A) {
            return u[A.toLowerCase()] ?? A;
          }
          function serializeJavascriptValueToJSONString(A) {
            const e = JSON.stringify(A);
            if (void 0 === e)
              throw new TypeError("Value is not JSON serializable");
            return h("string" == typeof e), e;
          }
          Object.setPrototypeOf(u, null),
            __name(normalizeMethod, "normalizeMethod"),
            __name(
              serializeJavascriptValueToJSONString,
              "serializeJavascriptValueToJSONString"
            );
          var D = Object.getPrototypeOf(
            Object.getPrototypeOf([][Symbol.iterator]())
          );
          function makeIterator(A, e, t) {
            const r = { index: 0, kind: t, target: A },
              E = {
                next() {
                  if (Object.getPrototypeOf(this) !== E)
                    throw new TypeError(
                      `'next' called on an object that does not implement interface ${e} Iterator.`
                    );
                  const { index: A, kind: t, target: Q } = r,
                    o = Q();
                  if (A >= o.length) return { value: void 0, done: !0 };
                  const s = o[A];
                  return (r.index = A + 1), iteratorResult(s, t);
                },
                [Symbol.toStringTag]: `${e} Iterator`,
              };
            return Object.setPrototypeOf(E, D), Object.setPrototypeOf({}, E);
          }
          function iteratorResult(A, e) {
            let t;
            switch (e) {
              case "key":
                t = A[0];
                break;
              case "value":
                t = A[1];
                break;
              case "key+value":
                t = A;
            }
            return { value: t, done: !1 };
          }
          async function fullyReadBody(A, e, t) {
            const r = e,
              E = t;
            let Q;
            try {
              Q = A.stream.getReader();
            } catch (A) {
              return void E(A);
            }
            try {
              r(await readAllBytes(Q));
            } catch (A) {
              E(A);
            }
          }
          __name(makeIterator, "makeIterator"),
            __name(iteratorResult, "iteratorResult"),
            __name(fullyReadBody, "fullyReadBody");
          var R = globalThis.ReadableStream;
          function isReadableStreamLike(A) {
            return (
              R || (R = e("stream/web").ReadableStream),
              A instanceof R ||
                ("ReadableStream" === A[Symbol.toStringTag] &&
                  "function" == typeof A.tee)
            );
          }
          __name(isReadableStreamLike, "isReadableStreamLike");
          function isomorphicDecode(A) {
            return A.length < 65535
              ? String.fromCharCode(...A)
              : A.reduce((A, e) => A + String.fromCharCode(e), "");
          }
          function readableStreamClose(A) {
            try {
              A.close();
            } catch (A) {
              if (!A.message.includes("Controller is already closed")) throw A;
            }
          }
          function isomorphicEncode(A) {
            for (let e = 0; e < A.length; e++) h(A.charCodeAt(e) <= 255);
            return A;
          }
          async function readAllBytes(A) {
            const e = [];
            let t = 0;
            for (;;) {
              const { done: r, value: E } = await A.read();
              if (r) return Buffer.concat(e, t);
              if (!c(E)) throw new TypeError("Received non-Uint8Array chunk");
              e.push(E), (t += E.length);
            }
          }
          function urlIsLocal(A) {
            h("protocol" in A);
            const e = A.protocol;
            return "about:" === e || "blob:" === e || "data:" === e;
          }
          function urlHasHttpsScheme(A) {
            return "string" == typeof A
              ? A.startsWith("https:")
              : "https:" === A.protocol;
          }
          function urlIsHttpHttpsScheme(A) {
            h("protocol" in A);
            const e = A.protocol;
            return "http:" === e || "https:" === e;
          }
          __name(isomorphicDecode, "isomorphicDecode"),
            __name(readableStreamClose, "readableStreamClose"),
            __name(isomorphicEncode, "isomorphicEncode"),
            __name(readAllBytes, "readAllBytes"),
            __name(urlIsLocal, "urlIsLocal"),
            __name(urlHasHttpsScheme, "urlHasHttpsScheme"),
            __name(urlIsHttpHttpsScheme, "urlIsHttpHttpsScheme");
          var y =
            Object.hasOwn ||
            ((A, e) => Object.prototype.hasOwnProperty.call(A, e));
          t.exports = {
            isAborted: isAborted,
            isCancelled: isCancelled,
            createDeferredPromise: createDeferredPromise,
            ReadableStreamFrom: C,
            toUSVString: B,
            tryUpgradeRequestToAPotentiallyTrustworthyURL:
              tryUpgradeRequestToAPotentiallyTrustworthyURL,
            coarsenedSharedCurrentTime: coarsenedSharedCurrentTime,
            determineRequestsReferrer: determineRequestsReferrer,
            makePolicyContainer: makePolicyContainer,
            clonePolicyContainer: clonePolicyContainer,
            appendFetchMetadata: appendFetchMetadata,
            appendRequestOriginHeader: appendRequestOriginHeader,
            TAOCheck: TAOCheck,
            corsCheck: corsCheck,
            crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck,
            createOpaqueTimingInfo: createOpaqueTimingInfo,
            setRequestReferrerPolicyOnRedirect:
              setRequestReferrerPolicyOnRedirect,
            isValidHTTPToken: isValidHTTPToken,
            requestBadPort: requestBadPort,
            requestCurrentURL: requestCurrentURL,
            responseURL: responseURL,
            responseLocationURL: responseLocationURL,
            isBlobLike: g,
            isURLPotentiallyTrustworthy: isURLPotentiallyTrustworthy,
            isValidReasonPhrase: isValidReasonPhrase,
            sameOrigin: sameOrigin,
            normalizeMethod: normalizeMethod,
            serializeJavascriptValueToJSONString:
              serializeJavascriptValueToJSONString,
            makeIterator: makeIterator,
            isValidHeaderName: isValidHeaderName,
            isValidHeaderValue: isValidHeaderValue,
            hasOwn: y,
            isErrorLike: isErrorLike,
            fullyReadBody: fullyReadBody,
            bytesMatch: bytesMatch,
            isReadableStreamLike: isReadableStreamLike,
            readableStreamClose: readableStreamClose,
            isomorphicEncode: isomorphicEncode,
            isomorphicDecode: isomorphicDecode,
            urlIsLocal: urlIsLocal,
            urlHasHttpsScheme: urlHasHttpsScheme,
            urlIsHttpHttpsScheme: urlIsHttpHttpsScheme,
            readAllBytes: readAllBytes,
            normalizeMethodRecord: u,
            parseMetadata: parseMetadata,
          };
        },
      }),
      c = __commonJS({
        "lib/fetch/webidl.js"(A, t) {
          var { types: r } = e("util"),
            { hasOwn: E, toUSVString: Q } = h(),
            o = { converters: {}, util: {}, errors: {} };
          (o.errors.exception = function (A) {
            return new TypeError(`${A.header}: ${A.message}`);
          }),
            (o.errors.conversionFailed = function (A) {
              const e = 1 === A.types.length ? "" : " one of",
                t = `${
                  A.argument
                } could not be converted to${e}: ${A.types.join(", ")}.`;
              return o.errors.exception({ header: A.prefix, message: t });
            }),
            (o.errors.invalidArgument = function (A) {
              return o.errors.exception({
                header: A.prefix,
                message: `"${A.value}" is an invalid ${A.type}.`,
              });
            }),
            (o.brandCheck = function (A, e, t = void 0) {
              if (!1 === t?.strict || A instanceof e)
                return (
                  A?.[Symbol.toStringTag] === e.prototype[Symbol.toStringTag]
                );
              throw new TypeError("Illegal invocation");
            }),
            (o.argumentLengthCheck = function ({ length: A }, e, t) {
              if (A < e)
                throw o.errors.exception({
                  message: `${e} argument${1 !== e ? "s" : ""} required, but${
                    A ? " only" : ""
                  } ${A} found.`,
                  ...t,
                });
            }),
            (o.illegalConstructor = function () {
              throw o.errors.exception({
                header: "TypeError",
                message: "Illegal constructor",
              });
            }),
            (o.util.Type = function (A) {
              switch (typeof A) {
                case "undefined":
                  return "Undefined";
                case "boolean":
                  return "Boolean";
                case "string":
                  return "String";
                case "symbol":
                  return "Symbol";
                case "number":
                  return "Number";
                case "bigint":
                  return "BigInt";
                case "function":
                case "object":
                  return null === A ? "Null" : "Object";
              }
            }),
            (o.util.ConvertToInt = function (A, e, t, r = {}) {
              let E, Q;
              64 === e
                ? ((E = Math.pow(2, 53) - 1),
                  (Q = "unsigned" === t ? 0 : Math.pow(-2, 53) + 1))
                : "unsigned" === t
                ? ((Q = 0), (E = Math.pow(2, e) - 1))
                : ((Q = Math.pow(-2, e) - 1), (E = Math.pow(2, e - 1) - 1));
              let s = Number(A);
              if ((0 === s && (s = 0), !0 === r.enforceRange)) {
                if (
                  Number.isNaN(s) ||
                  s === Number.POSITIVE_INFINITY ||
                  s === Number.NEGATIVE_INFINITY
                )
                  throw o.errors.exception({
                    header: "Integer conversion",
                    message: `Could not convert ${A} to an integer.`,
                  });
                if (((s = o.util.IntegerPart(s)), s < Q || s > E))
                  throw o.errors.exception({
                    header: "Integer conversion",
                    message: `Value must be between ${Q}-${E}, got ${s}.`,
                  });
                return s;
              }
              return Number.isNaN(s) || !0 !== r.clamp
                ? Number.isNaN(s) ||
                  (0 === s && Object.is(0, s)) ||
                  s === Number.POSITIVE_INFINITY ||
                  s === Number.NEGATIVE_INFINITY
                  ? 0
                  : ((s = o.util.IntegerPart(s)),
                    (s %= Math.pow(2, e)),
                    "signed" === t && s >= Math.pow(2, e) - 1
                      ? s - Math.pow(2, e)
                      : s)
                : ((s = Math.min(Math.max(s, Q), E)),
                  (s = Math.floor(s) % 2 == 0 ? Math.floor(s) : Math.ceil(s)),
                  s);
            }),
            (o.util.IntegerPart = function (A) {
              const e = Math.floor(Math.abs(A));
              return A < 0 ? -1 * e : e;
            }),
            (o.sequenceConverter = function (A) {
              return (e) => {
                if ("Object" !== o.util.Type(e))
                  throw o.errors.exception({
                    header: "Sequence",
                    message: `Value of type ${o.util.Type(
                      e
                    )} is not an Object.`,
                  });
                const t = e?.[Symbol.iterator]?.(),
                  r = [];
                if (void 0 === t || "function" != typeof t.next)
                  throw o.errors.exception({
                    header: "Sequence",
                    message: "Object is not an iterator.",
                  });
                for (;;) {
                  const { done: e, value: E } = t.next();
                  if (e) break;
                  r.push(A(E));
                }
                return r;
              };
            }),
            (o.recordConverter = function (A, e) {
              return (t) => {
                if ("Object" !== o.util.Type(t))
                  throw o.errors.exception({
                    header: "Record",
                    message: `Value of type ${o.util.Type(
                      t
                    )} is not an Object.`,
                  });
                const E = {};
                if (!r.isProxy(t)) {
                  const r = Object.keys(t);
                  for (const Q of r) {
                    const r = A(Q),
                      o = e(t[Q]);
                    E[r] = o;
                  }
                  return E;
                }
                const Q = Reflect.ownKeys(t);
                for (const r of Q) {
                  const Q = Reflect.getOwnPropertyDescriptor(t, r);
                  if (Q?.enumerable) {
                    const Q = A(r),
                      o = e(t[r]);
                    E[Q] = o;
                  }
                }
                return E;
              };
            }),
            (o.interfaceConverter = function (A) {
              return (e, t = {}) => {
                if (!1 !== t.strict && !(e instanceof A))
                  throw o.errors.exception({
                    header: A.name,
                    message: `Expected ${e} to be an instance of ${A.name}.`,
                  });
                return e;
              };
            }),
            (o.dictionaryConverter = function (A) {
              return (e) => {
                const t = o.util.Type(e),
                  r = {};
                if ("Null" === t || "Undefined" === t) return r;
                if ("Object" !== t)
                  throw o.errors.exception({
                    header: "Dictionary",
                    message: `Expected ${e} to be one of: Null, Undefined, Object.`,
                  });
                for (const t of A) {
                  const {
                    key: A,
                    defaultValue: Q,
                    required: s,
                    converter: i,
                  } = t;
                  if (!0 === s && !E(e, A))
                    throw o.errors.exception({
                      header: "Dictionary",
                      message: `Missing required key "${A}".`,
                    });
                  let g = e[A];
                  const B = E(t, "defaultValue");
                  if (
                    (B && null !== g && (g = g ?? Q), s || B || void 0 !== g)
                  ) {
                    if (
                      ((g = i(g)),
                      t.allowedValues && !t.allowedValues.includes(g))
                    )
                      throw o.errors.exception({
                        header: "Dictionary",
                        message: `${g} is not an accepted type. Expected one of ${t.allowedValues.join(
                          ", "
                        )}.`,
                      });
                    r[A] = g;
                  }
                }
                return r;
              };
            }),
            (o.nullableConverter = function (A) {
              return (e) => (null === e ? e : A(e));
            }),
            (o.converters.DOMString = function (A, e = {}) {
              if (null === A && e.legacyNullToEmptyString) return "";
              if ("symbol" == typeof A)
                throw new TypeError(
                  "Could not convert argument of type symbol to string."
                );
              return String(A);
            }),
            (o.converters.ByteString = function (A) {
              const e = o.converters.DOMString(A);
              for (let A = 0; A < e.length; A++)
                if (e.charCodeAt(A) > 255)
                  throw new TypeError(
                    `Cannot convert argument to a ByteString because the character at index ${A} has a value of ${e.charCodeAt(
                      A
                    )} which is greater than 255.`
                  );
              return e;
            }),
            (o.converters.USVString = Q),
            (o.converters.boolean = function (A) {
              return Boolean(A);
            }),
            (o.converters.any = function (A) {
              return A;
            }),
            (o.converters["long long"] = function (A) {
              return o.util.ConvertToInt(A, 64, "signed");
            }),
            (o.converters["unsigned long long"] = function (A) {
              return o.util.ConvertToInt(A, 64, "unsigned");
            }),
            (o.converters["unsigned long"] = function (A) {
              return o.util.ConvertToInt(A, 32, "unsigned");
            }),
            (o.converters["unsigned short"] = function (A, e) {
              return o.util.ConvertToInt(A, 16, "unsigned", e);
            }),
            (o.converters.ArrayBuffer = function (A, e = {}) {
              if ("Object" !== o.util.Type(A) || !r.isAnyArrayBuffer(A))
                throw o.errors.conversionFailed({
                  prefix: `${A}`,
                  argument: `${A}`,
                  types: ["ArrayBuffer"],
                });
              if (!1 === e.allowShared && r.isSharedArrayBuffer(A))
                throw o.errors.exception({
                  header: "ArrayBuffer",
                  message: "SharedArrayBuffer is not allowed.",
                });
              return A;
            }),
            (o.converters.TypedArray = function (A, e, t = {}) {
              if (
                "Object" !== o.util.Type(A) ||
                !r.isTypedArray(A) ||
                A.constructor.name !== e.name
              )
                throw o.errors.conversionFailed({
                  prefix: `${e.name}`,
                  argument: `${A}`,
                  types: [e.name],
                });
              if (!1 === t.allowShared && r.isSharedArrayBuffer(A.buffer))
                throw o.errors.exception({
                  header: "ArrayBuffer",
                  message: "SharedArrayBuffer is not allowed.",
                });
              return A;
            }),
            (o.converters.DataView = function (A, e = {}) {
              if ("Object" !== o.util.Type(A) || !r.isDataView(A))
                throw o.errors.exception({
                  header: "DataView",
                  message: "Object is not a DataView.",
                });
              if (!1 === e.allowShared && r.isSharedArrayBuffer(A.buffer))
                throw o.errors.exception({
                  header: "ArrayBuffer",
                  message: "SharedArrayBuffer is not allowed.",
                });
              return A;
            }),
            (o.converters.BufferSource = function (A, e = {}) {
              if (r.isAnyArrayBuffer(A)) return o.converters.ArrayBuffer(A, e);
              if (r.isTypedArray(A))
                return o.converters.TypedArray(A, A.constructor);
              if (r.isDataView(A)) return o.converters.DataView(A, e);
              throw new TypeError(`Could not convert ${A} to a BufferSource.`);
            }),
            (o.converters["sequence<ByteString>"] = o.sequenceConverter(
              o.converters.ByteString
            )),
            (o.converters["sequence<sequence<ByteString>>"] =
              o.sequenceConverter(o.converters["sequence<ByteString>"])),
            (o.converters["record<ByteString, ByteString>"] = o.recordConverter(
              o.converters.ByteString,
              o.converters.ByteString
            )),
            (t.exports = { webidl: o });
        },
      }),
      l = __commonJS({
        "lib/fetch/headers.js"(A, t) {
          var { kHeadersList: r, kConstruct: E } = i(),
            { kGuard: Q } = g(),
            { kEnumerableProperty: o } = I(),
            {
              makeIterator: s,
              isValidHeaderName: B,
              isValidHeaderValue: C,
            } = h(),
            { webidl: n } = c(),
            a = e("assert"),
            l = Symbol("headers map"),
            d = Symbol("headers map sorted");
          function isHTTPWhiteSpaceCharCode(A) {
            return 10 === A || 13 === A || 9 === A || 32 === A;
          }
          function headerValueNormalize(A) {
            let e = 0,
              t = A.length;
            for (; t > e && isHTTPWhiteSpaceCharCode(A.charCodeAt(t - 1)); )
              --t;
            for (; t > e && isHTTPWhiteSpaceCharCode(A.charCodeAt(e)); ) ++e;
            return 0 === e && t === A.length ? A : A.substring(e, t);
          }
          function fill(A, e) {
            if (Array.isArray(e))
              for (let t = 0; t < e.length; ++t) {
                const r = e[t];
                if (2 !== r.length)
                  throw n.errors.exception({
                    header: "Headers constructor",
                    message: `expected name/value pair to be length 2, found ${r.length}.`,
                  });
                appendHeader(A, r[0], r[1]);
              }
            else {
              if ("object" != typeof e || null === e)
                throw n.errors.conversionFailed({
                  prefix: "Headers constructor",
                  argument: "Argument 1",
                  types: [
                    "sequence<sequence<ByteString>>",
                    "record<ByteString, ByteString>",
                  ],
                });
              {
                const t = Object.keys(e);
                for (let r = 0; r < t.length; ++r)
                  appendHeader(A, t[r], e[t[r]]);
              }
            }
          }
          function appendHeader(A, e, t) {
            if (((t = headerValueNormalize(t)), !B(e)))
              throw n.errors.invalidArgument({
                prefix: "Headers.append",
                value: e,
                type: "header name",
              });
            if (!C(t))
              throw n.errors.invalidArgument({
                prefix: "Headers.append",
                value: t,
                type: "header value",
              });
            if ("immutable" === A[Q]) throw new TypeError("immutable");
            return A[Q], A[r].append(e, t);
          }
          __name(isHTTPWhiteSpaceCharCode, "isHTTPWhiteSpaceCharCode"),
            __name(headerValueNormalize, "headerValueNormalize"),
            __name(fill, "fill"),
            __name(appendHeader, "appendHeader");
          var u = class _HeadersList {
              static {
                __name(this, "HeadersList");
              }
              cookies = null;
              constructor(A) {
                A instanceof _HeadersList
                  ? ((this[l] = new Map(A[l])),
                    (this[d] = A[d]),
                    (this.cookies = null === A.cookies ? null : [...A.cookies]))
                  : ((this[l] = new Map(A)), (this[d] = null));
              }
              contains(A) {
                return (A = A.toLowerCase()), this[l].has(A);
              }
              clear() {
                this[l].clear(), (this[d] = null), (this.cookies = null);
              }
              append(A, e) {
                this[d] = null;
                const t = A.toLowerCase(),
                  r = this[l].get(t);
                if (r) {
                  const A = "cookie" === t ? "; " : ", ";
                  this[l].set(t, { name: r.name, value: `${r.value}${A}${e}` });
                } else this[l].set(t, { name: A, value: e });
                "set-cookie" === t &&
                  ((this.cookies ??= []), this.cookies.push(e));
              }
              set(A, e) {
                this[d] = null;
                const t = A.toLowerCase();
                "set-cookie" === t && (this.cookies = [e]),
                  this[l].set(t, { name: A, value: e });
              }
              delete(A) {
                (this[d] = null),
                  "set-cookie" === (A = A.toLowerCase()) &&
                    (this.cookies = null),
                  this[l].delete(A);
              }
              get(A) {
                const e = this[l].get(A.toLowerCase());
                return void 0 === e ? null : e.value;
              }
              *[Symbol.iterator]() {
                for (const [A, { value: e }] of this[l]) yield [A, e];
              }
              get entries() {
                const A = {};
                if (this[l].size)
                  for (const { name: e, value: t } of this[l].values())
                    A[e] = t;
                return A;
              }
            },
            D = class _Headers {
              static {
                __name(this, "Headers");
              }
              constructor(A = void 0) {
                A !== E &&
                  ((this[r] = new u()),
                  (this[Q] = "none"),
                  void 0 !== A &&
                    fill(this, (A = n.converters.HeadersInit(A))));
              }
              append(A, e) {
                return (
                  n.brandCheck(this, _Headers),
                  n.argumentLengthCheck(arguments, 2, {
                    header: "Headers.append",
                  }),
                  appendHeader(
                    this,
                    (A = n.converters.ByteString(A)),
                    (e = n.converters.ByteString(e))
                  )
                );
              }
              delete(A) {
                if (
                  (n.brandCheck(this, _Headers),
                  n.argumentLengthCheck(arguments, 1, {
                    header: "Headers.delete",
                  }),
                  (A = n.converters.ByteString(A)),
                  !B(A))
                )
                  throw n.errors.invalidArgument({
                    prefix: "Headers.delete",
                    value: A,
                    type: "header name",
                  });
                if ("immutable" === this[Q]) throw new TypeError("immutable");
                this[Q], this[r].contains(A) && this[r].delete(A);
              }
              get(A) {
                if (
                  (n.brandCheck(this, _Headers),
                  n.argumentLengthCheck(arguments, 1, {
                    header: "Headers.get",
                  }),
                  (A = n.converters.ByteString(A)),
                  !B(A))
                )
                  throw n.errors.invalidArgument({
                    prefix: "Headers.get",
                    value: A,
                    type: "header name",
                  });
                return this[r].get(A);
              }
              has(A) {
                if (
                  (n.brandCheck(this, _Headers),
                  n.argumentLengthCheck(arguments, 1, {
                    header: "Headers.has",
                  }),
                  (A = n.converters.ByteString(A)),
                  !B(A))
                )
                  throw n.errors.invalidArgument({
                    prefix: "Headers.has",
                    value: A,
                    type: "header name",
                  });
                return this[r].contains(A);
              }
              set(A, e) {
                if (
                  (n.brandCheck(this, _Headers),
                  n.argumentLengthCheck(arguments, 2, {
                    header: "Headers.set",
                  }),
                  (A = n.converters.ByteString(A)),
                  (e = headerValueNormalize((e = n.converters.ByteString(e)))),
                  !B(A))
                )
                  throw n.errors.invalidArgument({
                    prefix: "Headers.set",
                    value: A,
                    type: "header name",
                  });
                if (!C(e))
                  throw n.errors.invalidArgument({
                    prefix: "Headers.set",
                    value: e,
                    type: "header value",
                  });
                if ("immutable" === this[Q]) throw new TypeError("immutable");
                this[Q], this[r].set(A, e);
              }
              getSetCookie() {
                n.brandCheck(this, _Headers);
                const A = this[r].cookies;
                return A ? [...A] : [];
              }
              get [d]() {
                if (this[r][d]) return this[r][d];
                const A = [],
                  e = [...this[r]].sort((A, e) => (A[0] < e[0] ? -1 : 1)),
                  t = this[r].cookies;
                for (let r = 0; r < e.length; ++r) {
                  const [E, Q] = e[r];
                  if ("set-cookie" === E)
                    for (let e = 0; e < t.length; ++e) A.push([E, t[e]]);
                  else a(null !== Q), A.push([E, Q]);
                }
                return (this[r][d] = A), A;
              }
              keys() {
                if ((n.brandCheck(this, _Headers), "immutable" === this[Q])) {
                  const A = this[d];
                  return s(() => A, "Headers", "key");
                }
                return s(() => [...this[d].values()], "Headers", "key");
              }
              values() {
                if ((n.brandCheck(this, _Headers), "immutable" === this[Q])) {
                  const A = this[d];
                  return s(() => A, "Headers", "value");
                }
                return s(() => [...this[d].values()], "Headers", "value");
              }
              entries() {
                if ((n.brandCheck(this, _Headers), "immutable" === this[Q])) {
                  const A = this[d];
                  return s(() => A, "Headers", "key+value");
                }
                return s(() => [...this[d].values()], "Headers", "key+value");
              }
              forEach(A, e = globalThis) {
                if (
                  (n.brandCheck(this, _Headers),
                  n.argumentLengthCheck(arguments, 1, {
                    header: "Headers.forEach",
                  }),
                  "function" != typeof A)
                )
                  throw new TypeError(
                    "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
                  );
                for (const [t, r] of this) A.apply(e, [r, t, this]);
              }
              [Symbol.for("nodejs.util.inspect.custom")]() {
                return n.brandCheck(this, _Headers), this[r];
              }
            };
          (D.prototype[Symbol.iterator] = D.prototype.entries),
            Object.defineProperties(D.prototype, {
              append: o,
              delete: o,
              get: o,
              has: o,
              set: o,
              getSetCookie: o,
              keys: o,
              values: o,
              entries: o,
              forEach: o,
              [Symbol.iterator]: { enumerable: !1 },
              [Symbol.toStringTag]: { value: "Headers", configurable: !0 },
            }),
            (n.converters.HeadersInit = function (A) {
              if ("Object" === n.util.Type(A))
                return A[Symbol.iterator]
                  ? n.converters["sequence<sequence<ByteString>>"](A)
                  : n.converters["record<ByteString, ByteString>"](A);
              throw n.errors.conversionFailed({
                prefix: "Headers constructor",
                argument: "Argument 1",
                types: [
                  "sequence<sequence<ByteString>>",
                  "record<ByteString, ByteString>",
                ],
              });
            }),
            (t.exports = { fill: fill, Headers: D, HeadersList: u });
        },
      }),
      d = __commonJS({
        "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(A, t) {
          var r = e("node:events").EventEmitter,
            E = e("node:util").inherits;
          function SBMH(A) {
            if (
              ("string" == typeof A && (A = Buffer.from(A)),
              !Buffer.isBuffer(A))
            )
              throw new TypeError("The needle has to be a String or a Buffer.");
            const e = A.length;
            if (0 === e)
              throw new Error("The needle cannot be an empty String/Buffer.");
            if (e > 256)
              throw new Error(
                "The needle cannot have a length bigger than 256."
              );
            (this.maxMatches = 1 / 0),
              (this.matches = 0),
              (this._occ = new Array(256).fill(e)),
              (this._lookbehind_size = 0),
              (this._needle = A),
              (this._bufpos = 0),
              (this._lookbehind = Buffer.alloc(e));
            for (var t = 0; t < e - 1; ++t) this._occ[A[t]] = e - 1 - t;
          }
          __name(SBMH, "SBMH"),
            E(SBMH, r),
            (SBMH.prototype.reset = function () {
              (this._lookbehind_size = 0),
                (this.matches = 0),
                (this._bufpos = 0);
            }),
            (SBMH.prototype.push = function (A, e) {
              Buffer.isBuffer(A) || (A = Buffer.from(A, "binary"));
              const t = A.length;
              let r;
              for (
                this._bufpos = e || 0;
                r !== t && this.matches < this.maxMatches;

              )
                r = this._sbmh_feed(A);
              return r;
            }),
            (SBMH.prototype._sbmh_feed = function (A) {
              const e = A.length,
                t = this._needle,
                r = t.length,
                E = t[r - 1];
              let Q,
                o = -this._lookbehind_size;
              if (o < 0) {
                for (; o < 0 && o <= e - r; ) {
                  if (
                    ((Q = this._sbmh_lookup_char(A, o + r - 1)),
                    Q === E && this._sbmh_memcmp(A, o, r - 1))
                  )
                    return (
                      (this._lookbehind_size = 0),
                      ++this.matches,
                      this.emit("info", !0),
                      (this._bufpos = o + r)
                    );
                  o += this._occ[Q];
                }
                if (o < 0)
                  for (; o < 0 && !this._sbmh_memcmp(A, o, e - o); ) ++o;
                if (!(o >= 0)) {
                  const t = this._lookbehind_size + o;
                  return (
                    t > 0 && this.emit("info", !1, this._lookbehind, 0, t),
                    this._lookbehind.copy(
                      this._lookbehind,
                      0,
                      t,
                      this._lookbehind_size - t
                    ),
                    (this._lookbehind_size -= t),
                    A.copy(this._lookbehind, this._lookbehind_size),
                    (this._lookbehind_size += e),
                    (this._bufpos = e),
                    e
                  );
                }
                this.emit(
                  "info",
                  !1,
                  this._lookbehind,
                  0,
                  this._lookbehind_size
                ),
                  (this._lookbehind_size = 0);
              }
              if (((o += (o >= 0) * this._bufpos), -1 !== A.indexOf(t, o)))
                return (
                  (o = A.indexOf(t, o)),
                  ++this.matches,
                  o > 0
                    ? this.emit("info", !0, A, this._bufpos, o)
                    : this.emit("info", !0),
                  (this._bufpos = o + r)
                );
              for (
                o = e - r;
                o < e &&
                (A[o] !== t[0] ||
                  0 !==
                    Buffer.compare(
                      A.subarray(o, o + e - o),
                      t.subarray(0, e - o)
                    ));

              )
                ++o;
              return (
                o < e &&
                  (A.copy(this._lookbehind, 0, o, o + (e - o)),
                  (this._lookbehind_size = e - o)),
                o > 0 && this.emit("info", !1, A, this._bufpos, o < e ? o : e),
                (this._bufpos = e),
                e
              );
            }),
            (SBMH.prototype._sbmh_lookup_char = function (A, e) {
              return e < 0 ? this._lookbehind[this._lookbehind_size + e] : A[e];
            }),
            (SBMH.prototype._sbmh_memcmp = function (A, e, t) {
              for (var r = 0; r < t; ++r)
                if (this._sbmh_lookup_char(A, e + r) !== this._needle[r])
                  return !1;
              return !0;
            }),
            (t.exports = SBMH);
        },
      }),
      u = __commonJS({
        "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(A, t) {
          var r = e("node:util").inherits,
            E = e("node:stream").Readable;
          function PartStream(A) {
            E.call(this, A);
          }
          __name(PartStream, "PartStream"),
            r(PartStream, E),
            (PartStream.prototype._read = function (A) {}),
            (t.exports = PartStream);
        },
      }),
      D = __commonJS({
        "node_modules/@fastify/busboy/lib/utils/getLimit.js"(A, e) {
          e.exports = __name(function getLimit(A, e, t) {
            if (!A || void 0 === A[e] || null === A[e]) return t;
            if ("number" != typeof A[e] || isNaN(A[e]))
              throw new TypeError("Limit " + e + " is not a valid number");
            return A[e];
          }, "getLimit");
        },
      }),
      R = __commonJS({
        "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(A, t) {
          var r = e("node:events").EventEmitter,
            E = e("node:util").inherits,
            Q = D(),
            o = d(),
            s = Buffer.from("\r\n\r\n"),
            i = /\r\n/g,
            g = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
          function HeaderParser(A) {
            r.call(this), (A = A || {});
            const e = this;
            (this.nread = 0),
              (this.maxed = !1),
              (this.npairs = 0),
              (this.maxHeaderPairs = Q(A, "maxHeaderPairs", 2e3)),
              (this.maxHeaderSize = Q(A, "maxHeaderSize", 81920)),
              (this.buffer = ""),
              (this.header = {}),
              (this.finished = !1),
              (this.ss = new o(s)),
              this.ss.on("info", function (A, t, r, E) {
                t &&
                  !e.maxed &&
                  (e.nread + E - r >= e.maxHeaderSize
                    ? ((E = e.maxHeaderSize - e.nread + r),
                      (e.nread = e.maxHeaderSize),
                      (e.maxed = !0))
                    : (e.nread += E - r),
                  (e.buffer += t.toString("binary", r, E))),
                  A && e._finish();
              });
          }
          __name(HeaderParser, "HeaderParser"),
            E(HeaderParser, r),
            (HeaderParser.prototype.push = function (A) {
              const e = this.ss.push(A);
              if (this.finished) return e;
            }),
            (HeaderParser.prototype.reset = function () {
              (this.finished = !1),
                (this.buffer = ""),
                (this.header = {}),
                this.ss.reset();
            }),
            (HeaderParser.prototype._finish = function () {
              this.buffer && this._parseHeader(),
                (this.ss.matches = this.ss.maxMatches);
              const A = this.header;
              (this.header = {}),
                (this.buffer = ""),
                (this.finished = !0),
                (this.nread = this.npairs = 0),
                (this.maxed = !1),
                this.emit("header", A);
            }),
            (HeaderParser.prototype._parseHeader = function () {
              if (this.npairs === this.maxHeaderPairs) return;
              const A = this.buffer.split(i),
                e = A.length;
              let t, r;
              for (var E = 0; E < e; ++E) {
                if (0 === A[E].length) continue;
                if (("\t" === A[E][0] || " " === A[E][0]) && r) {
                  this.header[r][this.header[r].length - 1] += A[E];
                  continue;
                }
                const e = A[E].indexOf(":");
                if (-1 === e || 0 === e) return;
                if (
                  ((t = g.exec(A[E])),
                  (r = t[1].toLowerCase()),
                  (this.header[r] = this.header[r] || []),
                  this.header[r].push(t[2] || ""),
                  ++this.npairs === this.maxHeaderPairs)
                )
                  break;
              }
            }),
            (t.exports = HeaderParser);
        },
      }),
      y = __commonJS({
        "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(A, t) {
          var E = e("node:stream").Writable,
            Q = e("node:util").inherits,
            o = d(),
            s = u(),
            i = R(),
            g = Buffer.from("-"),
            B = Buffer.from("\r\n"),
            C = __name(function () {}, "EMPTY_FN");
          function Dicer(A) {
            if (!(this instanceof Dicer)) return new Dicer(A);
            if (
              (E.call(this, A),
              !A || (!A.headerFirst && "string" != typeof A.boundary))
            )
              throw new TypeError("Boundary required");
            "string" == typeof A.boundary
              ? this.setBoundary(A.boundary)
              : (this._bparser = void 0),
              (this._headerFirst = A.headerFirst),
              (this._dashes = 0),
              (this._parts = 0),
              (this._finished = !1),
              (this._realFinish = !1),
              (this._isPreamble = !0),
              (this._justMatched = !1),
              (this._firstWrite = !0),
              (this._inHeader = !0),
              (this._part = void 0),
              (this._cb = void 0),
              (this._ignoreData = !1),
              (this._partOpts = { highWaterMark: A.partHwm }),
              (this._pause = !1);
            const e = this;
            (this._hparser = new i(A)),
              this._hparser.on("header", function (A) {
                (e._inHeader = !1), e._part.emit("header", A);
              });
          }
          __name(Dicer, "Dicer"),
            Q(Dicer, E),
            (Dicer.prototype.emit = function (A) {
              if ("finish" !== A || this._realFinish)
                E.prototype.emit.apply(this, arguments);
              else if (!this._finished) {
                const A = this;
                r.nextTick(function () {
                  if (
                    (A.emit(
                      "error",
                      new Error("Unexpected end of multipart data")
                    ),
                    A._part && !A._ignoreData)
                  ) {
                    const e = A._isPreamble ? "Preamble" : "Part";
                    return (
                      A._part.emit(
                        "error",
                        new Error(
                          e +
                            " terminated early due to unexpected end of multipart data"
                        )
                      ),
                      A._part.push(null),
                      void r.nextTick(function () {
                        (A._realFinish = !0),
                          A.emit("finish"),
                          (A._realFinish = !1);
                      })
                    );
                  }
                  (A._realFinish = !0), A.emit("finish"), (A._realFinish = !1);
                });
              }
            }),
            (Dicer.prototype._write = function (A, e, t) {
              if (!this._hparser && !this._bparser) return t();
              if (this._headerFirst && this._isPreamble) {
                this._part ||
                  ((this._part = new s(this._partOpts)),
                  0 !== this.listenerCount("preamble")
                    ? this.emit("preamble", this._part)
                    : this._ignore());
                const e = this._hparser.push(A);
                if (this._inHeader || void 0 === e || !(e < A.length))
                  return t();
                A = A.slice(e);
              }
              this._firstWrite &&
                (this._bparser.push(B), (this._firstWrite = !1)),
                this._bparser.push(A),
                this._pause ? (this._cb = t) : t();
            }),
            (Dicer.prototype.reset = function () {
              (this._part = void 0),
                (this._bparser = void 0),
                (this._hparser = void 0);
            }),
            (Dicer.prototype.setBoundary = function (A) {
              const e = this;
              (this._bparser = new o("\r\n--" + A)),
                this._bparser.on("info", function (A, t, r, E) {
                  e._oninfo(A, t, r, E);
                });
            }),
            (Dicer.prototype._ignore = function () {
              this._part &&
                !this._ignoreData &&
                ((this._ignoreData = !0),
                this._part.on("error", C),
                this._part.resume());
            }),
            (Dicer.prototype._oninfo = function (A, e, t, r) {
              let E;
              const Q = this;
              let o,
                i = 0,
                B = !0;
              if (!this._part && this._justMatched && e) {
                for (; this._dashes < 2 && t + i < r; ) {
                  if (45 !== e[t + i]) {
                    this._dashes && (E = g), (this._dashes = 0);
                    break;
                  }
                  ++i, ++this._dashes;
                }
                if (
                  (2 === this._dashes &&
                    (t + i < r &&
                      0 !== this.listenerCount("trailer") &&
                      this.emit("trailer", e.slice(t + i, r)),
                    this.reset(),
                    (this._finished = !0),
                    0 === Q._parts &&
                      ((Q._realFinish = !0),
                      Q.emit("finish"),
                      (Q._realFinish = !1))),
                  this._dashes)
                )
                  return;
              }
              this._justMatched && (this._justMatched = !1),
                this._part ||
                  ((this._part = new s(this._partOpts)),
                  (this._part._read = function (A) {
                    Q._unpause();
                  }),
                  this._isPreamble && 0 !== this.listenerCount("preamble")
                    ? this.emit("preamble", this._part)
                    : !0 !== this._isPreamble &&
                      0 !== this.listenerCount("part")
                    ? this.emit("part", this._part)
                    : this._ignore(),
                  this._isPreamble || (this._inHeader = !0)),
                e &&
                  t < r &&
                  !this._ignoreData &&
                  (this._isPreamble || !this._inHeader
                    ? (E && (B = this._part.push(E)),
                      (B = this._part.push(e.slice(t, r))),
                      B || (this._pause = !0))
                    : !this._isPreamble &&
                      this._inHeader &&
                      (E && this._hparser.push(E),
                      (o = this._hparser.push(e.slice(t, r))),
                      !this._inHeader &&
                        void 0 !== o &&
                        o < r &&
                        this._oninfo(!1, e, t + o, r))),
                A &&
                  (this._hparser.reset(),
                  this._isPreamble
                    ? (this._isPreamble = !1)
                    : t !== r &&
                      (++this._parts,
                      this._part.on("end", function () {
                        0 == --Q._parts &&
                          (Q._finished
                            ? ((Q._realFinish = !0),
                              Q.emit("finish"),
                              (Q._realFinish = !1))
                            : Q._unpause());
                      })),
                  this._part.push(null),
                  (this._part = void 0),
                  (this._ignoreData = !1),
                  (this._justMatched = !0),
                  (this._dashes = 0));
            }),
            (Dicer.prototype._unpause = function () {
              if (this._pause && ((this._pause = !1), this._cb)) {
                const A = this._cb;
                (this._cb = void 0), A();
              }
            }),
            (t.exports = Dicer);
        },
      }),
      f = __commonJS({
        "node_modules/@fastify/busboy/lib/utils/decodeText.js"(A, e) {
          var t = new TextDecoder("utf-8"),
            r = new Map([
              ["utf-8", t],
              ["utf8", t],
            ]);
          function getDecoder(A) {
            let e;
            for (;;)
              switch (A) {
                case "utf-8":
                case "utf8":
                  return E.utf8;
                case "latin1":
                case "ascii":
                case "us-ascii":
                case "iso-8859-1":
                case "iso8859-1":
                case "iso88591":
                case "iso_8859-1":
                case "windows-1252":
                case "iso_8859-1:1987":
                case "cp1252":
                case "x-cp1252":
                  return E.latin1;
                case "utf16le":
                case "utf-16le":
                case "ucs2":
                case "ucs-2":
                  return E.utf16le;
                case "base64":
                  return E.base64;
                default:
                  if (void 0 === e) {
                    (e = !0), (A = A.toLowerCase());
                    continue;
                  }
                  return E.other.bind(A);
              }
          }
          __name(getDecoder, "getDecoder");
          var E = {
            utf8: (A, e) =>
              0 === A.length
                ? ""
                : ("string" == typeof A && (A = Buffer.from(A, e)),
                  A.utf8Slice(0, A.length)),
            latin1: (A, e) =>
              0 === A.length
                ? ""
                : "string" == typeof A
                ? A
                : A.latin1Slice(0, A.length),
            utf16le: (A, e) =>
              0 === A.length
                ? ""
                : ("string" == typeof A && (A = Buffer.from(A, e)),
                  A.ucs2Slice(0, A.length)),
            base64: (A, e) =>
              0 === A.length
                ? ""
                : ("string" == typeof A && (A = Buffer.from(A, e)),
                  A.base64Slice(0, A.length)),
            other: (e, t) => {
              if (0 === e.length) return "";
              if (
                ("string" == typeof e && (e = Buffer.from(e, t)),
                r.has(A.toString()))
              )
                try {
                  return r.get(A).decode(e);
                } catch {}
              return "string" == typeof e ? e : e.toString();
            },
          };
          function decodeText(A, e, t) {
            return A ? getDecoder(t)(A, e) : A;
          }
          __name(decodeText, "decodeText"), (e.exports = decodeText);
        },
      }),
      w = __commonJS({
        "node_modules/@fastify/busboy/lib/utils/parseParams.js"(A, e) {
          var t = f(),
            r = /%[a-fA-F0-9][a-fA-F0-9]/g,
            E = {
              "%00": "\0",
              "%01": "",
              "%02": "",
              "%03": "",
              "%04": "",
              "%05": "",
              "%06": "",
              "%07": "",
              "%08": "\b",
              "%09": "\t",
              "%0a": "\n",
              "%0A": "\n",
              "%0b": "\v",
              "%0B": "\v",
              "%0c": "\f",
              "%0C": "\f",
              "%0d": "\r",
              "%0D": "\r",
              "%0e": "",
              "%0E": "",
              "%0f": "",
              "%0F": "",
              "%10": "",
              "%11": "",
              "%12": "",
              "%13": "",
              "%14": "",
              "%15": "",
              "%16": "",
              "%17": "",
              "%18": "",
              "%19": "",
              "%1a": "",
              "%1A": "",
              "%1b": "",
              "%1B": "",
              "%1c": "",
              "%1C": "",
              "%1d": "",
              "%1D": "",
              "%1e": "",
              "%1E": "",
              "%1f": "",
              "%1F": "",
              "%20": " ",
              "%21": "!",
              "%22": '"',
              "%23": "#",
              "%24": "$",
              "%25": "%",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2a": "*",
              "%2A": "*",
              "%2b": "+",
              "%2B": "+",
              "%2c": ",",
              "%2C": ",",
              "%2d": "-",
              "%2D": "-",
              "%2e": ".",
              "%2E": ".",
              "%2f": "/",
              "%2F": "/",
              "%30": "0",
              "%31": "1",
              "%32": "2",
              "%33": "3",
              "%34": "4",
              "%35": "5",
              "%36": "6",
              "%37": "7",
              "%38": "8",
              "%39": "9",
              "%3a": ":",
              "%3A": ":",
              "%3b": ";",
              "%3B": ";",
              "%3c": "<",
              "%3C": "<",
              "%3d": "=",
              "%3D": "=",
              "%3e": ">",
              "%3E": ">",
              "%3f": "?",
              "%3F": "?",
              "%40": "@",
              "%41": "A",
              "%42": "B",
              "%43": "C",
              "%44": "D",
              "%45": "E",
              "%46": "F",
              "%47": "G",
              "%48": "H",
              "%49": "I",
              "%4a": "J",
              "%4A": "J",
              "%4b": "K",
              "%4B": "K",
              "%4c": "L",
              "%4C": "L",
              "%4d": "M",
              "%4D": "M",
              "%4e": "N",
              "%4E": "N",
              "%4f": "O",
              "%4F": "O",
              "%50": "P",
              "%51": "Q",
              "%52": "R",
              "%53": "S",
              "%54": "T",
              "%55": "U",
              "%56": "V",
              "%57": "W",
              "%58": "X",
              "%59": "Y",
              "%5a": "Z",
              "%5A": "Z",
              "%5b": "[",
              "%5B": "[",
              "%5c": "\\",
              "%5C": "\\",
              "%5d": "]",
              "%5D": "]",
              "%5e": "^",
              "%5E": "^",
              "%5f": "_",
              "%5F": "_",
              "%60": "`",
              "%61": "a",
              "%62": "b",
              "%63": "c",
              "%64": "d",
              "%65": "e",
              "%66": "f",
              "%67": "g",
              "%68": "h",
              "%69": "i",
              "%6a": "j",
              "%6A": "j",
              "%6b": "k",
              "%6B": "k",
              "%6c": "l",
              "%6C": "l",
              "%6d": "m",
              "%6D": "m",
              "%6e": "n",
              "%6E": "n",
              "%6f": "o",
              "%6F": "o",
              "%70": "p",
              "%71": "q",
              "%72": "r",
              "%73": "s",
              "%74": "t",
              "%75": "u",
              "%76": "v",
              "%77": "w",
              "%78": "x",
              "%79": "y",
              "%7a": "z",
              "%7A": "z",
              "%7b": "{",
              "%7B": "{",
              "%7c": "|",
              "%7C": "|",
              "%7d": "}",
              "%7D": "}",
              "%7e": "~",
              "%7E": "~",
              "%7f": "",
              "%7F": "",
              "%80": "",
              "%81": "",
              "%82": "",
              "%83": "",
              "%84": "",
              "%85": "",
              "%86": "",
              "%87": "",
              "%88": "",
              "%89": "",
              "%8a": "",
              "%8A": "",
              "%8b": "",
              "%8B": "",
              "%8c": "",
              "%8C": "",
              "%8d": "",
              "%8D": "",
              "%8e": "",
              "%8E": "",
              "%8f": "",
              "%8F": "",
              "%90": "",
              "%91": "",
              "%92": "",
              "%93": "",
              "%94": "",
              "%95": "",
              "%96": "",
              "%97": "",
              "%98": "",
              "%99": "",
              "%9a": "",
              "%9A": "",
              "%9b": "",
              "%9B": "",
              "%9c": "",
              "%9C": "",
              "%9d": "",
              "%9D": "",
              "%9e": "",
              "%9E": "",
              "%9f": "",
              "%9F": "",
              "%a0": " ",
              "%A0": " ",
              "%a1": "¡",
              "%A1": "¡",
              "%a2": "¢",
              "%A2": "¢",
              "%a3": "£",
              "%A3": "£",
              "%a4": "¤",
              "%A4": "¤",
              "%a5": "¥",
              "%A5": "¥",
              "%a6": "¦",
              "%A6": "¦",
              "%a7": "§",
              "%A7": "§",
              "%a8": "¨",
              "%A8": "¨",
              "%a9": "©",
              "%A9": "©",
              "%aa": "ª",
              "%Aa": "ª",
              "%aA": "ª",
              "%AA": "ª",
              "%ab": "«",
              "%Ab": "«",
              "%aB": "«",
              "%AB": "«",
              "%ac": "¬",
              "%Ac": "¬",
              "%aC": "¬",
              "%AC": "¬",
              "%ad": "­",
              "%Ad": "­",
              "%aD": "­",
              "%AD": "­",
              "%ae": "®",
              "%Ae": "®",
              "%aE": "®",
              "%AE": "®",
              "%af": "¯",
              "%Af": "¯",
              "%aF": "¯",
              "%AF": "¯",
              "%b0": "°",
              "%B0": "°",
              "%b1": "±",
              "%B1": "±",
              "%b2": "²",
              "%B2": "²",
              "%b3": "³",
              "%B3": "³",
              "%b4": "´",
              "%B4": "´",
              "%b5": "µ",
              "%B5": "µ",
              "%b6": "¶",
              "%B6": "¶",
              "%b7": "·",
              "%B7": "·",
              "%b8": "¸",
              "%B8": "¸",
              "%b9": "¹",
              "%B9": "¹",
              "%ba": "º",
              "%Ba": "º",
              "%bA": "º",
              "%BA": "º",
              "%bb": "»",
              "%Bb": "»",
              "%bB": "»",
              "%BB": "»",
              "%bc": "¼",
              "%Bc": "¼",
              "%bC": "¼",
              "%BC": "¼",
              "%bd": "½",
              "%Bd": "½",
              "%bD": "½",
              "%BD": "½",
              "%be": "¾",
              "%Be": "¾",
              "%bE": "¾",
              "%BE": "¾",
              "%bf": "¿",
              "%Bf": "¿",
              "%bF": "¿",
              "%BF": "¿",
              "%c0": "À",
              "%C0": "À",
              "%c1": "Á",
              "%C1": "Á",
              "%c2": "Â",
              "%C2": "Â",
              "%c3": "Ã",
              "%C3": "Ã",
              "%c4": "Ä",
              "%C4": "Ä",
              "%c5": "Å",
              "%C5": "Å",
              "%c6": "Æ",
              "%C6": "Æ",
              "%c7": "Ç",
              "%C7": "Ç",
              "%c8": "È",
              "%C8": "È",
              "%c9": "É",
              "%C9": "É",
              "%ca": "Ê",
              "%Ca": "Ê",
              "%cA": "Ê",
              "%CA": "Ê",
              "%cb": "Ë",
              "%Cb": "Ë",
              "%cB": "Ë",
              "%CB": "Ë",
              "%cc": "Ì",
              "%Cc": "Ì",
              "%cC": "Ì",
              "%CC": "Ì",
              "%cd": "Í",
              "%Cd": "Í",
              "%cD": "Í",
              "%CD": "Í",
              "%ce": "Î",
              "%Ce": "Î",
              "%cE": "Î",
              "%CE": "Î",
              "%cf": "Ï",
              "%Cf": "Ï",
              "%cF": "Ï",
              "%CF": "Ï",
              "%d0": "Ð",
              "%D0": "Ð",
              "%d1": "Ñ",
              "%D1": "Ñ",
              "%d2": "Ò",
              "%D2": "Ò",
              "%d3": "Ó",
              "%D3": "Ó",
              "%d4": "Ô",
              "%D4": "Ô",
              "%d5": "Õ",
              "%D5": "Õ",
              "%d6": "Ö",
              "%D6": "Ö",
              "%d7": "×",
              "%D7": "×",
              "%d8": "Ø",
              "%D8": "Ø",
              "%d9": "Ù",
              "%D9": "Ù",
              "%da": "Ú",
              "%Da": "Ú",
              "%dA": "Ú",
              "%DA": "Ú",
              "%db": "Û",
              "%Db": "Û",
              "%dB": "Û",
              "%DB": "Û",
              "%dc": "Ü",
              "%Dc": "Ü",
              "%dC": "Ü",
              "%DC": "Ü",
              "%dd": "Ý",
              "%Dd": "Ý",
              "%dD": "Ý",
              "%DD": "Ý",
              "%de": "Þ",
              "%De": "Þ",
              "%dE": "Þ",
              "%DE": "Þ",
              "%df": "ß",
              "%Df": "ß",
              "%dF": "ß",
              "%DF": "ß",
              "%e0": "à",
              "%E0": "à",
              "%e1": "á",
              "%E1": "á",
              "%e2": "â",
              "%E2": "â",
              "%e3": "ã",
              "%E3": "ã",
              "%e4": "ä",
              "%E4": "ä",
              "%e5": "å",
              "%E5": "å",
              "%e6": "æ",
              "%E6": "æ",
              "%e7": "ç",
              "%E7": "ç",
              "%e8": "è",
              "%E8": "è",
              "%e9": "é",
              "%E9": "é",
              "%ea": "ê",
              "%Ea": "ê",
              "%eA": "ê",
              "%EA": "ê",
              "%eb": "ë",
              "%Eb": "ë",
              "%eB": "ë",
              "%EB": "ë",
              "%ec": "ì",
              "%Ec": "ì",
              "%eC": "ì",
              "%EC": "ì",
              "%ed": "í",
              "%Ed": "í",
              "%eD": "í",
              "%ED": "í",
              "%ee": "î",
              "%Ee": "î",
              "%eE": "î",
              "%EE": "î",
              "%ef": "ï",
              "%Ef": "ï",
              "%eF": "ï",
              "%EF": "ï",
              "%f0": "ð",
              "%F0": "ð",
              "%f1": "ñ",
              "%F1": "ñ",
              "%f2": "ò",
              "%F2": "ò",
              "%f3": "ó",
              "%F3": "ó",
              "%f4": "ô",
              "%F4": "ô",
              "%f5": "õ",
              "%F5": "õ",
              "%f6": "ö",
              "%F6": "ö",
              "%f7": "÷",
              "%F7": "÷",
              "%f8": "ø",
              "%F8": "ø",
              "%f9": "ù",
              "%F9": "ù",
              "%fa": "ú",
              "%Fa": "ú",
              "%fA": "ú",
              "%FA": "ú",
              "%fb": "û",
              "%Fb": "û",
              "%fB": "û",
              "%FB": "û",
              "%fc": "ü",
              "%Fc": "ü",
              "%fC": "ü",
              "%FC": "ü",
              "%fd": "ý",
              "%Fd": "ý",
              "%fD": "ý",
              "%FD": "ý",
              "%fe": "þ",
              "%Fe": "þ",
              "%fE": "þ",
              "%FE": "þ",
              "%ff": "ÿ",
              "%Ff": "ÿ",
              "%fF": "ÿ",
              "%FF": "ÿ",
            };
          function encodedReplacer(A) {
            return E[A];
          }
          __name(encodedReplacer, "encodedReplacer");
          function parseParams(A) {
            const e = [];
            let E = 0,
              Q = "",
              o = !1,
              s = !1,
              i = 0,
              g = "";
            const B = A.length;
            for (var C = 0; C < B; ++C) {
              const B = A[C];
              if ("\\" === B && o) {
                if (!s) {
                  s = !0;
                  continue;
                }
                s = !1;
              } else if ('"' === B) {
                if (!s) {
                  o ? ((o = !1), (E = 0)) : (o = !0);
                  continue;
                }
                s = !1;
              } else {
                if (
                  (s && o && (g += "\\"),
                  (s = !1),
                  (2 === E || 3 === E) && "'" === B)
                ) {
                  2 === E ? ((E = 3), (Q = g.substring(1))) : (E = 1), (g = "");
                  continue;
                }
                if (0 === E && ("*" === B || "=" === B) && e.length) {
                  (E = "*" === B ? 2 : 1), (e[i] = [g, void 0]), (g = "");
                  continue;
                }
                if (!o && ";" === B) {
                  (E = 0),
                    Q
                      ? (g.length &&
                          (g = t(g.replace(r, encodedReplacer), "binary", Q)),
                        (Q = ""))
                      : g.length && (g = t(g, "binary", "utf8")),
                    void 0 === e[i] ? (e[i] = g) : (e[i][1] = g),
                    (g = ""),
                    ++i;
                  continue;
                }
                if (!o && (" " === B || "\t" === B)) continue;
              }
              g += B;
            }
            return (
              Q && g.length
                ? (g = t(g.replace(r, encodedReplacer), "binary", Q))
                : g && (g = t(g, "binary", "utf8")),
              void 0 === e[i] ? g && (e[i] = g) : (e[i][1] = g),
              e
            );
          }
          __name(parseParams, "parseParams"), (e.exports = parseParams);
        },
      }),
      F = __commonJS({
        "node_modules/@fastify/busboy/lib/utils/basename.js"(A, e) {
          e.exports = __name(function basename(A) {
            if ("string" != typeof A) return "";
            for (var e = A.length - 1; e >= 0; --e)
              switch (A.charCodeAt(e)) {
                case 47:
                case 92:
                  return ".." === (A = A.slice(e + 1)) || "." === A ? "" : A;
              }
            return ".." === A || "." === A ? "" : A;
          }, "basename");
        },
      }),
      k = __commonJS({
        "node_modules/@fastify/busboy/lib/types/multipart.js"(A, t) {
          var { Readable: E } = e("node:stream"),
            { inherits: Q } = e("node:util"),
            o = y(),
            s = w(),
            i = f(),
            g = F(),
            B = D(),
            C = /^boundary$/i,
            I = /^form-data$/i,
            n = /^charset$/i,
            a = /^filename$/i,
            h = /^name$/i;
          function Multipart(A, e) {
            let t, r;
            const E = this;
            let Q;
            const c = e.limits,
              l =
                e.isPartAFile ||
                ((A, e, t) => "application/octet-stream" === e || void 0 !== t),
              d = e.parsedConType || [],
              u = e.defCharset || "utf8",
              D = e.preservePath,
              R = { highWaterMark: e.fileHwm };
            for (t = 0, r = d.length; t < r; ++t)
              if (Array.isArray(d[t]) && C.test(d[t][0])) {
                Q = d[t][1];
                break;
              }
            function checkFinished() {
              0 === L && M && !A._done && ((M = !1), E.end());
            }
            if ((__name(checkFinished, "checkFinished"), "string" != typeof Q))
              throw new Error("Multipart: Boundary not found");
            const y = B(c, "fieldSize", 1048576),
              f = B(c, "fileSize", 1 / 0),
              w = B(c, "files", 1 / 0),
              F = B(c, "fields", 1 / 0),
              k = B(c, "parts", 1 / 0),
              N = B(c, "headerPairs", 2e3),
              p = B(c, "headerSize", 81920);
            let S,
              b,
              U = 0,
              m = 0,
              L = 0,
              M = !1;
            (this._needDrain = !1),
              (this._pause = !1),
              (this._cb = void 0),
              (this._nparts = 0),
              (this._boy = A);
            const Y = {
              boundary: Q,
              maxHeaderPairs: N,
              maxHeaderSize: p,
              partHwm: R.highWaterMark,
              highWaterMark: e.highWaterMark,
            };
            (this.parser = new o(Y)),
              this.parser
                .on("drain", function () {
                  if (((E._needDrain = !1), E._cb && !E._pause)) {
                    const A = E._cb;
                    (E._cb = void 0), A();
                  }
                })
                .on(
                  "part",
                  __name(function onPart(e) {
                    if (++E._nparts > k)
                      return (
                        E.parser.removeListener("part", onPart),
                        E.parser.on("part", skipPart),
                        (A.hitPartsLimit = !0),
                        A.emit("partsLimit"),
                        skipPart(e)
                      );
                    if (b) {
                      const A = b;
                      A.emit("end"), A.removeAllListeners("end");
                    }
                    e.on("header", function (Q) {
                      let o,
                        B,
                        C,
                        c,
                        d,
                        k,
                        N,
                        p,
                        M = 0;
                      if (
                        Q["content-type"] &&
                        ((C = s(Q["content-type"][0])), C[0])
                      )
                        for (
                          o = C[0].toLowerCase(), t = 0, r = C.length;
                          t < r;
                          ++t
                        )
                          if (n.test(C[t][0])) {
                            c = C[t][1].toLowerCase();
                            break;
                          }
                      if (
                        (void 0 === o && (o = "text/plain"),
                        void 0 === c && (c = u),
                        !Q["content-disposition"])
                      )
                        return skipPart(e);
                      if (((C = s(Q["content-disposition"][0])), !I.test(C[0])))
                        return skipPart(e);
                      for (t = 0, r = C.length; t < r; ++t)
                        h.test(C[t][0])
                          ? (B = C[t][1])
                          : a.test(C[t][0]) && ((k = C[t][1]), D || (k = g(k)));
                      if (
                        ((d = Q["content-transfer-encoding"]
                          ? Q["content-transfer-encoding"][0].toLowerCase()
                          : "7bit"),
                        l(B, o, k))
                      ) {
                        if (U === w)
                          return (
                            A.hitFilesLimit ||
                              ((A.hitFilesLimit = !0), A.emit("filesLimit")),
                            skipPart(e)
                          );
                        if ((++U, 0 === A.listenerCount("file")))
                          return void E.parser._ignore();
                        ++L;
                        const t = new FileStream(R);
                        (S = t),
                          t.on("end", function () {
                            if (
                              (--L,
                              (E._pause = !1),
                              checkFinished(),
                              E._cb && !E._needDrain)
                            ) {
                              const A = E._cb;
                              (E._cb = void 0), A();
                            }
                          }),
                          (t._read = function (A) {
                            if (
                              E._pause &&
                              ((E._pause = !1), E._cb && !E._needDrain)
                            ) {
                              const A = E._cb;
                              (E._cb = void 0), A();
                            }
                          }),
                          A.emit("file", B, t, k, d, o),
                          (N = __name(function (A) {
                            if ((M += A.length) > f) {
                              const r = f - M + A.length;
                              return (
                                r > 0 && t.push(A.slice(0, r)),
                                (t.truncated = !0),
                                (t.bytesRead = f),
                                e.removeAllListeners("data"),
                                void t.emit("limit")
                              );
                            }
                            t.push(A) || (E._pause = !0), (t.bytesRead = M);
                          }, "onData")),
                          (p = __name(function () {
                            (S = void 0), t.push(null);
                          }, "onEnd"));
                      } else {
                        if (m === F)
                          return (
                            A.hitFieldsLimit ||
                              ((A.hitFieldsLimit = !0), A.emit("fieldsLimit")),
                            skipPart(e)
                          );
                        ++m, ++L;
                        let t = "",
                          r = !1;
                        (b = e),
                          (N = __name(function (A) {
                            if ((M += A.length) > y) {
                              const E = y - (M - A.length);
                              (t += A.toString("binary", 0, E)),
                                (r = !0),
                                e.removeAllListeners("data");
                            } else t += A.toString("binary");
                          }, "onData")),
                          (p = __name(function () {
                            (b = void 0),
                              t.length && (t = i(t, "binary", c)),
                              A.emit("field", B, t, !1, r, d, o),
                              --L,
                              checkFinished();
                          }, "onEnd"));
                      }
                      (e._readableState.sync = !1),
                        e.on("data", N),
                        e.on("end", p);
                    }).on("error", function (A) {
                      S && S.emit("error", A);
                    });
                  }, "onPart")
                )
                .on("error", function (e) {
                  A.emit("error", e);
                })
                .on("finish", function () {
                  (M = !0), checkFinished();
                });
          }
          function skipPart(A) {
            A.resume();
          }
          function FileStream(A) {
            E.call(this, A), (this.bytesRead = 0), (this.truncated = !1);
          }
          (Multipart.detect = /^multipart\/form-data/i),
            __name(Multipart, "Multipart"),
            (Multipart.prototype.write = function (A, e) {
              const t = this.parser.write(A);
              t && !this._pause
                ? e()
                : ((this._needDrain = !t), (this._cb = e));
            }),
            (Multipart.prototype.end = function () {
              const A = this;
              A.parser.writable
                ? A.parser.end()
                : A._boy._done ||
                  r.nextTick(function () {
                    (A._boy._done = !0), A._boy.emit("finish");
                  });
            }),
            __name(skipPart, "skipPart"),
            __name(FileStream, "FileStream"),
            Q(FileStream, E),
            (FileStream.prototype._read = function (A) {}),
            (t.exports = Multipart);
        },
      }),
      N = __commonJS({
        "node_modules/@fastify/busboy/lib/utils/Decoder.js"(A, e) {
          var t = /\+/g,
            r = [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1,
              1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ];
          function Decoder() {
            this.buffer = void 0;
          }
          __name(Decoder, "Decoder"),
            (Decoder.prototype.write = function (A) {
              let e = "",
                E = 0,
                Q = 0;
              const o = (A = A.replace(t, " ")).length;
              for (; E < o; ++E)
                void 0 !== this.buffer
                  ? r[A.charCodeAt(E)]
                    ? ((this.buffer += A[E]),
                      ++Q,
                      2 === this.buffer.length &&
                        ((e += String.fromCharCode(parseInt(this.buffer, 16))),
                        (this.buffer = void 0)))
                    : ((e += "%" + this.buffer), (this.buffer = void 0), --E)
                  : "%" === A[E] &&
                    (E > Q && ((e += A.substring(Q, E)), (Q = E)),
                    (this.buffer = ""),
                    ++Q);
              return (
                Q < o && void 0 === this.buffer && (e += A.substring(Q)), e
              );
            }),
            (Decoder.prototype.reset = function () {
              this.buffer = void 0;
            }),
            (e.exports = Decoder);
        },
      }),
      p = __commonJS({
        "node_modules/@fastify/busboy/lib/types/urlencoded.js"(A, e) {
          var t = N(),
            r = f(),
            E = D(),
            Q = /^charset$/i;
          function UrlEncoded(A, e) {
            const r = e.limits,
              o = e.parsedConType;
            let s;
            (this.boy = A),
              (this.fieldSizeLimit = E(r, "fieldSize", 1048576)),
              (this.fieldNameSizeLimit = E(r, "fieldNameSize", 100)),
              (this.fieldsLimit = E(r, "fields", 1 / 0));
            for (var i = 0, g = o.length; i < g; ++i)
              if (Array.isArray(o[i]) && Q.test(o[i][0])) {
                s = o[i][1].toLowerCase();
                break;
              }
            void 0 === s && (s = e.defCharset || "utf8"),
              (this.decoder = new t()),
              (this.charset = s),
              (this._fields = 0),
              (this._state = "key"),
              (this._checkingBytes = !0),
              (this._bytesKey = 0),
              (this._bytesVal = 0),
              (this._key = ""),
              (this._val = ""),
              (this._keyTrunc = !1),
              (this._valTrunc = !1),
              (this._hitLimit = !1);
          }
          (UrlEncoded.detect = /^application\/x-www-form-urlencoded/i),
            __name(UrlEncoded, "UrlEncoded"),
            (UrlEncoded.prototype.write = function (A, e) {
              if (this._fields === this.fieldsLimit)
                return (
                  this.boy.hitFieldsLimit ||
                    ((this.boy.hitFieldsLimit = !0),
                    this.boy.emit("fieldsLimit")),
                  e()
                );
              let t,
                E,
                Q,
                o = 0;
              const s = A.length;
              for (; o < s; )
                if ("key" === this._state) {
                  for (t = E = void 0, Q = o; Q < s; ++Q) {
                    if ((this._checkingBytes || ++o, 61 === A[Q])) {
                      t = Q;
                      break;
                    }
                    if (38 === A[Q]) {
                      E = Q;
                      break;
                    }
                    if (
                      this._checkingBytes &&
                      this._bytesKey === this.fieldNameSizeLimit
                    ) {
                      this._hitLimit = !0;
                      break;
                    }
                    this._checkingBytes && ++this._bytesKey;
                  }
                  if (void 0 !== t)
                    t > o &&
                      (this._key += this.decoder.write(
                        A.toString("binary", o, t)
                      )),
                      (this._state = "val"),
                      (this._hitLimit = !1),
                      (this._checkingBytes = !0),
                      (this._val = ""),
                      (this._bytesVal = 0),
                      (this._valTrunc = !1),
                      this.decoder.reset(),
                      (o = t + 1);
                  else if (void 0 !== E) {
                    let t;
                    ++this._fields;
                    const Q = this._keyTrunc;
                    if (
                      ((t =
                        E > o
                          ? (this._key += this.decoder.write(
                              A.toString("binary", o, E)
                            ))
                          : this._key),
                      (this._hitLimit = !1),
                      (this._checkingBytes = !0),
                      (this._key = ""),
                      (this._bytesKey = 0),
                      (this._keyTrunc = !1),
                      this.decoder.reset(),
                      t.length &&
                        this.boy.emit(
                          "field",
                          r(t, "binary", this.charset),
                          "",
                          Q,
                          !1
                        ),
                      (o = E + 1),
                      this._fields === this.fieldsLimit)
                    )
                      return e();
                  } else
                    this._hitLimit
                      ? (Q > o &&
                          (this._key += this.decoder.write(
                            A.toString("binary", o, Q)
                          )),
                        (o = Q),
                        (this._bytesKey = this._key.length) ===
                          this.fieldNameSizeLimit &&
                          ((this._checkingBytes = !1), (this._keyTrunc = !0)))
                      : (o < s &&
                          (this._key += this.decoder.write(
                            A.toString("binary", o)
                          )),
                        (o = s));
                } else {
                  for (E = void 0, Q = o; Q < s; ++Q) {
                    if ((this._checkingBytes || ++o, 38 === A[Q])) {
                      E = Q;
                      break;
                    }
                    if (
                      this._checkingBytes &&
                      this._bytesVal === this.fieldSizeLimit
                    ) {
                      this._hitLimit = !0;
                      break;
                    }
                    this._checkingBytes && ++this._bytesVal;
                  }
                  if (void 0 !== E) {
                    if (
                      (++this._fields,
                      E > o &&
                        (this._val += this.decoder.write(
                          A.toString("binary", o, E)
                        )),
                      this.boy.emit(
                        "field",
                        r(this._key, "binary", this.charset),
                        r(this._val, "binary", this.charset),
                        this._keyTrunc,
                        this._valTrunc
                      ),
                      (this._state = "key"),
                      (this._hitLimit = !1),
                      (this._checkingBytes = !0),
                      (this._key = ""),
                      (this._bytesKey = 0),
                      (this._keyTrunc = !1),
                      this.decoder.reset(),
                      (o = E + 1),
                      this._fields === this.fieldsLimit)
                    )
                      return e();
                  } else
                    this._hitLimit
                      ? (Q > o &&
                          (this._val += this.decoder.write(
                            A.toString("binary", o, Q)
                          )),
                        (o = Q),
                        (("" === this._val && 0 === this.fieldSizeLimit) ||
                          (this._bytesVal = this._val.length) ===
                            this.fieldSizeLimit) &&
                          ((this._checkingBytes = !1), (this._valTrunc = !0)))
                      : (o < s &&
                          (this._val += this.decoder.write(
                            A.toString("binary", o)
                          )),
                        (o = s));
                }
              e();
            }),
            (UrlEncoded.prototype.end = function () {
              this.boy._done ||
                ("key" === this._state && this._key.length > 0
                  ? this.boy.emit(
                      "field",
                      r(this._key, "binary", this.charset),
                      "",
                      this._keyTrunc,
                      !1
                    )
                  : "val" === this._state &&
                    this.boy.emit(
                      "field",
                      r(this._key, "binary", this.charset),
                      r(this._val, "binary", this.charset),
                      this._keyTrunc,
                      this._valTrunc
                    ),
                (this.boy._done = !0),
                this.boy.emit("finish"));
            }),
            (e.exports = UrlEncoded);
        },
      }),
      S = __commonJS({
        "node_modules/@fastify/busboy/lib/main.js"(A, t) {
          var r = e("node:stream").Writable,
            { inherits: E } = e("node:util"),
            Q = y(),
            o = k(),
            s = p(),
            i = w();
          function Busboy(A) {
            if (!(this instanceof Busboy)) return new Busboy(A);
            if ("object" != typeof A)
              throw new TypeError("Busboy expected an options-Object.");
            if ("object" != typeof A.headers)
              throw new TypeError(
                "Busboy expected an options-Object with headers-attribute."
              );
            if ("string" != typeof A.headers["content-type"])
              throw new TypeError("Missing Content-Type-header.");
            const { headers: e, ...t } = A;
            (this.opts = { autoDestroy: !1, ...t }),
              r.call(this, this.opts),
              (this._done = !1),
              (this._parser = this.getParserByHeaders(e)),
              (this._finished = !1);
          }
          __name(Busboy, "Busboy"),
            E(Busboy, r),
            (Busboy.prototype.emit = function (A) {
              if ("finish" === A) {
                if (!this._done) return void this._parser?.end();
                if (this._finished) return;
                this._finished = !0;
              }
              r.prototype.emit.apply(this, arguments);
            }),
            (Busboy.prototype.getParserByHeaders = function (A) {
              const e = i(A["content-type"]),
                t = {
                  defCharset: this.opts.defCharset,
                  fileHwm: this.opts.fileHwm,
                  headers: A,
                  highWaterMark: this.opts.highWaterMark,
                  isPartAFile: this.opts.isPartAFile,
                  limits: this.opts.limits,
                  parsedConType: e,
                  preservePath: this.opts.preservePath,
                };
              if (o.detect.test(e[0])) return new o(this, t);
              if (s.detect.test(e[0])) return new s(this, t);
              throw new Error("Unsupported Content-Type.");
            }),
            (Busboy.prototype._write = function (A, e, t) {
              this._parser.write(A, t);
            }),
            (t.exports = Busboy),
            (t.exports.default = Busboy),
            (t.exports.Busboy = Busboy),
            (t.exports.Dicer = Q);
        },
      }),
      b = __commonJS({
        "lib/fetch/dataURL.js"(A, t) {
          var r = e("assert"),
            { atob: E } = e("buffer"),
            { isomorphicDecode: Q } = h(),
            o = new TextEncoder(),
            s = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/,
            i = /(\u000A|\u000D|\u0009|\u0020)/,
            g = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
          function dataURLProcessor(A) {
            r("data:" === A.protocol);
            let e = URLSerializer(A, !0);
            e = e.slice(5);
            const t = { position: 0 };
            let E = collectASequenceOfCodePointsFast(",", e, t);
            const o = E.length;
            if (
              ((E = removeASCIIWhitespace(E, !0, !0)), t.position >= e.length)
            )
              return "failure";
            t.position++;
            let s = stringPercentDecode(e.slice(o + 1));
            if (/;(\u0020){0,}base64$/i.test(E)) {
              if (((s = forgivingBase64(Q(s))), "failure" === s))
                return "failure";
              (E = E.slice(0, -6)),
                (E = E.replace(/(\u0020)+$/, "")),
                (E = E.slice(0, -1));
            }
            E.startsWith(";") && (E = "text/plain" + E);
            let i = parseMIMEType(E);
            return (
              "failure" === i &&
                (i = parseMIMEType("text/plain;charset=US-ASCII")),
              { mimeType: i, body: s }
            );
          }
          function URLSerializer(A, e = !1) {
            if (!e) return A.href;
            const t = A.href,
              r = A.hash.length;
            return 0 === r ? t : t.substring(0, t.length - r);
          }
          function collectASequenceOfCodePoints(A, e, t) {
            let r = "";
            for (; t.position < e.length && A(e[t.position]); )
              (r += e[t.position]), t.position++;
            return r;
          }
          function collectASequenceOfCodePointsFast(A, e, t) {
            const r = e.indexOf(A, t.position),
              E = t.position;
            return -1 === r
              ? ((t.position = e.length), e.slice(E))
              : ((t.position = r), e.slice(E, t.position));
          }
          function stringPercentDecode(A) {
            return percentDecode(o.encode(A));
          }
          function percentDecode(A) {
            const e = [];
            for (let t = 0; t < A.length; t++) {
              const r = A[t];
              if (37 !== r) e.push(r);
              else if (
                37 !== r ||
                /^[0-9A-Fa-f]{2}$/i.test(
                  String.fromCharCode(A[t + 1], A[t + 2])
                )
              ) {
                const r = String.fromCharCode(A[t + 1], A[t + 2]),
                  E = Number.parseInt(r, 16);
                e.push(E), (t += 2);
              } else e.push(37);
            }
            return Uint8Array.from(e);
          }
          function parseMIMEType(A) {
            const e = { position: 0 },
              t = collectASequenceOfCodePointsFast(
                "/",
                (A = removeHTTPWhitespace(A, !0, !0)),
                e
              );
            if (0 === t.length || !s.test(t)) return "failure";
            if (e.position > A.length) return "failure";
            e.position++;
            let r = collectASequenceOfCodePointsFast(";", A, e);
            if (
              ((r = removeHTTPWhitespace(r, !1, !0)),
              0 === r.length || !s.test(r))
            )
              return "failure";
            const E = t.toLowerCase(),
              Q = r.toLowerCase(),
              o = {
                type: E,
                subtype: Q,
                parameters: new Map(),
                essence: `${E}/${Q}`,
              };
            for (; e.position < A.length; ) {
              e.position++,
                collectASequenceOfCodePoints((A) => i.test(A), A, e);
              let t = collectASequenceOfCodePoints(
                (A) => ";" !== A && "=" !== A,
                A,
                e
              );
              if (((t = t.toLowerCase()), e.position < A.length)) {
                if (";" === A[e.position]) continue;
                e.position++;
              }
              if (e.position > A.length) break;
              let r = null;
              if ('"' === A[e.position])
                (r = collectAnHTTPQuotedString(A, e, !0)),
                  collectASequenceOfCodePointsFast(";", A, e);
              else if (
                ((r = collectASequenceOfCodePointsFast(";", A, e)),
                (r = removeHTTPWhitespace(r, !1, !0)),
                0 === r.length)
              )
                continue;
              0 === t.length ||
                !s.test(t) ||
                (0 !== r.length && !g.test(r)) ||
                o.parameters.has(t) ||
                o.parameters.set(t, r);
            }
            return o;
          }
          function forgivingBase64(A) {
            if (
              ((A = A.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "")).length %
                4 ==
                0 && (A = A.replace(/=?=$/, "")),
              A.length % 4 == 1)
            )
              return "failure";
            if (/[^+/0-9A-Za-z]/.test(A)) return "failure";
            const e = E(A),
              t = new Uint8Array(e.length);
            for (let A = 0; A < e.length; A++) t[A] = e.charCodeAt(A);
            return t;
          }
          function collectAnHTTPQuotedString(A, e, t) {
            const E = e.position;
            let Q = "";
            for (
              r('"' === A[e.position]), e.position++;
              (Q += collectASequenceOfCodePoints(
                (A) => '"' !== A && "\\" !== A,
                A,
                e
              )),
                !(e.position >= A.length);

            ) {
              const t = A[e.position];
              if ((e.position++, "\\" !== t)) {
                r('"' === t);
                break;
              }
              if (e.position >= A.length) {
                Q += "\\";
                break;
              }
              (Q += A[e.position]), e.position++;
            }
            return t ? Q : A.slice(E, e.position);
          }
          function serializeAMimeType(A) {
            r("failure" !== A);
            const { parameters: e, essence: t } = A;
            let E = t;
            for (let [A, t] of e.entries())
              (E += ";"),
                (E += A),
                (E += "="),
                s.test(t) ||
                  ((t = t.replace(/(\\|")/g, "\\$1")),
                  (t = '"' + t),
                  (t += '"')),
                (E += t);
            return E;
          }
          function isHTTPWhiteSpace(A) {
            return "\r" === A || "\n" === A || "\t" === A || " " === A;
          }
          function removeHTTPWhitespace(A, e = !0, t = !0) {
            let r = 0,
              E = A.length - 1;
            if (e) for (; r < A.length && isHTTPWhiteSpace(A[r]); r++);
            if (t) for (; E > 0 && isHTTPWhiteSpace(A[E]); E--);
            return A.slice(r, E + 1);
          }
          function isASCIIWhitespace(A) {
            return (
              "\r" === A || "\n" === A || "\t" === A || "\f" === A || " " === A
            );
          }
          function removeASCIIWhitespace(A, e = !0, t = !0) {
            let r = 0,
              E = A.length - 1;
            if (e) for (; r < A.length && isASCIIWhitespace(A[r]); r++);
            if (t) for (; E > 0 && isASCIIWhitespace(A[E]); E--);
            return A.slice(r, E + 1);
          }
          __name(dataURLProcessor, "dataURLProcessor"),
            __name(URLSerializer, "URLSerializer"),
            __name(
              collectASequenceOfCodePoints,
              "collectASequenceOfCodePoints"
            ),
            __name(
              collectASequenceOfCodePointsFast,
              "collectASequenceOfCodePointsFast"
            ),
            __name(stringPercentDecode, "stringPercentDecode"),
            __name(percentDecode, "percentDecode"),
            __name(parseMIMEType, "parseMIMEType"),
            __name(forgivingBase64, "forgivingBase64"),
            __name(collectAnHTTPQuotedString, "collectAnHTTPQuotedString"),
            __name(serializeAMimeType, "serializeAMimeType"),
            __name(isHTTPWhiteSpace, "isHTTPWhiteSpace"),
            __name(removeHTTPWhitespace, "removeHTTPWhitespace"),
            __name(isASCIIWhitespace, "isASCIIWhitespace"),
            __name(removeASCIIWhitespace, "removeASCIIWhitespace"),
            (t.exports = {
              dataURLProcessor: dataURLProcessor,
              URLSerializer: URLSerializer,
              collectASequenceOfCodePoints: collectASequenceOfCodePoints,
              collectASequenceOfCodePointsFast:
                collectASequenceOfCodePointsFast,
              stringPercentDecode: stringPercentDecode,
              parseMIMEType: parseMIMEType,
              collectAnHTTPQuotedString: collectAnHTTPQuotedString,
              serializeAMimeType: serializeAMimeType,
            });
        },
      }),
      U = __commonJS({
        "lib/fetch/file.js"(A, t) {
          var { Blob: E, File: Q } = e("buffer"),
            { types: o } = e("util"),
            { kState: s } = g(),
            { isBlobLike: i } = h(),
            { webidl: B } = c(),
            { parseMIMEType: C, serializeAMimeType: n } = b(),
            { kEnumerableProperty: a } = I(),
            l = new TextEncoder(),
            d = class _File extends E {
              static {
                __name(this, "File");
              }
              constructor(A, e, t = {}) {
                B.argumentLengthCheck(arguments, 2, {
                  header: "File constructor",
                }),
                  (A = B.converters["sequence<BlobPart>"](A));
                const r = (e = B.converters.USVString(e));
                let E,
                  Q = (t = B.converters.FilePropertyBag(t)).type;
                A: {
                  if (Q) {
                    if (((Q = C(Q)), "failure" === Q)) {
                      Q = "";
                      break A;
                    }
                    Q = n(Q).toLowerCase();
                  }
                  E = t.lastModified;
                }
                super(processBlobParts(A, t), { type: Q }),
                  (this[s] = { name: r, lastModified: E, type: Q });
              }
              get name() {
                return B.brandCheck(this, _File), this[s].name;
              }
              get lastModified() {
                return B.brandCheck(this, _File), this[s].lastModified;
              }
              get type() {
                return B.brandCheck(this, _File), this[s].type;
              }
            },
            u = class _FileLike {
              static {
                __name(this, "FileLike");
              }
              constructor(A, e, t = {}) {
                const r = e,
                  E = t.type,
                  Q = t.lastModified ?? Date.now();
                this[s] = { blobLike: A, name: r, type: E, lastModified: Q };
              }
              stream(...A) {
                return (
                  B.brandCheck(this, _FileLike), this[s].blobLike.stream(...A)
                );
              }
              arrayBuffer(...A) {
                return (
                  B.brandCheck(this, _FileLike),
                  this[s].blobLike.arrayBuffer(...A)
                );
              }
              slice(...A) {
                return (
                  B.brandCheck(this, _FileLike), this[s].blobLike.slice(...A)
                );
              }
              text(...A) {
                return (
                  B.brandCheck(this, _FileLike), this[s].blobLike.text(...A)
                );
              }
              get size() {
                return B.brandCheck(this, _FileLike), this[s].blobLike.size;
              }
              get type() {
                return B.brandCheck(this, _FileLike), this[s].blobLike.type;
              }
              get name() {
                return B.brandCheck(this, _FileLike), this[s].name;
              }
              get lastModified() {
                return B.brandCheck(this, _FileLike), this[s].lastModified;
              }
              get [Symbol.toStringTag]() {
                return "File";
              }
            };
          function processBlobParts(A, e) {
            const t = [];
            for (const r of A)
              if ("string" == typeof r) {
                let A = r;
                "native" === e.endings && (A = convertLineEndingsNative(A)),
                  t.push(l.encode(A));
              } else
                o.isAnyArrayBuffer(r) || o.isTypedArray(r)
                  ? r.buffer
                    ? t.push(
                        new Uint8Array(r.buffer, r.byteOffset, r.byteLength)
                      )
                    : t.push(new Uint8Array(r))
                  : i(r) && t.push(r);
            return t;
          }
          function convertLineEndingsNative(A) {
            let e = "\n";
            return (
              "win32" === r.platform && (e = "\r\n"), A.replace(/\r?\n/g, e)
            );
          }
          function isFileLike(A) {
            return (
              (Q && A instanceof Q) ||
              A instanceof d ||
              (A &&
                ("function" == typeof A.stream ||
                  "function" == typeof A.arrayBuffer) &&
                "File" === A[Symbol.toStringTag])
            );
          }
          Object.defineProperties(d.prototype, {
            [Symbol.toStringTag]: { value: "File", configurable: !0 },
            name: a,
            lastModified: a,
          }),
            (B.converters.Blob = B.interfaceConverter(E)),
            (B.converters.BlobPart = function (A, e) {
              if ("Object" === B.util.Type(A)) {
                if (i(A)) return B.converters.Blob(A, { strict: !1 });
                if (ArrayBuffer.isView(A) || o.isAnyArrayBuffer(A))
                  return B.converters.BufferSource(A, e);
              }
              return B.converters.USVString(A, e);
            }),
            (B.converters["sequence<BlobPart>"] = B.sequenceConverter(
              B.converters.BlobPart
            )),
            (B.converters.FilePropertyBag = B.dictionaryConverter([
              {
                key: "lastModified",
                converter: B.converters["long long"],
                get defaultValue() {
                  return Date.now();
                },
              },
              {
                key: "type",
                converter: B.converters.DOMString,
                defaultValue: "",
              },
              {
                key: "endings",
                converter: (A) => (
                  "native" !==
                    (A = (A = B.converters.DOMString(A)).toLowerCase()) &&
                    (A = "transparent"),
                  A
                ),
                defaultValue: "transparent",
              },
            ])),
            __name(processBlobParts, "processBlobParts"),
            __name(convertLineEndingsNative, "convertLineEndingsNative"),
            __name(isFileLike, "isFileLike"),
            (t.exports = { File: d, FileLike: u, isFileLike: isFileLike });
        },
      }),
      m = __commonJS({
        "lib/fetch/formdata.js"(A, t) {
          var { isBlobLike: r, toUSVString: E, makeIterator: Q } = h(),
            { kState: o } = g(),
            { File: s, FileLike: i, isFileLike: B } = U(),
            { webidl: C } = c(),
            { Blob: I, File: n } = e("buffer"),
            a = n ?? s,
            l = class _FormData {
              static {
                __name(this, "FormData");
              }
              constructor(A) {
                if (void 0 !== A)
                  throw C.errors.conversionFailed({
                    prefix: "FormData constructor",
                    argument: "Argument 1",
                    types: ["undefined"],
                  });
                this[o] = [];
              }
              append(A, e, t = void 0) {
                if (
                  (C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 2, {
                    header: "FormData.append",
                  }),
                  3 === arguments.length && !r(e))
                )
                  throw new TypeError(
                    "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
                  );
                const E = makeEntry(
                  (A = C.converters.USVString(A)),
                  (e = r(e)
                    ? C.converters.Blob(e, { strict: !1 })
                    : C.converters.USVString(e)),
                  (t =
                    3 === arguments.length ? C.converters.USVString(t) : void 0)
                );
                this[o].push(E);
              }
              delete(A) {
                C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 1, {
                    header: "FormData.delete",
                  }),
                  (A = C.converters.USVString(A)),
                  (this[o] = this[o].filter((e) => e.name !== A));
              }
              get(A) {
                C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 1, {
                    header: "FormData.get",
                  }),
                  (A = C.converters.USVString(A));
                const e = this[o].findIndex((e) => e.name === A);
                return -1 === e ? null : this[o][e].value;
              }
              getAll(A) {
                return (
                  C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 1, {
                    header: "FormData.getAll",
                  }),
                  (A = C.converters.USVString(A)),
                  this[o].filter((e) => e.name === A).map((A) => A.value)
                );
              }
              has(A) {
                return (
                  C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 1, {
                    header: "FormData.has",
                  }),
                  (A = C.converters.USVString(A)),
                  -1 !== this[o].findIndex((e) => e.name === A)
                );
              }
              set(A, e, t = void 0) {
                if (
                  (C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 2, {
                    header: "FormData.set",
                  }),
                  3 === arguments.length && !r(e))
                )
                  throw new TypeError(
                    "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
                  );
                (A = C.converters.USVString(A)),
                  (e = r(e)
                    ? C.converters.Blob(e, { strict: !1 })
                    : C.converters.USVString(e)),
                  (t = 3 === arguments.length ? E(t) : void 0);
                const Q = makeEntry(A, e, t),
                  s = this[o].findIndex((e) => e.name === A);
                -1 !== s
                  ? (this[o] = [
                      ...this[o].slice(0, s),
                      Q,
                      ...this[o].slice(s + 1).filter((e) => e.name !== A),
                    ])
                  : this[o].push(Q);
              }
              entries() {
                return (
                  C.brandCheck(this, _FormData),
                  Q(
                    () => this[o].map((A) => [A.name, A.value]),
                    "FormData",
                    "key+value"
                  )
                );
              }
              keys() {
                return (
                  C.brandCheck(this, _FormData),
                  Q(
                    () => this[o].map((A) => [A.name, A.value]),
                    "FormData",
                    "key"
                  )
                );
              }
              values() {
                return (
                  C.brandCheck(this, _FormData),
                  Q(
                    () => this[o].map((A) => [A.name, A.value]),
                    "FormData",
                    "value"
                  )
                );
              }
              forEach(A, e = globalThis) {
                if (
                  (C.brandCheck(this, _FormData),
                  C.argumentLengthCheck(arguments, 1, {
                    header: "FormData.forEach",
                  }),
                  "function" != typeof A)
                )
                  throw new TypeError(
                    "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
                  );
                for (const [t, r] of this) A.apply(e, [r, t, this]);
              }
            };
          function makeEntry(A, e, t) {
            if (((A = Buffer.from(A).toString("utf8")), "string" == typeof e))
              e = Buffer.from(e).toString("utf8");
            else if (
              (B(e) ||
                (e =
                  e instanceof I
                    ? new a([e], "blob", { type: e.type })
                    : new i(e, "blob", { type: e.type })),
              void 0 !== t)
            ) {
              const A = { type: e.type, lastModified: e.lastModified };
              e =
                (n && e instanceof n) || e instanceof s
                  ? new a([e], t, A)
                  : new i(e, t, A);
            }
            return { name: A, value: e };
          }
          (l.prototype[Symbol.iterator] = l.prototype.entries),
            Object.defineProperties(l.prototype, {
              [Symbol.toStringTag]: { value: "FormData", configurable: !0 },
            }),
            __name(makeEntry, "makeEntry"),
            (t.exports = { FormData: l });
        },
      }),
      L = __commonJS({
        "lib/fetch/body.js"(A, t) {
          var r = S(),
            E = I(),
            {
              ReadableStreamFrom: Q,
              isBlobLike: o,
              isReadableStreamLike: s,
              readableStreamClose: B,
              createDeferredPromise: C,
              fullyReadBody: a,
            } = h(),
            { FormData: l } = m(),
            { kState: d } = g(),
            { webidl: u } = c(),
            { DOMException: D, structuredClone: R } = n(),
            { Blob: y, File: f } = e("buffer"),
            { kBodyUsed: w } = i(),
            F = e("assert"),
            { isErrored: k } = I(),
            { isUint8Array: N, isArrayBuffer: p } = e("util/types"),
            { File: L } = U(),
            { parseMIMEType: M, serializeAMimeType: Y } = b(),
            J = globalThis.ReadableStream,
            G = f ?? L,
            T = new TextEncoder(),
            H = new TextDecoder();
          function extractBody(A, t = !1) {
            J || (J = e("stream/web").ReadableStream);
            let r = null;
            (r =
              A instanceof J
                ? A
                : o(A)
                ? A.stream()
                : new J({
                    async pull(A) {
                      A.enqueue("string" == typeof g ? T.encode(g) : g),
                        queueMicrotask(() => B(A));
                    },
                    start() {},
                    type: void 0,
                  })),
              F(s(r));
            let i = null,
              g = null,
              C = null,
              I = null;
            if ("string" == typeof A) (g = A), (I = "text/plain;charset=UTF-8");
            else if (A instanceof URLSearchParams)
              (g = A.toString()),
                (I = "application/x-www-form-urlencoded;charset=UTF-8");
            else if (p(A)) g = new Uint8Array(A.slice());
            else if (ArrayBuffer.isView(A))
              g = new Uint8Array(
                A.buffer.slice(A.byteOffset, A.byteOffset + A.byteLength)
              );
            else if (E.isFormDataLike(A)) {
              const e = `----formdata-undici-0${`${Math.floor(
                  1e11 * Math.random()
                )}`.padStart(11, "0")}`,
                t = `--${e}\r\nContent-Disposition: form-data`,
                r = __name(
                  (A) =>
                    A.replace(/\n/g, "%0A")
                      .replace(/\r/g, "%0D")
                      .replace(/"/g, "%22"),
                  "escape"
                ),
                E = __name(
                  (A) => A.replace(/\r?\n|\r/g, "\r\n"),
                  "normalizeLinefeeds"
                ),
                Q = [],
                o = new Uint8Array([13, 10]);
              C = 0;
              let s = !1;
              for (const [e, i] of A)
                if ("string" == typeof i) {
                  const A = T.encode(
                    t + `; name="${r(E(e))}"\r\n\r\n${E(i)}\r\n`
                  );
                  Q.push(A), (C += A.byteLength);
                } else {
                  const A = T.encode(
                    `${t}; name="${r(E(e))}"` +
                      (i.name ? `; filename="${r(i.name)}"` : "") +
                      `\r\nContent-Type: ${
                        i.type || "application/octet-stream"
                      }\r\n\r\n`
                  );
                  Q.push(A, i, o),
                    "number" == typeof i.size
                      ? (C += A.byteLength + i.size + o.byteLength)
                      : (s = !0);
                }
              const B = T.encode(`--${e}--`);
              Q.push(B),
                (C += B.byteLength),
                s && (C = null),
                (g = A),
                (i = __name(async function* () {
                  for (const A of Q) A.stream ? yield* A.stream() : yield A;
                }, "action")),
                (I = "multipart/form-data; boundary=" + e);
            } else if (o(A)) (g = A), (C = A.size), A.type && (I = A.type);
            else if ("function" == typeof A[Symbol.asyncIterator]) {
              if (t) throw new TypeError("keepalive");
              if (E.isDisturbed(A) || A.locked)
                throw new TypeError(
                  "Response body object should not be disturbed or locked"
                );
              r = A instanceof J ? A : Q(A);
            }
            if (
              (("string" == typeof g || E.isBuffer(g)) &&
                (C = Buffer.byteLength(g)),
              null != i)
            ) {
              let e;
              r = new J({
                async start() {
                  e = i(A)[Symbol.asyncIterator]();
                },
                async pull(A) {
                  const { value: t, done: E } = await e.next();
                  return (
                    E
                      ? queueMicrotask(() => {
                          A.close();
                        })
                      : k(r) || A.enqueue(new Uint8Array(t)),
                    A.desiredSize > 0
                  );
                },
                async cancel(A) {
                  await e.return();
                },
                type: void 0,
              });
            }
            return [{ stream: r, source: g, length: C }, I];
          }
          function safelyExtractBody(A, t = !1) {
            return (
              J || (J = e("stream/web").ReadableStream),
              A instanceof J &&
                (F(!E.isDisturbed(A), "The body has already been consumed."),
                F(!A.locked, "The stream is locked.")),
              extractBody(A, t)
            );
          }
          function cloneBody(A) {
            const [e, t] = A.stream.tee(),
              r = R(t, { transfer: [t] }),
              [, E] = r.tee();
            return (
              (A.stream = e), { stream: E, length: A.length, source: A.source }
            );
          }
          async function* consumeBody(A) {
            if (A)
              if (N(A)) yield A;
              else {
                const e = A.stream;
                if (E.isDisturbed(e))
                  throw new TypeError("The body has already been consumed.");
                if (e.locked) throw new TypeError("The stream is locked.");
                (e[w] = !0), yield* e;
              }
          }
          function throwIfAborted(A) {
            if (A.aborted)
              throw new D("The operation was aborted.", "AbortError");
          }
          function bodyMixinMethods(A) {
            return {
              blob() {
                return specConsumeBody(
                  this,
                  (A) => {
                    let e = bodyMimeType(this);
                    return (
                      "failure" === e ? (e = "") : e && (e = Y(e)),
                      new y([A], { type: e })
                    );
                  },
                  A
                );
              },
              arrayBuffer() {
                return specConsumeBody(
                  this,
                  (A) => new Uint8Array(A).buffer,
                  A
                );
              },
              text() {
                return specConsumeBody(this, utf8DecodeBytes, A);
              },
              json() {
                return specConsumeBody(this, parseJSONFromBytes, A);
              },
              async formData() {
                u.brandCheck(this, A), throwIfAborted(this[d]);
                const e = this.headers.get("Content-Type");
                if (/multipart\/form-data/.test(e)) {
                  const A = {};
                  for (const [e, t] of this.headers) A[e.toLowerCase()] = t;
                  const e = new l();
                  let t;
                  try {
                    t = new r({ headers: A, preservePath: !0 });
                  } catch (A) {
                    throw new D(`${A}`, "AbortError");
                  }
                  t.on("field", (A, t) => {
                    e.append(A, t);
                  }),
                    t.on("file", (A, t, r, E, Q) => {
                      const o = [];
                      if ("base64" === E || "base64" === E.toLowerCase()) {
                        let E = "";
                        t.on("data", (A) => {
                          E += A.toString().replace(/[\r\n]/gm, "");
                          const e = E.length - (E.length % 4);
                          o.push(Buffer.from(E.slice(0, e), "base64")),
                            (E = E.slice(e));
                        }),
                          t.on("end", () => {
                            o.push(Buffer.from(E, "base64")),
                              e.append(A, new G(o, r, { type: Q }));
                          });
                      } else
                        t.on("data", (A) => {
                          o.push(A);
                        }),
                          t.on("end", () => {
                            e.append(A, new G(o, r, { type: Q }));
                          });
                    });
                  const E = new Promise((A, e) => {
                    t.on("finish", A),
                      t.on("error", (A) => e(new TypeError(A)));
                  });
                  if (null !== this.body)
                    for await (const A of consumeBody(this[d].body)) t.write(A);
                  return t.end(), await E, e;
                }
                if (/application\/x-www-form-urlencoded/.test(e)) {
                  let A;
                  try {
                    let e = "";
                    const t = new TextDecoder("utf-8", { ignoreBOM: !0 });
                    for await (const A of consumeBody(this[d].body)) {
                      if (!N(A))
                        throw new TypeError("Expected Uint8Array chunk");
                      e += t.decode(A, { stream: !0 });
                    }
                    (e += t.decode()), (A = new URLSearchParams(e));
                  } catch (A) {
                    throw Object.assign(new TypeError(), { cause: A });
                  }
                  const e = new l();
                  for (const [t, r] of A) e.append(t, r);
                  return e;
                }
                throw (
                  (await Promise.resolve(),
                  throwIfAborted(this[d]),
                  u.errors.exception({
                    header: `${A.name}.formData`,
                    message: "Could not parse content as FormData.",
                  }))
                );
              },
            };
          }
          function mixinBody(A) {
            Object.assign(A.prototype, bodyMixinMethods(A));
          }
          async function specConsumeBody(A, e, t) {
            if (
              (u.brandCheck(A, t),
              throwIfAborted(A[d]),
              bodyUnusable(A[d].body))
            )
              throw new TypeError("Body is unusable");
            const r = C(),
              E = __name((A) => r.reject(A), "errorSteps"),
              Q = __name((A) => {
                try {
                  r.resolve(e(A));
                } catch (A) {
                  E(A);
                }
              }, "successSteps");
            return null == A[d].body
              ? (Q(new Uint8Array()), r.promise)
              : (await a(A[d].body, Q, E), r.promise);
          }
          function bodyUnusable(A) {
            return null != A && (A.stream.locked || E.isDisturbed(A.stream));
          }
          function utf8DecodeBytes(A) {
            if (0 === A.length) return "";
            239 === A[0] && 187 === A[1] && 191 === A[2] && (A = A.subarray(3));
            return H.decode(A);
          }
          function parseJSONFromBytes(A) {
            return JSON.parse(utf8DecodeBytes(A));
          }
          function bodyMimeType(A) {
            const { headersList: e } = A[d],
              t = e.get("content-type");
            return null === t ? "failure" : M(t);
          }
          __name(extractBody, "extractBody"),
            __name(safelyExtractBody, "safelyExtractBody"),
            __name(cloneBody, "cloneBody"),
            __name(consumeBody, "consumeBody"),
            __name(throwIfAborted, "throwIfAborted"),
            __name(bodyMixinMethods, "bodyMixinMethods"),
            __name(mixinBody, "mixinBody"),
            __name(specConsumeBody, "specConsumeBody"),
            __name(bodyUnusable, "bodyUnusable"),
            __name(utf8DecodeBytes, "utf8DecodeBytes"),
            __name(parseJSONFromBytes, "parseJSONFromBytes"),
            __name(bodyMimeType, "bodyMimeType"),
            (t.exports = {
              extractBody: extractBody,
              safelyExtractBody: safelyExtractBody,
              cloneBody: cloneBody,
              mixinBody: mixinBody,
            });
        },
      }),
      M = __commonJS({
        "lib/fetch/response.js"(A, t) {
          var { Headers: r, HeadersList: E, fill: Q } = l(),
            { extractBody: o, cloneBody: s, mixinBody: B } = L(),
            C = I(),
            { kEnumerableProperty: d } = C,
            {
              isValidReasonPhrase: u,
              isCancelled: D,
              isAborted: R,
              isBlobLike: y,
              serializeJavascriptValueToJSONString: f,
              isErrorLike: w,
              isomorphicEncode: F,
            } = h(),
            { redirectStatusSet: k, nullBodyStatus: N, DOMException: p } = n(),
            { kState: S, kHeaders: U, kGuard: M, kRealm: Y } = g(),
            { webidl: J } = c(),
            { FormData: G } = m(),
            { getGlobalOrigin: T } = a(),
            { URLSerializer: H } = b(),
            { kHeadersList: V, kConstruct: v } = i(),
            W = e("assert"),
            { types: x } = e("util"),
            q = globalThis.ReadableStream || e("stream/web").ReadableStream,
            O = new TextEncoder("utf-8"),
            P = class _Response {
              static {
                __name(this, "Response");
              }
              static error() {
                const A = { settingsObject: {} },
                  e = new _Response();
                return (
                  (e[S] = makeNetworkError()),
                  (e[Y] = A),
                  (e[U][V] = e[S].headersList),
                  (e[U][M] = "immutable"),
                  (e[U][Y] = A),
                  e
                );
              }
              static json(A, e = {}) {
                J.argumentLengthCheck(arguments, 1, {
                  header: "Response.json",
                }),
                  null !== e && (e = J.converters.ResponseInit(e));
                const t = O.encode(f(A)),
                  r = o(t),
                  E = { settingsObject: {} },
                  Q = new _Response();
                return (
                  (Q[Y] = E),
                  (Q[U][M] = "response"),
                  (Q[U][Y] = E),
                  initializeResponse(Q, e, {
                    body: r[0],
                    type: "application/json",
                  }),
                  Q
                );
              }
              static redirect(A, e = 302) {
                const t = { settingsObject: {} };
                let r;
                J.argumentLengthCheck(arguments, 1, {
                  header: "Response.redirect",
                }),
                  (A = J.converters.USVString(A)),
                  (e = J.converters["unsigned short"](e));
                try {
                  r = new URL(A, T());
                } catch (e) {
                  throw Object.assign(
                    new TypeError("Failed to parse URL from " + A),
                    { cause: e }
                  );
                }
                if (!k.has(e)) throw new RangeError("Invalid status code " + e);
                const E = new _Response();
                (E[Y] = t),
                  (E[U][M] = "immutable"),
                  (E[U][Y] = t),
                  (E[S].status = e);
                const Q = F(H(r));
                return E[S].headersList.append("location", Q), E;
              }
              constructor(A = null, e = {}) {
                null !== A && (A = J.converters.BodyInit(A)),
                  (e = J.converters.ResponseInit(e)),
                  (this[Y] = { settingsObject: {} }),
                  (this[S] = makeResponse({})),
                  (this[U] = new r(v)),
                  (this[U][M] = "response"),
                  (this[U][V] = this[S].headersList),
                  (this[U][Y] = this[Y]);
                let t = null;
                if (null != A) {
                  const [e, r] = o(A);
                  t = { body: e, type: r };
                }
                initializeResponse(this, e, t);
              }
              get type() {
                return J.brandCheck(this, _Response), this[S].type;
              }
              get url() {
                J.brandCheck(this, _Response);
                const A = this[S].urlList,
                  e = A[A.length - 1] ?? null;
                return null === e ? "" : H(e, !0);
              }
              get redirected() {
                return (
                  J.brandCheck(this, _Response), this[S].urlList.length > 1
                );
              }
              get status() {
                return J.brandCheck(this, _Response), this[S].status;
              }
              get ok() {
                return (
                  J.brandCheck(this, _Response),
                  this[S].status >= 200 && this[S].status <= 299
                );
              }
              get statusText() {
                return J.brandCheck(this, _Response), this[S].statusText;
              }
              get headers() {
                return J.brandCheck(this, _Response), this[U];
              }
              get body() {
                return (
                  J.brandCheck(this, _Response),
                  this[S].body ? this[S].body.stream : null
                );
              }
              get bodyUsed() {
                return (
                  J.brandCheck(this, _Response),
                  !!this[S].body && C.isDisturbed(this[S].body.stream)
                );
              }
              clone() {
                if (
                  (J.brandCheck(this, _Response),
                  this.bodyUsed || (this.body && this.body.locked))
                )
                  throw J.errors.exception({
                    header: "Response.clone",
                    message: "Body has already been consumed.",
                  });
                const A = cloneResponse(this[S]),
                  e = new _Response();
                return (
                  (e[S] = A),
                  (e[Y] = this[Y]),
                  (e[U][V] = A.headersList),
                  (e[U][M] = this[U][M]),
                  (e[U][Y] = this[U][Y]),
                  e
                );
              }
            };
          function cloneResponse(A) {
            if (A.internalResponse)
              return filterResponse(cloneResponse(A.internalResponse), A.type);
            const e = makeResponse({ ...A, body: null });
            return null != A.body && (e.body = s(A.body)), e;
          }
          function makeResponse(A) {
            return {
              aborted: !1,
              rangeRequested: !1,
              timingAllowPassed: !1,
              requestIncludesCredentials: !1,
              type: "default",
              status: 200,
              timingInfo: null,
              cacheState: "",
              statusText: "",
              ...A,
              headersList: A.headersList ? new E(A.headersList) : new E(),
              urlList: A.urlList ? [...A.urlList] : [],
            };
          }
          function makeNetworkError(A) {
            return makeResponse({
              type: "error",
              status: 0,
              error: w(A) ? A : new Error(A ? String(A) : A),
              aborted: A && "AbortError" === A.name,
            });
          }
          function makeFilteredResponse(A, e) {
            return (
              (e = { internalResponse: A, ...e }),
              new Proxy(A, {
                get: (A, t) => (t in e ? e[t] : A[t]),
                set: (A, t, r) => (W(!(t in e)), (A[t] = r), !0),
              })
            );
          }
          function filterResponse(A, e) {
            return "basic" === e
              ? makeFilteredResponse(A, {
                  type: "basic",
                  headersList: A.headersList,
                })
              : "cors" === e
              ? makeFilteredResponse(A, {
                  type: "cors",
                  headersList: A.headersList,
                })
              : "opaque" === e
              ? makeFilteredResponse(A, {
                  type: "opaque",
                  urlList: Object.freeze([]),
                  status: 0,
                  statusText: "",
                  body: null,
                })
              : "opaqueredirect" === e
              ? makeFilteredResponse(A, {
                  type: "opaqueredirect",
                  status: 0,
                  statusText: "",
                  headersList: [],
                  body: null,
                })
              : void W(!1);
          }
          function makeAppropriateNetworkError(A, e = null) {
            return (
              W(D(A)),
              R(A)
                ? makeNetworkError(
                    Object.assign(
                      new p("The operation was aborted.", "AbortError"),
                      { cause: e }
                    )
                  )
                : makeNetworkError(
                    Object.assign(new p("Request was cancelled."), { cause: e })
                  )
            );
          }
          function initializeResponse(A, e, t) {
            if (null !== e.status && (e.status < 200 || e.status > 599))
              throw new RangeError(
                'init["status"] must be in the range of 200 to 599, inclusive.'
              );
            if (
              "statusText" in e &&
              null != e.statusText &&
              !u(String(e.statusText))
            )
              throw new TypeError("Invalid statusText");
            if (
              ("status" in e && null != e.status && (A[S].status = e.status),
              "statusText" in e &&
                null != e.statusText &&
                (A[S].statusText = e.statusText),
              "headers" in e && null != e.headers && Q(A[U], e.headers),
              t)
            ) {
              if (N.includes(A.status))
                throw J.errors.exception({
                  header: "Response constructor",
                  message: "Invalid response status code " + A.status,
                });
              (A[S].body = t.body),
                null == t.type ||
                  A[S].headersList.contains("Content-Type") ||
                  A[S].headersList.append("content-type", t.type);
            }
          }
          B(P),
            Object.defineProperties(P.prototype, {
              type: d,
              url: d,
              status: d,
              ok: d,
              redirected: d,
              statusText: d,
              headers: d,
              clone: d,
              body: d,
              bodyUsed: d,
              [Symbol.toStringTag]: { value: "Response", configurable: !0 },
            }),
            Object.defineProperties(P, { json: d, redirect: d, error: d }),
            __name(cloneResponse, "cloneResponse"),
            __name(makeResponse, "makeResponse"),
            __name(makeNetworkError, "makeNetworkError"),
            __name(makeFilteredResponse, "makeFilteredResponse"),
            __name(filterResponse, "filterResponse"),
            __name(makeAppropriateNetworkError, "makeAppropriateNetworkError"),
            __name(initializeResponse, "initializeResponse"),
            (J.converters.ReadableStream = J.interfaceConverter(q)),
            (J.converters.FormData = J.interfaceConverter(G)),
            (J.converters.URLSearchParams =
              J.interfaceConverter(URLSearchParams)),
            (J.converters.XMLHttpRequestBodyInit = function (A) {
              return "string" == typeof A
                ? J.converters.USVString(A)
                : y(A)
                ? J.converters.Blob(A, { strict: !1 })
                : x.isArrayBuffer(A) || x.isTypedArray(A) || x.isDataView(A)
                ? J.converters.BufferSource(A)
                : C.isFormDataLike(A)
                ? J.converters.FormData(A, { strict: !1 })
                : A instanceof URLSearchParams
                ? J.converters.URLSearchParams(A)
                : J.converters.DOMString(A);
            }),
            (J.converters.BodyInit = function (A) {
              return A instanceof q
                ? J.converters.ReadableStream(A)
                : A?.[Symbol.asyncIterator]
                ? A
                : J.converters.XMLHttpRequestBodyInit(A);
            }),
            (J.converters.ResponseInit = J.dictionaryConverter([
              {
                key: "status",
                converter: J.converters["unsigned short"],
                defaultValue: 200,
              },
              {
                key: "statusText",
                converter: J.converters.ByteString,
                defaultValue: "",
              },
              { key: "headers", converter: J.converters.HeadersInit },
            ])),
            (t.exports = {
              makeNetworkError: makeNetworkError,
              makeResponse: makeResponse,
              makeAppropriateNetworkError: makeAppropriateNetworkError,
              filterResponse: filterResponse,
              Response: P,
              cloneResponse: cloneResponse,
            });
        },
      }),
      Y = __commonJS({
        "lib/compat/dispatcher-weakref.js"(A, e) {
          var { kConnected: t, kSize: E } = i(),
            Q = class {
              static {
                __name(this, "CompatWeakRef");
              }
              constructor(A) {
                this.value = A;
              }
              deref() {
                return 0 === this.value[t] && 0 === this.value[E]
                  ? void 0
                  : this.value;
              }
            },
            o = class {
              static {
                __name(this, "CompatFinalizer");
              }
              constructor(A) {
                this.finalizer = A;
              }
              register(A, e) {
                A.on &&
                  A.on("disconnect", () => {
                    0 === A[t] && 0 === A[E] && this.finalizer(e);
                  });
              }
            };
          e.exports = function () {
            return r.env.NODE_V8_COVERAGE
              ? { WeakRef: Q, FinalizationRegistry: o }
              : {
                  WeakRef: global.WeakRef || Q,
                  FinalizationRegistry: global.FinalizationRegistry || o,
                };
          };
        },
      }),
      J = __commonJS({
        "lib/fetch/request.js"(A, t) {
          var { extractBody: r, mixinBody: E, cloneBody: Q } = L(),
            { Headers: o, fill: s, HeadersList: B } = l(),
            { FinalizationRegistry: C } = Y()(),
            d = I(),
            {
              isValidHTTPToken: u,
              sameOrigin: D,
              normalizeMethod: R,
              makePolicyContainer: y,
              normalizeMethodRecord: f,
            } = h(),
            {
              forbiddenMethodsSet: w,
              corsSafeListedMethodsSet: F,
              referrerPolicy: k,
              requestRedirect: N,
              requestMode: p,
              requestCredentials: S,
              requestCache: U,
              requestDuplex: m,
            } = n(),
            { kEnumerableProperty: M } = d,
            { kHeaders: J, kSignal: G, kState: T, kGuard: H, kRealm: V } = g(),
            { webidl: v } = c(),
            { getGlobalOrigin: W } = a(),
            { URLSerializer: x } = b(),
            { kHeadersList: q, kConstruct: O } = i(),
            P = e("assert"),
            {
              getMaxListeners: _,
              setMaxListeners: Z,
              getEventListeners: X,
              defaultMaxListeners: K,
            } = e("events"),
            z = globalThis.TransformStream,
            j = Symbol("abortController"),
            $ = new C(({ signal: A, abort: e }) => {
              A.removeEventListener("abort", e);
            }),
            AA = class _Request {
              static {
                __name(this, "Request");
              }
              constructor(A, t = {}) {
                if (A === O) return;
                v.argumentLengthCheck(arguments, 1, {
                  header: "Request constructor",
                }),
                  (A = v.converters.RequestInfo(A)),
                  (t = v.converters.RequestInit(t)),
                  (this[V] = {
                    settingsObject: {
                      baseUrl: W(),
                      get origin() {
                        return this.baseUrl?.origin;
                      },
                      policyContainer: y(),
                    },
                  });
                let E = null,
                  Q = null;
                const i = this[V].settingsObject.baseUrl;
                let g = null;
                if ("string" == typeof A) {
                  let e;
                  try {
                    e = new URL(A, i);
                  } catch (e) {
                    throw new TypeError("Failed to parse URL from " + A, {
                      cause: e,
                    });
                  }
                  if (e.username || e.password)
                    throw new TypeError(
                      "Request cannot be constructed from a URL that includes credentials: " +
                        A
                    );
                  (E = makeRequest({ urlList: [e] })), (Q = "cors");
                } else P(A instanceof _Request), (E = A[T]), (g = A[G]);
                const C = this[V].settingsObject.origin;
                let I = "client";
                if (
                  ("EnvironmentSettingsObject" ===
                    E.window?.constructor?.name &&
                    D(E.window, C) &&
                    (I = E.window),
                  null != t.window)
                )
                  throw new TypeError(`'window' option '${I}' must be null`);
                "window" in t && (I = "no-window"),
                  (E = makeRequest({
                    method: E.method,
                    headersList: E.headersList,
                    unsafeRequest: E.unsafeRequest,
                    client: this[V].settingsObject,
                    window: I,
                    priority: E.priority,
                    origin: E.origin,
                    referrer: E.referrer,
                    referrerPolicy: E.referrerPolicy,
                    mode: E.mode,
                    credentials: E.credentials,
                    cache: E.cache,
                    redirect: E.redirect,
                    integrity: E.integrity,
                    keepalive: E.keepalive,
                    reloadNavigation: E.reloadNavigation,
                    historyNavigation: E.historyNavigation,
                    urlList: [...E.urlList],
                  }));
                const n = 0 !== Object.keys(t).length;
                if (
                  (n &&
                    ("navigate" === E.mode && (E.mode = "same-origin"),
                    (E.reloadNavigation = !1),
                    (E.historyNavigation = !1),
                    (E.origin = "client"),
                    (E.referrer = "client"),
                    (E.referrerPolicy = ""),
                    (E.url = E.urlList[E.urlList.length - 1]),
                    (E.urlList = [E.url])),
                  void 0 !== t.referrer)
                ) {
                  const A = t.referrer;
                  if ("" === A) E.referrer = "no-referrer";
                  else {
                    let e;
                    try {
                      e = new URL(A, i);
                    } catch (e) {
                      throw new TypeError(
                        `Referrer "${A}" is not a valid URL.`,
                        { cause: e }
                      );
                    }
                    ("about:" === e.protocol && "client" === e.hostname) ||
                    (C && !D(e, this[V].settingsObject.baseUrl))
                      ? (E.referrer = "client")
                      : (E.referrer = e);
                  }
                }
                let a;
                if (
                  (void 0 !== t.referrerPolicy &&
                    (E.referrerPolicy = t.referrerPolicy),
                  (a = void 0 !== t.mode ? t.mode : Q),
                  "navigate" === a)
                )
                  throw v.errors.exception({
                    header: "Request constructor",
                    message: "invalid request mode navigate.",
                  });
                if (
                  (null != a && (E.mode = a),
                  void 0 !== t.credentials && (E.credentials = t.credentials),
                  void 0 !== t.cache && (E.cache = t.cache),
                  "only-if-cached" === E.cache && "same-origin" !== E.mode)
                )
                  throw new TypeError(
                    "'only-if-cached' can be set only with 'same-origin' mode"
                  );
                if (
                  (void 0 !== t.redirect && (E.redirect = t.redirect),
                  null != t.integrity && (E.integrity = String(t.integrity)),
                  void 0 !== t.keepalive &&
                    (E.keepalive = Boolean(t.keepalive)),
                  void 0 !== t.method)
                ) {
                  let A = t.method;
                  if (!u(A))
                    throw new TypeError(`'${A}' is not a valid HTTP method.`);
                  if (w.has(A.toUpperCase()))
                    throw new TypeError(`'${A}' HTTP method is unsupported.`);
                  (A = f[A] ?? R(A)), (E.method = A);
                }
                void 0 !== t.signal && (g = t.signal), (this[T] = E);
                const h = new AbortController();
                if (((this[G] = h.signal), (this[G][V] = this[V]), null != g)) {
                  if (
                    !g ||
                    "boolean" != typeof g.aborted ||
                    "function" != typeof g.addEventListener
                  )
                    throw new TypeError(
                      "Failed to construct 'Request': member signal is not of type AbortSignal."
                    );
                  if (g.aborted) h.abort(g.reason);
                  else {
                    this[j] = h;
                    const A = new WeakRef(h),
                      e = __name(function () {
                        const e = A.deref();
                        void 0 !== e && e.abort(this.reason);
                      }, "abort");
                    try {
                      (("function" == typeof _ && _(g) === K) ||
                        X(g, "abort").length >= K) &&
                        Z(100, g);
                    } catch {}
                    d.addAbortListener(g, e),
                      $.register(h, { signal: g, abort: e });
                  }
                }
                if (
                  ((this[J] = new o(O)),
                  (this[J][q] = E.headersList),
                  (this[J][H] = "request"),
                  (this[J][V] = this[V]),
                  "no-cors" === a)
                ) {
                  if (!F.has(E.method))
                    throw new TypeError(
                      `'${E.method} is unsupported in no-cors mode.`
                    );
                  this[J][H] = "request-no-cors";
                }
                if (n) {
                  const A = this[J][q],
                    e = void 0 !== t.headers ? t.headers : new B(A);
                  if ((A.clear(), e instanceof B)) {
                    for (const [t, r] of e) A.append(t, r);
                    A.cookies = e.cookies;
                  } else s(this[J], e);
                }
                const c = A instanceof _Request ? A[T].body : null;
                if (
                  !(
                    (null == t.body && null == c) ||
                    ("GET" !== E.method && "HEAD" !== E.method)
                  )
                )
                  throw new TypeError(
                    "Request with GET/HEAD method cannot have body."
                  );
                let l = null;
                if (null != t.body) {
                  const [A, e] = r(t.body, E.keepalive);
                  (l = A),
                    e &&
                      !this[J][q].contains("content-type") &&
                      this[J].append("content-type", e);
                }
                const k = l ?? c;
                if (null != k && null == k.source) {
                  if (null != l && null == t.duplex)
                    throw new TypeError(
                      "RequestInit: duplex option is required when sending a body."
                    );
                  if ("same-origin" !== E.mode && "cors" !== E.mode)
                    throw new TypeError(
                      'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
                    );
                  E.useCORSPreflightFlag = !0;
                }
                let N = k;
                if (null == l && null != c) {
                  if (d.isDisturbed(c.stream) || c.stream.locked)
                    throw new TypeError(
                      "Cannot construct a Request with a Request object that has already been used."
                    );
                  z || (z = e("stream/web").TransformStream);
                  const A = new z();
                  c.stream.pipeThrough(A),
                    (N = {
                      source: c.source,
                      length: c.length,
                      stream: A.readable,
                    });
                }
                this[T].body = N;
              }
              get method() {
                return v.brandCheck(this, _Request), this[T].method;
              }
              get url() {
                return v.brandCheck(this, _Request), x(this[T].url);
              }
              get headers() {
                return v.brandCheck(this, _Request), this[J];
              }
              get destination() {
                return v.brandCheck(this, _Request), this[T].destination;
              }
              get referrer() {
                return (
                  v.brandCheck(this, _Request),
                  "no-referrer" === this[T].referrer
                    ? ""
                    : "client" === this[T].referrer
                    ? "about:client"
                    : this[T].referrer.toString()
                );
              }
              get referrerPolicy() {
                return v.brandCheck(this, _Request), this[T].referrerPolicy;
              }
              get mode() {
                return v.brandCheck(this, _Request), this[T].mode;
              }
              get credentials() {
                return this[T].credentials;
              }
              get cache() {
                return v.brandCheck(this, _Request), this[T].cache;
              }
              get redirect() {
                return v.brandCheck(this, _Request), this[T].redirect;
              }
              get integrity() {
                return v.brandCheck(this, _Request), this[T].integrity;
              }
              get keepalive() {
                return v.brandCheck(this, _Request), this[T].keepalive;
              }
              get isReloadNavigation() {
                return v.brandCheck(this, _Request), this[T].reloadNavigation;
              }
              get isHistoryNavigation() {
                return v.brandCheck(this, _Request), this[T].historyNavigation;
              }
              get signal() {
                return v.brandCheck(this, _Request), this[G];
              }
              get body() {
                return (
                  v.brandCheck(this, _Request),
                  this[T].body ? this[T].body.stream : null
                );
              }
              get bodyUsed() {
                return (
                  v.brandCheck(this, _Request),
                  !!this[T].body && d.isDisturbed(this[T].body.stream)
                );
              }
              get duplex() {
                return v.brandCheck(this, _Request), "half";
              }
              clone() {
                if (
                  (v.brandCheck(this, _Request),
                  this.bodyUsed || this.body?.locked)
                )
                  throw new TypeError("unusable");
                const A = cloneRequest(this[T]),
                  e = new _Request(O);
                (e[T] = A),
                  (e[V] = this[V]),
                  (e[J] = new o(O)),
                  (e[J][q] = A.headersList),
                  (e[J][H] = this[J][H]),
                  (e[J][V] = this[J][V]);
                const t = new AbortController();
                return (
                  this.signal.aborted
                    ? t.abort(this.signal.reason)
                    : d.addAbortListener(this.signal, () => {
                        t.abort(this.signal.reason);
                      }),
                  (e[G] = t.signal),
                  e
                );
              }
            };
          function makeRequest(A) {
            const e = {
              method: "GET",
              localURLsOnly: !1,
              unsafeRequest: !1,
              body: null,
              client: null,
              reservedClient: null,
              replacesClientId: "",
              window: "client",
              keepalive: !1,
              serviceWorkers: "all",
              initiator: "",
              destination: "",
              priority: null,
              origin: "client",
              policyContainer: "client",
              referrer: "client",
              referrerPolicy: "",
              mode: "no-cors",
              useCORSPreflightFlag: !1,
              credentials: "same-origin",
              useCredentials: !1,
              cache: "default",
              redirect: "follow",
              integrity: "",
              cryptoGraphicsNonceMetadata: "",
              parserMetadata: "",
              reloadNavigation: !1,
              historyNavigation: !1,
              userActivation: !1,
              taintedOrigin: !1,
              redirectCount: 0,
              responseTainting: "basic",
              preventNoCacheCacheControlHeaderModification: !1,
              done: !1,
              timingAllowFailed: !1,
              ...A,
              headersList: A.headersList ? new B(A.headersList) : new B(),
            };
            return (e.url = e.urlList[0]), e;
          }
          function cloneRequest(A) {
            const e = makeRequest({ ...A, body: null });
            return null != A.body && (e.body = Q(A.body)), e;
          }
          E(AA),
            __name(makeRequest, "makeRequest"),
            __name(cloneRequest, "cloneRequest"),
            Object.defineProperties(AA.prototype, {
              method: M,
              url: M,
              headers: M,
              redirect: M,
              clone: M,
              signal: M,
              duplex: M,
              destination: M,
              body: M,
              bodyUsed: M,
              isHistoryNavigation: M,
              isReloadNavigation: M,
              keepalive: M,
              integrity: M,
              cache: M,
              credentials: M,
              attribute: M,
              referrerPolicy: M,
              referrer: M,
              mode: M,
              [Symbol.toStringTag]: { value: "Request", configurable: !0 },
            }),
            (v.converters.Request = v.interfaceConverter(AA)),
            (v.converters.RequestInfo = function (A) {
              return "string" == typeof A
                ? v.converters.USVString(A)
                : A instanceof AA
                ? v.converters.Request(A)
                : v.converters.USVString(A);
            }),
            (v.converters.AbortSignal = v.interfaceConverter(AbortSignal)),
            (v.converters.RequestInit = v.dictionaryConverter([
              { key: "method", converter: v.converters.ByteString },
              { key: "headers", converter: v.converters.HeadersInit },
              {
                key: "body",
                converter: v.nullableConverter(v.converters.BodyInit),
              },
              { key: "referrer", converter: v.converters.USVString },
              {
                key: "referrerPolicy",
                converter: v.converters.DOMString,
                allowedValues: k,
              },
              {
                key: "mode",
                converter: v.converters.DOMString,
                allowedValues: p,
              },
              {
                key: "credentials",
                converter: v.converters.DOMString,
                allowedValues: S,
              },
              {
                key: "cache",
                converter: v.converters.DOMString,
                allowedValues: U,
              },
              {
                key: "redirect",
                converter: v.converters.DOMString,
                allowedValues: N,
              },
              { key: "integrity", converter: v.converters.DOMString },
              { key: "keepalive", converter: v.converters.boolean },
              {
                key: "signal",
                converter: v.nullableConverter((A) =>
                  v.converters.AbortSignal(A, { strict: !1 })
                ),
              },
              { key: "window", converter: v.converters.any },
              {
                key: "duplex",
                converter: v.converters.DOMString,
                allowedValues: m,
              },
            ])),
            (t.exports = { Request: AA, makeRequest: makeRequest });
        },
      }),
      G = __commonJS({
        "lib/dispatcher.js"(A, t) {
          var r = e("events"),
            E = class extends r {
              static {
                __name(this, "Dispatcher");
              }
              dispatch() {
                throw new Error("not implemented");
              }
              close() {
                throw new Error("not implemented");
              }
              destroy() {
                throw new Error("not implemented");
              }
            };
          t.exports = E;
        },
      }),
      T = __commonJS({
        "lib/dispatcher-base.js"(A, e) {
          var t = G(),
            {
              ClientDestroyedError: r,
              ClientClosedError: E,
              InvalidArgumentError: Q,
            } = B(),
            { kDestroy: o, kClose: s, kDispatch: g, kInterceptors: C } = i(),
            I = Symbol("destroyed"),
            n = Symbol("closed"),
            a = Symbol("onDestroyed"),
            h = Symbol("onClosed"),
            c = Symbol("Intercepted Dispatch"),
            l = class extends t {
              static {
                __name(this, "DispatcherBase");
              }
              constructor() {
                super(),
                  (this[I] = !1),
                  (this[a] = null),
                  (this[n] = !1),
                  (this[h] = []);
              }
              get destroyed() {
                return this[I];
              }
              get closed() {
                return this[n];
              }
              get interceptors() {
                return this[C];
              }
              set interceptors(A) {
                if (A)
                  for (let e = A.length - 1; e >= 0; e--) {
                    if ("function" != typeof this[C][e])
                      throw new Q("interceptor must be an function");
                  }
                this[C] = A;
              }
              close(A) {
                if (void 0 === A)
                  return new Promise((A, e) => {
                    this.close((t, r) => (t ? e(t) : A(r)));
                  });
                if ("function" != typeof A) throw new Q("invalid callback");
                if (this[I]) return void queueMicrotask(() => A(new r(), null));
                if (this[n])
                  return void (this[h]
                    ? this[h].push(A)
                    : queueMicrotask(() => A(null, null)));
                (this[n] = !0), this[h].push(A);
                const e = __name(() => {
                  const A = this[h];
                  this[h] = null;
                  for (let e = 0; e < A.length; e++) A[e](null, null);
                }, "onClosed");
                this[s]()
                  .then(() => this.destroy())
                  .then(() => {
                    queueMicrotask(e);
                  });
              }
              destroy(A, e) {
                if (
                  ("function" == typeof A && ((e = A), (A = null)),
                  void 0 === e)
                )
                  return new Promise((e, t) => {
                    this.destroy(A, (A, r) => (A ? t(A) : e(r)));
                  });
                if ("function" != typeof e) throw new Q("invalid callback");
                if (this[I])
                  return void (this[a]
                    ? this[a].push(e)
                    : queueMicrotask(() => e(null, null)));
                A || (A = new r()),
                  (this[I] = !0),
                  (this[a] = this[a] || []),
                  this[a].push(e);
                const t = __name(() => {
                  const A = this[a];
                  this[a] = null;
                  for (let e = 0; e < A.length; e++) A[e](null, null);
                }, "onDestroyed");
                this[o](A).then(() => {
                  queueMicrotask(t);
                });
              }
              [c](A, e) {
                if (!this[C] || 0 === this[C].length)
                  return (this[c] = this[g]), this[g](A, e);
                let t = this[g].bind(this);
                for (let A = this[C].length - 1; A >= 0; A--) t = this[C][A](t);
                return (this[c] = t), t(A, e);
              }
              dispatch(A, e) {
                if (!e || "object" != typeof e)
                  throw new Q("handler must be an object");
                try {
                  if (!A || "object" != typeof A)
                    throw new Q("opts must be an object.");
                  if (this[I] || this[a]) throw new r();
                  if (this[n]) throw new E();
                  return this[c](A, e);
                } catch (A) {
                  if ("function" != typeof e.onError)
                    throw new Q("invalid onError method");
                  return e.onError(A), !1;
                }
              }
            };
          e.exports = l;
        },
      }),
      H = __commonJS({
        "lib/node/fixed-queue.js"(A, e) {
          var t = 2047,
            r = class {
              static {
                __name(this, "FixedCircularBuffer");
              }
              constructor() {
                (this.bottom = 0),
                  (this.top = 0),
                  (this.list = new Array(2048)),
                  (this.next = null);
              }
              isEmpty() {
                return this.top === this.bottom;
              }
              isFull() {
                return ((this.top + 1) & t) === this.bottom;
              }
              push(A) {
                (this.list[this.top] = A), (this.top = (this.top + 1) & t);
              }
              shift() {
                const A = this.list[this.bottom];
                return void 0 === A
                  ? null
                  : ((this.list[this.bottom] = void 0),
                    (this.bottom = (this.bottom + 1) & t),
                    A);
              }
            };
          e.exports = class FixedQueue {
            static {
              __name(this, "FixedQueue");
            }
            constructor() {
              this.head = this.tail = new r();
            }
            isEmpty() {
              return this.head.isEmpty();
            }
            push(A) {
              this.head.isFull() && (this.head = this.head.next = new r()),
                this.head.push(A);
            }
            shift() {
              const A = this.tail,
                e = A.shift();
              return A.isEmpty() && null !== A.next && (this.tail = A.next), e;
            }
          };
        },
      }),
      V = __commonJS({
        "lib/pool-stats.js"(A, e) {
          var {
              kFree: t,
              kConnected: r,
              kPending: E,
              kQueued: Q,
              kRunning: o,
              kSize: s,
            } = i(),
            g = Symbol("pool"),
            B = class {
              static {
                __name(this, "PoolStats");
              }
              constructor(A) {
                this[g] = A;
              }
              get connected() {
                return this[g][r];
              }
              get free() {
                return this[g][t];
              }
              get pending() {
                return this[g][E];
              }
              get queued() {
                return this[g][Q];
              }
              get running() {
                return this[g][o];
              }
              get size() {
                return this[g][s];
              }
            };
          e.exports = B;
        },
      }),
      v = __commonJS({
        "lib/pool-base.js"(A, e) {
          var t = T(),
            E = H(),
            {
              kConnected: Q,
              kSize: o,
              kRunning: s,
              kPending: g,
              kQueued: B,
              kBusy: C,
              kFree: I,
              kUrl: n,
              kClose: a,
              kDestroy: h,
              kDispatch: c,
            } = i(),
            l = V(),
            d = Symbol("clients"),
            u = Symbol("needDrain"),
            D = Symbol("queue"),
            R = Symbol("closed resolve"),
            y = Symbol("onDrain"),
            f = Symbol("onConnect"),
            w = Symbol("onDisconnect"),
            F = Symbol("onConnectionError"),
            k = Symbol("get dispatcher"),
            N = Symbol("add client"),
            p = Symbol("remove client"),
            S = Symbol("stats"),
            b = class extends t {
              static {
                __name(this, "PoolBase");
              }
              constructor() {
                super(), (this[D] = new E()), (this[d] = []), (this[B] = 0);
                const A = this;
                (this[y] = __name(function onDrain(e, t) {
                  const r = A[D];
                  let E = !1;
                  for (; !E; ) {
                    const e = r.shift();
                    if (!e) break;
                    A[B]--, (E = !this.dispatch(e.opts, e.handler));
                  }
                  (this[u] = E),
                    !this[u] &&
                      A[u] &&
                      ((A[u] = !1), A.emit("drain", e, [A, ...t])),
                    A[R] &&
                      r.isEmpty() &&
                      Promise.all(A[d].map((A) => A.close())).then(A[R]);
                }, "onDrain")),
                  (this[f] = (e, t) => {
                    A.emit("connect", e, [A, ...t]);
                  }),
                  (this[w] = (e, t, r) => {
                    A.emit("disconnect", e, [A, ...t], r);
                  }),
                  (this[F] = (e, t, r) => {
                    A.emit("connectionError", e, [A, ...t], r);
                  }),
                  (this[S] = new l(this));
              }
              get [C]() {
                return this[u];
              }
              get [Q]() {
                return this[d].filter((A) => A[Q]).length;
              }
              get [I]() {
                return this[d].filter((A) => A[Q] && !A[u]).length;
              }
              get [g]() {
                let A = this[B];
                for (const { [g]: e } of this[d]) A += e;
                return A;
              }
              get [s]() {
                let A = 0;
                for (const { [s]: e } of this[d]) A += e;
                return A;
              }
              get [o]() {
                let A = this[B];
                for (const { [o]: e } of this[d]) A += e;
                return A;
              }
              get stats() {
                return this[S];
              }
              async [a]() {
                return this[D].isEmpty()
                  ? Promise.all(this[d].map((A) => A.close()))
                  : new Promise((A) => {
                      this[R] = A;
                    });
              }
              async [h](A) {
                for (;;) {
                  const e = this[D].shift();
                  if (!e) break;
                  e.handler.onError(A);
                }
                return Promise.all(this[d].map((e) => e.destroy(A)));
              }
              [c](A, e) {
                const t = this[k]();
                return (
                  t
                    ? t.dispatch(A, e) || ((t[u] = !0), (this[u] = !this[k]()))
                    : ((this[u] = !0),
                      this[D].push({ opts: A, handler: e }),
                      this[B]++),
                  !this[u]
                );
              }
              [N](A) {
                return (
                  A.on("drain", this[y])
                    .on("connect", this[f])
                    .on("disconnect", this[w])
                    .on("connectionError", this[F]),
                  this[d].push(A),
                  this[u] &&
                    r.nextTick(() => {
                      this[u] && this[y](A[n], [this, A]);
                    }),
                  this
                );
              }
              [p](A) {
                A.close(() => {
                  const e = this[d].indexOf(A);
                  -1 !== e && this[d].splice(e, 1);
                }),
                  (this[u] = this[d].some(
                    (A) => !A[u] && !0 !== A.closed && !0 !== A.destroyed
                  ));
              }
            };
          e.exports = {
            PoolBase: b,
            kClients: d,
            kNeedDrain: u,
            kAddClient: N,
            kRemoveClient: p,
            kGetDispatcher: k,
          };
        },
      }),
      W = __commonJS({
        "lib/timers.js"(A, e) {
          var t,
            r = Date.now(),
            E = [];
          function onTimeout() {
            r = Date.now();
            let A = E.length,
              e = 0;
            for (; e < A; ) {
              const t = E[e];
              0 === t.state
                ? (t.state = r + t.delay)
                : t.state > 0 &&
                  r >= t.state &&
                  ((t.state = -1), t.callback(t.opaque)),
                -1 === t.state
                  ? ((t.state = -2),
                    e !== A - 1 ? (E[e] = E.pop()) : E.pop(),
                    (A -= 1))
                  : (e += 1);
            }
            E.length > 0 && refreshTimeout();
          }
          function refreshTimeout() {
            t && t.refresh
              ? t.refresh()
              : (clearTimeout(t),
                (t = setTimeout(onTimeout, 1e3)).unref && t.unref());
          }
          __name(onTimeout, "onTimeout"),
            __name(refreshTimeout, "refreshTimeout");
          var Q = class {
            static {
              __name(this, "Timeout");
            }
            constructor(A, e, t) {
              (this.callback = A),
                (this.delay = e),
                (this.opaque = t),
                (this.state = -2),
                this.refresh();
            }
            refresh() {
              -2 === this.state &&
                (E.push(this), (t && 1 !== E.length) || refreshTimeout()),
                (this.state = 0);
            }
            clear() {
              this.state = -1;
            }
          };
          e.exports = {
            setTimeout: (A, e, t) =>
              e < 1e3 ? setTimeout(A, e, t) : new Q(A, e, t),
            clearTimeout(A) {
              A instanceof Q ? A.clear() : clearTimeout(A);
            },
          };
        },
      }),
      x = __commonJS({
        "lib/core/request.js"(A, t) {
          var r,
            { InvalidArgumentError: E, NotSupportedError: Q } = B(),
            o = e("assert"),
            {
              kHTTP2BuildRequest: s,
              kHTTP2CopyHeaders: g,
              kHTTP1BuildRequest: C,
            } = i(),
            n = I(),
            a = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/,
            h = /[^\t\x20-\x7e\x80-\xff]/,
            c = /[^\u0021-\u00ff]/,
            l = Symbol("handler"),
            d = {};
          try {
            const A = e("diagnostics_channel");
            (d.create = A.channel("undici:request:create")),
              (d.bodySent = A.channel("undici:request:bodySent")),
              (d.headers = A.channel("undici:request:headers")),
              (d.trailers = A.channel("undici:request:trailers")),
              (d.error = A.channel("undici:request:error"));
          } catch {
            (d.create = { hasSubscribers: !1 }),
              (d.bodySent = { hasSubscribers: !1 }),
              (d.headers = { hasSubscribers: !1 }),
              (d.trailers = { hasSubscribers: !1 }),
              (d.error = { hasSubscribers: !1 });
          }
          var u = class _Request {
            static {
              __name(this, "Request");
            }
            constructor(
              A,
              {
                path: e,
                method: t,
                body: Q,
                headers: o,
                query: s,
                idempotent: i,
                blocking: g,
                upgrade: B,
                headersTimeout: C,
                bodyTimeout: I,
                reset: h,
                throwOnError: u,
                expectContinue: D,
              },
              R
            ) {
              if ("string" != typeof e) throw new E("path must be a string");
              if (
                "/" !== e[0] &&
                !e.startsWith("http://") &&
                !e.startsWith("https://") &&
                "CONNECT" !== t
              )
                throw new E(
                  "path must be an absolute URL or start with a slash"
                );
              if (null !== c.exec(e)) throw new E("invalid request path");
              if ("string" != typeof t) throw new E("method must be a string");
              if (null === a.exec(t)) throw new E("invalid request method");
              if (B && "string" != typeof B)
                throw new E("upgrade must be a string");
              if (null != C && (!Number.isFinite(C) || C < 0))
                throw new E("invalid headersTimeout");
              if (null != I && (!Number.isFinite(I) || I < 0))
                throw new E("invalid bodyTimeout");
              if (null != h && "boolean" != typeof h)
                throw new E("invalid reset");
              if (null != D && "boolean" != typeof D)
                throw new E("invalid expectContinue");
              if (
                ((this.headersTimeout = C),
                (this.bodyTimeout = I),
                (this.throwOnError = !0 === u),
                (this.method = t),
                (this.abort = null),
                null == Q)
              )
                this.body = null;
              else if (n.isStream(Q)) {
                this.body = Q;
                const A = this.body._readableState;
                (A && A.autoDestroy) ||
                  ((this.endHandler = __name(function autoDestroy() {
                    n.destroy(this);
                  }, "autoDestroy")),
                  this.body.on("end", this.endHandler)),
                  (this.errorHandler = (A) => {
                    this.abort ? this.abort(A) : (this.error = A);
                  }),
                  this.body.on("error", this.errorHandler);
              } else if (n.isBuffer(Q)) this.body = Q.byteLength ? Q : null;
              else if (ArrayBuffer.isView(Q))
                this.body = Q.buffer.byteLength
                  ? Buffer.from(Q.buffer, Q.byteOffset, Q.byteLength)
                  : null;
              else if (Q instanceof ArrayBuffer)
                this.body = Q.byteLength ? Buffer.from(Q) : null;
              else if ("string" == typeof Q)
                this.body = Q.length ? Buffer.from(Q) : null;
              else {
                if (
                  !(n.isFormDataLike(Q) || n.isIterable(Q) || n.isBlobLike(Q))
                )
                  throw new E(
                    "body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable"
                  );
                this.body = Q;
              }
              if (
                ((this.completed = !1),
                (this.aborted = !1),
                (this.upgrade = B || null),
                (this.path = s ? n.buildURL(e, s) : e),
                (this.origin = A),
                (this.idempotent = null == i ? "HEAD" === t || "GET" === t : i),
                (this.blocking = null != g && g),
                (this.reset = null == h ? null : h),
                (this.host = null),
                (this.contentLength = null),
                (this.contentType = null),
                (this.headers = ""),
                (this.expectContinue = null != D && D),
                Array.isArray(o))
              ) {
                if (o.length % 2 != 0)
                  throw new E("headers array must be even");
                for (let A = 0; A < o.length; A += 2)
                  processHeader(this, o[A], o[A + 1]);
              } else if (o && "object" == typeof o) {
                const A = Object.keys(o);
                for (let e = 0; e < A.length; e++) {
                  const t = A[e];
                  processHeader(this, t, o[t]);
                }
              } else if (null != o)
                throw new E("headers must be an object or an array");
              if (n.isFormDataLike(this.body)) {
                if (n.nodeMajor < 16 || (16 === n.nodeMajor && n.nodeMinor < 8))
                  throw new E(
                    "Form-Data bodies are only supported in node v16.8 and newer."
                  );
                r || (r = L().extractBody);
                const [A, e] = r(Q);
                null == this.contentType &&
                  ((this.contentType = e),
                  (this.headers += `content-type: ${e}\r\n`)),
                  (this.body = A.stream),
                  (this.contentLength = A.length);
              } else
                n.isBlobLike(Q) &&
                  null == this.contentType &&
                  Q.type &&
                  ((this.contentType = Q.type),
                  (this.headers += `content-type: ${Q.type}\r\n`));
              n.validateHandler(R, t, B),
                (this.servername = n.getServerName(this.host)),
                (this[l] = R),
                d.create.hasSubscribers && d.create.publish({ request: this });
            }
            onBodySent(A) {
              if (this[l].onBodySent)
                try {
                  return this[l].onBodySent(A);
                } catch (A) {
                  this.abort(A);
                }
            }
            onRequestSent() {
              if (
                (d.bodySent.hasSubscribers &&
                  d.bodySent.publish({ request: this }),
                this[l].onRequestSent)
              )
                try {
                  return this[l].onRequestSent();
                } catch (A) {
                  this.abort(A);
                }
            }
            onConnect(A) {
              if ((o(!this.aborted), o(!this.completed), !this.error))
                return (this.abort = A), this[l].onConnect(A);
              A(this.error);
            }
            onHeaders(A, e, t, r) {
              o(!this.aborted),
                o(!this.completed),
                d.headers.hasSubscribers &&
                  d.headers.publish({
                    request: this,
                    response: { statusCode: A, headers: e, statusText: r },
                  });
              try {
                return this[l].onHeaders(A, e, t, r);
              } catch (A) {
                this.abort(A);
              }
            }
            onData(A) {
              o(!this.aborted), o(!this.completed);
              try {
                return this[l].onData(A);
              } catch (A) {
                return this.abort(A), !1;
              }
            }
            onUpgrade(A, e, t) {
              return (
                o(!this.aborted), o(!this.completed), this[l].onUpgrade(A, e, t)
              );
            }
            onComplete(A) {
              this.onFinally(),
                o(!this.aborted),
                (this.completed = !0),
                d.trailers.hasSubscribers &&
                  d.trailers.publish({ request: this, trailers: A });
              try {
                return this[l].onComplete(A);
              } catch (A) {
                this.onError(A);
              }
            }
            onError(A) {
              if (
                (this.onFinally(),
                d.error.hasSubscribers &&
                  d.error.publish({ request: this, error: A }),
                !this.aborted)
              )
                return (this.aborted = !0), this[l].onError(A);
            }
            onFinally() {
              this.errorHandler &&
                (this.body.off("error", this.errorHandler),
                (this.errorHandler = null)),
                this.endHandler &&
                  (this.body.off("end", this.endHandler),
                  (this.endHandler = null));
            }
            addHeader(A, e) {
              return processHeader(this, A, e), this;
            }
            static [C](A, e, t) {
              return new _Request(A, e, t);
            }
            static [s](A, e, t) {
              const r = e.headers;
              e = { ...e, headers: null };
              const Q = new _Request(A, e, t);
              if (((Q.headers = {}), Array.isArray(r))) {
                if (r.length % 2 != 0)
                  throw new E("headers array must be even");
                for (let A = 0; A < r.length; A += 2)
                  processHeader(Q, r[A], r[A + 1], !0);
              } else if (r && "object" == typeof r) {
                const A = Object.keys(r);
                for (let e = 0; e < A.length; e++) {
                  const t = A[e];
                  processHeader(Q, t, r[t], !0);
                }
              } else if (null != r)
                throw new E("headers must be an object or an array");
              return Q;
            }
            static [g](A) {
              const e = A.split("\r\n"),
                t = {};
              for (const A of e) {
                const [e, r] = A.split(": ");
                null != r &&
                  0 !== r.length &&
                  (t[e] ? (t[e] += `,${r}`) : (t[e] = r));
              }
              return t;
            }
          };
          function processHeaderValue(A, e, t) {
            if (e && "object" == typeof e) throw new E(`invalid ${A} header`);
            if (((e = null != e ? `${e}` : ""), null !== h.exec(e)))
              throw new E(`invalid ${A} header`);
            return t ? e : `${A}: ${e}\r\n`;
          }
          function processHeader(A, e, t, r = !1) {
            if (t && "object" == typeof t && !Array.isArray(t))
              throw new E(`invalid ${e} header`);
            if (void 0 !== t)
              if (
                null === A.host &&
                4 === e.length &&
                "host" === e.toLowerCase()
              ) {
                if (null !== h.exec(t)) throw new E(`invalid ${e} header`);
                A.host = t;
              } else if (
                null === A.contentLength &&
                14 === e.length &&
                "content-length" === e.toLowerCase()
              ) {
                if (
                  ((A.contentLength = parseInt(t, 10)),
                  !Number.isFinite(A.contentLength))
                )
                  throw new E("invalid content-length header");
              } else if (
                null === A.contentType &&
                12 === e.length &&
                "content-type" === e.toLowerCase()
              )
                (A.contentType = t),
                  r
                    ? (A.headers[e] = processHeaderValue(e, t, r))
                    : (A.headers += processHeaderValue(e, t));
              else {
                if (17 === e.length && "transfer-encoding" === e.toLowerCase())
                  throw new E("invalid transfer-encoding header");
                if (10 === e.length && "connection" === e.toLowerCase()) {
                  const e = "string" == typeof t ? t.toLowerCase() : null;
                  if ("close" !== e && "keep-alive" !== e)
                    throw new E("invalid connection header");
                  "close" === e && (A.reset = !0);
                } else {
                  if (10 === e.length && "keep-alive" === e.toLowerCase())
                    throw new E("invalid keep-alive header");
                  if (7 === e.length && "upgrade" === e.toLowerCase())
                    throw new E("invalid upgrade header");
                  if (6 === e.length && "expect" === e.toLowerCase())
                    throw new Q("expect header not supported");
                  if (null === a.exec(e)) throw new E("invalid header key");
                  if (Array.isArray(t))
                    for (let E = 0; E < t.length; E++)
                      r
                        ? A.headers[e]
                          ? (A.headers[e] += `,${processHeaderValue(
                              e,
                              t[E],
                              r
                            )}`)
                          : (A.headers[e] = processHeaderValue(e, t[E], r))
                        : (A.headers += processHeaderValue(e, t[E]));
                  else
                    r
                      ? (A.headers[e] = processHeaderValue(e, t, r))
                      : (A.headers += processHeaderValue(e, t));
                }
              }
          }
          __name(processHeaderValue, "processHeaderValue"),
            __name(processHeader, "processHeader"),
            (t.exports = u);
        },
      }),
      q = __commonJS({
        "lib/core/connect.js"(A, t) {
          var E,
            Q,
            o = e("net"),
            s = e("assert"),
            i = I(),
            { InvalidArgumentError: g, ConnectTimeoutError: C } = B();
          function buildConnector({
            allowH2: A,
            maxCachedSessions: t,
            socketPath: r,
            timeout: B,
            ...C
          }) {
            if (null != t && (!Number.isInteger(t) || t < 0))
              throw new g(
                "maxCachedSessions must be a positive integer or zero"
              );
            const I = { path: r, ...C },
              n = new Q(null == t ? 100 : t);
            return (
              (B = null == B ? 1e4 : B),
              (A = null != A && A),
              __name(function connect(
                {
                  hostname: t,
                  host: r,
                  protocol: Q,
                  port: g,
                  servername: C,
                  localAddress: a,
                  httpSocket: h,
                },
                c
              ) {
                let l;
                if ("https:" === Q) {
                  E || (E = e("tls"));
                  const Q =
                      (C = C || I.servername || i.getServerName(r) || null) ||
                      t,
                    o = n.get(Q) || null;
                  s(Q),
                    (l = E.connect({
                      highWaterMark: 16384,
                      ...I,
                      servername: C,
                      session: o,
                      localAddress: a,
                      ALPNProtocols: A ? ["http/1.1", "h2"] : ["http/1.1"],
                      socket: h,
                      port: g || 443,
                      host: t,
                    })),
                    l.on("session", function (A) {
                      n.set(Q, A);
                    });
                } else
                  s(!h, "httpSocket can only be sent on TLS update"),
                    (l = o.connect({
                      highWaterMark: 65536,
                      ...I,
                      localAddress: a,
                      port: g || 80,
                      host: t,
                    }));
                if (null == I.keepAlive || I.keepAlive) {
                  const A =
                    void 0 === I.keepAliveInitialDelay
                      ? 6e4
                      : I.keepAliveInitialDelay;
                  l.setKeepAlive(!0, A);
                }
                const d = setupTimeout(() => onConnectTimeout(l), B);
                return (
                  l
                    .setNoDelay(!0)
                    .once(
                      "https:" === Q ? "secureConnect" : "connect",
                      function () {
                        if ((d(), c)) {
                          const A = c;
                          (c = null), A(null, this);
                        }
                      }
                    )
                    .on("error", function (A) {
                      if ((d(), c)) {
                        const e = c;
                        (c = null), e(A);
                      }
                    }),
                  l
                );
              },
              "connect")
            );
          }
          function setupTimeout(A, e) {
            if (!e) return () => {};
            let t = null,
              E = null;
            const Q = setTimeout(() => {
              t = setImmediate(() => {
                "win32" === r.platform ? (E = setImmediate(() => A())) : A();
              });
            }, e);
            return () => {
              clearTimeout(Q), clearImmediate(t), clearImmediate(E);
            };
          }
          function onConnectTimeout(A) {
            i.destroy(A, new C());
          }
          (Q =
            global.FinalizationRegistry && !r.env.NODE_V8_COVERAGE
              ? class WeakSessionCache {
                  static {
                    __name(this, "WeakSessionCache");
                  }
                  constructor(A) {
                    (this._maxCachedSessions = A),
                      (this._sessionCache = new Map()),
                      (this._sessionRegistry = new global.FinalizationRegistry(
                        (A) => {
                          if (this._sessionCache.size < this._maxCachedSessions)
                            return;
                          const e = this._sessionCache.get(A);
                          void 0 !== e &&
                            void 0 === e.deref() &&
                            this._sessionCache.delete(A);
                        }
                      ));
                  }
                  get(A) {
                    const e = this._sessionCache.get(A);
                    return e ? e.deref() : null;
                  }
                  set(A, e) {
                    0 !== this._maxCachedSessions &&
                      (this._sessionCache.set(A, new WeakRef(e)),
                      this._sessionRegistry.register(e, A));
                  }
                }
              : class SimpleSessionCache {
                  static {
                    __name(this, "SimpleSessionCache");
                  }
                  constructor(A) {
                    (this._maxCachedSessions = A),
                      (this._sessionCache = new Map());
                  }
                  get(A) {
                    return this._sessionCache.get(A);
                  }
                  set(A, e) {
                    if (0 !== this._maxCachedSessions) {
                      if (this._sessionCache.size >= this._maxCachedSessions) {
                        const { value: A } = this._sessionCache.keys().next();
                        this._sessionCache.delete(A);
                      }
                      this._sessionCache.set(A, e);
                    }
                  }
                }),
            __name(buildConnector, "buildConnector"),
            __name(setupTimeout, "setupTimeout"),
            __name(onConnectTimeout, "onConnectTimeout"),
            (t.exports = buildConnector);
        },
      }),
      O = __commonJS({
        "lib/llhttp/utils.js"(A) {
          function enumToMap(A) {
            const e = {};
            return (
              Object.keys(A).forEach((t) => {
                const r = A[t];
                "number" == typeof r && (e[t] = r);
              }),
              e
            );
          }
          Object.defineProperty(A, "__esModule", { value: !0 }),
            (A.enumToMap = void 0),
            __name(enumToMap, "enumToMap"),
            (A.enumToMap = enumToMap);
        },
      }),
      P = __commonJS({
        "lib/llhttp/constants.js"(A) {
          Object.defineProperty(A, "__esModule", { value: !0 }),
            (A.SPECIAL_HEADERS =
              A.HEADER_STATE =
              A.MINOR =
              A.MAJOR =
              A.CONNECTION_TOKEN_CHARS =
              A.HEADER_CHARS =
              A.TOKEN =
              A.STRICT_TOKEN =
              A.HEX =
              A.URL_CHAR =
              A.STRICT_URL_CHAR =
              A.USERINFO_CHARS =
              A.MARK =
              A.ALPHANUM =
              A.NUM =
              A.HEX_MAP =
              A.NUM_MAP =
              A.ALPHA =
              A.FINISH =
              A.H_METHOD_MAP =
              A.METHOD_MAP =
              A.METHODS_RTSP =
              A.METHODS_ICE =
              A.METHODS_HTTP =
              A.METHODS =
              A.LENIENT_FLAGS =
              A.FLAGS =
              A.TYPE =
              A.ERROR =
                void 0);
          var e,
            t,
            r,
            E,
            Q,
            o,
            s,
            i,
            g,
            B = O();
          ((e = A.ERROR || (A.ERROR = {}))[(e.OK = 0)] = "OK"),
            (e[(e.INTERNAL = 1)] = "INTERNAL"),
            (e[(e.STRICT = 2)] = "STRICT"),
            (e[(e.LF_EXPECTED = 3)] = "LF_EXPECTED"),
            (e[(e.UNEXPECTED_CONTENT_LENGTH = 4)] =
              "UNEXPECTED_CONTENT_LENGTH"),
            (e[(e.CLOSED_CONNECTION = 5)] = "CLOSED_CONNECTION"),
            (e[(e.INVALID_METHOD = 6)] = "INVALID_METHOD"),
            (e[(e.INVALID_URL = 7)] = "INVALID_URL"),
            (e[(e.INVALID_CONSTANT = 8)] = "INVALID_CONSTANT"),
            (e[(e.INVALID_VERSION = 9)] = "INVALID_VERSION"),
            (e[(e.INVALID_HEADER_TOKEN = 10)] = "INVALID_HEADER_TOKEN"),
            (e[(e.INVALID_CONTENT_LENGTH = 11)] = "INVALID_CONTENT_LENGTH"),
            (e[(e.INVALID_CHUNK_SIZE = 12)] = "INVALID_CHUNK_SIZE"),
            (e[(e.INVALID_STATUS = 13)] = "INVALID_STATUS"),
            (e[(e.INVALID_EOF_STATE = 14)] = "INVALID_EOF_STATE"),
            (e[(e.INVALID_TRANSFER_ENCODING = 15)] =
              "INVALID_TRANSFER_ENCODING"),
            (e[(e.CB_MESSAGE_BEGIN = 16)] = "CB_MESSAGE_BEGIN"),
            (e[(e.CB_HEADERS_COMPLETE = 17)] = "CB_HEADERS_COMPLETE"),
            (e[(e.CB_MESSAGE_COMPLETE = 18)] = "CB_MESSAGE_COMPLETE"),
            (e[(e.CB_CHUNK_HEADER = 19)] = "CB_CHUNK_HEADER"),
            (e[(e.CB_CHUNK_COMPLETE = 20)] = "CB_CHUNK_COMPLETE"),
            (e[(e.PAUSED = 21)] = "PAUSED"),
            (e[(e.PAUSED_UPGRADE = 22)] = "PAUSED_UPGRADE"),
            (e[(e.PAUSED_H2_UPGRADE = 23)] = "PAUSED_H2_UPGRADE"),
            (e[(e.USER = 24)] = "USER"),
            ((t = A.TYPE || (A.TYPE = {}))[(t.BOTH = 0)] = "BOTH"),
            (t[(t.REQUEST = 1)] = "REQUEST"),
            (t[(t.RESPONSE = 2)] = "RESPONSE"),
            ((r = A.FLAGS || (A.FLAGS = {}))[(r.CONNECTION_KEEP_ALIVE = 1)] =
              "CONNECTION_KEEP_ALIVE"),
            (r[(r.CONNECTION_CLOSE = 2)] = "CONNECTION_CLOSE"),
            (r[(r.CONNECTION_UPGRADE = 4)] = "CONNECTION_UPGRADE"),
            (r[(r.CHUNKED = 8)] = "CHUNKED"),
            (r[(r.UPGRADE = 16)] = "UPGRADE"),
            (r[(r.CONTENT_LENGTH = 32)] = "CONTENT_LENGTH"),
            (r[(r.SKIPBODY = 64)] = "SKIPBODY"),
            (r[(r.TRAILING = 128)] = "TRAILING"),
            (r[(r.TRANSFER_ENCODING = 512)] = "TRANSFER_ENCODING"),
            ((E = A.LENIENT_FLAGS || (A.LENIENT_FLAGS = {}))[(E.HEADERS = 1)] =
              "HEADERS"),
            (E[(E.CHUNKED_LENGTH = 2)] = "CHUNKED_LENGTH"),
            (E[(E.KEEP_ALIVE = 4)] = "KEEP_ALIVE"),
            ((o = Q = A.METHODS || (A.METHODS = {}))[(o.DELETE = 0)] =
              "DELETE"),
            (o[(o.GET = 1)] = "GET"),
            (o[(o.HEAD = 2)] = "HEAD"),
            (o[(o.POST = 3)] = "POST"),
            (o[(o.PUT = 4)] = "PUT"),
            (o[(o.CONNECT = 5)] = "CONNECT"),
            (o[(o.OPTIONS = 6)] = "OPTIONS"),
            (o[(o.TRACE = 7)] = "TRACE"),
            (o[(o.COPY = 8)] = "COPY"),
            (o[(o.LOCK = 9)] = "LOCK"),
            (o[(o.MKCOL = 10)] = "MKCOL"),
            (o[(o.MOVE = 11)] = "MOVE"),
            (o[(o.PROPFIND = 12)] = "PROPFIND"),
            (o[(o.PROPPATCH = 13)] = "PROPPATCH"),
            (o[(o.SEARCH = 14)] = "SEARCH"),
            (o[(o.UNLOCK = 15)] = "UNLOCK"),
            (o[(o.BIND = 16)] = "BIND"),
            (o[(o.REBIND = 17)] = "REBIND"),
            (o[(o.UNBIND = 18)] = "UNBIND"),
            (o[(o.ACL = 19)] = "ACL"),
            (o[(o.REPORT = 20)] = "REPORT"),
            (o[(o.MKACTIVITY = 21)] = "MKACTIVITY"),
            (o[(o.CHECKOUT = 22)] = "CHECKOUT"),
            (o[(o.MERGE = 23)] = "MERGE"),
            (o[(o["M-SEARCH"] = 24)] = "M-SEARCH"),
            (o[(o.NOTIFY = 25)] = "NOTIFY"),
            (o[(o.SUBSCRIBE = 26)] = "SUBSCRIBE"),
            (o[(o.UNSUBSCRIBE = 27)] = "UNSUBSCRIBE"),
            (o[(o.PATCH = 28)] = "PATCH"),
            (o[(o.PURGE = 29)] = "PURGE"),
            (o[(o.MKCALENDAR = 30)] = "MKCALENDAR"),
            (o[(o.LINK = 31)] = "LINK"),
            (o[(o.UNLINK = 32)] = "UNLINK"),
            (o[(o.SOURCE = 33)] = "SOURCE"),
            (o[(o.PRI = 34)] = "PRI"),
            (o[(o.DESCRIBE = 35)] = "DESCRIBE"),
            (o[(o.ANNOUNCE = 36)] = "ANNOUNCE"),
            (o[(o.SETUP = 37)] = "SETUP"),
            (o[(o.PLAY = 38)] = "PLAY"),
            (o[(o.PAUSE = 39)] = "PAUSE"),
            (o[(o.TEARDOWN = 40)] = "TEARDOWN"),
            (o[(o.GET_PARAMETER = 41)] = "GET_PARAMETER"),
            (o[(o.SET_PARAMETER = 42)] = "SET_PARAMETER"),
            (o[(o.REDIRECT = 43)] = "REDIRECT"),
            (o[(o.RECORD = 44)] = "RECORD"),
            (o[(o.FLUSH = 45)] = "FLUSH"),
            (A.METHODS_HTTP = [
              Q.DELETE,
              Q.GET,
              Q.HEAD,
              Q.POST,
              Q.PUT,
              Q.CONNECT,
              Q.OPTIONS,
              Q.TRACE,
              Q.COPY,
              Q.LOCK,
              Q.MKCOL,
              Q.MOVE,
              Q.PROPFIND,
              Q.PROPPATCH,
              Q.SEARCH,
              Q.UNLOCK,
              Q.BIND,
              Q.REBIND,
              Q.UNBIND,
              Q.ACL,
              Q.REPORT,
              Q.MKACTIVITY,
              Q.CHECKOUT,
              Q.MERGE,
              Q["M-SEARCH"],
              Q.NOTIFY,
              Q.SUBSCRIBE,
              Q.UNSUBSCRIBE,
              Q.PATCH,
              Q.PURGE,
              Q.MKCALENDAR,
              Q.LINK,
              Q.UNLINK,
              Q.PRI,
              Q.SOURCE,
            ]),
            (A.METHODS_ICE = [Q.SOURCE]),
            (A.METHODS_RTSP = [
              Q.OPTIONS,
              Q.DESCRIBE,
              Q.ANNOUNCE,
              Q.SETUP,
              Q.PLAY,
              Q.PAUSE,
              Q.TEARDOWN,
              Q.GET_PARAMETER,
              Q.SET_PARAMETER,
              Q.REDIRECT,
              Q.RECORD,
              Q.FLUSH,
              Q.GET,
              Q.POST,
            ]),
            (A.METHOD_MAP = B.enumToMap(Q)),
            (A.H_METHOD_MAP = {}),
            Object.keys(A.METHOD_MAP).forEach((e) => {
              /^H/.test(e) && (A.H_METHOD_MAP[e] = A.METHOD_MAP[e]);
            }),
            ((s = A.FINISH || (A.FINISH = {}))[(s.SAFE = 0)] = "SAFE"),
            (s[(s.SAFE_WITH_CB = 1)] = "SAFE_WITH_CB"),
            (s[(s.UNSAFE = 2)] = "UNSAFE"),
            (A.ALPHA = []);
          for (let e = "A".charCodeAt(0); e <= "Z".charCodeAt(0); e++)
            A.ALPHA.push(String.fromCharCode(e)),
              A.ALPHA.push(String.fromCharCode(e + 32));
          (A.NUM_MAP = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
          }),
            (A.HEX_MAP = {
              0: 0,
              1: 1,
              2: 2,
              3: 3,
              4: 4,
              5: 5,
              6: 6,
              7: 7,
              8: 8,
              9: 9,
              A: 10,
              B: 11,
              C: 12,
              D: 13,
              E: 14,
              F: 15,
              a: 10,
              b: 11,
              c: 12,
              d: 13,
              e: 14,
              f: 15,
            }),
            (A.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]),
            (A.ALPHANUM = A.ALPHA.concat(A.NUM)),
            (A.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"]),
            (A.USERINFO_CHARS = A.ALPHANUM.concat(A.MARK).concat([
              "%",
              ";",
              ":",
              "&",
              "=",
              "+",
              "$",
              ",",
            ])),
            (A.STRICT_URL_CHAR = [
              "!",
              '"',
              "$",
              "%",
              "&",
              "'",
              "(",
              ")",
              "*",
              "+",
              ",",
              "-",
              ".",
              "/",
              ":",
              ";",
              "<",
              "=",
              ">",
              "@",
              "[",
              "\\",
              "]",
              "^",
              "_",
              "`",
              "{",
              "|",
              "}",
              "~",
            ].concat(A.ALPHANUM)),
            (A.URL_CHAR = A.STRICT_URL_CHAR.concat(["\t", "\f"]));
          for (let e = 128; e <= 255; e++) A.URL_CHAR.push(e);
          (A.HEX = A.NUM.concat([
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
          ])),
            (A.STRICT_TOKEN = [
              "!",
              "#",
              "$",
              "%",
              "&",
              "'",
              "*",
              "+",
              "-",
              ".",
              "^",
              "_",
              "`",
              "|",
              "~",
            ].concat(A.ALPHANUM)),
            (A.TOKEN = A.STRICT_TOKEN.concat([" "])),
            (A.HEADER_CHARS = ["\t"]);
          for (let e = 32; e <= 255; e++) 127 !== e && A.HEADER_CHARS.push(e);
          (A.CONNECTION_TOKEN_CHARS = A.HEADER_CHARS.filter((A) => 44 !== A)),
            (A.MAJOR = A.NUM_MAP),
            (A.MINOR = A.MAJOR),
            ((g = i = A.HEADER_STATE || (A.HEADER_STATE = {}))[
              (g.GENERAL = 0)
            ] = "GENERAL"),
            (g[(g.CONNECTION = 1)] = "CONNECTION"),
            (g[(g.CONTENT_LENGTH = 2)] = "CONTENT_LENGTH"),
            (g[(g.TRANSFER_ENCODING = 3)] = "TRANSFER_ENCODING"),
            (g[(g.UPGRADE = 4)] = "UPGRADE"),
            (g[(g.CONNECTION_KEEP_ALIVE = 5)] = "CONNECTION_KEEP_ALIVE"),
            (g[(g.CONNECTION_CLOSE = 6)] = "CONNECTION_CLOSE"),
            (g[(g.CONNECTION_UPGRADE = 7)] = "CONNECTION_UPGRADE"),
            (g[(g.TRANSFER_ENCODING_CHUNKED = 8)] =
              "TRANSFER_ENCODING_CHUNKED"),
            (A.SPECIAL_HEADERS = {
              connection: i.CONNECTION,
              "content-length": i.CONTENT_LENGTH,
              "proxy-connection": i.CONNECTION,
              "transfer-encoding": i.TRANSFER_ENCODING,
              upgrade: i.UPGRADE,
            });
        },
      }),
      _ = __commonJS({
        "lib/handler/RedirectHandler.js"(A, t) {
          var r = I(),
            { kBodyUsed: E } = i(),
            Q = e("assert"),
            { InvalidArgumentError: o } = B(),
            s = e("events"),
            g = [300, 301, 302, 303, 307, 308],
            C = Symbol("body"),
            n = class {
              static {
                __name(this, "BodyAsyncIterable");
              }
              constructor(A) {
                (this[C] = A), (this[E] = !1);
              }
              async *[Symbol.asyncIterator]() {
                Q(!this[E], "disturbed"), (this[E] = !0), yield* this[C];
              }
            },
            a = class {
              static {
                __name(this, "RedirectHandler");
              }
              constructor(A, e, t, i) {
                if (null != e && (!Number.isInteger(e) || e < 0))
                  throw new o("maxRedirections must be a positive number");
                r.validateHandler(i, t.method, t.upgrade),
                  (this.dispatch = A),
                  (this.location = null),
                  (this.abort = null),
                  (this.opts = { ...t, maxRedirections: 0 }),
                  (this.maxRedirections = e),
                  (this.handler = i),
                  (this.history = []),
                  r.isStream(this.opts.body)
                    ? (0 === r.bodyLength(this.opts.body) &&
                        this.opts.body.on("data", function () {
                          Q(!1);
                        }),
                      "boolean" != typeof this.opts.body.readableDidRead &&
                        ((this.opts.body[E] = !1),
                        s.prototype.on.call(
                          this.opts.body,
                          "data",
                          function () {
                            this[E] = !0;
                          }
                        )))
                    : ((this.opts.body &&
                        "function" == typeof this.opts.body.pipeTo) ||
                        (this.opts.body &&
                          "string" != typeof this.opts.body &&
                          !ArrayBuffer.isView(this.opts.body) &&
                          r.isIterable(this.opts.body))) &&
                      (this.opts.body = new n(this.opts.body));
              }
              onConnect(A) {
                (this.abort = A),
                  this.handler.onConnect(A, { history: this.history });
              }
              onUpgrade(A, e, t) {
                this.handler.onUpgrade(A, e, t);
              }
              onError(A) {
                this.handler.onError(A);
              }
              onHeaders(A, e, t, E) {
                if (
                  ((this.location =
                    this.history.length >= this.maxRedirections ||
                    r.isDisturbed(this.opts.body)
                      ? null
                      : parseLocation(A, e)),
                  this.opts.origin &&
                    this.history.push(
                      new URL(this.opts.path, this.opts.origin)
                    ),
                  !this.location)
                )
                  return this.handler.onHeaders(A, e, t, E);
                const {
                    origin: Q,
                    pathname: o,
                    search: s,
                  } = r.parseURL(
                    new URL(
                      this.location,
                      this.opts.origin &&
                        new URL(this.opts.path, this.opts.origin)
                    )
                  ),
                  i = s ? `${o}${s}` : o;
                (this.opts.headers = cleanRequestHeaders(
                  this.opts.headers,
                  303 === A,
                  this.opts.origin !== Q
                )),
                  (this.opts.path = i),
                  (this.opts.origin = Q),
                  (this.opts.maxRedirections = 0),
                  (this.opts.query = null),
                  303 === A &&
                    "HEAD" !== this.opts.method &&
                    ((this.opts.method = "GET"), (this.opts.body = null));
              }
              onData(A) {
                if (!this.location) return this.handler.onData(A);
              }
              onComplete(A) {
                this.location
                  ? ((this.location = null),
                    (this.abort = null),
                    this.dispatch(this.opts, this))
                  : this.handler.onComplete(A);
              }
              onBodySent(A) {
                this.handler.onBodySent && this.handler.onBodySent(A);
              }
            };
          function parseLocation(A, e) {
            if (-1 === g.indexOf(A)) return null;
            for (let A = 0; A < e.length; A += 2)
              if ("location" === e[A].toString().toLowerCase()) return e[A + 1];
          }
          function shouldRemoveHeader(A, e, t) {
            if (4 === A.length) return "host" === r.headerNameToString(A);
            if (e && r.headerNameToString(A).startsWith("content-")) return !0;
            if (t && (13 === A.length || 6 === A.length || 19 === A.length)) {
              const e = r.headerNameToString(A);
              return (
                "authorization" === e ||
                "cookie" === e ||
                "proxy-authorization" === e
              );
            }
            return !1;
          }
          function cleanRequestHeaders(A, e, t) {
            const r = [];
            if (Array.isArray(A))
              for (let E = 0; E < A.length; E += 2)
                shouldRemoveHeader(A[E], e, t) || r.push(A[E], A[E + 1]);
            else if (A && "object" == typeof A)
              for (const E of Object.keys(A))
                shouldRemoveHeader(E, e, t) || r.push(E, A[E]);
            else Q(null == A, "headers must be an object or an array");
            return r;
          }
          __name(parseLocation, "parseLocation"),
            __name(shouldRemoveHeader, "shouldRemoveHeader"),
            __name(cleanRequestHeaders, "cleanRequestHeaders"),
            (t.exports = a);
        },
      }),
      Z = __commonJS({
        "lib/interceptor/redirectInterceptor.js"(A, e) {
          var t = _();
          function createRedirectInterceptor({ maxRedirections: A }) {
            return (e) =>
              __name(function Intercept(r, E) {
                const { maxRedirections: Q = A } = r;
                if (!Q) return e(r, E);
                const o = new t(e, Q, r, E);
                return (r = { ...r, maxRedirections: 0 }), e(r, o);
              }, "Intercept");
          }
          __name(createRedirectInterceptor, "createRedirectInterceptor"),
            (e.exports = createRedirectInterceptor);
        },
      }),
      X = __commonJS({
        "lib/llhttp/llhttp-wasm.js"(A, e) {
          e.exports =
            "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
        },
      }),
      K = __commonJS({
        "lib/llhttp/llhttp_simd-wasm.js"(A, e) {
          e.exports =
            "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
        },
      }),
      z = __commonJS({
        "lib/client.js"(A, t) {
          var E,
            Q = e("assert"),
            o = e("net"),
            s = e("http"),
            { pipeline: g } = e("stream"),
            C = I(),
            n = W(),
            a = x(),
            h = T(),
            {
              RequestContentLengthMismatchError: c,
              ResponseContentLengthMismatchError: l,
              InvalidArgumentError: d,
              RequestAbortedError: u,
              HeadersTimeoutError: D,
              HeadersOverflowError: R,
              SocketError: y,
              InformationalError: f,
              BodyTimeoutError: w,
              HTTPParserError: F,
              ResponseExceededMaxSizeError: k,
              ClientDestroyedError: N,
            } = B(),
            p = q(),
            {
              kUrl: S,
              kReset: b,
              kServerName: U,
              kClient: m,
              kBusy: L,
              kParser: M,
              kConnect: Y,
              kBlocking: J,
              kResuming: G,
              kRunning: H,
              kPending: V,
              kSize: v,
              kWriting: O,
              kQueue: _,
              kConnected: z,
              kConnecting: j,
              kNeedDrain: $,
              kNoRef: AA,
              kKeepAliveDefaultTimeout: eA,
              kHostHeader: tA,
              kPendingIdx: rA,
              kRunningIdx: EA,
              kError: QA,
              kPipelining: oA,
              kSocket: sA,
              kKeepAliveTimeoutValue: iA,
              kMaxHeadersSize: gA,
              kKeepAliveMaxTimeout: BA,
              kKeepAliveTimeoutThreshold: CA,
              kHeadersTimeout: IA,
              kBodyTimeout: nA,
              kStrictContentLength: aA,
              kConnector: hA,
              kMaxRedirections: cA,
              kMaxRequests: lA,
              kCounter: dA,
              kClose: uA,
              kDestroy: DA,
              kDispatch: RA,
              kInterceptors: yA,
              kLocalAddress: fA,
              kMaxResponseSize: wA,
              kHTTPConnVersion: FA,
              kHost: kA,
              kHTTP2Session: NA,
              kHTTP2SessionState: pA,
              kHTTP2BuildRequest: SA,
              kHTTP2CopyHeaders: bA,
              kHTTP1BuildRequest: UA,
            } = i();
          try {
            E = e("http2");
          } catch {
            E = { constants: {} };
          }
          var {
              constants: {
                HTTP2_HEADER_AUTHORITY: mA,
                HTTP2_HEADER_METHOD: LA,
                HTTP2_HEADER_PATH: MA,
                HTTP2_HEADER_SCHEME: YA,
                HTTP2_HEADER_CONTENT_LENGTH: JA,
                HTTP2_HEADER_EXPECT: GA,
                HTTP2_HEADER_STATUS: TA,
              },
            } = E,
            HA = !1,
            VA = Buffer[Symbol.species],
            vA = Symbol("kClosedResolve"),
            WA = {};
          try {
            const A = e("diagnostics_channel");
            (WA.sendHeaders = A.channel("undici:client:sendHeaders")),
              (WA.beforeConnect = A.channel("undici:client:beforeConnect")),
              (WA.connectError = A.channel("undici:client:connectError")),
              (WA.connected = A.channel("undici:client:connected"));
          } catch {
            (WA.sendHeaders = { hasSubscribers: !1 }),
              (WA.beforeConnect = { hasSubscribers: !1 }),
              (WA.connectError = { hasSubscribers: !1 }),
              (WA.connected = { hasSubscribers: !1 });
          }
          var xA = class extends h {
            static {
              __name(this, "Client");
            }
            constructor(
              A,
              {
                interceptors: e,
                maxHeaderSize: t,
                headersTimeout: r,
                socketTimeout: E,
                requestTimeout: Q,
                connectTimeout: i,
                bodyTimeout: g,
                idleTimeout: B,
                keepAlive: I,
                keepAliveTimeout: n,
                maxKeepAliveTimeout: a,
                keepAliveMaxTimeout: h,
                keepAliveTimeoutThreshold: c,
                socketPath: l,
                pipelining: u,
                tls: D,
                strictContentLength: R,
                maxCachedSessions: y,
                maxRedirections: f,
                connect: w,
                maxRequestsPerClient: F,
                localAddress: k,
                maxResponseSize: N,
                autoSelectFamily: b,
                autoSelectFamilyAttemptTimeout: m,
                allowH2: L,
                maxConcurrentStreams: M,
              } = {}
            ) {
              if ((super(), void 0 !== I))
                throw new d("unsupported keepAlive, use pipelining=0 instead");
              if (void 0 !== E)
                throw new d(
                  "unsupported socketTimeout, use headersTimeout & bodyTimeout instead"
                );
              if (void 0 !== Q)
                throw new d(
                  "unsupported requestTimeout, use headersTimeout & bodyTimeout instead"
                );
              if (void 0 !== B)
                throw new d(
                  "unsupported idleTimeout, use keepAliveTimeout instead"
                );
              if (void 0 !== a)
                throw new d(
                  "unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead"
                );
              if (null != t && !Number.isFinite(t))
                throw new d("invalid maxHeaderSize");
              if (null != l && "string" != typeof l)
                throw new d("invalid socketPath");
              if (null != i && (!Number.isFinite(i) || i < 0))
                throw new d("invalid connectTimeout");
              if (null != n && (!Number.isFinite(n) || n <= 0))
                throw new d("invalid keepAliveTimeout");
              if (null != h && (!Number.isFinite(h) || h <= 0))
                throw new d("invalid keepAliveMaxTimeout");
              if (null != c && !Number.isFinite(c))
                throw new d("invalid keepAliveTimeoutThreshold");
              if (null != r && (!Number.isInteger(r) || r < 0))
                throw new d(
                  "headersTimeout must be a positive integer or zero"
                );
              if (null != g && (!Number.isInteger(g) || g < 0))
                throw new d("bodyTimeout must be a positive integer or zero");
              if (null != w && "function" != typeof w && "object" != typeof w)
                throw new d("connect must be a function or an object");
              if (null != f && (!Number.isInteger(f) || f < 0))
                throw new d("maxRedirections must be a positive number");
              if (null != F && (!Number.isInteger(F) || F < 0))
                throw new d("maxRequestsPerClient must be a positive number");
              if (null != k && ("string" != typeof k || 0 === o.isIP(k)))
                throw new d("localAddress must be valid string IP address");
              if (null != N && (!Number.isInteger(N) || N < -1))
                throw new d("maxResponseSize must be a positive number");
              if (null != m && (!Number.isInteger(m) || m < -1))
                throw new d(
                  "autoSelectFamilyAttemptTimeout must be a positive number"
                );
              if (null != L && "boolean" != typeof L)
                throw new d("allowH2 must be a valid boolean value");
              if (null != M && ("number" != typeof M || M < 1))
                throw new d(
                  "maxConcurrentStreams must be a possitive integer, greater than 0"
                );
              "function" != typeof w &&
                (w = p({
                  ...D,
                  maxCachedSessions: y,
                  allowH2: L,
                  socketPath: l,
                  timeout: i,
                  ...(C.nodeHasAutoSelectFamily && b
                    ? { autoSelectFamily: b, autoSelectFamilyAttemptTimeout: m }
                    : void 0),
                  ...w,
                })),
                (this[yA] =
                  e && e.Client && Array.isArray(e.Client)
                    ? e.Client
                    : [OA({ maxRedirections: f })]),
                (this[S] = C.parseOrigin(A)),
                (this[hA] = w),
                (this[sA] = null),
                (this[oA] = null != u ? u : 1),
                (this[gA] = t || s.maxHeaderSize),
                (this[eA] = null == n ? 4e3 : n),
                (this[BA] = null == h ? 6e5 : h),
                (this[CA] = null == c ? 1e3 : c),
                (this[iA] = this[eA]),
                (this[U] = null),
                (this[fA] = null != k ? k : null),
                (this[G] = 0),
                (this[$] = 0),
                (this[tA] = `host: ${this[S].hostname}${
                  this[S].port ? `:${this[S].port}` : ""
                }\r\n`),
                (this[nA] = null != g ? g : 3e5),
                (this[IA] = null != r ? r : 3e5),
                (this[aA] = null == R || R),
                (this[cA] = f),
                (this[lA] = F),
                (this[vA] = null),
                (this[wA] = N > -1 ? N : -1),
                (this[FA] = "h1"),
                (this[NA] = null),
                (this[pA] = L
                  ? {
                      openStreams: 0,
                      maxConcurrentStreams: null != M ? M : 100,
                    }
                  : null),
                (this[kA] = `${this[S].hostname}${
                  this[S].port ? `:${this[S].port}` : ""
                }`),
                (this[_] = []),
                (this[EA] = 0),
                (this[rA] = 0);
            }
            get pipelining() {
              return this[oA];
            }
            set pipelining(A) {
              (this[oA] = A), resume(this, !0);
            }
            get [V]() {
              return this[_].length - this[rA];
            }
            get [H]() {
              return this[rA] - this[EA];
            }
            get [v]() {
              return this[_].length - this[EA];
            }
            get [z]() {
              return !!this[sA] && !this[j] && !this[sA].destroyed;
            }
            get [L]() {
              const A = this[sA];
              return (
                (A && (A[b] || A[O] || A[J])) ||
                this[v] >= (this[oA] || 1) ||
                this[V] > 0
              );
            }
            [Y](A) {
              connect(this), this.once("connect", A);
            }
            [RA](A, e) {
              const t = A.origin || this[S].origin,
                E = "h2" === this[FA] ? a[SA](t, A, e) : a[UA](t, A, e);
              return (
                this[_].push(E),
                this[G] ||
                  (null == C.bodyLength(E.body) && C.isIterable(E.body)
                    ? ((this[G] = 1), r.nextTick(resume, this))
                    : resume(this, !0)),
                this[G] && 2 !== this[$] && this[L] && (this[$] = 2),
                this[$] < 2
              );
            }
            async [uA]() {
              return new Promise((A) => {
                this[v] ? (this[vA] = A) : A(null);
              });
            }
            async [DA](A) {
              return new Promise((e) => {
                const t = this[_].splice(this[rA]);
                for (let e = 0; e < t.length; e++) {
                  errorRequest(this, t[e], A);
                }
                const r = __name(() => {
                  this[vA] && (this[vA](), (this[vA] = null)), e();
                }, "callback");
                null != this[NA] &&
                  (C.destroy(this[NA], A),
                  (this[NA] = null),
                  (this[pA] = null)),
                  this[sA]
                    ? C.destroy(this[sA].on("close", r), A)
                    : queueMicrotask(r),
                  resume(this);
              });
            }
          };
          function onHttp2SessionError(A) {
            Q("ERR_TLS_CERT_ALTNAME_INVALID" !== A.code),
              (this[sA][QA] = A),
              onError(this[m], A);
          }
          function onHttp2FrameError(A, e, t) {
            const r = new f(
              `HTTP/2: "frameError" received - type ${A}, code ${e}`
            );
            0 === t && ((this[sA][QA] = r), onError(this[m], r));
          }
          function onHttp2SessionEnd() {
            C.destroy(this, new y("other side closed")),
              C.destroy(this[sA], new y("other side closed"));
          }
          function onHTTP2GoAway(A) {
            const e = this[m],
              t = new f(`HTTP/2: "GOAWAY" frame received with code ${A}`);
            if (((e[sA] = null), (e[NA] = null), e.destroyed)) {
              Q(0 === this[V]);
              const A = e[_].splice(e[EA]);
              for (let e = 0; e < A.length; e++) {
                errorRequest(this, A[e], t);
              }
            } else if (e[H] > 0) {
              const A = e[_][e[EA]];
              (e[_][e[EA]++] = null), errorRequest(e, A, t);
            }
            (e[rA] = e[EA]),
              Q(0 === e[H]),
              e.emit("disconnect", e[S], [e], t),
              resume(e);
          }
          __name(onHttp2SessionError, "onHttp2SessionError"),
            __name(onHttp2FrameError, "onHttp2FrameError"),
            __name(onHttp2SessionEnd, "onHttp2SessionEnd"),
            __name(onHTTP2GoAway, "onHTTP2GoAway");
          var qA = P(),
            OA = Z(),
            PA = Buffer.alloc(0);
          async function lazyllhttp() {
            const A = r.env.JEST_WORKER_ID ? X() : void 0;
            let e;
            try {
              e = await WebAssembly.compile(Buffer.from(K(), "base64"));
            } catch (t) {
              e = await WebAssembly.compile(Buffer.from(A || X(), "base64"));
            }
            return await WebAssembly.instantiate(e, {
              env: {
                wasm_on_url: (A, e, t) => 0,
                wasm_on_status: (A, e, t) => {
                  Q.strictEqual(XA.ptr, A);
                  const r = e - jA + KA.byteOffset;
                  return XA.onStatus(new VA(KA.buffer, r, t)) || 0;
                },
                wasm_on_message_begin: (A) => (
                  Q.strictEqual(XA.ptr, A), XA.onMessageBegin() || 0
                ),
                wasm_on_header_field: (A, e, t) => {
                  Q.strictEqual(XA.ptr, A);
                  const r = e - jA + KA.byteOffset;
                  return XA.onHeaderField(new VA(KA.buffer, r, t)) || 0;
                },
                wasm_on_header_value: (A, e, t) => {
                  Q.strictEqual(XA.ptr, A);
                  const r = e - jA + KA.byteOffset;
                  return XA.onHeaderValue(new VA(KA.buffer, r, t)) || 0;
                },
                wasm_on_headers_complete: (A, e, t, r) => (
                  Q.strictEqual(XA.ptr, A),
                  XA.onHeadersComplete(e, Boolean(t), Boolean(r)) || 0
                ),
                wasm_on_body: (A, e, t) => {
                  Q.strictEqual(XA.ptr, A);
                  const r = e - jA + KA.byteOffset;
                  return XA.onBody(new VA(KA.buffer, r, t)) || 0;
                },
                wasm_on_message_complete: (A) => (
                  Q.strictEqual(XA.ptr, A), XA.onMessageComplete() || 0
                ),
              },
            });
          }
          __name(lazyllhttp, "lazyllhttp");
          var _A = null,
            ZA = lazyllhttp();
          ZA.catch();
          var XA = null,
            KA = null,
            zA = 0,
            jA = null,
            $A = class {
              static {
                __name(this, "Parser");
              }
              constructor(A, e, { exports: t }) {
                Q(Number.isFinite(A[gA]) && A[gA] > 0),
                  (this.llhttp = t),
                  (this.ptr = this.llhttp.llhttp_alloc(qA.TYPE.RESPONSE)),
                  (this.client = A),
                  (this.socket = e),
                  (this.timeout = null),
                  (this.timeoutValue = null),
                  (this.timeoutType = null),
                  (this.statusCode = null),
                  (this.statusText = ""),
                  (this.upgrade = !1),
                  (this.headers = []),
                  (this.headersSize = 0),
                  (this.headersMaxSize = A[gA]),
                  (this.shouldKeepAlive = !1),
                  (this.paused = !1),
                  (this.resume = this.resume.bind(this)),
                  (this.bytesRead = 0),
                  (this.keepAlive = ""),
                  (this.contentLength = ""),
                  (this.connection = ""),
                  (this.maxResponseSize = A[wA]);
              }
              setTimeout(A, e) {
                (this.timeoutType = e),
                  A !== this.timeoutValue
                    ? (n.clearTimeout(this.timeout),
                      A
                        ? ((this.timeout = n.setTimeout(
                            onParserTimeout,
                            A,
                            this
                          )),
                          this.timeout.unref && this.timeout.unref())
                        : (this.timeout = null),
                      (this.timeoutValue = A))
                    : this.timeout &&
                      this.timeout.refresh &&
                      this.timeout.refresh();
              }
              resume() {
                !this.socket.destroyed &&
                  this.paused &&
                  (Q(null != this.ptr),
                  Q(null == XA),
                  this.llhttp.llhttp_resume(this.ptr),
                  Q(2 === this.timeoutType),
                  this.timeout &&
                    this.timeout.refresh &&
                    this.timeout.refresh(),
                  (this.paused = !1),
                  this.execute(this.socket.read() || PA),
                  this.readMore());
              }
              readMore() {
                for (; !this.paused && this.ptr; ) {
                  const A = this.socket.read();
                  if (null === A) break;
                  this.execute(A);
                }
              }
              execute(A) {
                Q(null != this.ptr), Q(null == XA), Q(!this.paused);
                const { socket: e, llhttp: t } = this;
                A.length > zA &&
                  (jA && t.free(jA),
                  (zA = 4096 * Math.ceil(A.length / 4096)),
                  (jA = t.malloc(zA))),
                  new Uint8Array(t.memory.buffer, jA, zA).set(A);
                try {
                  let r;
                  try {
                    (KA = A),
                      (XA = this),
                      (r = t.llhttp_execute(this.ptr, jA, A.length));
                  } catch (A) {
                    throw A;
                  } finally {
                    (XA = null), (KA = null);
                  }
                  const E = t.llhttp_get_error_pos(this.ptr) - jA;
                  if (r === qA.ERROR.PAUSED_UPGRADE) this.onUpgrade(A.slice(E));
                  else if (r === qA.ERROR.PAUSED)
                    (this.paused = !0), e.unshift(A.slice(E));
                  else if (r !== qA.ERROR.OK) {
                    const e = t.llhttp_get_error_reason(this.ptr);
                    let Q = "";
                    if (e) {
                      const A = new Uint8Array(t.memory.buffer, e).indexOf(0);
                      Q =
                        "Response does not match the HTTP/1.1 protocol (" +
                        Buffer.from(t.memory.buffer, e, A).toString() +
                        ")";
                    }
                    throw new F(Q, qA.ERROR[r], A.slice(E));
                  }
                } catch (A) {
                  C.destroy(e, A);
                }
              }
              destroy() {
                Q(null != this.ptr),
                  Q(null == XA),
                  this.llhttp.llhttp_free(this.ptr),
                  (this.ptr = null),
                  n.clearTimeout(this.timeout),
                  (this.timeout = null),
                  (this.timeoutValue = null),
                  (this.timeoutType = null),
                  (this.paused = !1);
              }
              onStatus(A) {
                this.statusText = A.toString();
              }
              onMessageBegin() {
                const { socket: A, client: e } = this;
                if (A.destroyed) return -1;
                return e[_][e[EA]] ? void 0 : -1;
              }
              onHeaderField(A) {
                const e = this.headers.length;
                0 == (1 & e)
                  ? this.headers.push(A)
                  : (this.headers[e - 1] = Buffer.concat([
                      this.headers[e - 1],
                      A,
                    ])),
                  this.trackHeader(A.length);
              }
              onHeaderValue(A) {
                let e = this.headers.length;
                1 == (1 & e)
                  ? (this.headers.push(A), (e += 1))
                  : (this.headers[e - 1] = Buffer.concat([
                      this.headers[e - 1],
                      A,
                    ]));
                const t = this.headers[e - 2];
                10 === t.length && "keep-alive" === t.toString().toLowerCase()
                  ? (this.keepAlive += A.toString())
                  : 10 === t.length &&
                    "connection" === t.toString().toLowerCase()
                  ? (this.connection += A.toString())
                  : 14 === t.length &&
                    "content-length" === t.toString().toLowerCase() &&
                    (this.contentLength += A.toString()),
                  this.trackHeader(A.length);
              }
              trackHeader(A) {
                (this.headersSize += A),
                  this.headersSize >= this.headersMaxSize &&
                    C.destroy(this.socket, new R());
              }
              onUpgrade(A) {
                const {
                  upgrade: e,
                  client: t,
                  socket: r,
                  headers: E,
                  statusCode: o,
                } = this;
                Q(e);
                const s = t[_][t[EA]];
                Q(s),
                  Q(!r.destroyed),
                  Q(r === t[sA]),
                  Q(!this.paused),
                  Q(s.upgrade || "CONNECT" === s.method),
                  (this.statusCode = null),
                  (this.statusText = ""),
                  (this.shouldKeepAlive = null),
                  Q(this.headers.length % 2 == 0),
                  (this.headers = []),
                  (this.headersSize = 0),
                  r.unshift(A),
                  r[M].destroy(),
                  (r[M] = null),
                  (r[m] = null),
                  (r[QA] = null),
                  r
                    .removeListener("error", onSocketError)
                    .removeListener("readable", onSocketReadable)
                    .removeListener("end", onSocketEnd)
                    .removeListener("close", onSocketClose),
                  (t[sA] = null),
                  (t[_][t[EA]++] = null),
                  t.emit("disconnect", t[S], [t], new f("upgrade"));
                try {
                  s.onUpgrade(o, E, r);
                } catch (A) {
                  C.destroy(r, A);
                }
                resume(t);
              }
              onHeadersComplete(A, e, t) {
                const {
                  client: r,
                  socket: E,
                  headers: o,
                  statusText: s,
                } = this;
                if (E.destroyed) return -1;
                const i = r[_][r[EA]];
                if (!i) return -1;
                if ((Q(!this.upgrade), Q(this.statusCode < 200), 100 === A))
                  return (
                    C.destroy(E, new y("bad response", C.getSocketInfo(E))), -1
                  );
                if (e && !i.upgrade)
                  return (
                    C.destroy(E, new y("bad upgrade", C.getSocketInfo(E))), -1
                  );
                if (
                  (Q.strictEqual(this.timeoutType, 1),
                  (this.statusCode = A),
                  (this.shouldKeepAlive =
                    t ||
                    ("HEAD" === i.method &&
                      !E[b] &&
                      "keep-alive" === this.connection.toLowerCase())),
                  this.statusCode >= 200)
                ) {
                  const A = null != i.bodyTimeout ? i.bodyTimeout : r[nA];
                  this.setTimeout(A, 2);
                } else
                  this.timeout &&
                    this.timeout.refresh &&
                    this.timeout.refresh();
                if ("CONNECT" === i.method)
                  return Q(1 === r[H]), (this.upgrade = !0), 2;
                if (e) return Q(1 === r[H]), (this.upgrade = !0), 2;
                if (
                  (Q(this.headers.length % 2 == 0),
                  (this.headers = []),
                  (this.headersSize = 0),
                  this.shouldKeepAlive && r[oA])
                ) {
                  const A = this.keepAlive
                    ? C.parseKeepAliveTimeout(this.keepAlive)
                    : null;
                  if (null != A) {
                    const e = Math.min(A - r[CA], r[BA]);
                    e <= 0 ? (E[b] = !0) : (r[iA] = e);
                  } else r[iA] = r[eA];
                } else E[b] = !0;
                const g = !1 === i.onHeaders(A, o, this.resume, s);
                return i.aborted
                  ? -1
                  : "HEAD" === i.method || A < 200
                  ? 1
                  : (E[J] && ((E[J] = !1), resume(r)), g ? qA.ERROR.PAUSED : 0);
              }
              onBody(A) {
                const {
                  client: e,
                  socket: t,
                  statusCode: r,
                  maxResponseSize: E,
                } = this;
                if (t.destroyed) return -1;
                const o = e[_][e[EA]];
                return (
                  Q(o),
                  Q.strictEqual(this.timeoutType, 2),
                  this.timeout &&
                    this.timeout.refresh &&
                    this.timeout.refresh(),
                  Q(r >= 200),
                  E > -1 && this.bytesRead + A.length > E
                    ? (C.destroy(t, new k()), -1)
                    : ((this.bytesRead += A.length),
                      !1 === o.onData(A) ? qA.ERROR.PAUSED : void 0)
                );
              }
              onMessageComplete() {
                const {
                  client: A,
                  socket: e,
                  statusCode: t,
                  upgrade: r,
                  headers: E,
                  contentLength: o,
                  bytesRead: s,
                  shouldKeepAlive: i,
                } = this;
                if (e.destroyed && (!t || i)) return -1;
                if (r) return;
                const g = A[_][A[EA]];
                return (
                  Q(g),
                  Q(t >= 100),
                  (this.statusCode = null),
                  (this.statusText = ""),
                  (this.bytesRead = 0),
                  (this.contentLength = ""),
                  (this.keepAlive = ""),
                  (this.connection = ""),
                  Q(this.headers.length % 2 == 0),
                  (this.headers = []),
                  (this.headersSize = 0),
                  t < 200
                    ? void 0
                    : "HEAD" !== g.method && o && s !== parseInt(o, 10)
                    ? (C.destroy(e, new l()), -1)
                    : (g.onComplete(E),
                      (A[_][A[EA]++] = null),
                      e[O]
                        ? (Q.strictEqual(A[H], 0),
                          C.destroy(e, new f("reset")),
                          qA.ERROR.PAUSED)
                        : i
                        ? e[b] && 0 === A[H]
                          ? (C.destroy(e, new f("reset")), qA.ERROR.PAUSED)
                          : void (1 === A[oA]
                              ? setImmediate(resume, A)
                              : resume(A))
                        : (C.destroy(e, new f("reset")), qA.ERROR.PAUSED))
                );
              }
            };
          function onParserTimeout(A) {
            const { socket: e, timeoutType: t, client: r } = A;
            1 === t
              ? (!e[O] || e.writableNeedDrain || r[H] > 1) &&
                (Q(!A.paused, "cannot be paused while waiting for headers"),
                C.destroy(e, new D()))
              : 2 === t
              ? A.paused || C.destroy(e, new w())
              : 3 === t &&
                (Q(0 === r[H] && r[iA]),
                C.destroy(e, new f("socket idle timeout")));
          }
          function onSocketReadable() {
            const { [M]: A } = this;
            A && A.readMore();
          }
          function onSocketError(A) {
            const { [m]: e, [M]: t } = this;
            Q("ERR_TLS_CERT_ALTNAME_INVALID" !== A.code),
              "h2" === e[FA] ||
              "ECONNRESET" !== A.code ||
              !t.statusCode ||
              t.shouldKeepAlive
                ? ((this[QA] = A), onError(this[m], A))
                : t.onMessageComplete();
          }
          function onError(A, e) {
            if (
              0 === A[H] &&
              "UND_ERR_INFO" !== e.code &&
              "UND_ERR_SOCKET" !== e.code
            ) {
              Q(A[rA] === A[EA]);
              const t = A[_].splice(A[EA]);
              for (let r = 0; r < t.length; r++) {
                errorRequest(A, t[r], e);
              }
              Q(0 === A[v]);
            }
          }
          function onSocketEnd() {
            const { [M]: A, [m]: e } = this;
            "h2" === e[FA] || !A.statusCode || A.shouldKeepAlive
              ? C.destroy(
                  this,
                  new y("other side closed", C.getSocketInfo(this))
                )
              : A.onMessageComplete();
          }
          function onSocketClose() {
            const { [m]: A, [M]: e } = this;
            "h1" === A[FA] &&
              e &&
              (this[QA] ||
                !e.statusCode ||
                e.shouldKeepAlive ||
                e.onMessageComplete(),
              this[M].destroy(),
              (this[M] = null));
            const t = this[QA] || new y("closed", C.getSocketInfo(this));
            if (((A[sA] = null), A.destroyed)) {
              Q(0 === A[V]);
              const e = A[_].splice(A[EA]);
              for (let r = 0; r < e.length; r++) {
                errorRequest(A, e[r], t);
              }
            } else if (A[H] > 0 && "UND_ERR_INFO" !== t.code) {
              const e = A[_][A[EA]];
              (A[_][A[EA]++] = null), errorRequest(A, e, t);
            }
            (A[rA] = A[EA]),
              Q(0 === A[H]),
              A.emit("disconnect", A[S], [A], t),
              resume(A);
          }
          async function connect(A) {
            Q(!A[j]), Q(!A[sA]);
            let { host: e, hostname: t, protocol: s, port: i } = A[S];
            if ("[" === t[0]) {
              const A = t.indexOf("]");
              Q(-1 !== A);
              const e = t.substring(1, A);
              Q(o.isIP(e)), (t = e);
            }
            (A[j] = !0),
              WA.beforeConnect.hasSubscribers &&
                WA.beforeConnect.publish({
                  connectParams: {
                    host: e,
                    hostname: t,
                    protocol: s,
                    port: i,
                    servername: A[U],
                    localAddress: A[fA],
                  },
                  connector: A[hA],
                });
            try {
              const o = await new Promise((r, E) => {
                A[hA](
                  {
                    host: e,
                    hostname: t,
                    protocol: s,
                    port: i,
                    servername: A[U],
                    localAddress: A[fA],
                  },
                  (A, e) => {
                    A ? E(A) : r(e);
                  }
                );
              });
              if (A.destroyed)
                return void C.destroy(
                  o.on("error", () => {}),
                  new N()
                );
              (A[j] = !1), Q(o);
              if ("h2" === o.alpnProtocol) {
                HA ||
                  ((HA = !0),
                  r.emitWarning(
                    "H2 support is experimental, expect them to change at any time.",
                    { code: "UNDICI-H2" }
                  ));
                const e = E.connect(A[S], {
                  createConnection: () => o,
                  peerMaxConcurrentStreams: A[pA].maxConcurrentStreams,
                });
                (A[FA] = "h2"),
                  (e[m] = A),
                  (e[sA] = o),
                  e.on("error", onHttp2SessionError),
                  e.on("frameError", onHttp2FrameError),
                  e.on("end", onHttp2SessionEnd),
                  e.on("goaway", onHTTP2GoAway),
                  e.on("close", onSocketClose),
                  e.unref(),
                  (A[NA] = e),
                  (o[NA] = e);
              } else
                _A || ((_A = await ZA), (ZA = null)),
                  (o[AA] = !1),
                  (o[O] = !1),
                  (o[b] = !1),
                  (o[J] = !1),
                  (o[M] = new $A(A, o, _A));
              (o[dA] = 0),
                (o[lA] = A[lA]),
                (o[m] = A),
                (o[QA] = null),
                o
                  .on("error", onSocketError)
                  .on("readable", onSocketReadable)
                  .on("end", onSocketEnd)
                  .on("close", onSocketClose),
                (A[sA] = o),
                WA.connected.hasSubscribers &&
                  WA.connected.publish({
                    connectParams: {
                      host: e,
                      hostname: t,
                      protocol: s,
                      port: i,
                      servername: A[U],
                      localAddress: A[fA],
                    },
                    connector: A[hA],
                    socket: o,
                  }),
                A.emit("connect", A[S], [A]);
            } catch (r) {
              if (A.destroyed) return;
              if (
                ((A[j] = !1),
                WA.connectError.hasSubscribers &&
                  WA.connectError.publish({
                    connectParams: {
                      host: e,
                      hostname: t,
                      protocol: s,
                      port: i,
                      servername: A[U],
                      localAddress: A[fA],
                    },
                    connector: A[hA],
                    error: r,
                  }),
                "ERR_TLS_CERT_ALTNAME_INVALID" === r.code)
              )
                for (
                  Q(0 === A[H]);
                  A[V] > 0 && A[_][A[rA]].servername === A[U];

                ) {
                  const e = A[_][A[rA]++];
                  errorRequest(A, e, r);
                }
              else onError(A, r);
              A.emit("connectionError", A[S], [A], r);
            }
            resume(A);
          }
          function emitDrain(A) {
            (A[$] = 0), A.emit("drain", A[S], [A]);
          }
          function resume(A, e) {
            2 !== A[G] &&
              ((A[G] = 2),
              _resume(A, e),
              (A[G] = 0),
              A[EA] > 256 &&
                (A[_].splice(0, A[EA]), (A[rA] -= A[EA]), (A[EA] = 0)));
          }
          function _resume(A, e) {
            for (;;) {
              if (A.destroyed) return void Q(0 === A[V]);
              if (A[vA] && !A[v]) return A[vA](), void (A[vA] = null);
              const t = A[sA];
              if (t && !t.destroyed && "h2" !== t.alpnProtocol)
                if (
                  (0 === A[v]
                    ? !t[AA] && t.unref && (t.unref(), (t[AA] = !0))
                    : t[AA] && t.ref && (t.ref(), (t[AA] = !1)),
                  0 === A[v])
                )
                  3 !== t[M].timeoutType && t[M].setTimeout(A[iA], 3);
                else if (
                  A[H] > 0 &&
                  t[M].statusCode < 200 &&
                  1 !== t[M].timeoutType
                ) {
                  const e = A[_][A[EA]],
                    r = null != e.headersTimeout ? e.headersTimeout : A[IA];
                  t[M].setTimeout(r, 1);
                }
              if (A[L]) A[$] = 2;
              else if (2 === A[$]) {
                e ? ((A[$] = 1), r.nextTick(emitDrain, A)) : emitDrain(A);
                continue;
              }
              if (0 === A[V]) return;
              if (A[H] >= (A[oA] || 1)) return;
              const E = A[_][A[rA]];
              if ("https:" === A[S].protocol && A[U] !== E.servername) {
                if (A[H] > 0) return;
                if (((A[U] = E.servername), t && t.servername !== E.servername))
                  return void C.destroy(t, new f("servername changed"));
              }
              if (A[j]) return;
              if (!t && !A[NA]) return void connect(A);
              if (t.destroyed || t[O] || t[b] || t[J]) return;
              if (A[H] > 0 && !E.idempotent) return;
              if (A[H] > 0 && (E.upgrade || "CONNECT" === E.method)) return;
              if (
                A[H] > 0 &&
                0 !== C.bodyLength(E.body) &&
                (C.isStream(E.body) || C.isAsyncIterable(E.body))
              )
                return;
              !E.aborted && write(A, E) ? A[rA]++ : A[_].splice(A[rA], 1);
            }
          }
          function shouldSendContentLength(A) {
            return (
              "GET" !== A &&
              "HEAD" !== A &&
              "OPTIONS" !== A &&
              "TRACE" !== A &&
              "CONNECT" !== A
            );
          }
          function write(A, e) {
            if ("h2" === A[FA]) return void writeH2(A, A[NA], e);
            const {
                body: t,
                method: E,
                path: o,
                host: s,
                upgrade: i,
                headers: g,
                blocking: B,
                reset: I,
              } = e,
              n = "PUT" === E || "POST" === E || "PATCH" === E;
            t && "function" == typeof t.read && t.read(0);
            const a = C.bodyLength(t);
            let h = a;
            if (
              (null === h && (h = e.contentLength),
              0 !== h || n || (h = null),
              shouldSendContentLength(E) &&
                h > 0 &&
                null !== e.contentLength &&
                e.contentLength !== h)
            ) {
              if (A[aA]) return errorRequest(A, e, new c()), !1;
              r.emitWarning(new c());
            }
            const l = A[sA];
            try {
              e.onConnect((t) => {
                e.aborted ||
                  e.completed ||
                  (errorRequest(A, e, t || new u()),
                  C.destroy(l, new f("aborted")));
              });
            } catch (t) {
              errorRequest(A, e, t);
            }
            if (e.aborted) return !1;
            "HEAD" === E && (l[b] = !0),
              (i || "CONNECT" === E) && (l[b] = !0),
              null != I && (l[b] = I),
              A[lA] && l[dA]++ >= A[lA] && (l[b] = !0),
              B && (l[J] = !0);
            let d = `${E} ${o} HTTP/1.1\r\n`;
            return (
              (d += "string" == typeof s ? `host: ${s}\r\n` : A[tA]),
              i
                ? (d += `connection: upgrade\r\nupgrade: ${i}\r\n`)
                : A[oA] && !l[b]
                ? (d += "connection: keep-alive\r\n")
                : (d += "connection: close\r\n"),
              g && (d += g),
              WA.sendHeaders.hasSubscribers &&
                WA.sendHeaders.publish({ request: e, headers: d, socket: l }),
              t && 0 !== a
                ? C.isBuffer(t)
                  ? (Q(
                      h === t.byteLength,
                      "buffer body must have content length"
                    ),
                    l.cork(),
                    l.write(`${d}content-length: ${h}\r\n\r\n`, "latin1"),
                    l.write(t),
                    l.uncork(),
                    e.onBodySent(t),
                    e.onRequestSent(),
                    n || (l[b] = !0))
                  : C.isBlobLike(t)
                  ? "function" == typeof t.stream
                    ? writeIterable({
                        body: t.stream(),
                        client: A,
                        request: e,
                        socket: l,
                        contentLength: h,
                        header: d,
                        expectsPayload: n,
                      })
                    : writeBlob({
                        body: t,
                        client: A,
                        request: e,
                        socket: l,
                        contentLength: h,
                        header: d,
                        expectsPayload: n,
                      })
                  : C.isStream(t)
                  ? writeStream({
                      body: t,
                      client: A,
                      request: e,
                      socket: l,
                      contentLength: h,
                      header: d,
                      expectsPayload: n,
                    })
                  : C.isIterable(t)
                  ? writeIterable({
                      body: t,
                      client: A,
                      request: e,
                      socket: l,
                      contentLength: h,
                      header: d,
                      expectsPayload: n,
                    })
                  : Q(!1)
                : (0 === h
                    ? l.write(`${d}content-length: 0\r\n\r\n`, "latin1")
                    : (Q(null === h, "no body must not have content length"),
                      l.write(`${d}\r\n`, "latin1")),
                  e.onRequestSent()),
              !0
            );
          }
          function writeH2(A, e, t) {
            const {
              body: E,
              method: o,
              path: s,
              host: i,
              upgrade: g,
              expectContinue: B,
              signal: I,
              headers: n,
            } = t;
            let h, l;
            if (((h = "string" == typeof n ? a[bA](n.trim()) : n), g))
              return (
                errorRequest(A, t, new Error("Upgrade not supported for H2")),
                !1
              );
            try {
              t.onConnect((e) => {
                t.aborted || t.completed || errorRequest(A, t, e || new u());
              });
            } catch (e) {
              errorRequest(A, t, e);
            }
            if (t.aborted) return !1;
            const d = A[pA];
            if (((h[mA] = i || A[kA]), (h[LA] = o), "CONNECT" === o))
              return (
                e.ref(),
                (l = e.request(h, { endStream: !1, signal: I })),
                l.id && !l.pending
                  ? (t.onUpgrade(null, null, l), ++d.openStreams)
                  : l.once("ready", () => {
                      t.onUpgrade(null, null, l), ++d.openStreams;
                    }),
                l.once("close", () => {
                  (d.openStreams -= 1), 0 === d.openStreams && e.unref();
                }),
                !0
              );
            (h[MA] = s), (h[YA] = "https");
            const D = "PUT" === o || "POST" === o || "PATCH" === o;
            E && "function" == typeof E.read && E.read(0);
            let R = C.bodyLength(E);
            if (
              (null == R && (R = t.contentLength),
              (0 !== R && D) || (R = null),
              shouldSendContentLength(o) &&
                R > 0 &&
                null != t.contentLength &&
                t.contentLength !== R)
            ) {
              if (A[aA]) return errorRequest(A, t, new c()), !1;
              r.emitWarning(new c());
            }
            null != R &&
              (Q(E, "no body must not have content length"), (h[JA] = `${R}`)),
              e.ref();
            const y = "GET" === o || "HEAD" === o;
            return (
              B
                ? ((h[GA] = "100-continue"),
                  (l = e.request(h, { endStream: y, signal: I })),
                  l.once("continue", writeBodyH2))
                : ((l = e.request(h, { endStream: y, signal: I })),
                  writeBodyH2()),
              ++d.openStreams,
              l.once("response", (A) => {
                const { [TA]: e, ...r } = A;
                !1 === t.onHeaders(Number(e), r, l.resume.bind(l), "") &&
                  l.pause();
              }),
              l.once("end", () => {
                t.onComplete([]);
              }),
              l.on("data", (A) => {
                !1 === t.onData(A) && l.pause();
              }),
              l.once("close", () => {
                (d.openStreams -= 1), 0 === d.openStreams && e.unref();
              }),
              l.once("error", function (e) {
                !A[NA] ||
                  A[NA].destroyed ||
                  this.closed ||
                  this.destroyed ||
                  ((d.streams -= 1), C.destroy(l, e));
              }),
              l.once("frameError", (e, r) => {
                const E = new f(
                  `HTTP/2: "frameError" received - type ${e}, code ${r}`
                );
                errorRequest(A, t, E),
                  !A[NA] ||
                    A[NA].destroyed ||
                    this.closed ||
                    this.destroyed ||
                    ((d.streams -= 1), C.destroy(l, E));
              }),
              !0
            );
            function writeBodyH2() {
              E
                ? C.isBuffer(E)
                  ? (Q(
                      R === E.byteLength,
                      "buffer body must have content length"
                    ),
                    l.cork(),
                    l.write(E),
                    l.uncork(),
                    l.end(),
                    t.onBodySent(E),
                    t.onRequestSent())
                  : C.isBlobLike(E)
                  ? "function" == typeof E.stream
                    ? writeIterable({
                        client: A,
                        request: t,
                        contentLength: R,
                        h2stream: l,
                        expectsPayload: D,
                        body: E.stream(),
                        socket: A[sA],
                        header: "",
                      })
                    : writeBlob({
                        body: E,
                        client: A,
                        request: t,
                        contentLength: R,
                        expectsPayload: D,
                        h2stream: l,
                        header: "",
                        socket: A[sA],
                      })
                  : C.isStream(E)
                  ? writeStream({
                      body: E,
                      client: A,
                      request: t,
                      contentLength: R,
                      expectsPayload: D,
                      socket: A[sA],
                      h2stream: l,
                      header: "",
                    })
                  : C.isIterable(E)
                  ? writeIterable({
                      body: E,
                      client: A,
                      request: t,
                      contentLength: R,
                      expectsPayload: D,
                      header: "",
                      h2stream: l,
                      socket: A[sA],
                    })
                  : Q(!1)
                : t.onRequestSent();
            }
          }
          function writeStream({
            h2stream: A,
            body: e,
            client: t,
            request: r,
            socket: E,
            contentLength: o,
            header: s,
            expectsPayload: i,
          }) {
            if (
              (Q(0 !== o || 0 === t[H], "stream body cannot be pipelined"),
              "h2" === t[FA])
            ) {
              let onPipeData = function (A) {
                r.onBodySent(A);
              };
              __name(onPipeData, "onPipeData");
              const t = g(e, A, (t) => {
                t ? (C.destroy(e, t), C.destroy(A, t)) : r.onRequestSent();
              });
              return (
                t.on("data", onPipeData),
                void t.once("end", () => {
                  t.removeListener("data", onPipeData), C.destroy(t);
                })
              );
            }
            let B = !1;
            const I = new Ae({
                socket: E,
                request: r,
                contentLength: o,
                client: t,
                expectsPayload: i,
                header: s,
              }),
              n = __name(function (A) {
                if (!B)
                  try {
                    !I.write(A) && this.pause && this.pause();
                  } catch (A) {
                    C.destroy(this, A);
                  }
              }, "onData"),
              a = __name(function () {
                B || (e.resume && e.resume());
              }, "onDrain"),
              h = __name(function () {
                if (B) return;
                const A = new u();
                queueMicrotask(() => c(A));
              }, "onAbort"),
              c = __name(function (A) {
                if (!B) {
                  if (
                    ((B = !0),
                    Q(E.destroyed || (E[O] && t[H] <= 1)),
                    E.off("drain", a).off("error", c),
                    e
                      .removeListener("data", n)
                      .removeListener("end", c)
                      .removeListener("error", c)
                      .removeListener("close", h),
                    !A)
                  )
                    try {
                      I.end();
                    } catch (e) {
                      A = e;
                    }
                  I.destroy(A),
                    !A || ("UND_ERR_INFO" === A.code && "reset" === A.message)
                      ? C.destroy(e)
                      : C.destroy(e, A);
                }
              }, "onFinished");
            e.on("data", n).on("end", c).on("error", c).on("close", h),
              e.resume && e.resume(),
              E.on("drain", a).on("error", c);
          }
          async function writeBlob({
            h2stream: A,
            body: e,
            client: t,
            request: r,
            socket: E,
            contentLength: o,
            header: s,
            expectsPayload: i,
          }) {
            Q(o === e.size, "blob body must have content length");
            const g = "h2" === t[FA];
            try {
              if (null != o && o !== e.size) throw new c();
              const Q = Buffer.from(await e.arrayBuffer());
              g
                ? (A.cork(), A.write(Q), A.uncork())
                : (E.cork(),
                  E.write(`${s}content-length: ${o}\r\n\r\n`, "latin1"),
                  E.write(Q),
                  E.uncork()),
                r.onBodySent(Q),
                r.onRequestSent(),
                i || (E[b] = !0),
                resume(t);
            } catch (e) {
              C.destroy(g ? A : E, e);
            }
          }
          async function writeIterable({
            h2stream: A,
            body: e,
            client: t,
            request: r,
            socket: E,
            contentLength: o,
            header: s,
            expectsPayload: i,
          }) {
            Q(0 !== o || 0 === t[H], "iterator body cannot be pipelined");
            let g = null;
            function onDrain() {
              if (g) {
                const A = g;
                (g = null), A();
              }
            }
            __name(onDrain, "onDrain");
            const B = __name(
              () =>
                new Promise((A, e) => {
                  Q(null === g), E[QA] ? e(E[QA]) : (g = A);
                }),
              "waitForDrain"
            );
            if ("h2" === t[FA]) {
              A.on("close", onDrain).on("drain", onDrain);
              try {
                for await (const t of e) {
                  if (E[QA]) throw E[QA];
                  const e = A.write(t);
                  r.onBodySent(t), e || (await B());
                }
              } catch (e) {
                A.destroy(e);
              } finally {
                r.onRequestSent(),
                  A.end(),
                  A.off("close", onDrain).off("drain", onDrain);
              }
              return;
            }
            E.on("close", onDrain).on("drain", onDrain);
            const C = new Ae({
              socket: E,
              request: r,
              contentLength: o,
              client: t,
              expectsPayload: i,
              header: s,
            });
            try {
              for await (const A of e) {
                if (E[QA]) throw E[QA];
                C.write(A) || (await B());
              }
              C.end();
            } catch (A) {
              C.destroy(A);
            } finally {
              E.off("close", onDrain).off("drain", onDrain);
            }
          }
          __name(onParserTimeout, "onParserTimeout"),
            __name(onSocketReadable, "onSocketReadable"),
            __name(onSocketError, "onSocketError"),
            __name(onError, "onError"),
            __name(onSocketEnd, "onSocketEnd"),
            __name(onSocketClose, "onSocketClose"),
            __name(connect, "connect"),
            __name(emitDrain, "emitDrain"),
            __name(resume, "resume"),
            __name(_resume, "_resume"),
            __name(shouldSendContentLength, "shouldSendContentLength"),
            __name(write, "write"),
            __name(writeH2, "writeH2"),
            __name(writeStream, "writeStream"),
            __name(writeBlob, "writeBlob"),
            __name(writeIterable, "writeIterable");
          var Ae = class {
            static {
              __name(this, "AsyncWriter");
            }
            constructor({
              socket: A,
              request: e,
              contentLength: t,
              client: r,
              expectsPayload: E,
              header: Q,
            }) {
              (this.socket = A),
                (this.request = e),
                (this.contentLength = t),
                (this.client = r),
                (this.bytesWritten = 0),
                (this.expectsPayload = E),
                (this.header = Q),
                (A[O] = !0);
            }
            write(A) {
              const {
                socket: e,
                request: t,
                contentLength: E,
                client: Q,
                bytesWritten: o,
                expectsPayload: s,
                header: i,
              } = this;
              if (e[QA]) throw e[QA];
              if (e.destroyed) return !1;
              const g = Buffer.byteLength(A);
              if (!g) return !0;
              if (null !== E && o + g > E) {
                if (Q[aA]) throw new c();
                r.emitWarning(new c());
              }
              e.cork(),
                0 === o &&
                  (s || (e[b] = !0),
                  null === E
                    ? e.write(`${i}transfer-encoding: chunked\r\n`, "latin1")
                    : e.write(`${i}content-length: ${E}\r\n\r\n`, "latin1")),
                null === E && e.write(`\r\n${g.toString(16)}\r\n`, "latin1"),
                (this.bytesWritten += g);
              const B = e.write(A);
              return (
                e.uncork(),
                t.onBodySent(A),
                B ||
                  (e[M].timeout &&
                    1 === e[M].timeoutType &&
                    e[M].timeout.refresh &&
                    e[M].timeout.refresh()),
                B
              );
            }
            end() {
              const {
                socket: A,
                contentLength: e,
                client: t,
                bytesWritten: E,
                expectsPayload: Q,
                header: o,
                request: s,
              } = this;
              if ((s.onRequestSent(), (A[O] = !1), A[QA])) throw A[QA];
              if (!A.destroyed) {
                if (
                  (0 === E
                    ? Q
                      ? A.write(`${o}content-length: 0\r\n\r\n`, "latin1")
                      : A.write(`${o}\r\n`, "latin1")
                    : null === e && A.write("\r\n0\r\n\r\n", "latin1"),
                  null !== e && E !== e)
                ) {
                  if (t[aA]) throw new c();
                  r.emitWarning(new c());
                }
                A[M].timeout &&
                  1 === A[M].timeoutType &&
                  A[M].timeout.refresh &&
                  A[M].timeout.refresh(),
                  resume(t);
              }
            }
            destroy(A) {
              const { socket: e, client: t } = this;
              (e[O] = !1),
                A &&
                  (Q(t[H] <= 1, "pipeline should only contain this request"),
                  C.destroy(e, A));
            }
          };
          function errorRequest(A, e, t) {
            try {
              e.onError(t), Q(e.aborted);
            } catch (e) {
              A.emit("error", e);
            }
          }
          __name(errorRequest, "errorRequest"), (t.exports = xA);
        },
      }),
      j = __commonJS({
        "lib/pool.js"(A, e) {
          var {
              PoolBase: t,
              kClients: r,
              kNeedDrain: E,
              kAddClient: Q,
              kGetDispatcher: o,
            } = v(),
            s = z(),
            { InvalidArgumentError: g } = B(),
            C = I(),
            { kUrl: n, kInterceptors: a } = i(),
            h = q(),
            c = Symbol("options"),
            l = Symbol("connections"),
            d = Symbol("factory");
          function defaultFactory(A, e) {
            return new s(A, e);
          }
          __name(defaultFactory, "defaultFactory");
          var u = class extends t {
            static {
              __name(this, "Pool");
            }
            constructor(
              A,
              {
                connections: e,
                factory: t = defaultFactory,
                connect: r,
                connectTimeout: E,
                tls: Q,
                maxCachedSessions: o,
                socketPath: s,
                autoSelectFamily: i,
                autoSelectFamilyAttemptTimeout: B,
                allowH2: I,
                ...u
              } = {}
            ) {
              if ((super(), null != e && (!Number.isFinite(e) || e < 0)))
                throw new g("invalid connections");
              if ("function" != typeof t)
                throw new g("factory must be a function.");
              if (null != r && "function" != typeof r && "object" != typeof r)
                throw new g("connect must be a function or an object");
              "function" != typeof r &&
                (r = h({
                  ...Q,
                  maxCachedSessions: o,
                  allowH2: I,
                  socketPath: s,
                  timeout: E,
                  ...(C.nodeHasAutoSelectFamily && i
                    ? { autoSelectFamily: i, autoSelectFamilyAttemptTimeout: B }
                    : void 0),
                  ...r,
                })),
                (this[a] =
                  u.interceptors &&
                  u.interceptors.Pool &&
                  Array.isArray(u.interceptors.Pool)
                    ? u.interceptors.Pool
                    : []),
                (this[l] = e || null),
                (this[n] = C.parseOrigin(A)),
                (this[c] = { ...C.deepClone(u), connect: r, allowH2: I }),
                (this[c].interceptors = u.interceptors
                  ? { ...u.interceptors }
                  : void 0),
                (this[d] = t);
            }
            [o]() {
              let A = this[r].find((A) => !A[E]);
              return (
                A ||
                ((!this[l] || this[r].length < this[l]) &&
                  ((A = this[d](this[n], this[c])), this[Q](A)),
                A)
              );
            }
          };
          e.exports = u;
        },
      }),
      $ = __commonJS({
        "lib/agent.js"(A, e) {
          var { InvalidArgumentError: t } = B(),
            {
              kClients: r,
              kRunning: E,
              kClose: Q,
              kDestroy: o,
              kDispatch: s,
              kInterceptors: g,
            } = i(),
            C = T(),
            n = j(),
            a = z(),
            h = I(),
            c = Z(),
            { WeakRef: l, FinalizationRegistry: d } = Y()(),
            u = Symbol("onConnect"),
            D = Symbol("onDisconnect"),
            R = Symbol("onConnectionError"),
            y = Symbol("maxRedirections"),
            f = Symbol("onDrain"),
            w = Symbol("factory"),
            F = Symbol("finalizer"),
            k = Symbol("options");
          function defaultFactory(A, e) {
            return e && 1 === e.connections ? new a(A, e) : new n(A, e);
          }
          __name(defaultFactory, "defaultFactory");
          var N = class extends C {
            static {
              __name(this, "Agent");
            }
            constructor({
              factory: A = defaultFactory,
              maxRedirections: e = 0,
              connect: E,
              ...Q
            } = {}) {
              if ((super(), "function" != typeof A))
                throw new t("factory must be a function.");
              if (null != E && "function" != typeof E && "object" != typeof E)
                throw new t("connect must be a function or an object");
              if (!Number.isInteger(e) || e < 0)
                throw new t("maxRedirections must be a positive number");
              E && "function" != typeof E && (E = { ...E }),
                (this[g] =
                  Q.interceptors &&
                  Q.interceptors.Agent &&
                  Array.isArray(Q.interceptors.Agent)
                    ? Q.interceptors.Agent
                    : [c({ maxRedirections: e })]),
                (this[k] = { ...h.deepClone(Q), connect: E }),
                (this[k].interceptors = Q.interceptors
                  ? { ...Q.interceptors }
                  : void 0),
                (this[y] = e),
                (this[w] = A),
                (this[r] = new Map()),
                (this[F] = new d((A) => {
                  const e = this[r].get(A);
                  void 0 !== e && void 0 === e.deref() && this[r].delete(A);
                }));
              const o = this;
              (this[f] = (A, e) => {
                o.emit("drain", A, [o, ...e]);
              }),
                (this[u] = (A, e) => {
                  o.emit("connect", A, [o, ...e]);
                }),
                (this[D] = (A, e, t) => {
                  o.emit("disconnect", A, [o, ...e], t);
                }),
                (this[R] = (A, e, t) => {
                  o.emit("connectionError", A, [o, ...e], t);
                });
            }
            get [E]() {
              let A = 0;
              for (const e of this[r].values()) {
                const t = e.deref();
                t && (A += t[E]);
              }
              return A;
            }
            [s](A, e) {
              let E;
              if (
                !A.origin ||
                !("string" == typeof A.origin || A.origin instanceof URL)
              )
                throw new t("opts.origin must be a non-empty string or URL.");
              E = String(A.origin);
              const Q = this[r].get(E);
              let o = Q ? Q.deref() : null;
              return (
                o ||
                  ((o = this[w](A.origin, this[k])
                    .on("drain", this[f])
                    .on("connect", this[u])
                    .on("disconnect", this[D])
                    .on("connectionError", this[R])),
                  this[r].set(E, new l(o)),
                  this[F].register(o, E)),
                o.dispatch(A, e)
              );
            }
            async [Q]() {
              const A = [];
              for (const e of this[r].values()) {
                const t = e.deref();
                t && A.push(t.close());
              }
              await Promise.all(A);
            }
            async [o](A) {
              const e = [];
              for (const t of this[r].values()) {
                const r = t.deref();
                r && e.push(r.destroy(A));
              }
              await Promise.all(e);
            }
          };
          e.exports = N;
        },
      }),
      AA = __commonJS({
        "lib/global.js"(A, e) {
          var t = Symbol.for("undici.globalDispatcher.1"),
            { InvalidArgumentError: r } = B(),
            E = $();
          function setGlobalDispatcher(A) {
            if (!A || "function" != typeof A.dispatch)
              throw new r("Argument agent must implement Agent");
            Object.defineProperty(globalThis, t, {
              value: A,
              writable: !0,
              enumerable: !1,
              configurable: !1,
            });
          }
          function getGlobalDispatcher() {
            return globalThis[t];
          }
          void 0 === getGlobalDispatcher() && setGlobalDispatcher(new E()),
            __name(setGlobalDispatcher, "setGlobalDispatcher"),
            __name(getGlobalDispatcher, "getGlobalDispatcher"),
            (e.exports = {
              setGlobalDispatcher: setGlobalDispatcher,
              getGlobalDispatcher: getGlobalDispatcher,
            });
        },
      }),
      eA = __commonJS({
        "lib/fetch/index.js"(A, t) {
          var r,
            {
              Response: E,
              makeNetworkError: Q,
              makeAppropriateNetworkError: o,
              filterResponse: s,
              makeResponse: B,
            } = M(),
            { Headers: C } = l(),
            { Request: a, makeRequest: d } = J(),
            u = e("zlib"),
            {
              bytesMatch: D,
              makePolicyContainer: R,
              clonePolicyContainer: y,
              requestBadPort: f,
              TAOCheck: w,
              appendRequestOriginHeader: F,
              responseLocationURL: k,
              requestCurrentURL: N,
              setRequestReferrerPolicyOnRedirect: p,
              tryUpgradeRequestToAPotentiallyTrustworthyURL: S,
              createOpaqueTimingInfo: U,
              appendFetchMetadata: m,
              corsCheck: Y,
              crossOriginResourcePolicyCheck: G,
              determineRequestsReferrer: T,
              coarsenedSharedCurrentTime: H,
              createDeferredPromise: V,
              isBlobLike: v,
              sameOrigin: W,
              isCancelled: x,
              isAborted: q,
              isErrorLike: O,
              fullyReadBody: P,
              readableStreamClose: _,
              isomorphicEncode: Z,
              urlIsLocal: X,
              urlIsHttpHttpsScheme: K,
              urlHasHttpsScheme: z,
            } = h(),
            { kState: j, kHeaders: $, kGuard: eA, kRealm: tA } = g(),
            rA = e("assert"),
            { safelyExtractBody: EA } = L(),
            {
              redirectStatusSet: QA,
              nullBodyStatus: oA,
              safeMethodsSet: sA,
              requestBodyHeader: iA,
              subresourceSet: gA,
              DOMException: BA,
            } = n(),
            { kHeadersList: CA } = i(),
            IA = e("events"),
            { Readable: nA, pipeline: aA } = e("stream"),
            {
              addAbortListener: hA,
              isErrored: cA,
              isReadable: lA,
              nodeMajor: dA,
              nodeMinor: uA,
            } = I(),
            { dataURLProcessor: DA, serializeAMimeType: RA } = b(),
            { TransformStream: yA } = e("stream/web"),
            { getGlobalDispatcher: fA } = AA(),
            { webidl: wA } = c(),
            { STATUS_CODES: FA } = e("http"),
            kA = ["GET", "HEAD"],
            NA = globalThis.ReadableStream,
            pA = class extends IA {
              static {
                __name(this, "Fetch");
              }
              constructor(A) {
                super(),
                  (this.dispatcher = A),
                  (this.connection = null),
                  (this.dump = !1),
                  (this.state = "ongoing"),
                  this.setMaxListeners(21);
              }
              terminate(A) {
                "ongoing" === this.state &&
                  ((this.state = "terminated"),
                  this.connection?.destroy(A),
                  this.emit("terminated", A));
              }
              abort(A) {
                "ongoing" === this.state &&
                  ((this.state = "aborted"),
                  A || (A = new BA("The operation was aborted.", "AbortError")),
                  (this.serializedAbortReason = A),
                  this.connection?.destroy(A),
                  this.emit("terminated", A));
              }
            };
          function fetch2(A, e = {}) {
            wA.argumentLengthCheck(arguments, 1, {
              header: "globalThis.fetch",
            });
            const t = V();
            let r;
            try {
              r = new a(A, e);
            } catch (A) {
              return t.reject(A), t.promise;
            }
            const Q = r[j];
            if (r.signal.aborted)
              return abortFetch(t, Q, null, r.signal.reason), t.promise;
            const o = Q.client.globalObject;
            "ServiceWorkerGlobalScope" === o?.constructor?.name &&
              (Q.serviceWorkers = "none");
            let s = null;
            let i = !1,
              g = null;
            hA(r.signal, () => {
              (i = !0),
                rA(null != g),
                g.abort(r.signal.reason),
                abortFetch(t, Q, s, r.signal.reason);
            });
            return (
              (g = fetching({
                request: Q,
                processResponseEndOfBody: __name(
                  (A) => finalizeAndReportTiming(A, "fetch"),
                  "handleFetchDone"
                ),
                processResponse: __name(
                  (A) =>
                    i
                      ? Promise.resolve()
                      : A.aborted
                      ? (abortFetch(t, Q, s, g.serializedAbortReason),
                        Promise.resolve())
                      : "error" === A.type
                      ? (t.reject(
                          Object.assign(new TypeError("fetch failed"), {
                            cause: A.error,
                          })
                        ),
                        Promise.resolve())
                      : ((s = new E()),
                        (s[j] = A),
                        (s[tA] = null),
                        (s[$][CA] = A.headersList),
                        (s[$][eA] = "immutable"),
                        (s[$][tA] = null),
                        void t.resolve(s)),
                  "processResponse"
                ),
                dispatcher: e.dispatcher ?? fA(),
              })),
              t.promise
            );
          }
          function finalizeAndReportTiming(A, e = "other") {
            if ("error" === A.type && A.aborted) return;
            if (!A.urlList?.length) return;
            const t = A.urlList[0];
            let r = A.timingInfo,
              E = A.cacheState;
            K(t) &&
              null !== r &&
              (A.timingAllowPassed ||
                ((r = U({ startTime: r.startTime })), (E = "")),
              (r.endTime = H()),
              (A.timingInfo = r),
              markResourceTiming(r, t, e, globalThis, E));
          }
          function markResourceTiming(A, e, t, r, E) {
            (dA > 18 || (18 === dA && uA >= 2)) &&
              performance.markResourceTiming(A, e.href, t, r, E);
          }
          function abortFetch(A, e, t, r) {
            if (
              (r || (r = new BA("The operation was aborted.", "AbortError")),
              A.reject(r),
              null != e.body &&
                lA(e.body?.stream) &&
                e.body.stream.cancel(r).catch((A) => {
                  if ("ERR_INVALID_STATE" !== A.code) throw A;
                }),
              null == t)
            )
              return;
            const E = t[j];
            null != E.body &&
              lA(E.body?.stream) &&
              E.body.stream.cancel(r).catch((A) => {
                if ("ERR_INVALID_STATE" !== A.code) throw A;
              });
          }
          function fetching({
            request: A,
            processRequestBodyChunkLength: e,
            processRequestEndOfBody: t,
            processResponse: r,
            processResponseEndOfBody: E,
            processResponseConsumeBody: Q,
            useParallelQueue: o = !1,
            dispatcher: s,
          }) {
            let i = null,
              g = !1;
            null != A.client &&
              ((i = A.client.globalObject),
              (g = A.client.crossOriginIsolatedCapability));
            const B = H(g),
              C = U({ startTime: B }),
              I = {
                controller: new pA(s),
                request: A,
                timingInfo: C,
                processRequestBodyChunkLength: e,
                processRequestEndOfBody: t,
                processResponse: r,
                processResponseConsumeBody: Q,
                processResponseEndOfBody: E,
                taskDestination: i,
                crossOriginIsolatedCapability: g,
              };
            if (
              (rA(!A.body || A.body.stream),
              "client" === A.window &&
                (A.window =
                  "Window" === A.client?.globalObject?.constructor?.name
                    ? A.client
                    : "no-window"),
              "client" === A.origin && (A.origin = A.client?.origin),
              "client" === A.policyContainer &&
                (null != A.client
                  ? (A.policyContainer = y(A.client.policyContainer))
                  : (A.policyContainer = R())),
              !A.headersList.contains("accept"))
            ) {
              const e = "*/*";
              A.headersList.append("accept", e);
            }
            return (
              A.headersList.contains("accept-language") ||
                A.headersList.append("accept-language", "*"),
              A.priority,
              gA.has(A.destination),
              mainFetch(I).catch((A) => {
                I.controller.terminate(A);
              }),
              I.controller
            );
          }
          async function mainFetch(A, e = !1) {
            const t = A.request;
            let r = null;
            if (
              (t.localURLsOnly && !X(N(t)) && (r = Q("local URLs only")),
              S(t),
              "blocked" === f(t) && (r = Q("bad port")),
              "" === t.referrerPolicy &&
                (t.referrerPolicy = t.policyContainer.referrerPolicy),
              "no-referrer" !== t.referrer && (t.referrer = T(t)),
              null === r &&
                (r = await (async () => {
                  const e = N(t);
                  return (W(e, t.url) && "basic" === t.responseTainting) ||
                    "data:" === e.protocol ||
                    "navigate" === t.mode ||
                    "websocket" === t.mode
                    ? ((t.responseTainting = "basic"), await schemeFetch(A))
                    : "same-origin" === t.mode
                    ? Q('request mode cannot be "same-origin"')
                    : "no-cors" === t.mode
                    ? "follow" !== t.redirect
                      ? Q(
                          'redirect mode cannot be "follow" for "no-cors" request'
                        )
                      : ((t.responseTainting = "opaque"), await schemeFetch(A))
                    : K(N(t))
                    ? ((t.responseTainting = "cors"), await httpFetch(A))
                    : Q("URL scheme must be a HTTP(S) scheme");
                })()),
              e)
            )
              return r;
            0 === r.status ||
              r.internalResponse ||
              (t.responseTainting,
              "basic" === t.responseTainting
                ? (r = s(r, "basic"))
                : "cors" === t.responseTainting
                ? (r = s(r, "cors"))
                : "opaque" === t.responseTainting
                ? (r = s(r, "opaque"))
                : rA(!1));
            let E = 0 === r.status ? r : r.internalResponse;
            if (
              (0 === E.urlList.length && E.urlList.push(...t.urlList),
              t.timingAllowFailed || (r.timingAllowPassed = !0),
              "opaque" === r.type &&
                206 === E.status &&
                E.rangeRequested &&
                !t.headers.contains("range") &&
                (r = E = Q()),
              0 === r.status ||
                ("HEAD" !== t.method &&
                  "CONNECT" !== t.method &&
                  !oA.includes(E.status)) ||
                ((E.body = null), (A.controller.dump = !0)),
              t.integrity)
            ) {
              const e = __name((e) => fetchFinale(A, Q(e)), "processBodyError");
              if ("opaque" === t.responseTainting || null == r.body)
                return void e(r.error);
              const E = __name((E) => {
                D(E, t.integrity)
                  ? ((r.body = EA(E)[0]), fetchFinale(A, r))
                  : e("integrity mismatch");
              }, "processBody");
              await P(r.body, E, e);
            } else fetchFinale(A, r);
          }
          function schemeFetch(A) {
            if (x(A) && 0 === A.request.redirectCount)
              return Promise.resolve(o(A));
            const { request: t } = A,
              { protocol: E } = N(t);
            switch (E) {
              case "about:":
                return Promise.resolve(Q("about scheme is not supported"));
              case "blob:": {
                r || (r = e("buffer").resolveObjectURL);
                const A = N(t);
                if (0 !== A.search.length)
                  return Promise.resolve(
                    Q("NetworkError when attempting to fetch resource.")
                  );
                const E = r(A.toString());
                if ("GET" !== t.method || !v(E))
                  return Promise.resolve(Q("invalid method"));
                const o = EA(E),
                  s = o[0],
                  i = Z(`${s.length}`),
                  g = o[1] ?? "",
                  C = B({
                    statusText: "OK",
                    headersList: [
                      ["content-length", { name: "Content-Length", value: i }],
                      ["content-type", { name: "Content-Type", value: g }],
                    ],
                  });
                return (C.body = s), Promise.resolve(C);
              }
              case "data:": {
                const A = N(t),
                  e = DA(A);
                if ("failure" === e)
                  return Promise.resolve(Q("failed to fetch the data URL"));
                const r = RA(e.mimeType);
                return Promise.resolve(
                  B({
                    statusText: "OK",
                    headersList: [
                      ["content-type", { name: "Content-Type", value: r }],
                    ],
                    body: EA(e.body)[0],
                  })
                );
              }
              case "file:":
                return Promise.resolve(Q("not implemented... yet..."));
              case "http:":
              case "https:":
                return httpFetch(A).catch((A) => Q(A));
              default:
                return Promise.resolve(Q("unknown scheme"));
            }
          }
          function finalizeResponse(A, e) {
            (A.request.done = !0),
              null != A.processResponseDone &&
                queueMicrotask(() => A.processResponseDone(e));
          }
          function fetchFinale(A, e) {
            "error" === e.type &&
              ((e.urlList = [A.request.urlList[0]]),
              (e.timingInfo = U({ startTime: A.timingInfo.startTime })));
            const t = __name(() => {
              (A.request.done = !0),
                null != A.processResponseEndOfBody &&
                  queueMicrotask(() => A.processResponseEndOfBody(e));
            }, "processResponseEndOfBody");
            if (
              (null != A.processResponse &&
                queueMicrotask(() => A.processResponse(e)),
              null == e.body)
            )
              t();
            else {
              const A = new yA(
                {
                  start() {},
                  transform: __name((A, e) => {
                    e.enqueue(A);
                  }, "identityTransformAlgorithm"),
                  flush: t,
                },
                { size: () => 1 },
                { size: () => 1 }
              );
              e.body = { stream: e.body.stream.pipeThrough(A) };
            }
            if (null != A.processResponseConsumeBody) {
              const t = __name(
                  (t) => A.processResponseConsumeBody(e, t),
                  "processBody"
                ),
                r = __name(
                  (t) => A.processResponseConsumeBody(e, t),
                  "processBodyError"
                );
              return null != e.body
                ? P(e.body, t, r)
                : (queueMicrotask(() => t(null)), Promise.resolve());
            }
          }
          async function httpFetch(A) {
            const e = A.request;
            let t = null,
              r = null;
            const E = A.timingInfo;
            if ((e.serviceWorkers, null === t)) {
              if (
                ("follow" === e.redirect && (e.serviceWorkers = "none"),
                (r = t = await httpNetworkOrCacheFetch(A)),
                "cors" === e.responseTainting && "failure" === Y(e, t))
              )
                return Q("cors failure");
              "failure" === w(e, t) && (e.timingAllowFailed = !0);
            }
            return ("opaque" !== e.responseTainting && "opaque" !== t.type) ||
              "blocked" !== G(e.origin, e.client, e.destination, r)
              ? (QA.has(r.status) &&
                  ("manual" !== e.redirect && A.controller.connection.destroy(),
                  "error" === e.redirect
                    ? (t = Q("unexpected redirect"))
                    : "manual" === e.redirect
                    ? (t = r)
                    : "follow" === e.redirect
                    ? (t = await httpRedirectFetch(A, t))
                    : rA(!1)),
                (t.timingInfo = E),
                t)
              : Q("blocked");
          }
          function httpRedirectFetch(A, e) {
            const t = A.request,
              r = e.internalResponse ? e.internalResponse : e;
            let E;
            try {
              if (((E = k(r, N(t).hash)), null == E)) return e;
            } catch (A) {
              return Promise.resolve(Q(A));
            }
            if (!K(E))
              return Promise.resolve(Q("URL scheme must be a HTTP(S) scheme"));
            if (20 === t.redirectCount)
              return Promise.resolve(Q("redirect count exceeded"));
            if (
              ((t.redirectCount += 1),
              "cors" === t.mode && (E.username || E.password) && !W(t, E))
            )
              return Promise.resolve(
                Q('cross origin not allowed for request mode "cors"')
              );
            if ("cors" === t.responseTainting && (E.username || E.password))
              return Promise.resolve(
                Q('URL cannot contain credentials for request mode "cors"')
              );
            if (303 !== r.status && null != t.body && null == t.body.source)
              return Promise.resolve(Q());
            if (
              ([301, 302].includes(r.status) && "POST" === t.method) ||
              (303 === r.status && !kA.includes(t.method))
            ) {
              (t.method = "GET"), (t.body = null);
              for (const A of iA) t.headersList.delete(A);
            }
            W(N(t), E) ||
              (t.headersList.delete("authorization"),
              t.headersList.delete("proxy-authorization", !0),
              t.headersList.delete("cookie"),
              t.headersList.delete("host")),
              null != t.body &&
                (rA(null != t.body.source), (t.body = EA(t.body.source)[0]));
            const o = A.timingInfo;
            return (
              (o.redirectEndTime = o.postRedirectStartTime =
                H(A.crossOriginIsolatedCapability)),
              0 === o.redirectStartTime && (o.redirectStartTime = o.startTime),
              t.urlList.push(E),
              p(t, r),
              mainFetch(A, !0)
            );
          }
          async function httpNetworkOrCacheFetch(A, e = !1, t = !1) {
            const r = A.request;
            let E = null,
              s = null,
              i = null;
            "no-window" === r.window && "error" === r.redirect
              ? ((E = A), (s = r))
              : ((s = d(r)), (E = { ...A }), (E.request = s));
            const g =
                "include" === r.credentials ||
                ("same-origin" === r.credentials &&
                  "basic" === r.responseTainting),
              B = s.body ? s.body.length : null;
            let C = null;
            if (
              (null == s.body &&
                ["POST", "PUT"].includes(s.method) &&
                (C = "0"),
              null != B && (C = Z(`${B}`)),
              null != C && s.headersList.append("content-length", C),
              null != B && s.keepalive,
              s.referrer instanceof URL &&
                s.headersList.append("referer", Z(s.referrer.href)),
              F(s),
              m(s),
              s.headersList.contains("user-agent") ||
                s.headersList.append("user-agent", "node"),
              "default" === s.cache &&
                (s.headersList.contains("if-modified-since") ||
                  s.headersList.contains("if-none-match") ||
                  s.headersList.contains("if-unmodified-since") ||
                  s.headersList.contains("if-match") ||
                  s.headersList.contains("if-range")) &&
                (s.cache = "no-store"),
              "no-cache" !== s.cache ||
                s.preventNoCacheCacheControlHeaderModification ||
                s.headersList.contains("cache-control") ||
                s.headersList.append("cache-control", "max-age=0"),
              ("no-store" !== s.cache && "reload" !== s.cache) ||
                (s.headersList.contains("pragma") ||
                  s.headersList.append("pragma", "no-cache"),
                s.headersList.contains("cache-control") ||
                  s.headersList.append("cache-control", "no-cache")),
              s.headersList.contains("range") &&
                s.headersList.append("accept-encoding", "identity"),
              s.headersList.contains("accept-encoding") ||
                (z(N(s))
                  ? s.headersList.append("accept-encoding", "br, gzip, deflate")
                  : s.headersList.append("accept-encoding", "gzip, deflate")),
              s.headersList.delete("host"),
              (s.cache = "no-store"),
              "no-store" !== s.mode && s.mode,
              null == i)
            ) {
              if ("only-if-cached" === s.mode) return Q("only if cached");
              const A = await httpNetworkFetch(E, g, t);
              !sA.has(s.method) && A.status >= 200 && A.status,
                null == i && (i = A);
            }
            if (
              ((i.urlList = [...s.urlList]),
              s.headersList.contains("range") && (i.rangeRequested = !0),
              (i.requestIncludesCredentials = g),
              407 === i.status)
            )
              return "no-window" === r.window
                ? Q()
                : x(A)
                ? o(A)
                : Q("proxy authentication required");
            if (
              421 === i.status &&
              !t &&
              (null == r.body || null != r.body.source)
            ) {
              if (x(A)) return o(A);
              A.controller.connection.destroy(),
                (i = await httpNetworkOrCacheFetch(A, e, !0));
            }
            return i;
          }
          async function httpNetworkFetch(A, t = !1, r = !1) {
            rA(!A.controller.connection || A.controller.connection.destroyed),
              (A.controller.connection = {
                abort: null,
                destroyed: !1,
                destroy(A) {
                  this.destroyed ||
                    ((this.destroyed = !0),
                    this.abort?.(
                      A ?? new BA("The operation was aborted.", "AbortError")
                    ));
                },
              });
            const E = A.request;
            let s = null;
            const i = A.timingInfo;
            E.cache = "no-store";
            E.mode;
            let g = null;
            if (null == E.body && A.processRequestEndOfBody)
              queueMicrotask(() => A.processRequestEndOfBody());
            else if (null != E.body) {
              const e = __name(async function* (e) {
                  x(A) ||
                    (yield e, A.processRequestBodyChunkLength?.(e.byteLength));
                }, "processBodyChunk"),
                t = __name(() => {
                  x(A) ||
                    (A.processRequestEndOfBody && A.processRequestEndOfBody());
                }, "processEndOfBody"),
                r = __name((e) => {
                  x(A) ||
                    ("AbortError" === e.name
                      ? A.controller.abort()
                      : A.controller.terminate(e));
                }, "processBodyError");
              g = (async function* () {
                try {
                  for await (const A of E.body.stream) yield* e(A);
                  t();
                } catch (A) {
                  r(A);
                }
              })();
            }
            try {
              const {
                body: e,
                status: t,
                statusText: r,
                headersList: E,
                socket: Q,
              } = await dispatch({ body: g });
              if (Q)
                s = B({ status: t, statusText: r, headersList: E, socket: Q });
              else {
                const Q = e[Symbol.asyncIterator]();
                (A.controller.next = () => Q.next()),
                  (s = B({ status: t, statusText: r, headersList: E }));
              }
            } catch (e) {
              return "AbortError" === e.name
                ? (A.controller.connection.destroy(), o(A, e))
                : Q(e);
            }
            const I = __name(() => {
                A.controller.resume();
              }, "pullAlgorithm"),
              n = __name((e) => {
                A.controller.abort(e);
              }, "cancelAlgorithm");
            NA || (NA = e("stream/web").ReadableStream);
            const a = new NA(
              {
                async start(e) {
                  A.controller.controller = e;
                },
                async pull(A) {
                  await I(A);
                },
                async cancel(A) {
                  await n(A);
                },
              },
              { highWaterMark: 0, size: () => 1 }
            );
            function onAborted(e) {
              q(A)
                ? ((s.aborted = !0),
                  lA(a) &&
                    A.controller.controller.error(
                      A.controller.serializedAbortReason
                    ))
                : lA(a) &&
                  A.controller.controller.error(
                    new TypeError("terminated", { cause: O(e) ? e : void 0 })
                  ),
                A.controller.connection.destroy();
            }
            return (
              (s.body = { stream: a }),
              A.controller.on("terminated", onAborted),
              (A.controller.resume = async () => {
                for (;;) {
                  let e, t;
                  try {
                    const { done: t, value: r } = await A.controller.next();
                    if (q(A)) break;
                    e = t ? void 0 : r;
                  } catch (r) {
                    A.controller.ended && !i.encodedBodySize
                      ? (e = void 0)
                      : ((e = r), (t = !0));
                  }
                  if (void 0 === e)
                    return (
                      _(A.controller.controller), void finalizeResponse(A, s)
                    );
                  if (((i.decodedBodySize += e?.byteLength ?? 0), t))
                    return void A.controller.terminate(e);
                  if (
                    (A.controller.controller.enqueue(new Uint8Array(e)), cA(a))
                  )
                    return void A.controller.terminate();
                  if (!A.controller.controller.desiredSize) return;
                }
              }),
              __name(onAborted, "onAborted"),
              s
            );
            async function dispatch({ body: e }) {
              const t = N(E),
                r = A.controller.dispatcher;
              return new Promise((Q, o) =>
                r.dispatch(
                  {
                    path: t.pathname + t.search,
                    origin: t.origin,
                    method: E.method,
                    body: A.controller.dispatcher.isMockActive
                      ? E.body && (E.body.source || E.body.stream)
                      : e,
                    headers: E.headersList.entries,
                    maxRedirections: 0,
                    upgrade: "websocket" === E.mode ? "websocket" : void 0,
                  },
                  {
                    body: null,
                    abort: null,
                    onConnect(e) {
                      const { connection: t } = A.controller;
                      t.destroyed
                        ? e(new BA("The operation was aborted.", "AbortError"))
                        : (A.controller.on("terminated", e),
                          (this.abort = t.abort = e));
                    },
                    onHeaders(A, e, t, r) {
                      if (A < 200) return;
                      let o = [],
                        s = "";
                      const i = new C();
                      if (Array.isArray(e))
                        for (let A = 0; A < e.length; A += 2) {
                          const t = e[A + 0].toString("latin1"),
                            r = e[A + 1].toString("latin1");
                          "content-encoding" === t.toLowerCase()
                            ? (o = r
                                .toLowerCase()
                                .split(",")
                                .map((A) => A.trim()))
                            : "location" === t.toLowerCase() && (s = r),
                            i[CA].append(t, r);
                        }
                      else {
                        const A = Object.keys(e);
                        for (const t of A) {
                          const A = e[t];
                          "content-encoding" === t.toLowerCase()
                            ? (o = A.toLowerCase()
                                .split(",")
                                .map((A) => A.trim())
                                .reverse())
                            : "location" === t.toLowerCase() && (s = A),
                            i[CA].append(t, A);
                        }
                      }
                      this.body = new nA({ read: t });
                      const g = [],
                        B = "follow" === E.redirect && s && QA.has(A);
                      if (
                        "HEAD" !== E.method &&
                        "CONNECT" !== E.method &&
                        !oA.includes(A) &&
                        !B
                      )
                        for (const A of o)
                          if ("x-gzip" === A || "gzip" === A)
                            g.push(
                              u.createGunzip({
                                flush: u.constants.Z_SYNC_FLUSH,
                                finishFlush: u.constants.Z_SYNC_FLUSH,
                              })
                            );
                          else if ("deflate" === A) g.push(u.createInflate());
                          else {
                            if ("br" !== A) {
                              g.length = 0;
                              break;
                            }
                            g.push(u.createBrotliDecompress());
                          }
                      return (
                        Q({
                          status: A,
                          statusText: r,
                          headersList: i[CA],
                          body: g.length
                            ? aA(this.body, ...g, () => {})
                            : this.body.on("error", () => {}),
                        }),
                        !0
                      );
                    },
                    onData(e) {
                      if (A.controller.dump) return;
                      const t = e;
                      return (
                        (i.encodedBodySize += t.byteLength), this.body.push(t)
                      );
                    },
                    onComplete() {
                      this.abort && A.controller.off("terminated", this.abort),
                        (A.controller.ended = !0),
                        this.body.push(null);
                    },
                    onError(e) {
                      this.abort && A.controller.off("terminated", this.abort),
                        this.body?.destroy(e),
                        A.controller.terminate(e),
                        o(e);
                    },
                    onUpgrade(A, e, t) {
                      if (101 !== A) return;
                      const r = new C();
                      for (let A = 0; A < e.length; A += 2) {
                        const t = e[A + 0].toString("latin1"),
                          E = e[A + 1].toString("latin1");
                        r[CA].append(t, E);
                      }
                      return (
                        Q({
                          status: A,
                          statusText: FA[A],
                          headersList: r[CA],
                          socket: t,
                        }),
                        !0
                      );
                    },
                  }
                )
              );
            }
          }
          __name(fetch2, "fetch"),
            __name(finalizeAndReportTiming, "finalizeAndReportTiming"),
            __name(markResourceTiming, "markResourceTiming"),
            __name(abortFetch, "abortFetch"),
            __name(fetching, "fetching"),
            __name(mainFetch, "mainFetch"),
            __name(schemeFetch, "schemeFetch"),
            __name(finalizeResponse, "finalizeResponse"),
            __name(fetchFinale, "fetchFinale"),
            __name(httpFetch, "httpFetch"),
            __name(httpRedirectFetch, "httpRedirectFetch"),
            __name(httpNetworkOrCacheFetch, "httpNetworkOrCacheFetch"),
            __name(httpNetworkFetch, "httpNetworkFetch"),
            (t.exports = {
              fetch: fetch2,
              Fetch: pA,
              fetching: fetching,
              finalizeAndReportTiming: finalizeAndReportTiming,
            });
        },
      }),
      tA = __commonJS({
        "lib/websocket/constants.js"(A, e) {
          var t = Buffer.allocUnsafe(0);
          e.exports = {
            uid: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
            staticPropertyDescriptors: {
              enumerable: !0,
              writable: !1,
              configurable: !1,
            },
            states: { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 },
            opcodes: {
              CONTINUATION: 0,
              TEXT: 1,
              BINARY: 2,
              CLOSE: 8,
              PING: 9,
              PONG: 10,
            },
            maxUnsigned16Bit: 65535,
            parserStates: {
              INFO: 0,
              PAYLOADLENGTH_16: 2,
              PAYLOADLENGTH_64: 3,
              READ_DATA: 4,
            },
            emptyBuffer: t,
          };
        },
      }),
      rA = __commonJS({
        "lib/websocket/symbols.js"(A, e) {
          e.exports = {
            kWebSocketURL: Symbol("url"),
            kReadyState: Symbol("ready state"),
            kController: Symbol("controller"),
            kResponse: Symbol("response"),
            kBinaryType: Symbol("binary type"),
            kSentClose: Symbol("sent close"),
            kReceivedClose: Symbol("received close"),
            kByteParser: Symbol("byte parser"),
          };
        },
      }),
      EA = __commonJS({
        "lib/websocket/events.js"(A, t) {
          var { webidl: r } = c(),
            { kEnumerableProperty: E } = I(),
            { MessagePort: Q } = e("worker_threads"),
            o = class _MessageEvent extends Event {
              static {
                __name(this, "MessageEvent");
              }
              #A;
              constructor(A, e = {}) {
                r.argumentLengthCheck(arguments, 1, {
                  header: "MessageEvent constructor",
                }),
                  super(
                    (A = r.converters.DOMString(A)),
                    (e = r.converters.MessageEventInit(e))
                  ),
                  (this.#A = e);
              }
              get data() {
                return r.brandCheck(this, _MessageEvent), this.#A.data;
              }
              get origin() {
                return r.brandCheck(this, _MessageEvent), this.#A.origin;
              }
              get lastEventId() {
                return r.brandCheck(this, _MessageEvent), this.#A.lastEventId;
              }
              get source() {
                return r.brandCheck(this, _MessageEvent), this.#A.source;
              }
              get ports() {
                return (
                  r.brandCheck(this, _MessageEvent),
                  Object.isFrozen(this.#A.ports) ||
                    Object.freeze(this.#A.ports),
                  this.#A.ports
                );
              }
              initMessageEvent(
                A,
                e = !1,
                t = !1,
                E = null,
                Q = "",
                o = "",
                s = null,
                i = []
              ) {
                return (
                  r.brandCheck(this, _MessageEvent),
                  r.argumentLengthCheck(arguments, 1, {
                    header: "MessageEvent.initMessageEvent",
                  }),
                  new _MessageEvent(A, {
                    bubbles: e,
                    cancelable: t,
                    data: E,
                    origin: Q,
                    lastEventId: o,
                    source: s,
                    ports: i,
                  })
                );
              }
            },
            s = class _CloseEvent extends Event {
              static {
                __name(this, "CloseEvent");
              }
              #A;
              constructor(A, e = {}) {
                r.argumentLengthCheck(arguments, 1, {
                  header: "CloseEvent constructor",
                }),
                  super(
                    (A = r.converters.DOMString(A)),
                    (e = r.converters.CloseEventInit(e))
                  ),
                  (this.#A = e);
              }
              get wasClean() {
                return r.brandCheck(this, _CloseEvent), this.#A.wasClean;
              }
              get code() {
                return r.brandCheck(this, _CloseEvent), this.#A.code;
              }
              get reason() {
                return r.brandCheck(this, _CloseEvent), this.#A.reason;
              }
            },
            i = class _ErrorEvent extends Event {
              static {
                __name(this, "ErrorEvent");
              }
              #A;
              constructor(A, e) {
                r.argumentLengthCheck(arguments, 1, {
                  header: "ErrorEvent constructor",
                }),
                  super(A, e),
                  (A = r.converters.DOMString(A)),
                  (e = r.converters.ErrorEventInit(e ?? {})),
                  (this.#A = e);
              }
              get message() {
                return r.brandCheck(this, _ErrorEvent), this.#A.message;
              }
              get filename() {
                return r.brandCheck(this, _ErrorEvent), this.#A.filename;
              }
              get lineno() {
                return r.brandCheck(this, _ErrorEvent), this.#A.lineno;
              }
              get colno() {
                return r.brandCheck(this, _ErrorEvent), this.#A.colno;
              }
              get error() {
                return r.brandCheck(this, _ErrorEvent), this.#A.error;
              }
            };
          Object.defineProperties(o.prototype, {
            [Symbol.toStringTag]: { value: "MessageEvent", configurable: !0 },
            data: E,
            origin: E,
            lastEventId: E,
            source: E,
            ports: E,
            initMessageEvent: E,
          }),
            Object.defineProperties(s.prototype, {
              [Symbol.toStringTag]: { value: "CloseEvent", configurable: !0 },
              reason: E,
              code: E,
              wasClean: E,
            }),
            Object.defineProperties(i.prototype, {
              [Symbol.toStringTag]: { value: "ErrorEvent", configurable: !0 },
              message: E,
              filename: E,
              lineno: E,
              colno: E,
              error: E,
            }),
            (r.converters.MessagePort = r.interfaceConverter(Q)),
            (r.converters["sequence<MessagePort>"] = r.sequenceConverter(
              r.converters.MessagePort
            ));
          var g = [
            {
              key: "bubbles",
              converter: r.converters.boolean,
              defaultValue: !1,
            },
            {
              key: "cancelable",
              converter: r.converters.boolean,
              defaultValue: !1,
            },
            {
              key: "composed",
              converter: r.converters.boolean,
              defaultValue: !1,
            },
          ];
          (r.converters.MessageEventInit = r.dictionaryConverter([
            ...g,
            { key: "data", converter: r.converters.any, defaultValue: null },
            {
              key: "origin",
              converter: r.converters.USVString,
              defaultValue: "",
            },
            {
              key: "lastEventId",
              converter: r.converters.DOMString,
              defaultValue: "",
            },
            {
              key: "source",
              converter: r.nullableConverter(r.converters.MessagePort),
              defaultValue: null,
            },
            {
              key: "ports",
              converter: r.converters["sequence<MessagePort>"],
              get defaultValue() {
                return [];
              },
            },
          ])),
            (r.converters.CloseEventInit = r.dictionaryConverter([
              ...g,
              {
                key: "wasClean",
                converter: r.converters.boolean,
                defaultValue: !1,
              },
              {
                key: "code",
                converter: r.converters["unsigned short"],
                defaultValue: 0,
              },
              {
                key: "reason",
                converter: r.converters.USVString,
                defaultValue: "",
              },
            ])),
            (r.converters.ErrorEventInit = r.dictionaryConverter([
              ...g,
              {
                key: "message",
                converter: r.converters.DOMString,
                defaultValue: "",
              },
              {
                key: "filename",
                converter: r.converters.USVString,
                defaultValue: "",
              },
              {
                key: "lineno",
                converter: r.converters["unsigned long"],
                defaultValue: 0,
              },
              {
                key: "colno",
                converter: r.converters["unsigned long"],
                defaultValue: 0,
              },
              { key: "error", converter: r.converters.any },
            ])),
            (t.exports = { MessageEvent: o, CloseEvent: s, ErrorEvent: i });
        },
      }),
      QA = __commonJS({
        "lib/websocket/util.js"(A, e) {
          var {
              kReadyState: t,
              kController: r,
              kResponse: E,
              kBinaryType: Q,
              kWebSocketURL: o,
            } = rA(),
            { states: s, opcodes: i } = tA(),
            { MessageEvent: g, ErrorEvent: B } = EA();
          function isEstablished(A) {
            return A[t] === s.OPEN;
          }
          function isClosing(A) {
            return A[t] === s.CLOSING;
          }
          function isClosed(A) {
            return A[t] === s.CLOSED;
          }
          function fireEvent(A, e, t = Event, r) {
            const E = new t(A, r);
            e.dispatchEvent(E);
          }
          function websocketMessageReceived(A, e, r) {
            if (A[t] !== s.OPEN) return;
            let E;
            if (e === i.TEXT)
              try {
                E = new TextDecoder("utf-8", { fatal: !0 }).decode(r);
              } catch {
                return void failWebsocketConnection(
                  A,
                  "Received invalid UTF-8 in text frame."
                );
              }
            else
              e === i.BINARY &&
                (E =
                  "blob" === A[Q] ? new Blob([r]) : new Uint8Array(r).buffer);
            fireEvent("message", A, g, { origin: A[o].origin, data: E });
          }
          function isValidSubprotocol(A) {
            if (0 === A.length) return !1;
            for (const e of A) {
              const A = e.charCodeAt(0);
              if (
                A < 33 ||
                A > 126 ||
                "(" === e ||
                ")" === e ||
                "<" === e ||
                ">" === e ||
                "@" === e ||
                "," === e ||
                ";" === e ||
                ":" === e ||
                "\\" === e ||
                '"' === e ||
                "/" === e ||
                "[" === e ||
                "]" === e ||
                "?" === e ||
                "=" === e ||
                "{" === e ||
                "}" === e ||
                32 === A ||
                9 === A
              )
                return !1;
            }
            return !0;
          }
          function isValidStatusCode(A) {
            return A >= 1e3 && A < 1015
              ? 1004 !== A && 1005 !== A && 1006 !== A
              : A >= 3e3 && A <= 4999;
          }
          function failWebsocketConnection(A, e) {
            const { [r]: t, [E]: Q } = A;
            t.abort(),
              Q?.socket && !Q.socket.destroyed && Q.socket.destroy(),
              e && fireEvent("error", A, B, { error: new Error(e) });
          }
          __name(isEstablished, "isEstablished"),
            __name(isClosing, "isClosing"),
            __name(isClosed, "isClosed"),
            __name(fireEvent, "fireEvent"),
            __name(websocketMessageReceived, "websocketMessageReceived"),
            __name(isValidSubprotocol, "isValidSubprotocol"),
            __name(isValidStatusCode, "isValidStatusCode"),
            __name(failWebsocketConnection, "failWebsocketConnection"),
            (e.exports = {
              isEstablished: isEstablished,
              isClosing: isClosing,
              isClosed: isClosed,
              fireEvent: fireEvent,
              isValidSubprotocol: isValidSubprotocol,
              isValidStatusCode: isValidStatusCode,
              failWebsocketConnection: failWebsocketConnection,
              websocketMessageReceived: websocketMessageReceived,
            });
        },
      }),
      oA = __commonJS({
        "lib/websocket/connection.js"(A, t) {
          var r,
            E = e("diagnostics_channel"),
            { uid: Q, states: o } = tA(),
            {
              kReadyState: s,
              kSentClose: g,
              kByteParser: B,
              kReceivedClose: C,
            } = rA(),
            { fireEvent: I, failWebsocketConnection: n } = QA(),
            { CloseEvent: a } = EA(),
            { makeRequest: h } = J(),
            { fetching: c } = eA(),
            { Headers: d } = l(),
            { getGlobalDispatcher: u } = AA(),
            { kHeadersList: D } = i(),
            R = {};
          (R.open = E.channel("undici:websocket:open")),
            (R.close = E.channel("undici:websocket:close")),
            (R.socketError = E.channel("undici:websocket:socket_error"));
          try {
            r = e("crypto");
          } catch {}
          function establishWebSocketConnection(A, e, t, E, o) {
            const s = A;
            s.protocol = "ws:" === A.protocol ? "http:" : "https:";
            const i = h({
              urlList: [s],
              serviceWorkers: "none",
              referrer: "no-referrer",
              mode: "websocket",
              credentials: "include",
              cache: "no-store",
              redirect: "error",
            });
            if (o.headers) {
              const A = new d(o.headers)[D];
              i.headersList = A;
            }
            const g = r.randomBytes(16).toString("base64");
            i.headersList.append("sec-websocket-key", g),
              i.headersList.append("sec-websocket-version", "13");
            for (const A of e)
              i.headersList.append("sec-websocket-protocol", A);
            return c({
              request: i,
              useParallelQueue: !0,
              dispatcher: o.dispatcher ?? u(),
              processResponse(A) {
                if ("error" === A.type || 101 !== A.status)
                  return void n(
                    t,
                    "Received network error or non-101 status code."
                  );
                if (
                  0 !== e.length &&
                  !A.headersList.get("Sec-WebSocket-Protocol")
                )
                  return void n(
                    t,
                    "Server did not respond with sent protocols."
                  );
                if ("websocket" !== A.headersList.get("Upgrade")?.toLowerCase())
                  return void n(
                    t,
                    'Server did not set Upgrade header to "websocket".'
                  );
                if (
                  "upgrade" !== A.headersList.get("Connection")?.toLowerCase()
                )
                  return void n(
                    t,
                    'Server did not set Connection header to "upgrade".'
                  );
                if (
                  A.headersList.get("Sec-WebSocket-Accept") !==
                  r
                    .createHash("sha1")
                    .update(g + Q)
                    .digest("base64")
                )
                  return void n(
                    t,
                    "Incorrect hash received in Sec-WebSocket-Accept header."
                  );
                const o = A.headersList.get("Sec-WebSocket-Extensions");
                if (null !== o && "" !== o)
                  return void n(
                    t,
                    "Received different permessage-deflate than the one set."
                  );
                const s = A.headersList.get("Sec-WebSocket-Protocol");
                null === s || s === i.headersList.get("Sec-WebSocket-Protocol")
                  ? (A.socket.on("data", onSocketData),
                    A.socket.on("close", onSocketClose),
                    A.socket.on("error", onSocketError),
                    R.open.hasSubscribers &&
                      R.open.publish({
                        address: A.socket.address(),
                        protocol: s,
                        extensions: o,
                      }),
                    E(A))
                  : n(t, "Protocol was not set in the opening handshake.");
              },
            });
          }
          function onSocketData(A) {
            this.ws[B].write(A) || this.pause();
          }
          function onSocketClose() {
            const { ws: A } = this,
              e = A[g] && A[C];
            let t = 1005,
              r = "";
            const E = A[B].closingInfo;
            E ? ((t = E.code ?? 1005), (r = E.reason)) : A[g] || (t = 1006),
              (A[s] = o.CLOSED),
              I("close", A, a, { wasClean: e, code: t, reason: r }),
              R.close.hasSubscribers &&
                R.close.publish({ websocket: A, code: t, reason: r });
          }
          function onSocketError(A) {
            const { ws: e } = this;
            (e[s] = o.CLOSING),
              R.socketError.hasSubscribers && R.socketError.publish(A),
              this.destroy();
          }
          __name(establishWebSocketConnection, "establishWebSocketConnection"),
            __name(onSocketData, "onSocketData"),
            __name(onSocketClose, "onSocketClose"),
            __name(onSocketError, "onSocketError"),
            (t.exports = {
              establishWebSocketConnection: establishWebSocketConnection,
            });
        },
      }),
      sA = __commonJS({
        "lib/websocket/frame.js"(A, t) {
          var r,
            { maxUnsigned16Bit: E } = tA();
          try {
            r = e("crypto");
          } catch {}
          var Q = class {
            static {
              __name(this, "WebsocketFrameSend");
            }
            constructor(A) {
              (this.frameData = A), (this.maskKey = r.randomBytes(4));
            }
            createFrame(A) {
              const e = this.frameData?.byteLength ?? 0;
              let t = e,
                r = 6;
              e > E ? ((r += 8), (t = 127)) : e > 125 && ((r += 2), (t = 126));
              const Q = Buffer.allocUnsafe(e + r);
              (Q[0] = Q[1] = 0),
                (Q[0] |= 128),
                (Q[0] = (240 & Q[0]) + A),
                (Q[r - 4] = this.maskKey[0]),
                (Q[r - 3] = this.maskKey[1]),
                (Q[r - 2] = this.maskKey[2]),
                (Q[r - 1] = this.maskKey[3]),
                (Q[1] = t),
                126 === t
                  ? Q.writeUInt16BE(e, 2)
                  : 127 === t && ((Q[2] = Q[3] = 0), Q.writeUIntBE(e, 4, 6)),
                (Q[1] |= 128);
              for (let A = 0; A < e; A++)
                Q[r + A] = this.frameData[A] ^ this.maskKey[A % 4];
              return Q;
            }
          };
          t.exports = { WebsocketFrameSend: Q };
        },
      }),
      iA = __commonJS({
        "lib/websocket/receiver.js"(A, t) {
          var { Writable: r } = e("stream"),
            E = e("diagnostics_channel"),
            { parserStates: Q, opcodes: o, states: s, emptyBuffer: i } = tA(),
            {
              kReadyState: g,
              kSentClose: B,
              kResponse: C,
              kReceivedClose: I,
            } = rA(),
            {
              isValidStatusCode: n,
              failWebsocketConnection: a,
              websocketMessageReceived: h,
            } = QA(),
            { WebsocketFrameSend: c } = sA(),
            l = {};
          (l.ping = E.channel("undici:websocket:ping")),
            (l.pong = E.channel("undici:websocket:pong"));
          var d = class extends r {
            static {
              __name(this, "ByteParser");
            }
            #e = [];
            #t = 0;
            #r = Q.INFO;
            #E = {};
            #Q = [];
            constructor(A) {
              super(), (this.ws = A);
            }
            _write(A, e, t) {
              this.#e.push(A), (this.#t += A.length), this.run(t);
            }
            run(A) {
              for (;;) {
                if (this.#r === Q.INFO) {
                  if (this.#t < 2) return A();
                  const e = this.consume(2);
                  if (
                    ((this.#E.fin = 0 != (128 & e[0])),
                    (this.#E.opcode = 15 & e[0]),
                    (this.#E.originalOpcode ??= this.#E.opcode),
                    (this.#E.fragmented =
                      !this.#E.fin && this.#E.opcode !== o.CONTINUATION),
                    this.#E.fragmented &&
                      this.#E.opcode !== o.BINARY &&
                      this.#E.opcode !== o.TEXT)
                  )
                    return void a(
                      this.ws,
                      "Invalid frame type was fragmented."
                    );
                  const t = 127 & e[1];
                  if (
                    (t <= 125
                      ? ((this.#E.payloadLength = t), (this.#r = Q.READ_DATA))
                      : 126 === t
                      ? (this.#r = Q.PAYLOADLENGTH_16)
                      : 127 === t && (this.#r = Q.PAYLOADLENGTH_64),
                    this.#E.fragmented && t > 125)
                  )
                    return void a(
                      this.ws,
                      "Fragmented frame exceeded 125 bytes."
                    );
                  if (
                    (this.#E.opcode === o.PING ||
                      this.#E.opcode === o.PONG ||
                      this.#E.opcode === o.CLOSE) &&
                    t > 125
                  )
                    return void a(
                      this.ws,
                      "Payload length for control frame exceeded 125 bytes."
                    );
                  if (this.#E.opcode === o.CLOSE) {
                    if (1 === t)
                      return void a(
                        this.ws,
                        "Received close frame with a 1-byte body."
                      );
                    const A = this.consume(t);
                    if (
                      ((this.#E.closeInfo = this.parseCloseBody(!1, A)),
                      !this.ws[B])
                    ) {
                      const A = Buffer.allocUnsafe(2);
                      A.writeUInt16BE(this.#E.closeInfo.code, 0);
                      const e = new c(A);
                      this.ws[C].socket.write(e.createFrame(o.CLOSE), (A) => {
                        A || (this.ws[B] = !0);
                      });
                    }
                    return (
                      (this.ws[g] = s.CLOSING),
                      (this.ws[I] = !0),
                      void this.end()
                    );
                  }
                  if (this.#E.opcode === o.PING) {
                    const e = this.consume(t);
                    if (!this.ws[I]) {
                      const A = new c(e);
                      this.ws[C].socket.write(A.createFrame(o.PONG)),
                        l.ping.hasSubscribers && l.ping.publish({ payload: e });
                    }
                    if (((this.#r = Q.INFO), this.#t > 0)) continue;
                    return void A();
                  }
                  if (this.#E.opcode === o.PONG) {
                    const e = this.consume(t);
                    if (
                      (l.pong.hasSubscribers && l.pong.publish({ payload: e }),
                      this.#t > 0)
                    )
                      continue;
                    return void A();
                  }
                } else if (this.#r === Q.PAYLOADLENGTH_16) {
                  if (this.#t < 2) return A();
                  const e = this.consume(2);
                  (this.#E.payloadLength = e.readUInt16BE(0)),
                    (this.#r = Q.READ_DATA);
                } else if (this.#r === Q.PAYLOADLENGTH_64) {
                  if (this.#t < 8) return A();
                  const e = this.consume(8),
                    t = e.readUInt32BE(0);
                  if (t > 2 ** 31 - 1)
                    return void a(
                      this.ws,
                      "Received payload length > 2^31 bytes."
                    );
                  const r = e.readUInt32BE(4);
                  (this.#E.payloadLength = (t << 8) + r),
                    (this.#r = Q.READ_DATA);
                } else if (this.#r === Q.READ_DATA) {
                  if (this.#t < this.#E.payloadLength) return A();
                  if (this.#t >= this.#E.payloadLength) {
                    const A = this.consume(this.#E.payloadLength);
                    if (
                      (this.#Q.push(A),
                      !this.#E.fragmented ||
                        (this.#E.fin && this.#E.opcode === o.CONTINUATION))
                    ) {
                      const A = Buffer.concat(this.#Q);
                      h(this.ws, this.#E.originalOpcode, A),
                        (this.#E = {}),
                        (this.#Q.length = 0);
                    }
                    this.#r = Q.INFO;
                  }
                }
                if (!(this.#t > 0)) {
                  A();
                  break;
                }
              }
            }
            consume(A) {
              if (A > this.#t) return null;
              if (0 === A) return i;
              if (this.#e[0].length === A)
                return (this.#t -= this.#e[0].length), this.#e.shift();
              const e = Buffer.allocUnsafe(A);
              let t = 0;
              for (; t !== A; ) {
                const r = this.#e[0],
                  { length: E } = r;
                if (E + t === A) {
                  e.set(this.#e.shift(), t);
                  break;
                }
                if (E + t > A) {
                  e.set(r.subarray(0, A - t), t),
                    (this.#e[0] = r.subarray(A - t));
                  break;
                }
                e.set(this.#e.shift(), t), (t += r.length);
              }
              return (this.#t -= A), e;
            }
            parseCloseBody(A, e) {
              let t;
              if ((e.length >= 2 && (t = e.readUInt16BE(0)), A))
                return n(t) ? { code: t } : null;
              let r = e.subarray(2);
              if (
                (239 === r[0] &&
                  187 === r[1] &&
                  191 === r[2] &&
                  (r = r.subarray(3)),
                void 0 !== t && !n(t))
              )
                return null;
              try {
                r = new TextDecoder("utf-8", { fatal: !0 }).decode(r);
              } catch {
                return null;
              }
              return { code: t, reason: r };
            }
            get closingInfo() {
              return this.#E.closeInfo;
            }
          };
          t.exports = { ByteParser: d };
        },
      }),
      gA = __commonJS({
        "lib/websocket/websocket.js"(A, t) {
          var { webidl: E } = c(),
            { DOMException: Q } = n(),
            { URLSerializer: o } = b(),
            { getGlobalOrigin: s } = a(),
            {
              staticPropertyDescriptors: i,
              states: g,
              opcodes: B,
              emptyBuffer: C,
            } = tA(),
            {
              kWebSocketURL: h,
              kReadyState: l,
              kController: d,
              kBinaryType: u,
              kResponse: D,
              kSentClose: R,
              kByteParser: y,
            } = rA(),
            {
              isEstablished: f,
              isClosing: w,
              isValidSubprotocol: F,
              failWebsocketConnection: k,
              fireEvent: N,
            } = QA(),
            { establishWebSocketConnection: p } = oA(),
            { WebsocketFrameSend: S } = sA(),
            { ByteParser: U } = iA(),
            { kEnumerableProperty: m, isBlobLike: L } = I(),
            { getGlobalDispatcher: M } = AA(),
            { types: Y } = e("util"),
            J = !1,
            G = class _WebSocket extends EventTarget {
              static {
                __name(this, "WebSocket");
              }
              #o = { open: null, error: null, close: null, message: null };
              #s = 0;
              #i = "";
              #g = "";
              constructor(A, e = []) {
                super(),
                  E.argumentLengthCheck(arguments, 1, {
                    header: "WebSocket constructor",
                  }),
                  J ||
                    ((J = !0),
                    r.emitWarning(
                      "WebSockets are experimental, expect them to change at any time.",
                      { code: "UNDICI-WS" }
                    ));
                const t =
                  E.converters[
                    "DOMString or sequence<DOMString> or WebSocketInit"
                  ](e);
                (A = E.converters.USVString(A)), (e = t.protocols);
                const o = s();
                let i;
                try {
                  i = new URL(A, o);
                } catch (A) {
                  throw new Q(A, "SyntaxError");
                }
                if (
                  ("http:" === i.protocol
                    ? (i.protocol = "ws:")
                    : "https:" === i.protocol && (i.protocol = "wss:"),
                  "ws:" !== i.protocol && "wss:" !== i.protocol)
                )
                  throw new Q(
                    `Expected a ws: or wss: protocol, got ${i.protocol}`,
                    "SyntaxError"
                  );
                if (i.hash || i.href.endsWith("#"))
                  throw new Q("Got fragment", "SyntaxError");
                if (
                  ("string" == typeof e && (e = [e]),
                  e.length !== new Set(e.map((A) => A.toLowerCase())).size)
                )
                  throw new Q(
                    "Invalid Sec-WebSocket-Protocol value",
                    "SyntaxError"
                  );
                if (e.length > 0 && !e.every((A) => F(A)))
                  throw new Q(
                    "Invalid Sec-WebSocket-Protocol value",
                    "SyntaxError"
                  );
                (this[h] = new URL(i.href)),
                  (this[d] = p(i, e, this, (A) => this.#B(A), t)),
                  (this[l] = _WebSocket.CONNECTING),
                  (this[u] = "blob");
              }
              close(A = void 0, e = void 0) {
                if (
                  (E.brandCheck(this, _WebSocket),
                  void 0 !== A &&
                    (A = E.converters["unsigned short"](A, { clamp: !0 })),
                  void 0 !== e && (e = E.converters.USVString(e)),
                  void 0 !== A && 1e3 !== A && (A < 3e3 || A > 4999))
                )
                  throw new Q("invalid code", "InvalidAccessError");
                let t = 0;
                if (void 0 !== e && ((t = Buffer.byteLength(e)), t > 123))
                  throw new Q(
                    `Reason must be less than 123 bytes; received ${t}`,
                    "SyntaxError"
                  );
                if (
                  this[l] === _WebSocket.CLOSING ||
                  this[l] === _WebSocket.CLOSED
                );
                else if (f(this))
                  if (w(this)) this[l] = _WebSocket.CLOSING;
                  else {
                    const r = new S();
                    void 0 !== A && void 0 === e
                      ? ((r.frameData = Buffer.allocUnsafe(2)),
                        r.frameData.writeUInt16BE(A, 0))
                      : void 0 !== A && void 0 !== e
                      ? ((r.frameData = Buffer.allocUnsafe(2 + t)),
                        r.frameData.writeUInt16BE(A, 0),
                        r.frameData.write(e, 2, "utf-8"))
                      : (r.frameData = C);
                    this[D].socket.write(r.createFrame(B.CLOSE), (A) => {
                      A || (this[R] = !0);
                    }),
                      (this[l] = g.CLOSING);
                  }
                else
                  k(this, "Connection was closed before it was established."),
                    (this[l] = _WebSocket.CLOSING);
              }
              send(A) {
                if (
                  (E.brandCheck(this, _WebSocket),
                  E.argumentLengthCheck(arguments, 1, {
                    header: "WebSocket.send",
                  }),
                  (A = E.converters.WebSocketSendData(A)),
                  this[l] === _WebSocket.CONNECTING)
                )
                  throw new Q("Sent before connected.", "InvalidStateError");
                if (!f(this) || w(this)) return;
                const e = this[D].socket;
                if ("string" == typeof A) {
                  const t = Buffer.from(A),
                    r = new S(t).createFrame(B.TEXT);
                  (this.#s += t.byteLength),
                    e.write(r, () => {
                      this.#s -= t.byteLength;
                    });
                } else if (Y.isArrayBuffer(A)) {
                  const t = Buffer.from(A),
                    r = new S(t).createFrame(B.BINARY);
                  (this.#s += t.byteLength),
                    e.write(r, () => {
                      this.#s -= t.byteLength;
                    });
                } else if (ArrayBuffer.isView(A)) {
                  const t = Buffer.from(A, A.byteOffset, A.byteLength),
                    r = new S(t).createFrame(B.BINARY);
                  (this.#s += t.byteLength),
                    e.write(r, () => {
                      this.#s -= t.byteLength;
                    });
                } else if (L(A)) {
                  const t = new S();
                  A.arrayBuffer().then((A) => {
                    const r = Buffer.from(A);
                    t.frameData = r;
                    const E = t.createFrame(B.BINARY);
                    (this.#s += r.byteLength),
                      e.write(E, () => {
                        this.#s -= r.byteLength;
                      });
                  });
                }
              }
              get readyState() {
                return E.brandCheck(this, _WebSocket), this[l];
              }
              get bufferedAmount() {
                return E.brandCheck(this, _WebSocket), this.#s;
              }
              get url() {
                return E.brandCheck(this, _WebSocket), o(this[h]);
              }
              get extensions() {
                return E.brandCheck(this, _WebSocket), this.#g;
              }
              get protocol() {
                return E.brandCheck(this, _WebSocket), this.#i;
              }
              get onopen() {
                return E.brandCheck(this, _WebSocket), this.#o.open;
              }
              set onopen(A) {
                E.brandCheck(this, _WebSocket),
                  this.#o.open &&
                    this.removeEventListener("open", this.#o.open),
                  "function" == typeof A
                    ? ((this.#o.open = A), this.addEventListener("open", A))
                    : (this.#o.open = null);
              }
              get onerror() {
                return E.brandCheck(this, _WebSocket), this.#o.error;
              }
              set onerror(A) {
                E.brandCheck(this, _WebSocket),
                  this.#o.error &&
                    this.removeEventListener("error", this.#o.error),
                  "function" == typeof A
                    ? ((this.#o.error = A), this.addEventListener("error", A))
                    : (this.#o.error = null);
              }
              get onclose() {
                return E.brandCheck(this, _WebSocket), this.#o.close;
              }
              set onclose(A) {
                E.brandCheck(this, _WebSocket),
                  this.#o.close &&
                    this.removeEventListener("close", this.#o.close),
                  "function" == typeof A
                    ? ((this.#o.close = A), this.addEventListener("close", A))
                    : (this.#o.close = null);
              }
              get onmessage() {
                return E.brandCheck(this, _WebSocket), this.#o.message;
              }
              set onmessage(A) {
                E.brandCheck(this, _WebSocket),
                  this.#o.message &&
                    this.removeEventListener("message", this.#o.message),
                  "function" == typeof A
                    ? ((this.#o.message = A),
                      this.addEventListener("message", A))
                    : (this.#o.message = null);
              }
              get binaryType() {
                return E.brandCheck(this, _WebSocket), this[u];
              }
              set binaryType(A) {
                E.brandCheck(this, _WebSocket),
                  (this[u] = "blob" !== A && "arraybuffer" !== A ? "blob" : A);
              }
              #B(A) {
                this[D] = A;
                const e = new U(this);
                e.on(
                  "drain",
                  __name(function onParserDrain() {
                    this.ws[D].socket.resume();
                  }, "onParserDrain")
                ),
                  (A.socket.ws = this),
                  (this[y] = e),
                  (this[l] = g.OPEN);
                const t = A.headersList.get("sec-websocket-extensions");
                null !== t && (this.#g = t);
                const r = A.headersList.get("sec-websocket-protocol");
                null !== r && (this.#i = r), N("open", this);
              }
            };
          (G.CONNECTING = G.prototype.CONNECTING = g.CONNECTING),
            (G.OPEN = G.prototype.OPEN = g.OPEN),
            (G.CLOSING = G.prototype.CLOSING = g.CLOSING),
            (G.CLOSED = G.prototype.CLOSED = g.CLOSED),
            Object.defineProperties(G.prototype, {
              CONNECTING: i,
              OPEN: i,
              CLOSING: i,
              CLOSED: i,
              url: m,
              readyState: m,
              bufferedAmount: m,
              onopen: m,
              onerror: m,
              onclose: m,
              close: m,
              onmessage: m,
              binaryType: m,
              send: m,
              extensions: m,
              protocol: m,
              [Symbol.toStringTag]: {
                value: "WebSocket",
                writable: !1,
                enumerable: !1,
                configurable: !0,
              },
            }),
            Object.defineProperties(G, {
              CONNECTING: i,
              OPEN: i,
              CLOSING: i,
              CLOSED: i,
            }),
            (E.converters["sequence<DOMString>"] = E.sequenceConverter(
              E.converters.DOMString
            )),
            (E.converters["DOMString or sequence<DOMString>"] = function (A) {
              return "Object" === E.util.Type(A) && Symbol.iterator in A
                ? E.converters["sequence<DOMString>"](A)
                : E.converters.DOMString(A);
            }),
            (E.converters.WebSocketInit = E.dictionaryConverter([
              {
                key: "protocols",
                converter: E.converters["DOMString or sequence<DOMString>"],
                get defaultValue() {
                  return [];
                },
              },
              {
                key: "dispatcher",
                converter: (A) => A,
                get defaultValue() {
                  return M();
                },
              },
              {
                key: "headers",
                converter: E.nullableConverter(E.converters.HeadersInit),
              },
            ])),
            (E.converters["DOMString or sequence<DOMString> or WebSocketInit"] =
              function (A) {
                return "Object" !== E.util.Type(A) || Symbol.iterator in A
                  ? {
                      protocols:
                        E.converters["DOMString or sequence<DOMString>"](A),
                    }
                  : E.converters.WebSocketInit(A);
              }),
            (E.converters.WebSocketSendData = function (A) {
              if ("Object" === E.util.Type(A)) {
                if (L(A)) return E.converters.Blob(A, { strict: !1 });
                if (ArrayBuffer.isView(A) || Y.isAnyArrayBuffer(A))
                  return E.converters.BufferSource(A);
              }
              return E.converters.USVString(A);
            }),
            (t.exports = { WebSocket: G });
        },
      }),
      BA = eA().fetch;
    (t.exports.fetch = __name(function fetch(A, e = void 0) {
      return BA(A, e).catch((A) => {
        throw (Error.captureStackTrace(A, this), A);
      });
    }, "fetch")),
      (t.exports.FormData = m().FormData),
      (t.exports.Headers = l().Headers),
      (t.exports.Response = M().Response),
      (t.exports.Request = J().Request),
      (t.exports.WebSocket = gA().WebSocket);
  },
  "internal/dgram": function (n, e, o, t, l, u) {
    "use strict";
    const { FunctionPrototypeBind: i, Symbol: r } = u,
      { codes: c } = e("internal/errors"),
      { UDP: d } = l("udp_wrap"),
      { guessHandleType: s } = l("util"),
      { isInt32: a, validateFunction: p } = e("internal/validators"),
      { UV_EINVAL: k } = l("uv"),
      { ERR_SOCKET_BAD_TYPE: _ } = c,
      w = r("state symbol");
    let f;
    function lookup4(n, e, o) {
      return n(e || "127.0.0.1", 4, o);
    }
    function lookup6(n, e, o) {
      return n(e || "::1", 6, o);
    }
    function newHandle(n, o) {
      if (
        (void 0 === o
          ? (void 0 === f && (f = e("dns")), (o = f.lookup))
          : p(o, "lookup"),
        "udp4" === n)
      ) {
        const n = new d();
        return (n.lookup = i(lookup4, n, o)), n;
      }
      if ("udp6" === n) {
        const n = new d();
        return (
          (n.lookup = i(lookup6, n, o)),
          (n.bind = n.bind6),
          (n.connect = n.connect6),
          (n.send = n.send6),
          n
        );
      }
      throw new _();
    }
    o.exports = {
      kStateSymbol: w,
      _createSocketHandle: function _createSocketHandle(n, e, o, t, l) {
        const u = newHandle(o);
        let i;
        if (a(t) && t > 0) {
          i = "UDP" !== s(t) ? k : u.open(t);
        } else (e || n) && (i = u.bind(n, e || 0, l));
        return i ? (u.close(), i) : u;
      },
      newHandle: newHandle,
    };
  },
  "internal/dns/callback_resolver": function (e, t, n, r, o, s) {
    "use strict";
    const {
        ObjectDefineProperty: l,
        ReflectApply: i,
        ArrayPrototypeMap: a,
        Symbol: c,
      } = s,
      {
        codes: { ERR_INVALID_ARG_TYPE: p, ERR_INVALID_ARG_VALUE: u },
        dnsException: f,
      } = t("internal/errors"),
      { createResolverClass: h } = t("internal/dns/utils"),
      { validateFunction: d, validateString: v } = t("internal/validators"),
      { QueryReqWrap: y } = o("cares_wrap"),
      {
        hasObserver: _,
        startPerf: R,
        stopPerf: b,
      } = t("internal/perf/observe"),
      m = c("kPerfHooksDnsLookupResolveContext");
    function onresolve(e, t, n) {
      n && this.ttl && (t = a(t, (e, t) => ({ address: e, ttl: n[t] }))),
        e
          ? this.callback(f(e, this.bindingName, this.hostname))
          : (this.callback(null, t),
            this[m] && _("dns") && b(this, m, { detail: { result: t } }));
    }
    const { Resolver: A, resolveMap: k } = h(function resolver(e) {
      function query(t, n) {
        let r;
        arguments.length > 2 && ((r = n), (n = arguments[2])),
          v(t, "name"),
          d(n, "callback");
        const o = new y();
        (o.bindingName = e),
          (o.callback = n),
          (o.hostname = t),
          (o.oncomplete = onresolve),
          (o.ttl = !(!r || !r.ttl));
        const s = this._handle[e](o, t);
        if (s) throw f(s, e, t);
        return (
          _("dns") &&
            R(o, m, { type: "dns", name: e, detail: { host: t, ttl: o.ttl } }),
          o
        );
      }
      return l(query, "name", { __proto__: null, value: e }), query;
    });
    (A.prototype.resolve = function resolve(e, t, n) {
      let r;
      if ("string" == typeof t) r = k[t];
      else {
        if ("function" != typeof t) throw new p("rrtype", "string", t);
        (r = k.A), (n = t);
      }
      if ("function" == typeof r) return i(r, this, [e, n]);
      throw new u("rrtype", t);
    }),
      (n.exports = { Resolver: A });
  },
  "internal/dns/promises": function (e, t, o, n, s, r) {
    "use strict";
    const {
        ArrayPrototypeMap: i,
        ObjectDefineProperty: l,
        Promise: a,
        ReflectApply: d,
        Symbol: u,
      } = r,
      {
        bindDefaultResolver: f,
        createResolverClass: c,
        validateHints: p,
        emitInvalidHostnameWarning: v,
        getDefaultVerbatim: h,
        errorCodes: m,
        getDefaultResultOrder: A,
        setDefaultResultOrder: R,
        setDefaultResolver: D,
      } = t("internal/dns/utils"),
      {
        NODATA: E,
        FORMERR: N,
        SERVFAIL: I,
        NOTFOUND: O,
        NOTIMP: y,
        REFUSED: S,
        BADQUERY: T,
        BADNAME: L,
        BADFAMILY: P,
        BADRESP: k,
        CONNREFUSED: M,
        TIMEOUT: F,
        EOF: b,
        FILE: g,
        NOMEM: _,
        DESTRUCTION: w,
        BADSTR: B,
        BADFLAGS: C,
        NONAME: U,
        BADHINTS: j,
        NOTINITIALIZED: G,
        LOADIPHLPAPI: H,
        ADDRGETNETWORKPARAMS: x,
        CANCELLED: q,
      } = m,
      { codes: V, dnsException: W } = t("internal/errors"),
      { isIP: Y } = t("internal/net"),
      {
        getaddrinfo: Q,
        getnameinfo: K,
        GetAddrInfoReqWrap: Z,
        GetNameInfoReqWrap: z,
        QueryReqWrap: J,
      } = s("cares_wrap"),
      {
        ERR_INVALID_ARG_TYPE: X,
        ERR_INVALID_ARG_VALUE: $,
        ERR_MISSING_ARGS: ee,
      } = V,
      {
        validateBoolean: te,
        validateNumber: oe,
        validateOneOf: ne,
        validatePort: se,
        validateString: re,
      } = t("internal/validators"),
      ie = u("kPerfHooksDnsLookupContext"),
      le = u("kPerfHooksDnsLookupServiceContext"),
      ae = u("kPerfHooksDnsLookupResolveContext"),
      {
        hasObserver: de,
        startPerf: ue,
        stopPerf: fe,
      } = t("internal/perf/observe");
    function onlookup(e, t) {
      if (e) return void this.reject(W(e, "getaddrinfo", this.hostname));
      const o = this.family || Y(t[0]);
      this.resolve({ address: t[0], family: o }),
        this[ie] && de("dns") && fe(this, ie, { detail: { addresses: t } });
    }
    function onlookupall(e, t) {
      if (e) return void this.reject(W(e, "getaddrinfo", this.hostname));
      const o = this.family;
      for (let e = 0; e < t.length; e++) {
        const n = t[e];
        t[e] = { address: n, family: o || Y(t[e]) };
      }
      this.resolve(t),
        this[ie] && de("dns") && fe(this, ie, { detail: { addresses: t } });
    }
    const ce = [0, 4, 6];
    function onlookupservice(e, t, o) {
      e
        ? this.reject(W(e, "getnameinfo", this.host))
        : (this.resolve({ hostname: t, service: o }),
          this[le] &&
            de("dns") &&
            fe(this, le, { detail: { hostname: t, service: o } }));
    }
    function onresolve(e, t, o) {
      e
        ? this.reject(W(e, this.bindingName, this.hostname))
        : (o && this.ttl && (t = i(t, (e, t) => ({ address: e, ttl: o[t] }))),
          this.resolve(t),
          this[ae] && de("dns") && fe(this, ae, { detail: { result: t } }));
    }
    const { Resolver: pe, resolveMap: ve } = c(function resolver(e) {
      function query(t, o) {
        re(t, "name");
        const n = !(!o || !o.ttl);
        return (function createResolverPromise(e, t, o, n) {
          return new a((s, r) => {
            const i = new J();
            (i.bindingName = t),
              (i.hostname = o),
              (i.oncomplete = onresolve),
              (i.resolve = s),
              (i.reject = r),
              (i.ttl = n);
            const l = e._handle[t](i, o);
            l
              ? r(W(l, t, o))
              : de("dns") &&
                ue(i, ae, {
                  type: "dns",
                  name: t,
                  detail: { host: o, ttl: n },
                });
          });
        })(this, e, t, n);
      }
      return l(query, "name", { __proto__: null, value: e }), query;
    });
    (pe.prototype.resolve = function resolve(e, t) {
      let o;
      if (void 0 !== t) {
        if ((re(t, "rrtype"), (o = ve[t]), "function" != typeof o))
          throw new $("rrtype", t);
      } else o = ve.A;
      return d(o, this, [e]);
    }),
      (o.exports = {
        lookup: function lookup(e, t) {
          let o = 0,
            n = 0,
            s = !1,
            r = h();
          if ((e && re(e, "hostname"), "number" == typeof t))
            ne(t, "family", ce), (n = t);
          else {
            if (void 0 !== t && "object" != typeof t)
              throw new X("options", ["integer", "object"], t);
            null != t?.hints &&
              (oe(t.hints, "options.hints"), (o = t.hints >>> 0), p(o)),
              null != t?.family &&
                (ne(t.family, "options.family", ce), (n = t.family)),
              null != t?.all && (te(t.all, "options.all"), (s = t.all)),
              null != t?.verbatim &&
                (te(t.verbatim, "options.verbatim"), (r = t.verbatim));
          }
          return (function createLookupPromise(e, t, o, n, s) {
            return new a((r, i) => {
              if (!t)
                return (
                  v(t),
                  void r(o ? [] : { address: null, family: 6 === e ? 6 : 4 })
                );
              const l = Y(t);
              if (0 !== l) {
                const e = { address: t, family: l };
                return void r(o ? [e] : e);
              }
              const a = new Z();
              (a.family = e),
                (a.hostname = t),
                (a.oncomplete = o ? onlookupall : onlookup),
                (a.resolve = r),
                (a.reject = i);
              const d = Q(a, t, e, n, s);
              d
                ? i(W(d, "getaddrinfo", t))
                : de("dns") &&
                  ue(a, ie, {
                    type: "dns",
                    name: "lookup",
                    detail: { hostname: t, family: e, hints: n, verbatim: s },
                  });
            });
          })(n, e, s, o, r);
        },
        lookupService: function lookupService(e, t) {
          if (2 !== arguments.length) throw new ee("address", "port");
          if (0 === Y(e)) throw new $("address", e);
          return (
            se(t),
            (function createLookupServicePromise(e, t) {
              return new a((o, n) => {
                const s = new z();
                (s.hostname = e),
                  (s.port = t),
                  (s.oncomplete = onlookupservice),
                  (s.resolve = o),
                  (s.reject = n);
                const r = K(s, e, t);
                r
                  ? n(W(r, "getnameinfo", e))
                  : de("dns") &&
                    ue(s, le, {
                      type: "dns",
                      name: "lookupService",
                      detail: { host: e, port: t },
                    });
              });
            })(e, +t)
          );
        },
        Resolver: pe,
        getDefaultResultOrder: A,
        setDefaultResultOrder: R,
        setServers: function defaultResolverSetServers(e) {
          const t = new pe();
          t.setServers(e), D(t), f(o.exports, pe.prototype);
        },
        NODATA: E,
        FORMERR: N,
        SERVFAIL: I,
        NOTFOUND: O,
        NOTIMP: y,
        REFUSED: S,
        BADQUERY: T,
        BADNAME: L,
        BADFAMILY: P,
        BADRESP: k,
        CONNREFUSED: M,
        TIMEOUT: F,
        EOF: b,
        FILE: g,
        NOMEM: _,
        DESTRUCTION: w,
        BADSTR: B,
        BADFLAGS: C,
        NONAME: U,
        BADHINTS: j,
        NOTINITIALIZED: G,
        LOADIPHLPAPI: H,
        ADDRGETNETWORKPARAMS: x,
        CANCELLED: q,
      }),
      f(o.exports, pe.prototype);
  },
  "internal/dns/utils": function (e, t, r, s, o, n) {
    "use strict";
    const {
        ArrayPrototypeForEach: i,
        ArrayPrototypeJoin: l,
        ArrayPrototypeMap: a,
        ArrayPrototypePush: v,
        FunctionPrototypeBind: A,
        NumberParseInt: d,
        RegExpPrototypeExec: u,
        RegExpPrototypeSymbolReplace: E,
        ObjectCreate: R,
        Symbol: c,
      } = n,
      p = t("internal/errors"),
      { isIP: D } = t("internal/net"),
      { getOptionValue: y } = t("internal/options"),
      {
        validateArray: N,
        validateInt32: S,
        validateOneOf: T,
        validateString: f,
      } = t("internal/validators");
    let I;
    function lazyBinding() {
      return (I ??= o("cares_wrap")), I;
    }
    const h = /^\[([^[\]]*)\]/,
      O = /(^.+?)(?::(\d+))?$/,
      {
        ERR_DNS_SET_SERVERS_FAILED: P,
        ERR_INVALID_ARG_VALUE: m,
        ERR_INVALID_IP_ADDRESS: g,
      } = p.codes,
      {
        namespace: {
          addSerializeCallback: L,
          addDeserializeCallback: _,
          isBuildingSnapshot: M,
        },
      } = t("internal/v8/startup_snapshot");
    function validateTimeout(e) {
      const { timeout: t = -1 } = { ...e };
      return S(t, "options.timeout", -1), t;
    }
    function validateTries(e) {
      const { tries: t = 4 } = { ...e };
      return S(t, "options.tries", 1), t;
    }
    const B = c("dns:resolver:serialize"),
      C = c("dns:resolver:deserialize"),
      F = c("dns:resolver:config"),
      b = c("dns:resolver:initializeHandle"),
      U = c("dns:resolver:setServers");
    class ResolverBase {
      constructor(e = void 0) {
        const t = validateTimeout(e),
          r = validateTries(e);
        M() && (this[F] = { timeout: t, tries: r }), this[b](t, r);
      }
      [b](e, t) {
        const { ChannelWrap: r } = lazyBinding();
        this._handle = new r(e, t);
      }
      cancel() {
        this._handle.cancel();
      }
      getServers() {
        return a(this._handle.getServers() || [], (e) => {
          if (!e[1] || 53 === e[1]) return e[0];
          return `${6 === D(e[0]) ? `[${e[0]}]` : e[0]}:${e[1]}`;
        });
      }
      setServers(e) {
        N(e, "servers");
        const t = [];
        i(e, (e, r) => {
          f(e, `servers[${r}]`);
          let s = D(e);
          if (0 !== s) return v(t, [s, e, 53]);
          const o = u(h, e);
          if (o && ((s = D(o[1])), 0 !== s)) {
            const r = d(E(O, e, "$2")) || 53;
            return v(t, [s, o[1], r]);
          }
          const n = u(O, e);
          if (n) {
            const e = n[1],
              r = n[2] || 53;
            if (((s = D(e)), 0 !== s)) return v(t, [s, e, d(r)]);
          }
          throw new g(e);
        }),
          this[U](t, e);
      }
      [U](e, t) {
        const r = this._handle.getServers() || [],
          s = this._handle.setServers(e);
        if (0 !== s) {
          this._handle.setServers(l(r, ","));
          const { strerror: e } = lazyBinding(),
            o = e(s);
          throw new P(o, t);
        }
        M() && (this[F].servers = e);
      }
      setLocalAddress(e, t) {
        f(e, "ipv4"),
          void 0 !== t && f(t, "ipv6"),
          this._handle.setLocalAddress(e, t),
          M() && (this[F].localAddress = { ipv4: e, ipv6: t });
      }
      [B]() {
        (this._handle = null),
          _(function deserializeResolver(e) {
            e[C]();
          }, this);
      }
      [C]() {
        const { timeout: e, tries: t, localAddress: r, servers: s } = this[F];
        if ((this[b](e, t), r)) {
          const { ipv4: e, ipv6: t } = r;
          this._handle.setLocalAddress(e, t);
        }
        s && this[U](s, s);
      }
    }
    let q, z;
    const x = [
      "getServers",
      "resolve",
      "resolve4",
      "resolve6",
      "resolveAny",
      "resolveCaa",
      "resolveCname",
      "resolveMx",
      "resolveNaptr",
      "resolveNs",
      "resolvePtr",
      "resolveSoa",
      "resolveSrv",
      "resolveTxt",
      "reverse",
    ];
    function getDefaultResolver() {
      return void 0 === q && (q = new ResolverBase()), q;
    }
    let V = !1;
    r.exports = {
      bindDefaultResolver: function bindDefaultResolver(e, t) {
        const r = getDefaultResolver();
        i(x, (s) => {
          e[s] = A(t[s], r);
        });
      },
      getDefaultResolver: getDefaultResolver,
      setDefaultResolver: function setDefaultResolver(e) {
        q = e;
      },
      validateHints: function validateHints(e) {
        const { AI_ADDRCONFIG: t, AI_ALL: r, AI_V4MAPPED: s } = lazyBinding();
        if (0 != (e & ~(t | r | s))) throw new m("hints", e);
      },
      validateTimeout: validateTimeout,
      validateTries: validateTries,
      emitInvalidHostnameWarning: function emitInvalidHostnameWarning(e) {
        V ||
          (s.emitWarning(
            `The provided hostname "${e}" is not a valid hostname, and is supported in the dns module solely for compatibility.`,
            "DeprecationWarning",
            "DEP0118"
          ),
          (V = !0));
      },
      getDefaultVerbatim: function getDefaultVerbatim() {
        return "ipv4first" !== z;
      },
      getDefaultResultOrder: function getDefaultResultOrder() {
        return z;
      },
      setDefaultResultOrder: function setDefaultResultOrder(e) {
        T(e, "dnsOrder", ["verbatim", "ipv4first"]), (z = e);
      },
      errorCodes: {
        NODATA: "ENODATA",
        FORMERR: "EFORMERR",
        SERVFAIL: "ESERVFAIL",
        NOTFOUND: "ENOTFOUND",
        NOTIMP: "ENOTIMP",
        REFUSED: "EREFUSED",
        BADQUERY: "EBADQUERY",
        BADNAME: "EBADNAME",
        BADFAMILY: "EBADFAMILY",
        BADRESP: "EBADRESP",
        CONNREFUSED: "ECONNREFUSED",
        TIMEOUT: "ETIMEOUT",
        EOF: "EOF",
        FILE: "EFILE",
        NOMEM: "ENOMEM",
        DESTRUCTION: "EDESTRUCTION",
        BADSTR: "EBADSTR",
        BADFLAGS: "EBADFLAGS",
        NONAME: "ENONAME",
        BADHINTS: "EBADHINTS",
        NOTINITIALIZED: "ENOTINITIALIZED",
        LOADIPHLPAPI: "ELOADIPHLPAPI",
        ADDRGETNETWORKPARAMS: "EADDRGETNETWORKPARAMS",
        CANCELLED: "ECANCELLED",
      },
      createResolverClass: function createResolverClass(e) {
        const t = R(null);
        class Resolver extends ResolverBase {}
        return (
          (Resolver.prototype.resolveAny = t.ANY = e("queryAny")),
          (Resolver.prototype.resolve4 = t.A = e("queryA")),
          (Resolver.prototype.resolve6 = t.AAAA = e("queryAaaa")),
          (Resolver.prototype.resolveCaa = t.CAA = e("queryCaa")),
          (Resolver.prototype.resolveCname = t.CNAME = e("queryCname")),
          (Resolver.prototype.resolveMx = t.MX = e("queryMx")),
          (Resolver.prototype.resolveNs = t.NS = e("queryNs")),
          (Resolver.prototype.resolveTxt = t.TXT = e("queryTxt")),
          (Resolver.prototype.resolveSrv = t.SRV = e("querySrv")),
          (Resolver.prototype.resolvePtr = t.PTR = e("queryPtr")),
          (Resolver.prototype.resolveNaptr = t.NAPTR = e("queryNaptr")),
          (Resolver.prototype.resolveSoa = t.SOA = e("querySoa")),
          (Resolver.prototype.reverse = e("getHostByAddr")),
          { resolveMap: t, Resolver: Resolver }
        );
      },
      initializeDns: function initializeDns() {
        const e = y("--dns-result-order");
        e ? (z = e) : (z ??= "verbatim"),
          M() &&
            L(() => {
              q?.[B]();
            });
      },
    };
  },
  "internal/dtrace": function (E, T, _, R, N, C) {
    "use strict";
    const S = N("config"),
      {
        DTRACE_HTTP_CLIENT_REQUEST: D = () => {},
        DTRACE_HTTP_CLIENT_RESPONSE: A = () => {},
        DTRACE_HTTP_SERVER_REQUEST: P = () => {},
        DTRACE_HTTP_SERVER_RESPONSE: H = () => {},
        DTRACE_NET_SERVER_CONNECTION: O = () => {},
        DTRACE_NET_STREAM_END: t = () => {},
      } = S.hasDtrace ? N("dtrace") : {};
    _.exports = {
      DTRACE_HTTP_CLIENT_REQUEST: D,
      DTRACE_HTTP_CLIENT_RESPONSE: A,
      DTRACE_HTTP_SERVER_REQUEST: P,
      DTRACE_HTTP_SERVER_RESPONSE: H,
      DTRACE_NET_SERVER_CONNECTION: O,
      DTRACE_NET_STREAM_END: t,
    };
  },
  "internal/encoding": function (i, o, s, e, t, n) {
    "use strict";
    const {
        Boolean: r,
        ObjectCreate: c,
        ObjectDefineProperties: w,
        ObjectGetOwnPropertyDescriptors: a,
        ObjectSetPrototypeOf: d,
        ObjectValues: l,
        SafeMap: u,
        StringPrototypeSlice: f,
        Symbol: h,
        SymbolToStringTag: g,
        Uint32Array: b,
        Uint8Array: p,
      } = n,
      {
        ERR_ENCODING_NOT_SUPPORTED: _,
        ERR_INVALID_ARG_TYPE: k,
        ERR_INVALID_THIS: m,
        ERR_NO_ICU: y,
      } = o("internal/errors").codes,
      x = h("handle"),
      j = h("flags"),
      v = h("encoding"),
      E = h("decoder"),
      D = h("encoder"),
      O = h("kFatal"),
      T = h("kUTF8FastPath"),
      A = h("kIgnoreBOM"),
      {
        getConstructorOf: B,
        customInspectSymbol: I,
        kEmptyObject: S,
        kEnumerableProperty: F,
      } = o("internal/util"),
      {
        isAnyArrayBuffer: C,
        isArrayBufferView: R,
        isUint8Array: U,
      } = o("internal/util/types"),
      { validateString: L, validateObject: M } = o("internal/validators"),
      { encodeInto: P, encodeUtf8String: N, decodeUTF8: V } = t("buffer");
    let $;
    function lazyBuffer() {
      return void 0 === $ && ($ = o("buffer").Buffer), $;
    }
    function validateEncoder(i) {
      if (null == i || !0 !== i[D]) throw new m("TextEncoder");
    }
    function validateDecoder(i) {
      if (null == i || !0 !== i[E]) throw new m("TextDecoder");
    }
    const z = new p(0),
      G = new u([
        ["unicode-1-1-utf-8", "utf-8"],
        ["utf8", "utf-8"],
        ["utf-8", "utf-8"],
        ["866", "ibm866"],
        ["cp866", "ibm866"],
        ["csibm866", "ibm866"],
        ["ibm866", "ibm866"],
        ["csisolatin2", "iso-8859-2"],
        ["iso-8859-2", "iso-8859-2"],
        ["iso-ir-101", "iso-8859-2"],
        ["iso8859-2", "iso-8859-2"],
        ["iso88592", "iso-8859-2"],
        ["iso_8859-2", "iso-8859-2"],
        ["iso_8859-2:1987", "iso-8859-2"],
        ["l2", "iso-8859-2"],
        ["latin2", "iso-8859-2"],
        ["csisolatin3", "iso-8859-3"],
        ["iso-8859-3", "iso-8859-3"],
        ["iso-ir-109", "iso-8859-3"],
        ["iso8859-3", "iso-8859-3"],
        ["iso88593", "iso-8859-3"],
        ["iso_8859-3", "iso-8859-3"],
        ["iso_8859-3:1988", "iso-8859-3"],
        ["l3", "iso-8859-3"],
        ["latin3", "iso-8859-3"],
        ["csisolatin4", "iso-8859-4"],
        ["iso-8859-4", "iso-8859-4"],
        ["iso-ir-110", "iso-8859-4"],
        ["iso8859-4", "iso-8859-4"],
        ["iso88594", "iso-8859-4"],
        ["iso_8859-4", "iso-8859-4"],
        ["iso_8859-4:1988", "iso-8859-4"],
        ["l4", "iso-8859-4"],
        ["latin4", "iso-8859-4"],
        ["csisolatincyrillic", "iso-8859-5"],
        ["cyrillic", "iso-8859-5"],
        ["iso-8859-5", "iso-8859-5"],
        ["iso-ir-144", "iso-8859-5"],
        ["iso8859-5", "iso-8859-5"],
        ["iso88595", "iso-8859-5"],
        ["iso_8859-5", "iso-8859-5"],
        ["iso_8859-5:1988", "iso-8859-5"],
        ["arabic", "iso-8859-6"],
        ["asmo-708", "iso-8859-6"],
        ["csiso88596e", "iso-8859-6"],
        ["csiso88596i", "iso-8859-6"],
        ["csisolatinarabic", "iso-8859-6"],
        ["ecma-114", "iso-8859-6"],
        ["iso-8859-6", "iso-8859-6"],
        ["iso-8859-6-e", "iso-8859-6"],
        ["iso-8859-6-i", "iso-8859-6"],
        ["iso-ir-127", "iso-8859-6"],
        ["iso8859-6", "iso-8859-6"],
        ["iso88596", "iso-8859-6"],
        ["iso_8859-6", "iso-8859-6"],
        ["iso_8859-6:1987", "iso-8859-6"],
        ["csisolatingreek", "iso-8859-7"],
        ["ecma-118", "iso-8859-7"],
        ["elot_928", "iso-8859-7"],
        ["greek", "iso-8859-7"],
        ["greek8", "iso-8859-7"],
        ["iso-8859-7", "iso-8859-7"],
        ["iso-ir-126", "iso-8859-7"],
        ["iso8859-7", "iso-8859-7"],
        ["iso88597", "iso-8859-7"],
        ["iso_8859-7", "iso-8859-7"],
        ["iso_8859-7:1987", "iso-8859-7"],
        ["sun_eu_greek", "iso-8859-7"],
        ["csiso88598e", "iso-8859-8"],
        ["csisolatinhebrew", "iso-8859-8"],
        ["hebrew", "iso-8859-8"],
        ["iso-8859-8", "iso-8859-8"],
        ["iso-8859-8-e", "iso-8859-8"],
        ["iso-ir-138", "iso-8859-8"],
        ["iso8859-8", "iso-8859-8"],
        ["iso88598", "iso-8859-8"],
        ["iso_8859-8", "iso-8859-8"],
        ["iso_8859-8:1988", "iso-8859-8"],
        ["visual", "iso-8859-8"],
        ["csiso88598i", "iso-8859-8-i"],
        ["iso-8859-8-i", "iso-8859-8-i"],
        ["logical", "iso-8859-8-i"],
        ["csisolatin6", "iso-8859-10"],
        ["iso-8859-10", "iso-8859-10"],
        ["iso-ir-157", "iso-8859-10"],
        ["iso8859-10", "iso-8859-10"],
        ["iso885910", "iso-8859-10"],
        ["l6", "iso-8859-10"],
        ["latin6", "iso-8859-10"],
        ["iso-8859-13", "iso-8859-13"],
        ["iso8859-13", "iso-8859-13"],
        ["iso885913", "iso-8859-13"],
        ["iso-8859-14", "iso-8859-14"],
        ["iso8859-14", "iso-8859-14"],
        ["iso885914", "iso-8859-14"],
        ["csisolatin9", "iso-8859-15"],
        ["iso-8859-15", "iso-8859-15"],
        ["iso8859-15", "iso-8859-15"],
        ["iso885915", "iso-8859-15"],
        ["iso_8859-15", "iso-8859-15"],
        ["l9", "iso-8859-15"],
        ["cskoi8r", "koi8-r"],
        ["koi", "koi8-r"],
        ["koi8", "koi8-r"],
        ["koi8-r", "koi8-r"],
        ["koi8_r", "koi8-r"],
        ["koi8-ru", "koi8-u"],
        ["koi8-u", "koi8-u"],
        ["csmacintosh", "macintosh"],
        ["mac", "macintosh"],
        ["macintosh", "macintosh"],
        ["x-mac-roman", "macintosh"],
        ["dos-874", "windows-874"],
        ["iso-8859-11", "windows-874"],
        ["iso8859-11", "windows-874"],
        ["iso885911", "windows-874"],
        ["tis-620", "windows-874"],
        ["windows-874", "windows-874"],
        ["cp1250", "windows-1250"],
        ["windows-1250", "windows-1250"],
        ["x-cp1250", "windows-1250"],
        ["cp1251", "windows-1251"],
        ["windows-1251", "windows-1251"],
        ["x-cp1251", "windows-1251"],
        ["ansi_x3.4-1968", "windows-1252"],
        ["ascii", "windows-1252"],
        ["cp1252", "windows-1252"],
        ["cp819", "windows-1252"],
        ["csisolatin1", "windows-1252"],
        ["ibm819", "windows-1252"],
        ["iso-8859-1", "windows-1252"],
        ["iso-ir-100", "windows-1252"],
        ["iso8859-1", "windows-1252"],
        ["iso88591", "windows-1252"],
        ["iso_8859-1", "windows-1252"],
        ["iso_8859-1:1987", "windows-1252"],
        ["l1", "windows-1252"],
        ["latin1", "windows-1252"],
        ["us-ascii", "windows-1252"],
        ["windows-1252", "windows-1252"],
        ["x-cp1252", "windows-1252"],
        ["cp1253", "windows-1253"],
        ["windows-1253", "windows-1253"],
        ["x-cp1253", "windows-1253"],
        ["cp1254", "windows-1254"],
        ["csisolatin5", "windows-1254"],
        ["iso-8859-9", "windows-1254"],
        ["iso-ir-148", "windows-1254"],
        ["iso8859-9", "windows-1254"],
        ["iso88599", "windows-1254"],
        ["iso_8859-9", "windows-1254"],
        ["iso_8859-9:1989", "windows-1254"],
        ["l5", "windows-1254"],
        ["latin5", "windows-1254"],
        ["windows-1254", "windows-1254"],
        ["x-cp1254", "windows-1254"],
        ["cp1255", "windows-1255"],
        ["windows-1255", "windows-1255"],
        ["x-cp1255", "windows-1255"],
        ["cp1256", "windows-1256"],
        ["windows-1256", "windows-1256"],
        ["x-cp1256", "windows-1256"],
        ["cp1257", "windows-1257"],
        ["windows-1257", "windows-1257"],
        ["x-cp1257", "windows-1257"],
        ["cp1258", "windows-1258"],
        ["windows-1258", "windows-1258"],
        ["x-cp1258", "windows-1258"],
        ["x-mac-cyrillic", "x-mac-cyrillic"],
        ["x-mac-ukrainian", "x-mac-cyrillic"],
        ["chinese", "gbk"],
        ["csgb2312", "gbk"],
        ["csiso58gb231280", "gbk"],
        ["gb2312", "gbk"],
        ["gb_2312", "gbk"],
        ["gb_2312-80", "gbk"],
        ["gbk", "gbk"],
        ["iso-ir-58", "gbk"],
        ["x-gbk", "gbk"],
        ["gb18030", "gb18030"],
        ["big5", "big5"],
        ["big5-hkscs", "big5"],
        ["cn-big5", "big5"],
        ["csbig5", "big5"],
        ["x-x-big5", "big5"],
        ["cseucpkdfmtjapanese", "euc-jp"],
        ["euc-jp", "euc-jp"],
        ["x-euc-jp", "euc-jp"],
        ["csiso2022jp", "iso-2022-jp"],
        ["iso-2022-jp", "iso-2022-jp"],
        ["csshiftjis", "shift_jis"],
        ["ms932", "shift_jis"],
        ["ms_kanji", "shift_jis"],
        ["shift-jis", "shift_jis"],
        ["shift_jis", "shift_jis"],
        ["sjis", "shift_jis"],
        ["windows-31j", "shift_jis"],
        ["x-sjis", "shift_jis"],
        ["cseuckr", "euc-kr"],
        ["csksc56011987", "euc-kr"],
        ["euc-kr", "euc-kr"],
        ["iso-ir-149", "euc-kr"],
        ["korean", "euc-kr"],
        ["ks_c_5601-1987", "euc-kr"],
        ["ks_c_5601-1989", "euc-kr"],
        ["ksc5601", "euc-kr"],
        ["ksc_5601", "euc-kr"],
        ["windows-949", "euc-kr"],
        ["utf-16be", "utf-16be"],
        ["utf-16le", "utf-16le"],
        ["utf-16", "utf-16le"],
      ]);
    function getEncodingFromLabel(i) {
      const o = G.get(i);
      return void 0 !== o
        ? o
        : G.get(
            (function trimAsciiWhitespace(i) {
              let o = 0,
                s = i.length;
              for (
                ;
                o < s &&
                ("\t" === i[o] ||
                  "\n" === i[o] ||
                  "\f" === i[o] ||
                  "\r" === i[o] ||
                  " " === i[o]);

              )
                o++;
              for (
                ;
                s > o &&
                ("\t" === i[s - 1] ||
                  "\n" === i[s - 1] ||
                  "\f" === i[s - 1] ||
                  "\r" === i[s - 1] ||
                  " " === i[s - 1]);

              )
                s--;
              return f(i, o, s);
            })(i.toLowerCase())
          );
    }
    const H = new b(2);
    class TextEncoder {
      constructor() {
        this[D] = !0;
      }
      get encoding() {
        return validateEncoder(this), "utf-8";
      }
      encode(i = "") {
        return validateEncoder(this), N(`${i}`);
      }
      encodeInto(i, o) {
        if ((validateEncoder(this), L(i, "src"), !o || !U(o)))
          throw new k("dest", "Uint8Array", o);
        return P(i, o, H), { read: H[0], written: H[1] };
      }
      [I](i, s) {
        if ((validateEncoder(this), "number" == typeof i && i < 0)) return this;
        const e = B(this),
          t = c({ constructor: null === e ? TextEncoder : e });
        return (
          (t.encoding = this.encoding), o("internal/util/inspect").inspect(t, s)
        );
      }
    }
    w(TextEncoder.prototype, {
      encode: F,
      encodeInto: F,
      encoding: F,
      [g]: { __proto__: null, configurable: !0, value: "TextEncoder" },
    });
    const J = t("config").hasIntl
      ? (function makeTextDecoderICU() {
          const { decode: i, getConverter: o } = t("icu");
          return class TextDecoder2 {
            constructor(i = "utf-8", o = S) {
              (i = `${i}`),
                M(o, "options", {
                  nullable: !0,
                  allowArray: !0,
                  allowFunction: !0,
                });
              const s = getEncodingFromLabel(i);
              if (void 0 === s) throw new _(i);
              let e = 0;
              null !== o &&
                ((e |= o.fatal ? 2 : 0), (e |= o.ignoreBOM ? 4 : 0)),
                (this[E] = !0),
                (this[j] = e),
                (this[v] = s),
                (this[A] = r(o?.ignoreBOM)),
                (this[O] = r(o?.fatal)),
                (this[T] = "utf-8" === s),
                (this[x] = void 0),
                this[T] || this.#i();
            }
            #i() {
              if (void 0 !== this[x]) return;
              const i = o(this[v], this[j]);
              if (void 0 === i) throw new _(this[v]);
              this[x] = i;
            }
            decode(o = z, s = S) {
              if ((validateDecoder(this), (this[T] &&= !s?.stream), this[T]))
                return V(o, this[A], this[O]);
              this.#i(),
                M(s, "options", {
                  nullable: !0,
                  allowArray: !0,
                  allowFunction: !0,
                });
              let e = 0;
              return (
                null !== s && (e |= s.stream ? 0 : 1),
                i(this[x], o, e, this.encoding)
              );
            }
          };
        })()
      : (function makeTextDecoderJS() {
          let i;
          const s = h("BOM seen");
          return class TextDecoder2 {
            constructor(e = "utf-8", t = S) {
              (e = `${e}`),
                M(t, "options", {
                  nullable: !0,
                  allowArray: !0,
                  allowFunction: !0,
                });
              const n = getEncodingFromLabel(e);
              if (
                void 0 === n ||
                !(function hasConverter(i) {
                  return "utf-8" === i || "utf-16le" === i;
                })(n)
              )
                throw new _(e);
              let r = 0;
              if (null !== t) {
                if (t.fatal) throw new y('"fatal" option');
                r |= t.ignoreBOM ? 4 : 0;
              }
              (this[E] = !0),
                (this[x] = new ((function lazyStringDecoder() {
                  return (
                    void 0 === i &&
                      ({ StringDecoder: i } = o("string_decoder")),
                    i
                  );
                })())(n)),
                (this[j] = r),
                (this[v] = n),
                (this[s] = !1);
            }
            decode(i = z, o = S) {
              if ((validateDecoder(this), C(i)))
                try {
                  i = lazyBuffer().from(i);
                } catch {
                  i = z;
                }
              else {
                if (!R(i))
                  throw new k("input", ["ArrayBuffer", "ArrayBufferView"], i);
                try {
                  i = lazyBuffer().from(i.buffer, i.byteOffset, i.byteLength);
                } catch {
                  i = z;
                }
              }
              M(o, "options", {
                nullable: !0,
                allowArray: !0,
                allowFunction: !0,
              }),
                1 & this[j] && (this[s] = !1),
                null !== o && o.stream ? (this[j] &= -2) : (this[j] |= 1);
              let e = 1 & this[j] ? this[x].end(i) : this[x].write(i);
              return (
                !(e.length > 0) ||
                  this[s] ||
                  4 & this[j] ||
                  ("\ufeff" === e[0] && (e = f(e, 1)), (this[s] = !0)),
                e
              );
            }
          };
        })();
    const W = a({
        get encoding() {
          return validateDecoder(this), this[v];
        },
        get fatal() {
          return validateDecoder(this), 2 == (2 & this[j]);
        },
        get ignoreBOM() {
          return validateDecoder(this), 4 == (4 & this[j]);
        },
        [I](i, s) {
          if ((validateDecoder(this), "number" == typeof i && i < 0))
            return this;
          const e = B(this) || J,
            t = c({ constructor: e });
          (t.encoding = this.encoding),
            (t.fatal = this.fatal),
            (t.ignoreBOM = this.ignoreBOM),
            s.showHidden && ((t[j] = this[j]), (t[x] = this[x]));
          const { inspect: n } = o("internal/util/inspect");
          return `${e.name} ${n(t)}`;
        },
      }),
      Y = l(W);
    for (let i = 0; i < Y.length; i++) d(Y[i], null);
    (W[I].enumerable = !1),
      w(J.prototype, {
        decode: F,
        ...W,
        [g]: { __proto__: null, configurable: !0, value: "TextDecoder" },
      }),
      (s.exports = {
        getEncodingFromLabel: getEncodingFromLabel,
        TextDecoder: J,
        TextEncoder: TextEncoder,
      });
  },
  "internal/error_serdes": function (r, e, t, o, n, u) {
    "use strict";
    const c = e("buffer").Buffer,
      {
        ArrayPrototypeForEach: a,
        Error: l,
        EvalError: s,
        FunctionPrototypeCall: i,
        ObjectAssign: f,
        ObjectCreate: p,
        ObjectDefineProperty: y,
        ObjectGetOwnPropertyDescriptor: E,
        ObjectGetOwnPropertyNames: _,
        ObjectGetPrototypeOf: m,
        ObjectKeys: b,
        ObjectPrototypeToString: g,
        RangeError: v,
        ReferenceError: h,
        SafeSet: P,
        StringFromCharCode: S,
        StringPrototypeSubstring: G,
        SymbolToStringTag: O,
        SyntaxError: T,
        SymbolFor: d,
        TypeError: j,
        TypedArrayPrototypeGetBuffer: z,
        TypedArrayPrototypeGetByteOffset: A,
        TypedArrayPrototypeGetByteLength: B,
        URIError: R,
      } = u,
      {
        inspect: { custom: C },
      } = e("util"),
      F = 0,
      w = 1,
      N = 2,
      x = 3,
      D = 4,
      I = {
        Error: l,
        TypeError: j,
        RangeError: v,
        URIError: R,
        SyntaxError: T,
        ReferenceError: h,
        EvalError: s,
      },
      U = new P(b(I));
    function TryGetAllProperties(r, e = r) {
      const t = p(null);
      if (null === r) return t;
      f(t, TryGetAllProperties(m(r), e));
      const o = _(r);
      return (
        a(o, (o) => {
          let n;
          try {
            n = E(r, o);
          } catch {
            return;
          }
          const u = n.get;
          if (u && "__proto__" !== o)
            try {
              (n.value = i(u, e)), delete n.get, delete n.set;
            } catch {}
          "cause" === o
            ? ((n.value = serializeError(n.value)), (t[o] = n))
            : "value" in n &&
              "function" != typeof n.value &&
              "symbol" != typeof n.value &&
              (t[o] = n);
        }),
        t
      );
    }
    function GetName(r) {
      const e = E(r, "name");
      return e && e.value;
    }
    let K, L, k;
    function inspect(...r) {
      return K || (K = e("internal/util/inspect")), K.inspect(...r);
    }
    function serializeError(r) {
      if ((L || (L = e("v8").serialize), "symbol" == typeof r))
        return c.from(S(x) + inspect(r), "utf8");
      try {
        if ("object" == typeof r && "[object Error]" === g(r)) {
          const e = (function GetConstructors(r) {
            const e = [];
            for (let t = r; null !== t; t = m(t)) {
              const r = E(t, "constructor");
              r &&
                r.value &&
                y(e, e.length, {
                  __proto__: null,
                  value: r.value,
                  enumerable: !0,
                });
            }
            return e;
          })(r);
          for (let t = 0; t < e.length; t++) {
            const o = GetName(e[t]);
            if (U.has(o)) {
              const e = L({
                constructor: o,
                properties: TryGetAllProperties(r),
              });
              return c.concat([c.from([F]), e]);
            }
          }
        }
      } catch {}
      try {
        if (null != r && C in r) return c.from(S(D) + inspect(r), "utf8");
      } catch {}
      try {
        const e = L(r);
        return c.concat([c.from([w]), e]);
      } catch {}
      return c.from(S(N) + inspect(r), "utf8");
    }
    function fromBuffer(r) {
      return c.from(z(r), A(r) + 1, B(r) - 1);
    }
    t.exports = {
      serializeError: serializeError,
      deserializeError: function deserializeError(r) {
        switch ((k || (k = e("v8").deserialize), r[0])) {
          case F: {
            const { constructor: e, properties: t } = k(r.subarray(1)),
              o = I[e];
            return (
              y(t, O, {
                __proto__: null,
                value: { __proto__: null, value: "Error", configurable: !0 },
                enumerable: !0,
              }),
              "cause" in t &&
                "value" in t.cause &&
                (t.cause.value = deserializeError(t.cause.value)),
              p(o.prototype, t)
            );
          }
          case w:
            return k(r.subarray(1));
          case N:
            return fromBuffer(r).toString("utf8");
          case x: {
            const e = fromBuffer(r);
            return d(G(e.toString("utf8"), 7, e.length - 1));
          }
          case D:
            return {
              __proto__: null,
              [C]: () => fromBuffer(r).toString("utf8"),
            };
        }
        e("assert").fail("This should not happen");
      },
    };
  },
  "internal/errors": function (e, t, r, n, o, s) {
    "use strict";
    const {
        AggregateError: a,
        ArrayFrom: i,
        ArrayIsArray: _,
        ArrayPrototypeFilter: R,
        ArrayPrototypeIncludes: c,
        ArrayPrototypeIndexOf: l,
        ArrayPrototypeJoin: T,
        ArrayPrototypeMap: d,
        ArrayPrototypePush: u,
        ArrayPrototypeSlice: I,
        ArrayPrototypeSplice: N,
        ArrayPrototypeUnshift: S,
        Error: p,
        ErrorCaptureStackTrace: A,
        ErrorPrototypeToString: m,
        JSONStringify: h,
        MapPrototypeGet: O,
        MathAbs: f,
        MathMax: L,
        Number: P,
        NumberIsInteger: C,
        ObjectAssign: g,
        ObjectDefineProperty: y,
        ObjectDefineProperties: D,
        ObjectIsExtensible: b,
        ObjectGetOwnPropertyDescriptor: U,
        ObjectKeys: $,
        ObjectPrototypeHasOwnProperty: v,
        RangeError: k,
        ReflectApply: M,
        RegExpPrototypeExec: H,
        SafeArrayIterator: F,
        SafeMap: w,
        SafeWeakMap: V,
        String: G,
        StringPrototypeEndsWith: Y,
        StringPrototypeIncludes: W,
        StringPrototypeSlice: B,
        StringPrototypeSplit: K,
        StringPrototypeStartsWith: x,
        StringPrototypeToLowerCase: j,
        Symbol: z,
        SymbolFor: q,
        SyntaxError: X,
        TypeError: Z,
        URIError: J,
      } = s,
      Q = z("kIsNodeError"),
      ee = "win32" === n.platform,
      te = new w(),
      re = {},
      ne = /^([A-Z][a-z0-9]*)+$/,
      oe = [
        "string",
        "function",
        "number",
        "object",
        "Function",
        "Object",
        "boolean",
        "bigint",
        "symbol",
      ],
      se = p,
      ae = new V(),
      Ee = z("kNoOverride");
    let ie;
    const _e = "__node_internal_",
      maybeOverridePrepareStackTrace = (e, t, r) =>
        "function" == typeof e.Error?.prepareStackTrace
          ? e.Error.prepareStackTrace(t, r)
          : "function" == typeof se.prepareStackTrace
          ? se.prepareStackTrace(t, r)
          : Ee,
      Re = hideStackFrames((e, t) => {
        if (e && t && e !== t) {
          if (_(t.errors)) return u(t.errors, e), t;
          const r = new a(new F([t, e]), t.message);
          return (r.code = t.code), r;
        }
        return e || t;
      }),
      ce = hideStackFrames((e, t, r) => {
        const n = new a(new F(e), t);
        return (n.code = e[0]?.code), n;
      });
    let le,
      Te,
      de = null;
    function lazyInternalUtil() {
      return (de ??= t("internal/util")), de;
    }
    let ue,
      Ie,
      Ne,
      Se = null;
    function lazyInternalUtilInspect() {
      return (Se ??= t("internal/util/inspect")), Se;
    }
    function lazyBuffer() {
      return (Ie ??= t("buffer").Buffer), Ie;
    }
    function isErrorStackTraceLimitWritable() {
      if (t("internal/v8/startup_snapshot").namespace.isBuildingSnapshot())
        return !1;
      const e = U(p, "stackTraceLimit");
      return void 0 === e
        ? b(p)
        : v(e, "writable")
        ? e.writable
        : void 0 !== e.set;
    }
    function inspectWithNoCustomRetry(e, t) {
      const r = lazyInternalUtilInspect();
      try {
        return r.inspect(e, t);
      } catch {
        return r.inspect(e, { ...t, customInspect: !1 });
      }
    }
    class SystemError extends p {
      constructor(e, t) {
        const r = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0),
          super(),
          isErrorStackTraceLimitWritable() && (p.stackTraceLimit = r);
        let n = `${getMessage(e, [], this)}: ${t.syscall} returned ${t.code} (${
          t.message
        })`;
        void 0 !== t.path && (n += ` ${t.path}`),
          void 0 !== t.dest && (n += ` => ${t.dest}`),
          Ae(this),
          (this.code = e),
          D(this, {
            [Q]: {
              __proto__: null,
              value: !0,
              enumerable: !1,
              writable: !1,
              configurable: !0,
            },
            name: {
              __proto__: null,
              value: "SystemError",
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
            message: {
              __proto__: null,
              value: n,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
            info: {
              __proto__: null,
              value: t,
              enumerable: !0,
              configurable: !0,
              writable: !1,
            },
            errno: {
              __proto__: null,
              get: () => t.errno,
              set: (e) => {
                t.errno = e;
              },
              enumerable: !0,
              configurable: !0,
            },
            syscall: {
              __proto__: null,
              get: () => t.syscall,
              set: (e) => {
                t.syscall = e;
              },
              enumerable: !0,
              configurable: !0,
            },
          }),
          void 0 !== t.path &&
            y(this, "path", {
              __proto__: null,
              get: () => (null != t.path ? t.path.toString() : t.path),
              set: (e) => {
                t.path = e ? lazyBuffer().from(e.toString()) : void 0;
              },
              enumerable: !0,
              configurable: !0,
            }),
          void 0 !== t.dest &&
            y(this, "dest", {
              __proto__: null,
              get: () => (null != t.dest ? t.dest.toString() : t.dest),
              set: (e) => {
                t.dest = e ? lazyBuffer().from(e.toString()) : void 0;
              },
              enumerable: !0,
              configurable: !0,
            });
      }
      toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
      }
      [q("nodejs.util.inspect.custom")](e, t) {
        return lazyInternalUtilInspect().inspect(this, {
          ...t,
          getters: !0,
          customInspect: !1,
        });
      }
    }
    function makeNodeErrorWithCode(e, t) {
      return function NodeError(...r) {
        const n = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0);
        const o = new e();
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = n);
        const s = getMessage(t, r, o);
        return (
          D(o, {
            [Q]: {
              __proto__: null,
              value: !0,
              enumerable: !1,
              writable: !1,
              configurable: !0,
            },
            message: {
              __proto__: null,
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
            toString: {
              __proto__: null,
              value() {
                return `${this.name} [${t}]: ${this.message}`;
              },
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
          }),
          Ae(o),
          (o.code = t),
          o
        );
      };
    }
    function hideStackFrames(e) {
      const t = _e + e.name;
      return y(e, "name", { __proto__: null, value: t }), e;
    }
    function E(e, t, r, ...n) {
      te.set(e, t),
        (r =
          r === SystemError
            ? (function makeSystemErrorWithCode(e) {
                return class NodeError extends SystemError {
                  constructor(t) {
                    super(e, t);
                  }
                };
              })(e)
            : makeNodeErrorWithCode(r, e)),
        0 !== n.length &&
          n.forEach((t) => {
            r[t.name] = makeNodeErrorWithCode(t, e);
          }),
        (re[e] = r);
    }
    function getMessage(e, r, n) {
      const o = te.get(e);
      if (((Te ??= t("internal/assert")), "function" == typeof o))
        return (
          Te(
            o.length <= r.length,
            `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${o.length}).`
          ),
          M(o, n, r)
        );
      const s = /%[dfijoOs]/g;
      let a = 0;
      for (; null !== H(s, o); ) a++;
      return (
        Te(
          a === r.length,
          `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${a}).`
        ),
        0 === r.length
          ? o
          : (S(r, o), M(lazyInternalUtilInspect().format, null, r))
      );
    }
    function lazyUv() {
      return (Ne ??= o("uv")), Ne;
    }
    const pe = ["UNKNOWN", "unknown error"];
    function uvErrmapGet(e) {
      return (Ne = lazyUv()), (Ne.errmap ??= Ne.getErrorMap()), O(Ne.errmap, e);
    }
    const Ae = hideStackFrames(function captureLargerStackTrace2(e) {
        const t = isErrorStackTraceLimitWritable();
        return (
          t && ((ie = p.stackTraceLimit), (p.stackTraceLimit = 1 / 0)),
          A(e),
          t && (p.stackTraceLimit = ie),
          e
        );
      }),
      me = hideStackFrames(function uvException2(e) {
        const { 0: t, 1: r } = uvErrmapGet(e.errno) || pe;
        let n,
          o,
          s = `${t}: ${e.message || r}, ${e.syscall}`;
        e.path && ((n = e.path.toString()), (s += ` '${n}'`)),
          e.dest && ((o = e.dest.toString()), (s += ` -> '${o}'`));
        const a = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0);
        const i = new p(s);
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = a);
        for (const t of $(e))
          "message" !== t && "path" !== t && "dest" !== t && (i[t] = e[t]);
        return (i.code = t), n && (i.path = n), o && (i.dest = o), Ae(i);
      }),
      he = hideStackFrames(function uvExceptionWithHostPort2(e, t, r, n) {
        const { 0: o, 1: s } = uvErrmapGet(e) || pe,
          a = `${t} ${o}: ${s}`;
        let i = "";
        n && n > 0 ? (i = ` ${r}:${n}`) : r && (i = ` ${r}`);
        const _ = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0);
        const R = new p(`${a}${i}`);
        return (
          isErrorStackTraceLimitWritable() && (p.stackTraceLimit = _),
          (R.code = o),
          (R.errno = e),
          (R.syscall = t),
          (R.address = r),
          n && (R.port = n),
          Ae(R)
        );
      }),
      Oe = hideStackFrames(function errnoException2(e, r, n) {
        le ??= t("util");
        const o = le.getSystemErrorName(e),
          s = n ? `${r} ${o} ${n}` : `${r} ${o}`,
          a = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0);
        const i = new p(s);
        return (
          isErrorStackTraceLimitWritable() && (p.stackTraceLimit = a),
          (i.errno = e),
          (i.code = o),
          (i.syscall = r),
          Ae(i)
        );
      }),
      fe = hideStackFrames(function exceptionWithHostPort2(e, r, n, o, s) {
        le ??= t("util");
        const a = le.getSystemErrorName(e);
        let i = "";
        o && o > 0 ? (i = ` ${n}:${o}`) : n && (i = ` ${n}`),
          s && (i += ` - Local (${s})`);
        const _ = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0);
        const R = new p(`${r} ${a}${i}`);
        return (
          isErrorStackTraceLimitWritable() && (p.stackTraceLimit = _),
          (R.errno = e),
          (R.code = a),
          (R.syscall = r),
          (R.address = n),
          o && (R.port = o),
          Ae(R)
        );
      }),
      Le = hideStackFrames(function (e, t, r) {
        let n;
        "number" == typeof e &&
          ((n = e),
          (e =
            e === lazyUv().UV_EAI_NODATA || e === lazyUv().UV_EAI_NONAME
              ? "ENOTFOUND"
              : lazyInternalUtil().getSystemErrorName(e)));
        const o = `${t} ${e}${r ? ` ${r}` : ""}`,
          s = p.stackTraceLimit;
        isErrorStackTraceLimitWritable() && (p.stackTraceLimit = 0);
        const a = new p(o);
        return (
          isErrorStackTraceLimitWritable() && (p.stackTraceLimit = s),
          (a.errno = n),
          (a.code = e),
          (a.syscall = t),
          r && (a.hostname = r),
          Ae(a)
        );
      });
    let Pe, Ce;
    function addNumericalSeparator(e) {
      let t = "",
        r = e.length;
      const n = "-" === e[0] ? 1 : 0;
      for (; r >= n + 4; r -= 3) t = `_${B(e, r - 3, r)}${t}`;
      return `${B(e, 0, r)}${t}`;
    }
    const ge = z("kEnhanceStackBeforeInspector"),
      ye = {
        beforeInspector(e) {
          if ("function" != typeof e[ge]) return e.stack;
          try {
            e.stack = e[ge]();
          } catch {}
          return e.stack;
        },
        afterInspector(e) {
          const r = e.stack;
          let s = !0;
          if (ee) {
            const e = o("os").getOSInformation(),
              t = d(K(e[2], "."), P);
            (10 !== t[0] || t[2] < 14393) && (s = !1);
          }
          const {
              inspect: a,
              inspectDefaultOptions: { colors: i },
            } = lazyInternalUtilInspect(),
            _ =
              s &&
              ((function lazyUtilColors() {
                return (ue ??= t("internal/util/colors")), ue;
              })().shouldColorize(n.stderr) ||
                i);
          try {
            return a(e, {
              colors: _,
              customInspect: !1,
              depth: L(a.defaultOptions.depth, 5),
            });
          } catch {
            return r;
          }
        },
      },
      {
        privateSymbols: { arrow_message_private_symbol: De },
      } = o("util");
    function hideInternalStackFrames(e) {
      ae.set(e, (e, t) => {
        let r = t;
        return (
          "object" == typeof t &&
            (r = R(t, (e) => !x(e.getFileName() || "", "node:internal"))),
          S(r, e),
          T(r, "\n    at ")
        );
      });
    }
    const be = hideStackFrames(function genericNodeError2(e, t) {
      const r = new p(e);
      return g(r, t), r;
    });
    function determineSpecificType(e) {
      if (null == e) return "" + e;
      if ("function" == typeof e && e.name) return `function ${e.name}`;
      if ("object" == typeof e)
        return e.constructor?.name
          ? `an instance of ${e.constructor.name}`
          : `${lazyInternalUtilInspect().inspect(e, { depth: -1 })}`;
      let t = lazyInternalUtilInspect().inspect(e, { colors: !1 });
      return (
        t.length > 28 && (t = `${B(t, 0, 25)}...`), `type ${typeof e} (${t})`
      );
    }
    function formatList(e, t = "and") {
      return e.length < 3
        ? T(e, ` ${t} `)
        : `${T(I(e, 0, -1), ", ")}, ${t} ${e[e.length - 1]}`;
    }
    (r.exports = {
      AbortError: class AbortError extends p {
        constructor(e = "The operation was aborted", t = void 0) {
          if (void 0 !== t && "object" != typeof t)
            throw new re.ERR_INVALID_ARG_TYPE("options", "Object", t);
          super(e, t), (this.code = "ABORT_ERR"), (this.name = "AbortError");
        }
      },
      aggregateTwoErrors: Re,
      aggregateErrors: ce,
      captureLargerStackTrace: Ae,
      codes: re,
      connResetException: function connResetException(e) {
        const t = new p(e);
        return (t.code = "ECONNRESET"), t;
      },
      dnsException: Le,
      determineSpecificType: determineSpecificType,
      E: E,
      errnoException: Oe,
      exceptionWithHostPort: fe,
      fatalExceptionStackEnhancers: ye,
      formatList: formatList,
      genericNodeError: be,
      getMessage: getMessage,
      hideInternalStackFrames: hideInternalStackFrames,
      hideStackFrames: hideStackFrames,
      inspectWithNoCustomRetry: inspectWithNoCustomRetry,
      isErrorStackTraceLimitWritable: isErrorStackTraceLimitWritable,
      isStackOverflowError: function isStackOverflowError(e) {
        if (void 0 === Ce)
          try {
            let overflowStack = function () {
              overflowStack();
            };
            overflowStack();
          } catch (e) {
            (Ce = e.message), (Pe = e.name);
          }
        return e && e.name === Pe && e.message === Ce;
      },
      kEnhanceStackBeforeInspector: ge,
      kIsNodeError: Q,
      kNoOverride: Ee,
      maybeOverridePrepareStackTrace: maybeOverridePrepareStackTrace,
      overrideStackTrace: ae,
      prepareStackTrace: (e, t, r) => {
        if (ae.has(t)) {
          const e = ae.get(t);
          return ae.delete(t), e(t, r);
        }
        const n = r[0]?.getFunctionName();
        if (n && x(n, _e)) {
          for (let e = r.length - 1; e >= 0; e--) {
            const t = r[e]?.getFunctionName();
            if (t && x(t, _e)) {
              N(r, 0, e + 1);
              break;
            }
          }
          r.length > ie && N(r, ie);
        }
        const o = maybeOverridePrepareStackTrace(e, t, r);
        if (o !== Ee) return o;
        let s;
        return (
          (s = Q in t ? `${t.name} [${t.code}]: ${t.message}` : m(t)),
          0 === r.length ? s : `${s}\n    at ${T(r, "\n    at ")}`
        );
      },
      setArrowMessage: function setArrowMessage(e, t) {
        e[De] = t;
      },
      SystemError: SystemError,
      uvErrmapGet: uvErrmapGet,
      uvException: me,
      uvExceptionWithHostPort: he,
    }),
      E(
        "ERR_ACCESS_DENIED",
        "Access to this API has been restricted. Permission: %s",
        p
      ),
      E("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', Z),
      E("ERR_ARG_NOT_ITERABLE", "%s must be iterable", Z),
      E("ERR_ASSERTION", "%s", p),
      E("ERR_ASYNC_CALLBACK", "%s must be a function", Z),
      E("ERR_ASYNC_TYPE", 'Invalid name for async "type": %s', Z),
      E("ERR_BROTLI_INVALID_PARAM", "%s is not a valid Brotli parameter", k),
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        (e = void 0) =>
          e
            ? `"${e}" is outside of buffer bounds`
            : "Attempt to access memory outside buffer bounds",
        k
      ),
      E(
        "ERR_BUFFER_TOO_LARGE",
        "Cannot create a Buffer larger than %s bytes",
        k
      ),
      E("ERR_CANNOT_WATCH_SIGINT", "Cannot watch for SIGINT signals", p),
      E(
        "ERR_CHILD_CLOSED_BEFORE_REPLY",
        "Child closed before reply received",
        p
      ),
      E(
        "ERR_CHILD_PROCESS_IPC_REQUIRED",
        "Forked processes must have an IPC channel, missing value 'ipc' in %s",
        p
      ),
      E("ERR_CHILD_PROCESS_STDIO_MAXBUFFER", "%s maxBuffer length exceeded", k),
      E(
        "ERR_CONSOLE_WRITABLE_STREAM",
        "Console expects a writable stream instance for %s",
        Z
      ),
      E("ERR_CONTEXT_NOT_INITIALIZED", "context used is not initialized", p),
      E(
        "ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED",
        "Custom engines not supported by this OpenSSL",
        p
      ),
      E("ERR_CRYPTO_ECDH_INVALID_FORMAT", "Invalid ECDH format: %s", Z),
      E(
        "ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY",
        "Public key is not valid for specified curve",
        p
      ),
      E("ERR_CRYPTO_ENGINE_UNKNOWN", 'Engine "%s" was not found', p),
      E(
        "ERR_CRYPTO_FIPS_FORCED",
        "Cannot set FIPS mode, it was forced with --force-fips at startup.",
        p
      ),
      E(
        "ERR_CRYPTO_FIPS_UNAVAILABLE",
        "Cannot set FIPS mode in a non-FIPS build.",
        p
      ),
      E("ERR_CRYPTO_HASH_FINALIZED", "Digest already called", p),
      E("ERR_CRYPTO_HASH_UPDATE_FAILED", "Hash update failed", p),
      E("ERR_CRYPTO_INCOMPATIBLE_KEY", "Incompatible %s: %s", p),
      E(
        "ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS",
        "The selected key encoding %s %s.",
        p
      ),
      E("ERR_CRYPTO_INVALID_DIGEST", "Invalid digest: %s", Z),
      E("ERR_CRYPTO_INVALID_JWK", "Invalid JWK data", Z),
      E(
        "ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE",
        "Invalid key object type %s, expected %s.",
        Z
      ),
      E("ERR_CRYPTO_INVALID_STATE", "Invalid state for operation %s", p),
      E("ERR_CRYPTO_PBKDF2_ERROR", "PBKDF2 error", p),
      E("ERR_CRYPTO_SCRYPT_INVALID_PARAMETER", "Invalid scrypt parameter", p),
      E("ERR_CRYPTO_SCRYPT_NOT_SUPPORTED", "Scrypt algorithm not supported", p),
      E("ERR_CRYPTO_SIGN_KEY_REQUIRED", "No key provided to sign", p),
      E("ERR_DEBUGGER_ERROR", "%s", p),
      E("ERR_DEBUGGER_STARTUP_ERROR", "%s", p),
      E("ERR_DIR_CLOSED", "Directory handle was closed", p),
      E(
        "ERR_DIR_CONCURRENT_OPERATION",
        "Cannot do synchronous work on directory handle with concurrent asynchronous operations",
        p
      ),
      E(
        "ERR_DNS_SET_SERVERS_FAILED",
        'c-ares failed to set servers: "%s" [%s]',
        p
      ),
      E(
        "ERR_DOMAIN_CALLBACK_NOT_AVAILABLE",
        "A callback was registered through process.setUncaughtExceptionCaptureCallback(), which is mutually exclusive with using the `domain` module",
        p
      ),
      E(
        "ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE",
        "The `domain` module is in use, which is mutually exclusive with calling process.setUncaughtExceptionCaptureCallback()",
        p
      ),
      E(
        "ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION",
        "Deserialize main function is already configured.",
        p
      ),
      E(
        "ERR_ENCODING_INVALID_ENCODED_DATA",
        function (e, t) {
          return (
            (this.errno = t), `The encoded data was not valid for encoding ${e}`
          );
        },
        Z
      ),
      E("ERR_ENCODING_NOT_SUPPORTED", 'The "%s" encoding is not supported', k),
      E(
        "ERR_EVAL_ESM_CANNOT_PRINT",
        "--print cannot be used with ESM input",
        p
      ),
      E("ERR_EVENT_RECURSION", 'The event "%s" is already being dispatched', p),
      E(
        "ERR_FALSY_VALUE_REJECTION",
        function (e) {
          return (this.reason = e), "Promise was rejected with falsy value";
        },
        p
      ),
      E(
        "ERR_FEATURE_UNAVAILABLE_ON_PLATFORM",
        "The feature %s is unavailable on the current platform, which is being used to run Node.js",
        Z
      ),
      E(
        "ERR_FS_CP_DIR_TO_NON_DIR",
        "Cannot overwrite directory with non-directory",
        SystemError
      ),
      E("ERR_FS_CP_EEXIST", "Target already exists", SystemError),
      E("ERR_FS_CP_EINVAL", "Invalid src or dest", SystemError),
      E("ERR_FS_CP_FIFO_PIPE", "Cannot copy a FIFO pipe", SystemError),
      E(
        "ERR_FS_CP_NON_DIR_TO_DIR",
        "Cannot overwrite non-directory with directory",
        SystemError
      ),
      E("ERR_FS_CP_SOCKET", "Cannot copy a socket file", SystemError),
      E(
        "ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY",
        "Cannot overwrite symlink in subdirectory of self",
        SystemError
      ),
      E("ERR_FS_CP_UNKNOWN", "Cannot copy an unknown file type", SystemError),
      E("ERR_FS_EISDIR", "Path is a directory", SystemError),
      E("ERR_FS_FILE_TOO_LARGE", "File size (%s) is greater than 2 GiB", k),
      E(
        "ERR_FS_INVALID_SYMLINK_TYPE",
        'Symlink type must be one of "dir", "file", or "junction". Received "%s"',
        p
      ),
      E(
        "ERR_HTTP2_ALTSVC_INVALID_ORIGIN",
        "HTTP/2 ALTSVC frames require a valid origin",
        Z
      ),
      E(
        "ERR_HTTP2_ALTSVC_LENGTH",
        "HTTP/2 ALTSVC frames are limited to 16382 bytes",
        Z
      ),
      E(
        "ERR_HTTP2_CONNECT_AUTHORITY",
        ":authority header is required for CONNECT requests",
        p
      ),
      E(
        "ERR_HTTP2_CONNECT_PATH",
        "The :path header is forbidden for CONNECT requests",
        p
      ),
      E(
        "ERR_HTTP2_CONNECT_SCHEME",
        "The :scheme header is forbidden for CONNECT requests",
        p
      ),
      E(
        "ERR_HTTP2_GOAWAY_SESSION",
        "New streams cannot be created after receiving a GOAWAY",
        p
      ),
      E(
        "ERR_HTTP2_HEADERS_AFTER_RESPOND",
        "Cannot specify additional headers after response initiated",
        p
      ),
      E("ERR_HTTP2_HEADERS_SENT", "Response has already been initiated.", p),
      E(
        "ERR_HTTP2_HEADER_SINGLE_VALUE",
        'Header field "%s" must only have a single value',
        Z
      ),
      E(
        "ERR_HTTP2_INFO_STATUS_NOT_ALLOWED",
        "Informational status codes cannot be used",
        k
      ),
      E(
        "ERR_HTTP2_INVALID_CONNECTION_HEADERS",
        'HTTP/1 Connection specific headers are forbidden: "%s"',
        Z
      ),
      E(
        "ERR_HTTP2_INVALID_HEADER_VALUE",
        'Invalid value "%s" for header "%s"',
        Z
      ),
      E(
        "ERR_HTTP2_INVALID_INFO_STATUS",
        "Invalid informational status code: %s",
        k
      ),
      E(
        "ERR_HTTP2_INVALID_ORIGIN",
        "HTTP/2 ORIGIN frames require a valid origin",
        Z
      ),
      E(
        "ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH",
        "Packed settings length must be a multiple of six",
        k
      ),
      E(
        "ERR_HTTP2_INVALID_PSEUDOHEADER",
        '"%s" is an invalid pseudoheader or is used incorrectly',
        Z
      ),
      E("ERR_HTTP2_INVALID_SESSION", "The session has been destroyed", p),
      E(
        "ERR_HTTP2_INVALID_SETTING_VALUE",
        function (e, t, r = void 0, n = void 0) {
          return (
            (this.actual = t),
            void 0 !== r && ((this.min = r), (this.max = n)),
            `Invalid value for setting "${e}": ${t}`
          );
        },
        Z,
        k
      ),
      E("ERR_HTTP2_INVALID_STREAM", "The stream has been destroyed", p),
      E(
        "ERR_HTTP2_MAX_PENDING_SETTINGS_ACK",
        "Maximum number of pending settings acknowledgements",
        p
      ),
      E(
        "ERR_HTTP2_NESTED_PUSH",
        "A push stream cannot initiate another push stream.",
        p
      ),
      E("ERR_HTTP2_NO_MEM", "Out of memory", p),
      E(
        "ERR_HTTP2_NO_SOCKET_MANIPULATION",
        "HTTP/2 sockets should not be directly manipulated (e.g. read and written)",
        p
      ),
      E(
        "ERR_HTTP2_ORIGIN_LENGTH",
        "HTTP/2 ORIGIN frames are limited to 16382 bytes",
        Z
      ),
      E(
        "ERR_HTTP2_OUT_OF_STREAMS",
        "No stream ID is available because maximum stream ID has been reached",
        p
      ),
      E(
        "ERR_HTTP2_PAYLOAD_FORBIDDEN",
        "Responses with %s status must not have a payload",
        p
      ),
      E("ERR_HTTP2_PING_CANCEL", "HTTP2 ping cancelled", p),
      E("ERR_HTTP2_PING_LENGTH", "HTTP2 ping payload must be 8 bytes", k),
      E(
        "ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED",
        "Cannot set HTTP/2 pseudo-headers",
        Z
      ),
      E(
        "ERR_HTTP2_PUSH_DISABLED",
        "HTTP/2 client has disabled push streams",
        p
      ),
      E("ERR_HTTP2_SEND_FILE", "Directories cannot be sent", p),
      E(
        "ERR_HTTP2_SEND_FILE_NOSEEK",
        "Offset or length can only be specified for regular files",
        p
      ),
      E("ERR_HTTP2_SESSION_ERROR", "Session closed with error code %s", p),
      E("ERR_HTTP2_SETTINGS_CANCEL", "HTTP2 session settings canceled", p),
      E(
        "ERR_HTTP2_SOCKET_BOUND",
        "The socket is already bound to an Http2Session",
        p
      ),
      E(
        "ERR_HTTP2_SOCKET_UNBOUND",
        "The socket has been disconnected from the Http2Session",
        p
      ),
      E(
        "ERR_HTTP2_STATUS_101",
        "HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2",
        p
      ),
      E("ERR_HTTP2_STATUS_INVALID", "Invalid status code: %s", k),
      E(
        "ERR_HTTP2_STREAM_CANCEL",
        function (e) {
          let t = "The pending stream has been canceled";
          return (
            e &&
              ((this.cause = e),
              "string" == typeof e.message &&
                (t += ` (caused by: ${e.message})`)),
            t
          );
        },
        p
      ),
      E("ERR_HTTP2_STREAM_ERROR", "Stream closed with error code %s", p),
      E(
        "ERR_HTTP2_STREAM_SELF_DEPENDENCY",
        "A stream cannot depend on itself",
        p
      ),
      E(
        "ERR_HTTP2_TOO_MANY_INVALID_FRAMES",
        "Too many invalid HTTP/2 frames",
        p
      ),
      E(
        "ERR_HTTP2_TRAILERS_ALREADY_SENT",
        "Trailing headers have already been sent",
        p
      ),
      E(
        "ERR_HTTP2_TRAILERS_NOT_READY",
        "Trailing headers cannot be sent until after the wantTrailers event is emitted",
        p
      ),
      E("ERR_HTTP2_UNSUPPORTED_PROTOCOL", 'protocol "%s" is unsupported.', p),
      E(
        "ERR_HTTP_BODY_NOT_ALLOWED",
        "Adding content for this request method or response status is not allowed.",
        p
      ),
      E(
        "ERR_HTTP_CONTENT_LENGTH_MISMATCH",
        "Response body's content-length of %s byte(s) does not match the content-length of %s byte(s) set in header",
        p
      ),
      E(
        "ERR_HTTP_HEADERS_SENT",
        "Cannot %s headers after they are sent to the client",
        p
      ),
      E(
        "ERR_HTTP_INVALID_HEADER_VALUE",
        'Invalid value "%s" for header "%s"',
        Z
      ),
      E("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s", k),
      E("ERR_HTTP_REQUEST_TIMEOUT", "Request timeout", p),
      E(
        "ERR_HTTP_SOCKET_ASSIGNED",
        "ServerResponse has an already assigned socket",
        p
      ),
      E(
        "ERR_HTTP_SOCKET_ENCODING",
        "Changing the socket encoding is not allowed per RFC7230 Section 3.",
        p
      ),
      E(
        "ERR_HTTP_TRAILER_INVALID",
        "Trailers are invalid with this transfer encoding",
        p
      ),
      E("ERR_ILLEGAL_CONSTRUCTOR", "Illegal constructor", Z),
      E(
        "ERR_IMPORT_ASSERTION_TYPE_FAILED",
        'Module "%s" is not of type "%s"',
        Z
      ),
      E(
        "ERR_IMPORT_ASSERTION_TYPE_MISSING",
        'Module "%s" needs an import attribute of type "%s"',
        Z
      ),
      E(
        "ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED",
        'Import attribute type "%s" is unsupported',
        Z
      ),
      E(
        "ERR_IMPORT_ATTRIBUTE_UNSUPPORTED",
        'Import attribute "%s" with value "%s" is not supported',
        Z
      ),
      E(
        "ERR_INCOMPATIBLE_OPTION_PAIR",
        'Option "%s" cannot be used in combination with option "%s"',
        Z
      ),
      E(
        "ERR_INPUT_TYPE_NOT_ALLOWED",
        "--input-type can only be used with string input via --eval, --print, or STDIN",
        p
      ),
      E(
        "ERR_INSPECTOR_ALREADY_ACTIVATED",
        "Inspector is already activated. Close it with inspector.close() before activating it again.",
        p
      ),
      E("ERR_INSPECTOR_ALREADY_CONNECTED", "%s is already connected", p),
      E("ERR_INSPECTOR_CLOSED", "Session was closed", p),
      E("ERR_INSPECTOR_COMMAND", "Inspector error %d: %s", p),
      E("ERR_INSPECTOR_NOT_ACTIVE", "Inspector is not active", p),
      E("ERR_INSPECTOR_NOT_AVAILABLE", "Inspector is not available", p),
      E("ERR_INSPECTOR_NOT_CONNECTED", "Session is not connected", p),
      E("ERR_INSPECTOR_NOT_WORKER", "Current thread is not a worker", p),
      E(
        "ERR_INTERNAL_ASSERTION",
        (e) => {
          const t =
            "This is caused by either a bug in Node.js or incorrect usage of Node.js internals.\nPlease open an issue with this stack trace at https://github.com/nodejs/node/issues\n";
          return void 0 === e ? t : `${e}\n${t}`;
        },
        p
      ),
      E(
        "ERR_INVALID_ADDRESS_FAMILY",
        function (e, t, r) {
          return (
            (this.host = t),
            (this.port = r),
            `Invalid address family: ${e} ${t}:${r}`
          );
        },
        k
      ),
      E(
        "ERR_INVALID_ARG_TYPE",
        (e, t, r) => {
          Te("string" == typeof e, "'name' must be a string"),
            _(t) || (t = [t]);
          let n = "The ";
          if (Y(e, " argument")) n += `${e} `;
          else {
            n += `"${e}" ${W(e, ".") ? "property" : "argument"} `;
          }
          n += "must be ";
          const o = [],
            s = [],
            a = [];
          for (const e of t)
            Te(
              "string" == typeof e,
              "All expected entries have to be of type string"
            ),
              c(oe, e)
                ? u(o, j(e))
                : null !== H(ne, e)
                ? u(s, e)
                : (Te(
                    "object" !== e,
                    'The value "object" should be written as "Object"'
                  ),
                  u(a, e));
          if (s.length > 0) {
            const e = l(o, "object");
            -1 !== e && (N(o, e, 1), u(s, "Object"));
          }
          return (
            o.length > 0 &&
              ((n += `${o.length > 1 ? "one of type" : "of type"} ${formatList(
                o,
                "or"
              )}`),
              (s.length > 0 || a.length > 0) && (n += " or ")),
            s.length > 0 &&
              ((n += `an instance of ${formatList(s, "or")}`),
              a.length > 0 && (n += " or ")),
            a.length > 0 &&
              (a.length > 1
                ? (n += `one of ${formatList(a, "or")}`)
                : (j(a[0]) !== a[0] && (n += "an "), (n += `${a[0]}`))),
            (n += `. Received ${determineSpecificType(r)}`),
            n
          );
        },
        Z
      ),
      E(
        "ERR_INVALID_ARG_VALUE",
        (e, t, r = "is invalid") => {
          let n = lazyInternalUtilInspect().inspect(t);
          n.length > 128 && (n = `${B(n, 0, 128)}...`);
          return `The ${
            W(e, ".") ? "property" : "argument"
          } '${e}' ${r}. Received ${n}`;
        },
        Z,
        k
      ),
      E("ERR_INVALID_ASYNC_ID", "Invalid %s value: %s", k),
      E("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s", k),
      E(
        "ERR_INVALID_CHAR",
        (e, t = void 0) => {
          let r = `Invalid character in ${e}`;
          return void 0 !== t && (r += ` ["${t}"]`), r;
        },
        Z
      ),
      E(
        "ERR_INVALID_CURSOR_POS",
        "Cannot set cursor row without setting its column",
        Z
      ),
      E("ERR_INVALID_FD", '"fd" must be a positive integer: %s', k),
      E("ERR_INVALID_FD_TYPE", "Unsupported fd type: %s", Z),
      E(
        "ERR_INVALID_FILE_URL_HOST",
        'File URL host must be "localhost" or empty on %s',
        Z
      ),
      E("ERR_INVALID_FILE_URL_PATH", "File URL path %s", Z),
      E("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent", Z),
      E("ERR_INVALID_HTTP_TOKEN", '%s must be a valid HTTP token ["%s"]', Z),
      E("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s", Z),
      E(
        "ERR_INVALID_MIME_SYNTAX",
        (e, t, r) =>
          `The MIME syntax for a ${e} in "${t}" is invalid` +
          (-1 !== r ? ` at ${r}` : ""),
        Z
      ),
      E(
        "ERR_INVALID_MODULE_SPECIFIER",
        (e, t, r = void 0) =>
          `Invalid module "${e}" ${t}${r ? ` imported from ${r}` : ""}`,
        Z
      ),
      E(
        "ERR_INVALID_PACKAGE_CONFIG",
        (e, t, r) =>
          `Invalid package config ${e}${t ? ` while importing ${t}` : ""}${
            r ? `. ${r}` : ""
          }`,
        p
      ),
      E(
        "ERR_INVALID_PACKAGE_TARGET",
        (e, t, r, n = !1, o = void 0) => {
          const s = "string" == typeof r && !n && r.length && !x(r, "./");
          return "." === t
            ? (Te(!1 === n),
              `Invalid "exports" main target ${h(
                r
              )} defined in the package config ${e}package.json${
                o ? ` imported from ${o}` : ""
              }${s ? '; targets must start with "./"' : ""}`)
            : `Invalid "${n ? "imports" : "exports"}" target ${h(
                r
              )} defined for '${t}' in the package config ${e}package.json${
                o ? ` imported from ${o}` : ""
              }${s ? '; targets must start with "./"' : ""}`;
        },
        p
      ),
      E(
        "ERR_INVALID_PROTOCOL",
        'Protocol "%s" not supported. Expected "%s"',
        Z
      ),
      E(
        "ERR_INVALID_REPL_EVAL_CONFIG",
        'Cannot specify both "breakEvalOnSigint" and "eval" for REPL',
        Z
      ),
      E("ERR_INVALID_REPL_INPUT", "%s", Z),
      E(
        "ERR_INVALID_RETURN_PROPERTY",
        (e, t, r, n) =>
          `Expected a valid ${e} to be returned for the "${r}" from the "${t}" function but got ${n}.`,
        Z
      ),
      E(
        "ERR_INVALID_RETURN_PROPERTY_VALUE",
        (e, t, r, n) => {
          let o;
          return (
            (o = n?.constructor?.name
              ? `instance of ${n.constructor.name}`
              : "type " + typeof n),
            `Expected ${e} to be returned for the "${r}" from the "${t}" function but got ${o}.`
          );
        },
        Z
      ),
      E(
        "ERR_INVALID_RETURN_VALUE",
        (e, t, r) =>
          `Expected ${e} to be returned from the "${t}" function but got ${determineSpecificType(
            r
          )}.`,
        Z,
        k
      ),
      E("ERR_INVALID_STATE", "Invalid state: %s", p, Z, k),
      E(
        "ERR_INVALID_SYNC_FORK_INPUT",
        "Asynchronous forks do not support Buffer, TypedArray, DataView or string input: %s",
        Z
      ),
      E("ERR_INVALID_THIS", 'Value of "this" must be of type %s', Z),
      E("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple", Z),
      E("ERR_INVALID_URI", "URI malformed", J),
      E(
        "ERR_INVALID_URL",
        function (e) {
          return (this.input = e), "Invalid URL";
        },
        Z
      ),
      E(
        "ERR_INVALID_URL_SCHEME",
        (e) => {
          "string" == typeof e && (e = [e]), Te(e.length <= 2);
          return `The URL must be ${
            2 === e.length
              ? `one of scheme ${e[0]} or ${e[1]}`
              : `of scheme ${e[0]}`
          }`;
        },
        Z
      ),
      E("ERR_IPC_CHANNEL_CLOSED", "Channel closed", p),
      E("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected", p),
      E("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe", p),
      E("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks", p),
      E(
        "ERR_LOADER_CHAIN_INCOMPLETE",
        '"%s" did not call the next hook in its chain and did not explicitly signal a short circuit. If this is intentional, include `shortCircuit: true` in the hook\'s return.',
        p
      ),
      E(
        "ERR_MANIFEST_ASSERT_INTEGRITY",
        (e, t) => {
          let r = `The content of "${e}" does not match the expected integrity.`;
          if (t.size) {
            r += ` Integrities found are: ${T(
              i(t.entries(), ({ 0: e, 1: t }) => `${e}-${t}`),
              " "
            )}`;
          } else r += " The resource was not found in the policy.";
          return r;
        },
        p
      ),
      E(
        "ERR_MANIFEST_DEPENDENCY_MISSING",
        "Manifest resource %s does not list %s as a dependency specifier for conditions: %s",
        p
      ),
      E(
        "ERR_MANIFEST_INTEGRITY_MISMATCH",
        "Manifest resource %s has multiple entries but integrity lists do not match",
        X
      ),
      E(
        "ERR_MANIFEST_INVALID_RESOURCE_FIELD",
        "Manifest resource %s has invalid property value for %s",
        Z
      ),
      E(
        "ERR_MANIFEST_INVALID_SPECIFIER",
        "Manifest resource %s has invalid dependency mapping %s",
        Z
      ),
      E("ERR_MANIFEST_TDZ", "Manifest initialization has not yet run", p),
      E(
        "ERR_MANIFEST_UNKNOWN_ONERROR",
        'Manifest specified unknown error behavior "%s".',
        X
      ),
      E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", p),
      E(
        "ERR_MISSING_ARGS",
        (...e) => {
          Te(e.length > 0, "At least one arg needs to be specified");
          let t = "The ";
          const r = e.length,
            wrap = (e) => `"${e}"`;
          return (
            (t += `${formatList(
              (e = d(e, (e) => (_(e) ? T(d(e, wrap), " or ") : wrap(e))))
            )} argument${r > 1 ? "s" : ""}`),
            `${t} must be specified`
          );
        },
        Z
      ),
      E("ERR_MISSING_OPTION", "%s is required", Z),
      E(
        "ERR_MODULE_NOT_FOUND",
        function (e, t, r) {
          return (
            r && lazyInternalUtil().setOwnProperty(this, "url", `${r}`),
            `Cannot find ${r ? "module" : "package"} '${e}' imported from ${t}`
          );
        },
        p
      ),
      E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", p),
      E("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function", Z),
      E(
        "ERR_NAPI_INVALID_DATAVIEW_ARGS",
        "byte_offset + byte_length should be less than or equal to the size in bytes of the array passed in",
        k
      ),
      E(
        "ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT",
        "start offset of %s should be a multiple of %s",
        k
      ),
      E("ERR_NAPI_INVALID_TYPEDARRAY_LENGTH", "Invalid typed array length", k),
      E(
        "ERR_NETWORK_IMPORT_BAD_RESPONSE",
        "import '%s' received a bad response: %s",
        p
      ),
      E(
        "ERR_NETWORK_IMPORT_DISALLOWED",
        "import of '%s' by %s is not supported: %s",
        p
      ),
      E(
        "ERR_NOT_BUILDING_SNAPSHOT",
        "Operation cannot be invoked when not building startup snapshot",
        p
      ),
      E(
        "ERR_NO_CRYPTO",
        "Node.js is not compiled with OpenSSL crypto support",
        p
      ),
      E("ERR_NO_ICU", "%s is not supported on Node.js compiled without ICU", Z),
      E("ERR_OPERATION_FAILED", "Operation failed: %s", p, Z),
      E(
        "ERR_OUT_OF_RANGE",
        (e, t, r, n = !1) => {
          Te(t, 'Missing "range" argument');
          let o,
            s = n ? e : `The value of "${e}" is out of range.`;
          return (
            C(r) && f(r) > 2 ** 32
              ? (o = addNumericalSeparator(G(r)))
              : "bigint" == typeof r
              ? ((o = G(r)),
                (r > 2n ** 32n || r < -(2n ** 32n)) &&
                  (o = addNumericalSeparator(o)),
                (o += "n"))
              : (o = lazyInternalUtilInspect().inspect(r)),
            (s += ` It must be ${t}. Received ${o}`),
            s
          );
        },
        k
      ),
      E(
        "ERR_PACKAGE_IMPORT_NOT_DEFINED",
        (e, t, r) =>
          `Package import specifier "${e}" is not defined${
            t ? ` in package ${t}package.json` : ""
          } imported from ${r}`,
        Z
      ),
      E(
        "ERR_PACKAGE_PATH_NOT_EXPORTED",
        (e, t, r = void 0) =>
          "." === t
            ? `No "exports" main defined in ${e}package.json${
                r ? ` imported from ${r}` : ""
              }`
            : `Package subpath '${t}' is not defined by "exports" in ${e}package.json${
                r ? ` imported from ${r}` : ""
              }`,
        p
      ),
      E("ERR_PARSE_ARGS_INVALID_OPTION_VALUE", "%s", Z),
      E(
        "ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL",
        "Unexpected argument '%s'. This command does not take positional arguments",
        Z
      ),
      E(
        "ERR_PARSE_ARGS_UNKNOWN_OPTION",
        (e, t) =>
          `Unknown option '${e}'${
            t
              ? `. To specify a positional argument starting with a '-', place it at the end of the command after '--', as in '-- ${h(
                  e
                )}`
              : ""
          }`,
        Z
      ),
      E("ERR_PERFORMANCE_INVALID_TIMESTAMP", "%d is not a valid timestamp", Z),
      E("ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS", "%s", Z),
      E(
        "ERR_REQUIRE_ESM",
        function (e, r, n = null, o = null) {
          hideInternalStackFrames(this);
          let s = `require() of ES Module ${e}${
            n ? ` from ${n}` : ""
          } not supported.`;
          if (!o)
            return (
              Y(e, ".mjs") &&
                (s += `\nInstead change the require of ${e} to a dynamic import() which is available in all CommonJS modules.`),
              s
            );
          const a = t("path"),
            i = n && a.basename(e) === a.basename(n) ? e : a.basename(e);
          return r
            ? ((s += `\nInstead change the require of ${i} in ${n} to a dynamic import() which is available in all CommonJS modules.`),
              s)
            : ((s += `\n${i} is treated as an ES module file as it is a .js file whose nearest parent package.json contains "type": "module" which declares all .js files in that package scope as ES modules.\nInstead either rename ${i} to end in .cjs, change the requiring code to use dynamic import() which is available in all CommonJS modules, or change "type": "module" to "type": "commonjs" in ${o} to treat all .js files as CommonJS (using .mjs for all ES modules instead).\n`),
              s);
        },
        p
      ),
      E(
        "ERR_SCRIPT_EXECUTION_INTERRUPTED",
        "Script execution was interrupted by `SIGINT`",
        p
      ),
      E(
        "ERR_SERVER_ALREADY_LISTEN",
        "Listen method has been called more than once without closing.",
        p
      ),
      E("ERR_SERVER_NOT_RUNNING", "Server is not running.", p),
      E("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound", p),
      E(
        "ERR_SOCKET_BAD_BUFFER_SIZE",
        "Buffer size must be a positive integer",
        Z
      ),
      E(
        "ERR_SOCKET_BAD_PORT",
        (e, t, r = !0) => {
          Te(
            "boolean" == typeof r,
            "The 'allowZero' argument must be of type boolean."
          );
          return `${e} should be ${
            r ? ">=" : ">"
          } 0 and < 65536. Received ${determineSpecificType(t)}.`;
        },
        k
      ),
      E(
        "ERR_SOCKET_BAD_TYPE",
        "Bad socket type specified. Valid types are: udp4, udp6",
        Z
      ),
      E(
        "ERR_SOCKET_BUFFER_SIZE",
        "Could not get or set buffer size",
        SystemError
      ),
      E("ERR_SOCKET_CLOSED", "Socket is closed", p),
      E(
        "ERR_SOCKET_CLOSED_BEFORE_CONNECTION",
        "Socket closed before the connection was established",
        p
      ),
      E("ERR_SOCKET_DGRAM_IS_CONNECTED", "Already connected", p),
      E("ERR_SOCKET_DGRAM_NOT_CONNECTED", "Not connected", p),
      E("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running", p),
      E(
        "ERR_SRI_PARSE",
        "Subresource Integrity string %j had an unexpected %j at position %d",
        X
      ),
      E(
        "ERR_STREAM_ALREADY_FINISHED",
        "Cannot call %s after a stream was finished",
        p
      ),
      E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", p),
      E(
        "ERR_STREAM_DESTROYED",
        "Cannot call %s after a stream was destroyed",
        p
      ),
      E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", Z),
      E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", p),
      E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", p),
      E(
        "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
        "stream.unshift() after end event",
        p
      ),
      E(
        "ERR_STREAM_WRAP",
        "Stream has StringDecoder set or is in objectMode",
        p
      ),
      E("ERR_STREAM_WRITE_AFTER_END", "write after end", p),
      E("ERR_SYNTHETIC", "JavaScript Callstack", p),
      E("ERR_SYSTEM_ERROR", "A system error occurred", SystemError),
      E(
        "ERR_TAP_LEXER_ERROR",
        function (e) {
          return hideInternalStackFrames(this), e;
        },
        p
      ),
      E(
        "ERR_TAP_PARSER_ERROR",
        function (e, t, r, n) {
          hideInternalStackFrames(this), (this.cause = r);
          const { column: o, line: s, start: a, end: i } = r.location;
          return e + `${t} at line ${s}, column ${o} (start ${a}, end ${i})`;
        },
        X
      ),
      E(
        "ERR_TAP_VALIDATION_ERROR",
        function (e) {
          return hideInternalStackFrames(this), e;
        },
        p
      ),
      E(
        "ERR_TEST_FAILURE",
        function (e, t) {
          hideInternalStackFrames(this),
            Te(
              "string" == typeof t || "symbol" == typeof t,
              "The 'failureType' argument must be of type string or symbol."
            );
          let r = e?.message ?? e;
          return (
            "string" != typeof r && (r = inspectWithNoCustomRetry(r)),
            (this.failureType = t),
            (this.cause = e),
            r
          );
        },
        p
      ),
      E(
        "ERR_TLS_ALPN_CALLBACK_INVALID_RESULT",
        (e, t) =>
          `ALPN callback returned a value (${e}) that did not match any of the client's offered protocols (${t.join(
            ", "
          )})`,
        Z
      ),
      E(
        "ERR_TLS_ALPN_CALLBACK_WITH_PROTOCOLS",
        "The ALPNCallback and ALPNProtocols TLS options are mutually exclusive",
        Z
      ),
      E(
        "ERR_TLS_CERT_ALTNAME_FORMAT",
        "Invalid subject alternative name string",
        X
      ),
      E(
        "ERR_TLS_CERT_ALTNAME_INVALID",
        function (e, t, r) {
          return (
            (this.reason = e),
            (this.host = t),
            (this.cert = r),
            `Hostname/IP does not match certificate's altnames: ${e}`
          );
        },
        p
      ),
      E("ERR_TLS_DH_PARAM_SIZE", "DH parameter size %s is less than 2048", p),
      E("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout", p),
      E("ERR_TLS_INVALID_CONTEXT", "%s must be a SecureContext", Z),
      E(
        "ERR_TLS_INVALID_PROTOCOL_VERSION",
        "%j is not a valid %s TLS protocol version",
        Z
      ),
      E(
        "ERR_TLS_INVALID_STATE",
        "TLS socket connection must be securely established",
        p
      ),
      E(
        "ERR_TLS_PROTOCOL_VERSION_CONFLICT",
        "TLS protocol version %j conflicts with secureProtocol %j",
        Z
      ),
      E(
        "ERR_TLS_RENEGOTIATION_DISABLED",
        "TLS session renegotiation disabled for this socket",
        p
      ),
      E(
        "ERR_TLS_REQUIRED_SERVER_NAME",
        '"servername" is required parameter for Server.addContext',
        p
      ),
      E(
        "ERR_TLS_SESSION_ATTACK",
        "TLS session renegotiation attack detected",
        p
      ),
      E(
        "ERR_TLS_SNI_FROM_SERVER",
        "Cannot issue SNI from a TLS server-side socket",
        p
      ),
      E(
        "ERR_TRACE_EVENTS_CATEGORY_REQUIRED",
        "At least one category is required",
        Z
      ),
      E("ERR_TRACE_EVENTS_UNAVAILABLE", "Trace events are unavailable", p),
      E("ERR_TTY_INIT_FAILED", "TTY initialization failed", SystemError),
      E(
        "ERR_UNAVAILABLE_DURING_EXIT",
        "Cannot call function in process exit handler",
        p
      ),
      E(
        "ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET",
        "`process.setupUncaughtExceptionCapture()` was called while a capture callback was already active",
        p
      ),
      E("ERR_UNESCAPED_CHARACTERS", "%s contains unescaped characters", Z),
      E(
        "ERR_UNHANDLED_ERROR",
        (e = void 0) => {
          const t = "Unhandled error.";
          return void 0 === e ? t : `${t} (${e})`;
        },
        p
      ),
      E("ERR_UNKNOWN_BUILTIN_MODULE", "No such built-in module: %s", p),
      E("ERR_UNKNOWN_CREDENTIAL", "%s identifier does not exist: %s", p),
      E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", Z),
      E("ERR_UNKNOWN_FILE_EXTENSION", 'Unknown file extension "%s" for %s', Z),
      E("ERR_UNKNOWN_MODULE_FORMAT", "Unknown module format: %s for URL %s", k),
      E("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s", Z),
      E(
        "ERR_UNSUPPORTED_DIR_IMPORT",
        function (e, t, r) {
          return (
            lazyInternalUtil().setOwnProperty(this, "url", r),
            `Directory import '${e}' is not supported resolving ES modules imported from ${t}`
          );
        },
        p
      ),
      E(
        "ERR_UNSUPPORTED_ESM_URL_SCHEME",
        (e, t) => {
          let r = `Only URLs with a scheme in: ${formatList(
            t
          )} are supported by the default ESM loader`;
          return (
            ee &&
              2 === e.protocol.length &&
              (r += ". On Windows, absolute paths must be valid file:// URLs"),
            (r += `. Received protocol '${e.protocol}'`),
            r
          );
        },
        p
      ),
      E("ERR_USE_AFTER_CLOSE", "%s was closed", p),
      E(
        "ERR_VALID_PERFORMANCE_ENTRY_TYPE",
        "At least one valid performance entry type is required",
        p
      ),
      E(
        "ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING",
        "A dynamic import callback was not specified.",
        Z
      ),
      E(
        "ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG",
        "A dynamic import callback was invoked without --experimental-vm-modules",
        Z
      ),
      E("ERR_VM_MODULE_ALREADY_LINKED", "Module has already been linked", p),
      E(
        "ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA",
        "Cached data cannot be created for a module which has been evaluated",
        p
      ),
      E(
        "ERR_VM_MODULE_DIFFERENT_CONTEXT",
        "Linked modules must use the same context",
        p
      ),
      E(
        "ERR_VM_MODULE_LINK_FAILURE",
        function (e, t) {
          return (this.cause = t), e;
        },
        p
      ),
      E(
        "ERR_VM_MODULE_NOT_MODULE",
        "Provided module is not an instance of Module",
        p
      ),
      E("ERR_VM_MODULE_STATUS", "Module status %s", p),
      E("ERR_WASI_ALREADY_STARTED", "WASI instance has already started", p),
      E("ERR_WEBASSEMBLY_RESPONSE", "WebAssembly response %s", Z),
      E("ERR_WORKER_INIT_FAILED", "Worker initialization failure: %s", p),
      E(
        "ERR_WORKER_INVALID_EXEC_ARGV",
        (e, t = "invalid execArgv flags") =>
          `Initiated Worker with ${t}: ${T(e, ", ")}`,
        p
      ),
      E("ERR_WORKER_NOT_RUNNING", "Worker instance not running", p),
      E(
        "ERR_WORKER_OUT_OF_MEMORY",
        "Worker terminated due to reaching memory limit: %s",
        p
      ),
      E(
        "ERR_WORKER_PATH",
        (e) =>
          "The worker script or module filename must be an absolute path or a relative path starting with './' or '../'." +
          (x(e, "file://") ? " Wrap file:// URLs with `new URL`." : "") +
          (x(e, "data:text/javascript")
            ? " Wrap data: URLs with `new URL`."
            : "") +
          ` Received "${e}"`,
        Z
      ),
      E(
        "ERR_WORKER_UNSERIALIZABLE_ERROR",
        "Serializing an uncaught exception failed",
        p
      ),
      E(
        "ERR_WORKER_UNSUPPORTED_OPERATION",
        "%s is not supported in workers",
        Z
      ),
      E("ERR_ZLIB_INITIALIZATION_FAILED", "Initialization failed", p);
  },
  "internal/event_target": function (e, t, n, i, r, s) {
    "use strict";
    const {
        ArrayFrom: o,
        Boolean: a,
        Error: h,
        FunctionPrototypeCall: v,
        NumberIsInteger: l,
        ObjectAssign: d,
        ObjectDefineProperties: c,
        ObjectDefineProperty: u,
        ObjectGetOwnPropertyDescriptor: E,
        ObjectGetOwnPropertyDescriptors: g,
        ObjectSetPrototypeOf: p,
        ObjectValues: f,
        ReflectApply: w,
        SafeArrayIterator: m,
        SafeFinalizationRegistry: T,
        SafeMap: b,
        SafeWeakMap: y,
        SafeWeakRef: L,
        SafeWeakSet: N,
        String: k,
        Symbol: S,
        SymbolFor: _,
        SymbolToStringTag: x,
      } = s,
      {
        codes: {
          ERR_INVALID_ARG_TYPE: P,
          ERR_EVENT_RECURSION: R,
          ERR_MISSING_ARGS: A,
          ERR_INVALID_THIS: I,
        },
      } = t("internal/errors"),
      { validateObject: M, validateString: C } = t("internal/validators"),
      {
        customInspectSymbol: z,
        kEmptyObject: O,
        kEnumerableProperty: H,
      } = t("internal/util"),
      { inspect: j } = t("util"),
      D = t("internal/webidl"),
      W = _("nodejs.event_target"),
      $ = S("kIsNodeEventTarget"),
      G = t("events"),
      { kMaxEventTargetListeners: B, kMaxEventTargetListenersWarned: U } = G,
      F = S("kEvents"),
      V = S("kIsBeingDispatched"),
      Y = S("kStop"),
      q = S("kTarget"),
      J = S("kHandlers"),
      K = S("kWeak"),
      Q = S("kResistStopPropagation"),
      X = _("nodejs.internal.kHybridDispatch"),
      Z = S("nodejs.internal.removeWeakListenerHelper"),
      ee = S("kCreateEvent"),
      te = S("kNewListener"),
      ne = S("kRemoveListener"),
      ie = S("kIsNodeStyleListener"),
      re = S("kTrustEvent"),
      { now: se } = t("internal/perf/utils"),
      oe = S("type"),
      ae = S("detail"),
      he = new N(),
      ve = {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        get: E(
          {
            get isTrusted() {
              return he.has(this);
            },
          },
          "isTrusted"
        ).get,
      };
    function isEvent(e) {
      return "string" == typeof e?.[oe];
    }
    class Event {
      #e = !1;
      #t = !1;
      #n = !1;
      #i = !1;
      #r = se();
      #s = !1;
      constructor(e, t = O) {
        if (0 === arguments.length) throw new A("type");
        M(t, "options");
        const { bubbles: n, cancelable: i, composed: r } = t;
        (this.#e = !!i),
          (this.#t = !!n),
          (this.#n = !!r),
          (this[oe] = `${e}`),
          t?.[re] && he.add(this),
          (this[q] = null),
          (this[V] = !1);
      }
      [z](e, t) {
        if (!isEvent(this)) throw new I("Event");
        const n = this.constructor.name;
        if (e < 0) return n;
        const i = d({}, t, { depth: l(t.depth) ? t.depth - 1 : t.depth });
        return `${n} ${j(
          {
            type: this[oe],
            defaultPrevented: this.#i,
            cancelable: this.#e,
            timeStamp: this.#r,
          },
          i
        )}`;
      }
      stopImmediatePropagation() {
        if (!isEvent(this)) throw new I("Event");
        this[Y] = !0;
      }
      preventDefault() {
        if (!isEvent(this)) throw new I("Event");
        this.#i = !0;
      }
      get target() {
        if (!isEvent(this)) throw new I("Event");
        return this[q];
      }
      get currentTarget() {
        if (!isEvent(this)) throw new I("Event");
        return this[q];
      }
      get srcElement() {
        if (!isEvent(this)) throw new I("Event");
        return this[q];
      }
      get type() {
        if (!isEvent(this)) throw new I("Event");
        return this[oe];
      }
      get cancelable() {
        if (!isEvent(this)) throw new I("Event");
        return this.#e;
      }
      get defaultPrevented() {
        if (!isEvent(this)) throw new I("Event");
        return this.#e && this.#i;
      }
      get timeStamp() {
        if (!isEvent(this)) throw new I("Event");
        return this.#r;
      }
      composedPath() {
        if (!isEvent(this)) throw new I("Event");
        return this[V] ? [this[q]] : [];
      }
      get returnValue() {
        if (!isEvent(this)) throw new I("Event");
        return !this.#e || !this.#i;
      }
      get bubbles() {
        if (!isEvent(this)) throw new I("Event");
        return this.#t;
      }
      get composed() {
        if (!isEvent(this)) throw new I("Event");
        return this.#n;
      }
      get eventPhase() {
        if (!isEvent(this)) throw new I("Event");
        return this[V] ? Event.AT_TARGET : Event.NONE;
      }
      get cancelBubble() {
        if (!isEvent(this)) throw new I("Event");
        return this.#s;
      }
      set cancelBubble(e) {
        if (!isEvent(this)) throw new I("Event");
        e && this.stopPropagation();
      }
      stopPropagation() {
        if (!isEvent(this)) throw new I("Event");
        this.#s = !0;
      }
      static NONE = 0;
      static CAPTURING_PHASE = 1;
      static AT_TARGET = 2;
      static BUBBLING_PHASE = 3;
    }
    c(Event.prototype, {
      [x]: {
        __proto__: null,
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: "Event",
      },
      stopImmediatePropagation: H,
      preventDefault: H,
      target: H,
      currentTarget: H,
      srcElement: H,
      type: H,
      cancelable: H,
      defaultPrevented: H,
      timeStamp: H,
      composedPath: H,
      returnValue: H,
      bubbles: H,
      composed: H,
      eventPhase: H,
      cancelBubble: H,
      stopPropagation: H,
      isTrusted: ve,
    });
    class CustomEvent extends Event {
      constructor(e, t = O) {
        if (0 === arguments.length) throw new A("type");
        super(e, t), (this[ae] = t?.detail ?? null);
      }
      get detail() {
        if (
          !(function isCustomEvent(e) {
            return isEvent(e) && void 0 !== e?.[ae];
          })(this)
        )
          throw new I("CustomEvent");
        return this[ae];
      }
    }
    c(CustomEvent.prototype, {
      [x]: {
        __proto__: null,
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: "CustomEvent",
      },
      detail: H,
    });
    class NodeCustomEvent extends Event {
      constructor(e, t) {
        super(e, t), t?.detail && (this.detail = t.detail);
      }
    }
    let le = null,
      de = null;
    function weakListeners() {
      return (
        (le ??= new T(({ eventTarget: e, listener: t, eventType: n }) =>
          e.deref()?.[Z](n, t)
        )),
        (de ??= new y()),
        { registry: le, map: de }
      );
    }
    class Listener {
      constructor(e, t, n, i, r, s, o, a, h, v) {
        (this.next = void 0),
          void 0 !== n && (n.next = this),
          (this.previous = n),
          (this.listener = i);
        let l = 0;
        r && (l |= 1),
          s && (l |= 2),
          o && (l |= 4),
          a && (l |= 8),
          h && (l |= 16),
          v && (l |= 64),
          (this.flags = l),
          (this.removed = !1),
          this.weak
            ? ((this.callback = new L(i)),
              weakListeners().registry.register(
                i,
                {
                  __proto__: null,
                  eventTarget: new L(e),
                  listener: this,
                  eventType: t,
                },
                this
              ),
              weakListeners().map.set(h, i),
              (this.listener = this.callback))
            : "function" == typeof i
            ? ((this.callback = i), (this.listener = i))
            : ((this.callback = async (...e) => {
                i.handleEvent && (await w(i.handleEvent, i, e));
              }),
              (this.listener = i));
      }
      get once() {
        return a(1 & this.flags);
      }
      get capture() {
        return a(2 & this.flags);
      }
      get passive() {
        return a(4 & this.flags);
      }
      get isNodeStyleListener() {
        return a(8 & this.flags);
      }
      get weak() {
        return a(16 & this.flags);
      }
      get resistStopPropagation() {
        return a(64 & this.flags);
      }
      get removed() {
        return a(32 & this.flags);
      }
      set removed(e) {
        e ? (this.flags |= 32) : (this.flags &= -33);
      }
      same(e, t) {
        return (
          (this.weak ? this.listener.deref() : this.listener) === e &&
          this.capture === t
        );
      }
      remove() {
        void 0 !== this.previous && (this.previous.next = this.next),
          void 0 !== this.next && (this.next.previous = this.previous),
          (this.removed = !0),
          this.weak && weakListeners().registry.unregister(this);
      }
    }
    function initEventTarget(e) {
      (e[F] = new b()), (e[B] = G.defaultMaxListeners), (e[U] = !1);
    }
    class EventTarget {
      static [W] = !0;
      constructor() {
        initEventTarget(this);
      }
      [te](e, t, n, r, s, o, a) {
        if (this[B] > 0 && e > this[B] && !this[U]) {
          this[U] = !0;
          const n = new h(
            `Possible EventTarget memory leak detected. ${e} ${t} listeners added to ${j(
              this,
              { depth: -1 }
            )}. Use events.setMaxListeners() to increase limit`
          );
          (n.name = "MaxListenersExceededWarning"),
            (n.target = this),
            (n.type = t),
            (n.count = e),
            i.emitWarning(n);
        }
      }
      [ne](e, t, n, i) {}
      addEventListener(e, t, n = O) {
        if (!isEventTarget(this)) throw new I("EventTarget");
        if (arguments.length < 2) throw new A("type", "listener");
        const {
          once: r,
          capture: s,
          passive: o,
          signal: v,
          isNodeStyleListener: l,
          weak: d,
          resistStopPropagation: c,
        } = (function validateEventListenerOptions(e) {
          return "boolean" == typeof e
            ? { capture: e }
            : null === e
            ? O
            : (M(e, "options", { allowArray: !0, allowFunction: !0 }),
              {
                once: a(e.once),
                capture: a(e.capture),
                passive: a(e.passive),
                signal: e.signal,
                weak: e[K],
                resistStopPropagation: e[Q] ?? !1,
                isNodeStyleListener: a(e[ie]),
              });
        })(n);
        if (!validateEventListener(t)) {
          const n = new h(
            `addEventListener called with ${t} which has no effect.`
          );
          return (
            (n.name = "AddEventListenerArgumentTypeWarning"),
            (n.target = this),
            (n.type = e),
            void i.emitWarning(n)
          );
        }
        if (((e = D.converters.DOMString(e)), v)) {
          if (v.aborted) return;
          v.addEventListener(
            "abort",
            () => {
              this.removeEventListener(e, t, n);
            },
            { __proto__: null, once: !0, [K]: this, [Q]: !0 }
          );
        }
        let u = this[F].get(e);
        if (void 0 === u)
          return (
            (u = { size: 1, next: void 0, resistStopPropagation: a(c) }),
            new Listener(this, e, u, t, r, s, o, l, d, c),
            this[te](u.size, e, t, r, s, o, d),
            void this[F].set(e, u)
          );
        let E = u.next,
          g = u;
        for (; void 0 !== E && !E.same(t, s); ) (g = E), (E = E.next);
        void 0 === E &&
          (new Listener(this, e, g, t, r, s, o, l, d, c),
          u.size++,
          (u.resistStopPropagation ||= a(c)),
          this[te](u.size, e, t, r, s, o, d));
      }
      removeEventListener(e, t, n = O) {
        if (!isEventTarget(this)) throw new I("EventTarget");
        if (arguments.length < 2) throw new A("type", "listener");
        if (!validateEventListener(t)) return;
        e = D.converters.DOMString(e);
        const i = !0 === n?.capture,
          r = this[F].get(e);
        if (void 0 === r || void 0 === r.next) return;
        let s = r.next;
        for (; void 0 !== s; ) {
          if (s.same(t, i)) {
            s.remove(),
              r.size--,
              0 === r.size && this[F].delete(e),
              this[ne](r.size, e, t, i);
            break;
          }
          s = s.next;
        }
      }
      [Z](e, t) {
        const n = this[F].get(e);
        if (void 0 === n || void 0 === n.next) return;
        const i = !0 === t.capture;
        let r = n.next;
        for (; void 0 !== r; ) {
          if (r === t) {
            r.remove(),
              n.size--,
              0 === n.size && this[F].delete(e),
              this[ne](n.size, e, void 0, i);
            break;
          }
          r = r.next;
        }
      }
      dispatchEvent(e) {
        if (!isEventTarget(this)) throw new I("EventTarget");
        if (arguments.length < 1) throw new A("event");
        if (!(e instanceof Event)) throw new P("event", "Event", e);
        if (e[V]) throw new R(e.type);
        return this[X](e, e.type, e), !0 !== e.defaultPrevented;
      }
      [X](e, t, n) {
        const createEvent = () => (
          void 0 === n && (((n = this[ee](e, t))[q] = this), (n[V] = !0)), n
        );
        void 0 !== n && ((n[q] = this), (n[V] = !0));
        const i = this[F].get(t);
        if (void 0 === i || void 0 === i.next)
          return void 0 !== n && (n[V] = !1), !0;
        let r,
          s = i.next;
        for (
          ;
          void 0 !== s &&
          (i.resistStopPropagation || s.passive || !0 !== n?.[Y]);

        )
          if (
            ((r = s.next),
            s.removed || (!0 === n?.[Y] && !s.resistStopPropagation))
          )
            s = r;
          else {
            if (s.once) {
              s.remove(), i.size--;
              const { listener: e, capture: n } = s;
              this[ne](i.size, t, e, n);
            }
            try {
              let t;
              t = s.isNodeStyleListener ? e : createEvent();
              const n = s.weak ? s.callback.deref() : s.callback;
              let i;
              n && ((i = v(n, this, t)), s.isNodeStyleListener || (t[V] = !1)),
                null != i && addCatch(i);
            } catch (e) {
              emitUncaughtException(e);
            }
            s = r;
          }
        void 0 !== n && (n[V] = !1);
      }
      [ee](e, t) {
        return new NodeCustomEvent(t, { detail: e });
      }
      [z](e, t) {
        if (!isEventTarget(this)) throw new I("EventTarget");
        const n = this.constructor.name;
        if (e < 0) return n;
        const i = d({}, t, { depth: l(t.depth) ? t.depth - 1 : t.depth });
        return `${n} ${j({}, i)}`;
      }
    }
    function initNodeEventTarget(e) {
      initEventTarget(e);
    }
    c(EventTarget.prototype, {
      addEventListener: H,
      removeEventListener: H,
      dispatchEvent: H,
      [x]: {
        __proto__: null,
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: "EventTarget",
      },
    });
    class NodeEventTarget extends EventTarget {
      static [$] = !0;
      static defaultMaxListeners = 10;
      constructor() {
        super(), initNodeEventTarget(this);
      }
      setMaxListeners(e) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        G.setMaxListeners(e, this);
      }
      getMaxListeners() {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return this[B];
      }
      eventNames() {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return o(this[F].keys());
      }
      listenerCount(e) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        const t = this[F].get(k(e));
        return void 0 !== t ? t.size : 0;
      }
      off(e, t, n) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return this.removeEventListener(e, t, n), this;
      }
      removeListener(e, t, n) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return this.removeEventListener(e, t, n), this;
      }
      on(e, t) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return this.addEventListener(e, t, { [ie]: !0 }), this;
      }
      addListener(e, t) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return this.addEventListener(e, t, { [ie]: !0 }), this;
      }
      emit(e, t) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        C(e, "type");
        const n = this.listenerCount(e) > 0;
        return this[X](t, e), n;
      }
      once(e, t) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return this.addEventListener(e, t, { once: !0, [ie]: !0 }), this;
      }
      removeAllListeners(e) {
        if (!isNodeEventTarget(this)) throw new I("NodeEventTarget");
        return void 0 !== e ? this[F].delete(k(e)) : this[F].clear(), this;
      }
    }
    function validateEventListener(e) {
      if ("function" == typeof e || "function" == typeof e?.handleEvent)
        return !0;
      if (null == e) return !1;
      if ("object" == typeof e) return !0;
      throw new P("listener", "EventListener", e);
    }
    function isEventTarget(e) {
      return e?.constructor?.[W];
    }
    function isNodeEventTarget(e) {
      return e?.constructor?.[$];
    }
    function addCatch(e) {
      const t = e.then;
      "function" == typeof t &&
        v(t, e, void 0, function (e) {
          emitUncaughtException(e);
        });
    }
    function emitUncaughtException(e) {
      i.nextTick(() => {
        throw e;
      });
    }
    c(NodeEventTarget.prototype, {
      setMaxListeners: H,
      getMaxListeners: H,
      eventNames: H,
      listenerCount: H,
      off: H,
      removeListener: H,
      on: H,
      addListener: H,
      once: H,
      emit: H,
      removeAllListeners: H,
    });
    n.exports = {
      Event: Event,
      CustomEvent: CustomEvent,
      EventEmitterMixin: (e) => {
        class MixedEventEmitter extends e {
          constructor(...e) {
            (e = new m(e)), super(...e), v(G, this);
          }
        }
        const t = g(G.prototype);
        delete t.constructor;
        const n = f(t);
        for (let e = 0; e < n.length; e++) p(n[e], null);
        return c(MixedEventEmitter.prototype, t), MixedEventEmitter;
      },
      EventTarget: EventTarget,
      NodeEventTarget: NodeEventTarget,
      defineEventHandler: function defineEventHandler(e, t) {
        u(e, `on${t}`, {
          __proto__: null,
          get() {
            return this[J]?.get(t)?.handler ?? null;
          },
          set(e) {
            this[J] || (this[J] = new b());
            let n = this[J]?.get(t);
            if (n) {
              if ("function" == typeof n.handler) {
                this[F].get(t).size--;
                const e = this[F].get(t).size;
                this[ne](e, t, n.handler, !1);
              }
              if (((n.handler = e), "function" == typeof n.handler)) {
                this[F].get(t).size++;
                const n = this[F].get(t).size;
                this[te](n, t, e, !1, !1, !1, !1);
              }
            } else
              (n = (function makeEventHandler(e) {
                function eventHandler(...e) {
                  if ("function" == typeof eventHandler.handler)
                    return w(eventHandler.handler, this, e);
                }
                return (eventHandler.handler = e), eventHandler;
              })(e)),
                this.addEventListener(t, n);
            this[J].set(t, n);
          },
          configurable: !0,
          enumerable: !0,
        });
      },
      initEventTarget: initEventTarget,
      initNodeEventTarget: initNodeEventTarget,
      kCreateEvent: ee,
      kNewListener: te,
      kTrustEvent: re,
      kRemoveListener: ne,
      kEvents: F,
      kWeakHandler: K,
      kResistStopPropagation: Q,
      isEventTarget: isEventTarget,
    };
  },
  "internal/file": function (e, t, i, n, l, s) {
    "use strict";
    const {
        DateNow: r,
        NumberIsNaN: o,
        ObjectDefineProperties: a,
        SymbolToStringTag: d,
      } = s,
      { Blob: u } = t("internal/blob"),
      {
        customInspectSymbol: f,
        emitExperimentalWarning: p,
        kEnumerableProperty: m,
        kEmptyObject: c,
        toUSVString: h,
      } = t("internal/util"),
      {
        codes: { ERR_MISSING_ARGS: b },
      } = t("internal/errors"),
      { inspect: M } = t("internal/util/inspect");
    class File extends u {
      #e;
      #t;
      constructor(e, t, i = c) {
        if ((p("buffer.File"), arguments.length < 2))
          throw new b("fileBits", "fileName");
        super(e, i);
        let { lastModified: n } = i ?? c;
        void 0 !== n ? ((n = +n), o(n) && (n = 0)) : (n = r()),
          (this.#e = h(t)),
          (this.#t = n);
      }
      get name() {
        return this.#e;
      }
      get lastModified() {
        return this.#t;
      }
      [f](e, t) {
        if (e < 0) return this;
        const i = { ...t, depth: null == t.depth ? null : t.depth - 1 };
        return `File ${M(
          {
            size: this.size,
            type: this.type,
            name: this.#e,
            lastModified: this.#t,
          },
          i
        )}`;
      }
    }
    a(File.prototype, {
      name: m,
      lastModified: m,
      [d]: { __proto__: null, configurable: !0, value: "File" },
    }),
      (i.exports = { File: File });
  },
  "internal/fixed_queue": function (t, s, i, h, o, e) {
    "use strict";
    const { Array: r } = e,
      u = 2047;
    class FixedCircularBuffer {
      constructor() {
        (this.bottom = 0),
          (this.top = 0),
          (this.list = new r(2048)),
          (this.next = null);
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return ((this.top + 1) & u) === this.bottom;
      }
      push(t) {
        (this.list[this.top] = t), (this.top = (this.top + 1) & u);
      }
      shift() {
        const t = this.list[this.bottom];
        return void 0 === t
          ? null
          : ((this.list[this.bottom] = void 0),
            (this.bottom = (this.bottom + 1) & u),
            t);
      }
    }
    i.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(t) {
        this.head.isFull() &&
          (this.head = this.head.next = new FixedCircularBuffer()),
          this.head.push(t);
      }
      shift() {
        const t = this.tail,
          s = t.shift();
        return (
          t.isEmpty() &&
            null !== t.next &&
            ((this.tail = t.next), (t.next = null)),
          s
        );
      }
    };
  },
  "internal/freelist": function (t, s, i, h, e, l) {
    "use strict";
    const { ReflectApply: r } = l;
    i.exports = class FreeList {
      constructor(t, s, i) {
        (this.name = t), (this.ctor = i), (this.max = s), (this.list = []);
      }
      alloc() {
        return this.list.length > 0
          ? this.list.pop()
          : r(this.ctor, this, arguments);
      }
      free(t) {
        return this.list.length < this.max && (this.list.push(t), !0);
      }
    };
  },
  "internal/freeze_intrinsics": function (e, r, t, o, n, a) {
    "use strict";
    const {
        AggregateError: y,
        AggregateErrorPrototype: p,
        Array: i,
        ArrayBuffer: l,
        ArrayBufferPrototype: c,
        ArrayIteratorPrototype: u,
        ArrayPrototype: s,
        ArrayPrototypeForEach: P,
        ArrayPrototypePush: f,
        BigInt: m,
        BigInt64Array: b,
        BigInt64ArrayPrototype: A,
        BigIntPrototype: d,
        BigUint64Array: g,
        BigUint64ArrayPrototype: I,
        Boolean: E,
        BooleanPrototype: v,
        DataView: O,
        DataViewPrototype: F,
        Date: R,
        DatePrototype: w,
        Error: S,
        ErrorPrototype: h,
        EvalError: U,
        EvalErrorPrototype: _,
        FinalizationRegistry: D,
        FinalizationRegistryPrototype: j,
        Float32Array: B,
        Float32ArrayPrototype: T,
        Float64Array: q,
        Float64ArrayPrototype: C,
        Function: M,
        FunctionPrototype: N,
        Int16Array: k,
        Int16ArrayPrototype: z,
        Int32Array: W,
        Int32ArrayPrototype: x,
        Int8Array: G,
        Int8ArrayPrototype: L,
        IteratorPrototype: V,
        Map: $,
        MapPrototype: H,
        Number: J,
        NumberPrototype: K,
        Object: Q,
        ObjectDefineProperty: X,
        ObjectFreeze: Y,
        ObjectGetOwnPropertyDescriptor: Z,
        ObjectGetOwnPropertyDescriptors: ee,
        ObjectGetOwnPropertyNames: re,
        ObjectGetOwnPropertySymbols: te,
        ObjectGetPrototypeOf: oe,
        ObjectPrototype: ne,
        ObjectPrototypeHasOwnProperty: ae,
        Promise: ye,
        PromisePrototype: pe,
        Proxy: ie,
        RangeError: le,
        RangeErrorPrototype: ce,
        ReferenceError: ue,
        ReferenceErrorPrototype: se,
        ReflectOwnKeys: Pe,
        RegExp: fe,
        RegExpPrototype: me,
        SafeSet: be,
        Set: Ae,
        SetPrototype: de,
        String: ge,
        StringIteratorPrototype: Ie,
        StringPrototype: Ee,
        Symbol: ve,
        SymbolIterator: Oe,
        SymbolMatchAll: Fe,
        SymbolPrototype: Re,
        SyntaxError: we,
        SyntaxErrorPrototype: Se,
        TypeError: he,
        TypeErrorPrototype: Ue,
        TypedArray: _e,
        TypedArrayPrototype: De,
        Uint16Array: je,
        Uint16ArrayPrototype: Be,
        Uint32Array: Te,
        Uint32ArrayPrototype: qe,
        Uint8Array: Ce,
        Uint8ArrayPrototype: Me,
        Uint8ClampedArray: Ne,
        Uint8ClampedArrayPrototype: ke,
        URIError: ze,
        URIErrorPrototype: We,
        WeakMap: xe,
        WeakMapPrototype: Ge,
        WeakRef: Le,
        WeakRefPrototype: Ve,
        WeakSet: $e,
        WeakSetPrototype: He,
        decodeURI: Je,
        decodeURIComponent: Ke,
        encodeURI: Qe,
        encodeURIComponent: Xe,
        escape: Ye,
        globalThis: Ze,
        unescape: er,
      } = a,
      { Atomics: rr, Intl: tr, SharedArrayBuffer: or, WebAssembly: nr } = Ze;
    t.exports = function () {
      const { Console: e } = r("internal/console/constructor"),
        t = r("internal/console/global"),
        {
          clearImmediate: o,
          clearInterval: n,
          clearTimeout: a,
          setImmediate: ar,
          setInterval: yr,
          setTimeout: pr,
        } = r("timers"),
        ir = [
          ne,
          N,
          v,
          Re,
          h,
          p,
          _,
          ce,
          se,
          Se,
          Ue,
          We,
          K,
          d,
          w,
          Ee,
          Ie,
          me,
          oe(/e/[Fe]()),
          s,
          u,
          De,
          L,
          Me,
          ke,
          z,
          Be,
          x,
          qe,
          T,
          C,
          A,
          I,
          H,
          oe(new $()[Oe]()),
          de,
          oe(new Ae()[Oe]()),
          Ge,
          He,
          c,
          or.prototype,
          F,
          Ve,
          j,
          V,
          oe(oe(oe((async function* () {})()))),
          pe,
          e.prototype,
          nr.Module.prototype,
          nr.Instance.prototype,
          nr.Table.prototype,
          nr.Memory.prototype,
          nr.CompileError.prototype,
          nr.LinkError.prototype,
          nr.RuntimeError.prototype,
        ],
        lr = [
          Z(N, "caller").get,
          eval,
          isFinite,
          isNaN,
          parseFloat,
          parseInt,
          Je,
          Ke,
          Qe,
          Xe,
          Q,
          M,
          E,
          ve,
          S,
          y,
          U,
          le,
          ue,
          we,
          he,
          ze,
          J,
          m,
          Math,
          R,
          ge,
          Ie,
          fe,
          oe(/e/[Fe]()),
          i,
          u,
          _e,
          G,
          Ce,
          Ne,
          k,
          je,
          W,
          Te,
          B,
          q,
          b,
          g,
          $,
          oe(new $()[Oe]()),
          Ae,
          oe(new Ae()[Oe]()),
          xe,
          $e,
          l,
          or,
          O,
          rr,
          JSON,
          Le,
          D,
          oe(u),
          oe(oe(oe((async function* () {})()))),
          ye,
          oe(function* () {}),
          oe(async function* () {}),
          oe(async function () {}),
          Reflect,
          ie,
          Ye,
          er,
          o,
          n,
          a,
          ar,
          yr,
          pr,
          t,
          nr,
        ];
      void 0 !== tr &&
        (f(
          ir,
          tr.Collator.prototype,
          tr.DateTimeFormat.prototype,
          tr.ListFormat.prototype,
          tr.NumberFormat.prototype,
          tr.PluralRules.prototype,
          tr.RelativeTimeFormat.prototype
        ),
        f(lr, tr)),
        P(ir, function enableDerivedOverrides(e) {
          if (!e) return;
          const r = ee(e);
          if (!r) return;
          P(re(e), (t) => enableDerivedOverride(e, t, r[t])),
            P(te(e), (t) => enableDerivedOverride(e, t, r[t]));
        });
      const cr = new $e();
      function enableDerivedOverride(e, r, t) {
        if (ae(t, "value") && t.configurable) {
          let getter = function () {
              return o;
            },
            setter = function (t) {
              if (e === this)
                throw new he(
                  `Cannot assign to read only property '${r}' of object '${e}'`
                );
              ae(this, r)
                ? (this[r] = t)
                : X(this, r, {
                    __proto__: null,
                    value: t,
                    writable: !0,
                    enumerable: !0,
                    configurable: !0,
                  });
            };
          const o = t.value;
          (getter.value = o),
            X(e, r, {
              __proto__: null,
              get: getter,
              set: setter,
              enumerable: t.enumerable,
              configurable: t.configurable,
            });
        }
      }
      P(lr, function deepFreeze(e) {
        return (
          (function innerDeepFreeze(e) {
            const r = new be();
            function enqueue(e) {
              if (Q(e) !== e) return;
              cr.has(e) || r.has(e) || r.add(e);
            }
            function doFreeze(e) {
              Y(e);
              const r = oe(e),
                t = ee(e);
              enqueue(r),
                P(Pe(t), (e) => {
                  const r = t[e];
                  ae(r, "value")
                    ? enqueue(r.value)
                    : (enqueue(r.get), enqueue(r.set));
                });
            }
            function dequeue() {
              r.forEach(doFreeze);
            }
            function commit() {
              r.forEach(cr.add, cr);
            }
            enqueue(e), dequeue(), commit();
          })(e),
          e
        );
      }),
        X(Ze, "globalThis", {
          __proto__: null,
          configurable: !1,
          writable: !1,
          value: Ze,
        });
    };
  },
  "internal/fs/cp/cp": function (e, t, r, n, i, o) {
    "use strict";
    const {
        ArrayPrototypeEvery: s,
        ArrayPrototypeFilter: c,
        Boolean: a,
        PromisePrototypeThen: p,
        PromiseReject: d,
        SafePromiseAll: y,
        StringPrototypeSplit: u,
      } = o,
      {
        codes: {
          ERR_FS_CP_DIR_TO_NON_DIR: l,
          ERR_FS_CP_EEXIST: f,
          ERR_FS_CP_EINVAL: m,
          ERR_FS_CP_FIFO_PIPE: w,
          ERR_FS_CP_NON_DIR_TO_DIR: h,
          ERR_FS_CP_SOCKET: S,
          ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY: _,
          ERR_FS_CP_UNKNOWN: E,
          ERR_FS_EISDIR: I,
        },
      } = t("internal/errors"),
      {
        os: {
          errno: { EEXIST: D, EISDIR: N, EINVAL: R, ENOTDIR: F },
        },
      } = i("constants"),
      {
        chmod: P,
        copyFile: k,
        lstat: g,
        mkdir: T,
        opendir: A,
        readlink: b,
        stat: O,
        symlink: v,
        unlink: $,
        utimes: C,
      } = t("fs/promises"),
      {
        dirname: L,
        isAbsolute: V,
        join: M,
        parse: W,
        resolve: x,
        sep: K,
      } = t("path");
    async function checkPaths(e, t, r) {
      if (r.filter && !(await r.filter(e, t)))
        return { __proto__: null, skipped: !0 };
      const { 0: n, 1: i } = await (function getStats(e, t, r) {
        const n = r.dereference
          ? (e) => O(e, { bigint: !0 })
          : (e) => g(e, { bigint: !0 });
        return y([
          n(e),
          p(n(t), void 0, (e) => {
            if ("ENOENT" === e.code) return null;
            throw e;
          }),
        ]);
      })(e, t, r);
      if (i) {
        if (areIdentical(n, i))
          throw new m({
            message: "src and dest cannot be the same",
            path: t,
            syscall: "cp",
            errno: R,
            code: "EINVAL",
          });
        if (n.isDirectory() && !i.isDirectory())
          throw new l({
            message: `cannot overwrite directory ${e} with non-directory ${t}`,
            path: t,
            syscall: "cp",
            errno: N,
            code: "EISDIR",
          });
        if (!n.isDirectory() && i.isDirectory())
          throw new h({
            message: `cannot overwrite non-directory ${e} with directory ${t}`,
            path: t,
            syscall: "cp",
            errno: F,
            code: "ENOTDIR",
          });
      }
      if (n.isDirectory() && isSrcSubdir(e, t))
        throw new m({
          message: `cannot copy ${e} to a subdirectory of self ${t}`,
          path: t,
          syscall: "cp",
          errno: R,
          code: "EINVAL",
        });
      return { srcStat: n, destStat: i, skipped: !1 };
    }
    function areIdentical(e, t) {
      return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
    }
    async function checkParentPaths(e, t, r) {
      const n = x(L(e)),
        i = x(L(r));
      if (i === n || i === W(i).root) return;
      let o;
      try {
        o = await O(i, { bigint: !0 });
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw e;
      }
      if (areIdentical(t, o))
        throw new m({
          message: `cannot copy ${e} to a subdirectory of self ${r}`,
          path: r,
          syscall: "cp",
          errno: R,
          code: "EINVAL",
        });
      return checkParentPaths(e, t, i);
    }
    const normalizePathToArray = (e) => c(u(x(e), K), a);
    function isSrcSubdir(e, t) {
      const r = normalizePathToArray(e),
        n = normalizePathToArray(t);
      return s(r, (e, t) => n[t] === e);
    }
    async function getStatsForCopy(e, t, r, n) {
      const i = n.dereference ? O : g,
        o = await i(t);
      if (o.isDirectory() && n.recursive)
        return (function onDir(e, t, r, n, i) {
          return t
            ? copyDir(r, n, i)
            : (async function mkDirAndCopy(e, t, r, n) {
                return await T(r), await copyDir(t, r, n), setDestMode(r, e);
              })(e.mode, r, n, i);
        })(o, e, t, r, n);
      if (o.isDirectory())
        throw new I({
          message: `${t} is a directory (not copied)`,
          path: t,
          syscall: "cp",
          errno: N,
          code: "EISDIR",
        });
      if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice())
        return (function onFile(e, t, r, n, i) {
          return t
            ? (async function mayCopyFile(e, t, r, n) {
                if (n.force) return await $(r), _copyFile(e, t, r, n);
                if (n.errorOnExist)
                  throw new f({
                    message: `${r} already exists`,
                    path: r,
                    syscall: "cp",
                    errno: D,
                    code: "EEXIST",
                  });
              })(e, r, n, i)
            : _copyFile(e, r, n, i);
        })(o, e, t, r, n);
      if (o.isSymbolicLink())
        return (async function onLink(e, t, r, n) {
          let i,
            o = await b(t);
          n.verbatimSymlinks || V(o) || (o = x(L(t), o));
          if (!e) return v(o, r);
          try {
            i = await b(r);
          } catch (e) {
            if ("EINVAL" === e.code || "UNKNOWN" === e.code) return v(o, r);
            throw e;
          }
          V(i) || (i = x(L(r), i));
          if (isSrcSubdir(o, i))
            throw new m({
              message: `cannot copy ${o} to a subdirectory of self ${i}`,
              path: r,
              syscall: "cp",
              errno: R,
              code: "EINVAL",
            });
          const s = await O(t);
          if (s.isDirectory() && isSrcSubdir(i, o))
            throw new _({
              message: `cannot overwrite ${i} with ${o}`,
              path: r,
              syscall: "cp",
              errno: R,
              code: "EINVAL",
            });
          return (async function copyLink(e, t) {
            return await $(t), v(e, t);
          })(o, r);
        })(e, t, r, n);
      if (o.isSocket())
        throw new S({
          message: `cannot copy a socket file: ${r}`,
          path: r,
          syscall: "cp",
          errno: R,
          code: "EINVAL",
        });
      if (o.isFIFO())
        throw new w({
          message: `cannot copy a FIFO pipe: ${r}`,
          path: r,
          syscall: "cp",
          errno: R,
          code: "EINVAL",
        });
      throw new E({
        message: `cannot copy an unknown file type: ${r}`,
        path: r,
        syscall: "cp",
        errno: R,
        code: "EINVAL",
      });
    }
    async function _copyFile(e, t, r, n) {
      return (
        await k(t, r, n.mode),
        n.preserveTimestamps
          ? (async function handleTimestampsAndMode(e, t, r) {
              if (
                (function fileIsNotWritable(e) {
                  return 0 == (128 & e);
                })(e)
              )
                return (
                  await (function makeFileWritable(e, t) {
                    return setDestMode(e, 128 | t);
                  })(r, e),
                  setDestTimestampsAndMode(e, t, r)
                );
              return setDestTimestampsAndMode(e, t, r);
            })(e.mode, t, r)
          : setDestMode(r, e.mode)
      );
    }
    async function setDestTimestampsAndMode(e, t, r) {
      return (
        await (async function setDestTimestamps(e, t) {
          const r = await O(e);
          return C(t, r.atime, r.mtime);
        })(t, r),
        setDestMode(r, e)
      );
    }
    function setDestMode(e, t) {
      return P(e, t);
    }
    async function copyDir(e, t, r) {
      const n = await A(e);
      for await (const { name: i } of n) {
        const n = M(e, i),
          o = M(t, i),
          { destStat: s, skipped: c } = await checkPaths(n, o, r);
        c || (await getStatsForCopy(s, n, o, r));
      }
    }
    r.exports = {
      areIdentical: areIdentical,
      cpFn: async function cpFn(e, t, r) {
        if (r.preserveTimestamps && "ia32" === n.arch) {
          const e =
            "Using the preserveTimestamps option in 32-bit node is not recommended";
          n.emitWarning(e, "TimestampPrecisionWarning");
        }
        const i = await checkPaths(e, t, r),
          { srcStat: o, destStat: s, skipped: c } = i;
        if (!c)
          return (
            await checkParentPaths(e, o, t),
            (async function checkParentDir(e, t, r, n) {
              const i = L(r);
              return (
                (await (function pathExists(e) {
                  return p(
                    O(e),
                    () => !0,
                    (e) => "ENOENT" !== e.code && d(e)
                  );
                })(i)) || (await T(i, { recursive: !0 })),
                getStatsForCopy(e, t, r, n)
              );
            })(s, e, t, r)
          );
      },
      isSrcSubdir: isSrcSubdir,
    };
  },
  "internal/fs/cp/cp-sync": function (e, t, n, r, c, o) {
    "use strict";
    const { areIdentical: s, isSrcSubdir: i } = t("internal/fs/cp/cp"),
      { codes: a } = t("internal/errors"),
      {
        os: {
          errno: { EEXIST: y, EISDIR: l, EINVAL: p, ENOTDIR: f },
        },
      } = c("constants"),
      {
        ERR_FS_CP_DIR_TO_NON_DIR: d,
        ERR_FS_CP_EEXIST: u,
        ERR_FS_CP_EINVAL: S,
        ERR_FS_CP_FIFO_PIPE: h,
        ERR_FS_CP_NON_DIR_TO_DIR: _,
        ERR_FS_CP_SOCKET: m,
        ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY: E,
        ERR_FS_CP_UNKNOWN: I,
        ERR_FS_EISDIR: w,
        ERR_INVALID_RETURN_VALUE: D,
      } = a,
      {
        chmodSync: R,
        copyFileSync: N,
        existsSync: F,
        lstatSync: k,
        mkdirSync: g,
        opendirSync: P,
        readlinkSync: T,
        statSync: L,
        symlinkSync: O,
        unlinkSync: $,
        utimesSync: b,
      } = t("fs"),
      { dirname: A, isAbsolute: C, join: V, parse: v, resolve: U } = t("path"),
      { isPromise: W } = t("util/types");
    function checkPathsSync(e, t, n) {
      if (n.filter) {
        const r = n.filter(e, t);
        if (W(r)) throw new D("boolean", "filter", r);
        if (!r) return { __proto__: null, skipped: !0 };
      }
      const { srcStat: r, destStat: c } = (function getStatsSync(e, t, n) {
        let r;
        const c = n.dereference
            ? (e) => L(e, { bigint: !0 })
            : (e) => k(e, { bigint: !0 }),
          o = c(e);
        try {
          r = c(t);
        } catch (e) {
          if ("ENOENT" === e.code) return { srcStat: o, destStat: null };
          throw e;
        }
        return { srcStat: o, destStat: r };
      })(e, t, n);
      if (c) {
        if (s(r, c))
          throw new S({
            message: "src and dest cannot be the same",
            path: t,
            syscall: "cp",
            errno: p,
            code: "EINVAL",
          });
        if (r.isDirectory() && !c.isDirectory())
          throw new d({
            message: `cannot overwrite directory ${e} with non-directory ${t}`,
            path: t,
            syscall: "cp",
            errno: l,
            code: "EISDIR",
          });
        if (!r.isDirectory() && c.isDirectory())
          throw new _({
            message: `cannot overwrite non-directory ${e} with directory ${t}`,
            path: t,
            syscall: "cp",
            errno: f,
            code: "ENOTDIR",
          });
      }
      if (r.isDirectory() && i(e, t))
        throw new S({
          message: `cannot copy ${e} to a subdirectory of self ${t}`,
          path: t,
          syscall: "cp",
          errno: p,
          code: "EINVAL",
        });
      return { __proto__: null, srcStat: r, destStat: c, skipped: !1 };
    }
    function checkParentPathsSync(e, t, n) {
      const r = U(A(e)),
        c = U(A(n));
      if (c === r || c === v(c).root) return;
      let o;
      try {
        o = L(c, { bigint: !0 });
      } catch (e) {
        if ("ENOENT" === e.code) return;
        throw e;
      }
      if (s(t, o))
        throw new S({
          message: `cannot copy ${e} to a subdirectory of self ${n}`,
          path: n,
          syscall: "cp",
          errno: p,
          code: "EINVAL",
        });
      return checkParentPathsSync(e, t, c);
    }
    function getStats(e, t, n, r) {
      const c = (r.dereference ? L : k)(t);
      if (c.isDirectory() && r.recursive)
        return (function onDir(e, t, n, r, c) {
          return t
            ? copyDir(n, r, c)
            : (function mkDirAndCopy(e, t, n, r) {
                return g(n), copyDir(t, n, r), setDestMode(n, e);
              })(e.mode, n, r, c);
        })(c, e, t, n, r);
      if (c.isDirectory())
        throw new w({
          message: `${t} is a directory (not copied)`,
          path: t,
          syscall: "cp",
          errno: p,
          code: "EISDIR",
        });
      if (c.isFile() || c.isCharacterDevice() || c.isBlockDevice())
        return (function onFile(e, t, n, r, c) {
          return t
            ? (function mayCopyFile(e, t, n, r) {
                if (r.force) return $(n), copyFile(e, t, n, r);
                if (r.errorOnExist)
                  throw new u({
                    message: `${n} already exists`,
                    path: n,
                    syscall: "cp",
                    errno: y,
                    code: "EEXIST",
                  });
              })(e, n, r, c)
            : copyFile(e, n, r, c);
        })(c, e, t, n, r);
      if (c.isSymbolicLink())
        return (function onLink(e, t, n, r) {
          let c,
            o = T(t);
          r.verbatimSymlinks || C(o) || (o = U(A(t), o));
          if (!e) return O(o, n);
          try {
            c = T(n);
          } catch (e) {
            if ("EINVAL" === e.code || "UNKNOWN" === e.code) return O(o, n);
            throw e;
          }
          C(c) || (c = U(A(n), c));
          if (i(o, c))
            throw new S({
              message: `cannot copy ${o} to a subdirectory of self ${c}`,
              path: n,
              syscall: "cp",
              errno: p,
              code: "EINVAL",
            });
          if (L(n).isDirectory() && i(c, o))
            throw new E({
              message: `cannot overwrite ${c} with ${o}`,
              path: n,
              syscall: "cp",
              errno: p,
              code: "EINVAL",
            });
          return (function copyLink(e, t) {
            return $(t), O(e, t);
          })(o, n);
        })(e, t, n, r);
      if (c.isSocket())
        throw new m({
          message: `cannot copy a socket file: ${n}`,
          path: n,
          syscall: "cp",
          errno: p,
          code: "EINVAL",
        });
      if (c.isFIFO())
        throw new h({
          message: `cannot copy a FIFO pipe: ${n}`,
          path: n,
          syscall: "cp",
          errno: p,
          code: "EINVAL",
        });
      throw new I({
        message: `cannot copy an unknown file type: ${n}`,
        path: n,
        syscall: "cp",
        errno: p,
        code: "EINVAL",
      });
    }
    function copyFile(e, t, n, r) {
      return (
        N(t, n, r.mode),
        r.preserveTimestamps &&
          (function handleTimestamps(e, t, n) {
            (function fileIsNotWritable(e) {
              return 0 == (128 & e);
            })(e) &&
              (function makeFileWritable(e, t) {
                return setDestMode(e, 128 | t);
              })(n, e);
            return (function setDestTimestamps(e, t) {
              const n = L(e);
              return b(t, n.atime, n.mtime);
            })(t, n);
          })(e.mode, t, n),
        setDestMode(n, e.mode)
      );
    }
    function setDestMode(e, t) {
      return R(e, t);
    }
    function copyDir(e, t, n) {
      const r = P(e);
      try {
        let c;
        for (; null !== (c = r.readSync()); ) {
          const { name: r } = c,
            o = V(e, r),
            s = V(t, r),
            { destStat: i, skipped: a } = checkPathsSync(o, s, n);
          a || getStats(i, o, s, n);
        }
      } finally {
        r.closeSync();
      }
    }
    n.exports = {
      cpSyncFn: function cpSyncFn(e, t, n) {
        if (n.preserveTimestamps && "ia32" === r.arch) {
          const e =
            "Using the preserveTimestamps option in 32-bit node is not recommended";
          r.emitWarning(e, "TimestampPrecisionWarning");
        }
        const { srcStat: c, destStat: o, skipped: s } = checkPathsSync(e, t, n);
        if (!s)
          return (
            checkParentPathsSync(e, c, t),
            (function checkParentDir(e, t, n, r) {
              const c = A(n);
              F(c) || g(c, { recursive: !0 });
              return getStats(e, t, n, r);
            })(o, e, t, n)
          );
      },
    };
  },
  "internal/fs/dir": function (i, t, e, r, s, n) {
    "use strict";
    const {
        ArrayPrototypePush: o,
        ArrayPrototypeShift: h,
        FunctionPrototypeBind: c,
        ObjectDefineProperty: l,
        PromiseReject: a,
        Symbol: u,
        SymbolAsyncIterator: d,
      } = n,
      f = t("path"),
      p = s("fs"),
      y = s("fs_dir"),
      {
        codes: {
          ERR_DIR_CLOSED: R,
          ERR_DIR_CONCURRENT_OPERATION: D,
          ERR_MISSING_ARGS: v,
        },
      } = t("internal/errors"),
      { FSReqCallback: S } = p,
      w = t("internal/util"),
      {
        getDirent: b,
        getOptions: g,
        getValidatedPath: k,
        handleErrorFromBinding: m,
      } = t("internal/fs/utils"),
      { validateFunction: _, validateUint32: P } = t("internal/validators"),
      E = u("kDirHandle"),
      I = u("kDirPath"),
      N = u("kDirBufferedEntries"),
      O = u("kDirClosed"),
      C = u("kDirOptions"),
      z = u("kDirReadImpl"),
      A = u("kDirReadPromisified"),
      F = u("kDirClosePromisified"),
      T = u("kDirOperationQueue");
    class Dir {
      constructor(i, t, e) {
        if (null == i) throw new v("handle");
        (this[E] = i),
          (this[N] = []),
          (this[I] = t),
          (this[O] = !1),
          (this[T] = null),
          (this[C] = { bufferSize: 32, ...g(e, { encoding: "utf8" }) }),
          P(this[C].bufferSize, "options.bufferSize", !0),
          (this[A] = c(w.promisify(this[z]), this, !1)),
          (this[F] = c(w.promisify(this.close), this));
      }
      get path() {
        return this[I];
      }
      read(i) {
        return this[z](!0, i);
      }
      [z](i, t) {
        if (!0 === this[O]) throw new R();
        if (void 0 === t) return this[A]();
        if ((_(t, "callback"), null !== this[T]))
          return void o(this[T], () => {
            this[z](i, t);
          });
        if (this[N].length > 0)
          try {
            const e = h(this[N]);
            return (
              this[C].recursive && e.isDirectory() && this.readSyncRecursive(e),
              void (i ? r.nextTick(t, null, e) : t(null, e))
            );
          } catch (i) {
            return t(i);
          }
        const e = new S();
        (e.oncomplete = (i, e) => {
          if (
            (r.nextTick(() => {
              const i = this[T];
              this[T] = null;
              for (const t of i) t();
            }),
            i || null === e)
          )
            return t(i, e);
          try {
            this.processReadResult(this[I], e);
            const i = h(this[N]);
            this[C].recursive && i.isDirectory() && this.readSyncRecursive(i),
              t(null, i);
          } catch (i) {
            t(i);
          }
        }),
          (this[T] = []),
          this[E].read(this[C].encoding, this[C].bufferSize, e);
      }
      processReadResult(i, t) {
        for (let e = 0; e < t.length; e += 2)
          o(this[N], b(i, t[e], t[e + 1], !0));
      }
      readSyncRecursive(i) {
        const t = { path: i.path },
          e = y.opendir(
            f.toNamespacedPath(i.path),
            this[C].encoding,
            void 0,
            t
          );
        m(t);
        const r = e.read(this[C].encoding, this[C].bufferSize, void 0, t);
        r && this.processReadResult(i.path, r), e.close(void 0, t), m(t);
      }
      readSync() {
        if (!0 === this[O]) throw new R();
        if (null !== this[T]) throw new D();
        if (this[N].length > 0) {
          const i = h(this[N]);
          return (
            this[C].recursive && i.isDirectory() && this.readSyncRecursive(i), i
          );
        }
        const i = { path: this[I] },
          t = this[E].read(this[C].encoding, this[C].bufferSize, void 0, i);
        if ((m(i), null === t)) return t;
        this.processReadResult(this[I], t);
        const e = h(this[N]);
        return (
          this[C].recursive && e.isDirectory() && this.readSyncRecursive(e), e
        );
      }
      close(i) {
        if (void 0 === i) return !0 === this[O] ? a(new R()) : this[F]();
        if ((_(i, "callback"), !0 === this[O]))
          return void r.nextTick(i, new R());
        if (null !== this[T])
          return void o(this[T], () => {
            this.close(i);
          });
        this[O] = !0;
        const t = new S();
        (t.oncomplete = i), this[E].close(t);
      }
      closeSync() {
        if (!0 === this[O]) throw new R();
        if (null !== this[T]) throw new D();
        this[O] = !0;
        const i = { path: this[I] },
          t = this[E].close(void 0, i);
        return m(i), t;
      }
      async *entries() {
        try {
          for (;;) {
            const i = await this[A]();
            if (null === i) break;
            yield i;
          }
        } finally {
          await this[F]();
        }
      }
    }
    l(Dir.prototype, d, {
      __proto__: null,
      value: Dir.prototype.entries,
      enumerable: !1,
      writable: !0,
      configurable: !0,
    }),
      (e.exports = {
        Dir: Dir,
        opendir: function opendir(i, t, e) {
          _((e = "function" == typeof t ? t : e), "callback"),
            (i = k(i)),
            (t = g(t, { encoding: "utf8" }));
          const r = new S();
          (r.oncomplete = function opendirCallback(r, s) {
            r ? e(r) : e(null, new Dir(s, i, t));
          }),
            y.opendir(f.toNamespacedPath(i), t.encoding, r);
        },
        opendirSync: function opendirSync(i, t) {
          (i = k(i)), (t = g(t, { encoding: "utf8" }));
          const e = { path: i },
            r = y.opendir(f.toNamespacedPath(i), t.encoding, void 0, e);
          return m(e), new Dir(r, i, t);
        },
      });
  },
  "internal/fs/promises": function (e, t, n, a, r, i) {
    "use strict";
    const {
        ArrayPrototypePush: s,
        ArrayPrototypePop: o,
        Error: c,
        MathMax: l,
        MathMin: f,
        NumberIsSafeInteger: d,
        Promise: u,
        PromisePrototypeThen: h,
        PromiseResolve: y,
        PromiseReject: m,
        SafeArrayIterator: p,
        SafePromisePrototypeFinally: w,
        Symbol: b,
        SymbolAsyncDispose: g,
        Uint8Array: F,
        FunctionPrototypeBind: k,
      } = i,
      { fs: P } = r("constants"),
      { F_OK: v, O_SYMLINK: S, O_WRONLY: R, S_IFMT: N, S_IFREG: C } = P,
      L = r("fs"),
      { Buffer: A } = t("buffer"),
      {
        codes: {
          ERR_FS_FILE_TOO_LARGE: I,
          ERR_INVALID_ARG_VALUE: T,
          ERR_INVALID_STATE: E,
          ERR_METHOD_NOT_IMPLEMENTED: _,
        },
        AbortError: H,
        aggregateTwoErrors: O,
      } = t("internal/errors"),
      { isArrayBufferView: M } = t("internal/util/types"),
      { rimrafPromises: B } = t("internal/fs/rimraf"),
      {
        constants: {
          kIoMaxLength: D,
          kMaxUserId: W,
          kReadFileBufferLength: x,
          kReadFileUnknownBufferLength: X,
          kWriteFileMaxChunkSize: U,
        },
        copyObject: j,
        emitRecursiveRmdirWarning: z,
        getDirents: V,
        getOptions: G,
        getStatFsFromBinding: q,
        getStatsFromBinding: K,
        getValidatedPath: Y,
        getValidMode: J,
        preprocessSymlinkDestination: $,
        stringToFlags: Q,
        stringToSymlinkType: Z,
        toUnixTimestamp: ee,
        validateBufferArray: te,
        validateCpOptions: ne,
        validateOffsetLengthRead: ae,
        validateOffsetLengthWrite: re,
        validateRmOptions: ie,
        validateRmdirOptions: se,
        validatePrimitiveStringAfterArrayBufferView: oe,
        warnOnNonPortableTemplate: ce,
      } = t("internal/fs/utils"),
      { opendir: le } = t("internal/fs/dir"),
      {
        parseFileMode: fe,
        validateAbortSignal: de,
        validateBoolean: ue,
        validateBuffer: he,
        validateEncoding: ye,
        validateInteger: me,
        validateString: pe,
      } = t("internal/validators"),
      we = t("path"),
      {
        kEmptyObject: be,
        lazyDOMException: ge,
        promisify: Fe,
      } = t("internal/util"),
      { EventEmitterMixin: ke } = t("internal/event_target"),
      { StringDecoder: Pe } = t("string_decoder"),
      { watch: ve } = t("internal/fs/watchers"),
      { isIterable: Se } = t("internal/streams/utils"),
      Re = t("internal/assert"),
      Ne = b("kHandle"),
      Ce = b("kFd"),
      Le = b("kRefs"),
      Ae = b("kClosePromise"),
      Ie = b("kCloseResolve"),
      Te = b("kCloseReject"),
      Ee = b("kRef"),
      _e = b("kUnref"),
      He = b("kLocked"),
      { kUsePromises: Oe } = L,
      { Interface: Me } = t("internal/readline/interface"),
      {
        JSTransferable: Be,
        kDeserialize: De,
        kTransfer: We,
        kTransferList: xe,
      } = t("internal/worker/js_transferable"),
      Xe = Fe(V),
      Ue = Fe(ie);
    let je, ze;
    function lazyFsStreams() {
      return (ze ??= t("internal/fs/streams"));
    }
    class FileHandle extends ke(Be) {
      constructor(e) {
        super(),
          (this[Ne] = e),
          (this[Ce] = e ? e.fd : -1),
          (this[Le] = 1),
          (this[Ae] = null);
      }
      getAsyncId() {
        return this[Ne].getAsyncId();
      }
      get fd() {
        return this[Ce];
      }
      appendFile(e, t) {
        return fsCall(writeFile, this, e, t);
      }
      chmod(e) {
        return fsCall(fchmod, this, e);
      }
      chown(e, t) {
        return fsCall(fchown, this, e, t);
      }
      datasync() {
        return fsCall(fdatasync, this);
      }
      sync() {
        return fsCall(fsync, this);
      }
      read(e, t, n, a) {
        return fsCall(read, this, e, t, n, a);
      }
      readv(e, t) {
        return fsCall(readv, this, e, t);
      }
      readFile(e) {
        return fsCall(readFile, this, e);
      }
      readLines(e = void 0) {
        return new Me({ input: this.createReadStream(e), crlfDelay: 1 / 0 });
      }
      stat(e) {
        return fsCall(fstat, this, e);
      }
      truncate(e = 0) {
        return fsCall(ftruncate, this, e);
      }
      utimes(e, t) {
        return fsCall(futimes, this, e, t);
      }
      write(e, t, n, a) {
        return fsCall(write, this, e, t, n, a);
      }
      writev(e, t) {
        return fsCall(writev, this, e, t);
      }
      writeFile(e, t) {
        return fsCall(writeFile, this, e, t);
      }
      close = () =>
        -1 === this[Ce]
          ? y()
          : (this[Ae] ||
              (this[Le]--,
              0 === this[Le]
                ? ((this[Ce] = -1),
                  (this[Ae] = w(this[Ne].close(), () => {
                    this[Ae] = void 0;
                  })))
                : (this[Ae] = w(
                    new u((e, t) => {
                      (this[Ie] = e), (this[Te] = t);
                    }),
                    () => {
                      (this[Ae] = void 0),
                        (this[Te] = void 0),
                        (this[Ie] = void 0);
                    }
                  )),
              this.emit("close")),
            this[Ae]);
      async [g]() {
        return this.close();
      }
      readableWebStream(e = be) {
        if (-1 === this[Ce]) throw new E("The FileHandle is closed");
        if (this[Ae]) throw new E("The FileHandle is closing");
        if (this[He]) throw new E("The FileHandle is locked");
        let n;
        if (
          ((this[He] = !0),
          void 0 !== e.type && pe(e.type, "options.type"),
          "bytes" !== e.type)
        ) {
          const { newReadableStreamFromStreamBase: e } = t(
            "internal/webstreams/adapters"
          );
          n = e(this[Ne], void 0, { ondone: () => this[_e]() });
        } else {
          const { ReadableStream: e } = t("internal/webstreams/readablestream"),
            a = k(this.read, this),
            r = k(this[_e], this);
          n = new e({
            type: "bytes",
            autoAllocateChunkSize: 16384,
            async pull(e) {
              const t = e.byobRequest.view,
                { bytesRead: n } = await a(t, t.byteOffset, t.byteLength);
              0 === n && (r(), e.close()), e.byobRequest.respond(n);
            },
            cancel() {
              r();
            },
          });
        }
        const { readableStreamCancel: a } = t(
          "internal/webstreams/readablestream"
        );
        return (
          this[Ee](),
          this.once("close", () => {
            a(n);
          }),
          n
        );
      }
      createReadStream(e = void 0) {
        const { ReadStream: t } = lazyFsStreams();
        return new t(void 0, { ...e, fd: this });
      }
      createWriteStream(e = void 0) {
        const { WriteStream: t } = lazyFsStreams();
        return new t(void 0, { ...e, fd: this });
      }
      [We]() {
        if (this[Ae] || this[Le] > 1)
          throw ge("Cannot transfer FileHandle while in use", "DataCloneError");
        const e = this[Ne];
        return (
          (this[Ce] = -1),
          (this[Ne] = null),
          (this[Le] = 0),
          {
            data: { handle: e },
            deserializeInfo: "internal/fs/promises:FileHandle",
          }
        );
      }
      [xe]() {
        return [this[Ne]];
      }
      [De]({ handle: e }) {
        (this[Ne] = e), (this[Ce] = e.fd);
      }
      [Ee]() {
        this[Le]++;
      }
      [_e]() {
        this[Le]--,
          0 === this[Le] &&
            ((this[Ce] = -1), h(this[Ne].close(), this[Ie], this[Te]));
      }
    }
    async function handleFdClose(e, t) {
      return h(
        e,
        (e) => h(t(), () => e),
        (e) =>
          h(
            t(),
            () => m(e),
            (t) => m(O(t, e))
          )
      );
    }
    async function fsCall(e, t, ...n) {
      if (
        (Re(void 0 !== t[Le], "handle must be an instance of FileHandle"),
        -1 === t.fd)
      ) {
        const t = new c("file closed");
        throw ((t.code = "EBADF"), (t.syscall = e.name), t);
      }
      try {
        return t[Ee](), await e(t, ...new p(n));
      } finally {
        t[_e]();
      }
    }
    function checkAborted(e) {
      if (e?.aborted) throw new H(void 0, { cause: e?.reason });
    }
    async function writeFileHandle(e, t, n, a) {
      if ((checkAborted(n), isCustomIterable(t))) {
        for await (const r of t) {
          checkAborted(n);
          const t = M(r) ? r : A.from(r, a || "utf8");
          let i = t.byteLength;
          for (; i > 0; ) {
            const a = f(U, i),
              { bytesWritten: r } = await write(e, t, t.byteLength - i, a);
            (i -= r), checkAborted(n);
          }
        }
        return;
      }
      let r = (t = new F(t.buffer, t.byteOffset, t.byteLength)).byteLength;
      if (0 !== r)
        do {
          checkAborted(n);
          const { bytesWritten: a } = await write(e, t, 0, f(U, t.byteLength));
          (r -= a), (t = new F(t.buffer, t.byteOffset + a, t.byteLength - a));
        } while (r > 0);
    }
    async function readFileHandle(e, t) {
      const n = t?.signal,
        a = t?.encoding,
        r = a && new Pe(a);
      checkAborted(n);
      const i = await L.fstat(e.fd, !1, Oe);
      checkAborted(n);
      let o = 0,
        c = 0;
      if (
        ((i[1] & N) === C && ((o = i[8]), (c = a ? f(o, x) : o)),
        0 === c && (c = X),
        o > D)
      )
        throw new I(o);
      let l,
        d = 0,
        u = A.allocUnsafeSlow(c),
        h = "",
        y = 0;
      const m = c > x;
      for (;;) {
        checkAborted(n), m && (c = f(o - d, x));
        const t = (await L.read(e.fd, u, y, c, -1, Oe)) ?? 0;
        if (((d += t), 0 === t || d === o || (t !== u.length && !m))) {
          const e = t === d,
            n = m ? d : t;
          return (
            n !== u.length && (u = u.subarray(0, n)),
            a
              ? e
                ? u.toString(a)
                : ((h += r.end(u)), h)
              : 0 !== o || e
              ? u
              : (s(l, u), A.concat(l, d))
          );
        }
        a
          ? (h += r.write(u))
          : 0 !== o
          ? (y = d)
          : ((l ??= []), s(l, u), (u = A.allocUnsafeSlow(X)));
      }
    }
    async function open(e, t, n) {
      e = Y(e);
      const a = Q(t);
      return (
        (n = fe(n, "mode", 438)),
        new FileHandle(await L.openFileHandle(we.toNamespacedPath(e), a, n, Oe))
      );
    }
    async function read(e, t, n, a, r) {
      let i = t;
      if (
        (M(i) ||
          (({
            buffer: i = A.alloc(16384),
            offset: n = 0,
            length: a = i.byteLength - n,
            position: r = null,
          } = t ?? be),
          he(i)),
        null !== n &&
          "object" == typeof n &&
          ({
            offset: n = 0,
            length: a = i.byteLength - n,
            position: r = null,
          } = n),
        null == n ? (n = 0) : me(n, "offset", 0),
        0 === (a |= 0))
      )
        return { bytesRead: a, buffer: i };
      if (0 === i.byteLength)
        throw new T("buffer", i, "is empty and cannot be written");
      ae(n, a, i.byteLength), d(r) || (r = -1);
      return {
        bytesRead: (await L.read(e.fd, i, n, a, r, Oe)) || 0,
        buffer: i,
      };
    }
    async function readv(e, t, n) {
      te(t), "number" != typeof n && (n = null);
      return {
        bytesRead: (await L.readBuffers(e.fd, t, n, Oe)) || 0,
        buffers: t,
      };
    }
    async function write(e, t, n, a, r) {
      if (0 === t?.byteLength) return { bytesWritten: 0, buffer: t };
      let i = n;
      if (M(t)) {
        "object" == typeof i &&
          ({
            offset: i = 0,
            length: a = t.byteLength - i,
            position: r = null,
          } = n ?? be),
          null == i ? (i = 0) : me(i, "offset", 0),
          "number" != typeof a && (a = t.byteLength - i),
          "number" != typeof r && (r = null),
          re(i, a, t.byteLength);
        return {
          bytesWritten: (await L.writeBuffer(e.fd, t, i, a, r, Oe)) || 0,
          buffer: t,
        };
      }
      oe(t, "buffer"), ye(t, a);
      return {
        bytesWritten: (await L.writeString(e.fd, t, i, a, Oe)) || 0,
        buffer: t,
      };
    }
    async function writev(e, t, n) {
      if ((te(t), "number" != typeof n && (n = null), 0 === t.length))
        return { bytesWritten: 0, buffers: t };
      return {
        bytesWritten: (await L.writeBuffers(e.fd, t, n, Oe)) || 0,
        buffers: t,
      };
    }
    async function ftruncate(e, t = 0) {
      return me(t, "len"), (t = l(0, t)), L.ftruncate(e.fd, t, Oe);
    }
    async function fdatasync(e) {
      return L.fdatasync(e.fd, Oe);
    }
    async function fsync(e) {
      return L.fsync(e.fd, Oe);
    }
    async function fstat(e, t = { bigint: !1 }) {
      const n = await L.fstat(e.fd, t.bigint, Oe);
      return K(n);
    }
    async function stat(e, t = { bigint: !1 }) {
      e = Y(e);
      const n = await L.stat(we.toNamespacedPath(e), t.bigint, Oe);
      return K(n);
    }
    async function fchmod(e, t) {
      return (t = fe(t, "mode")), L.fchmod(e.fd, t, Oe);
    }
    async function fchown(e, t, n) {
      return me(t, "uid", -1, W), me(n, "gid", -1, W), L.fchown(e.fd, t, n, Oe);
    }
    async function futimes(e, t, n) {
      return (
        (t = ee(t, "atime")), (n = ee(n, "mtime")), L.futimes(e.fd, t, n, Oe)
      );
    }
    async function writeFile(e, t, n) {
      const a =
        (n = G(n, { encoding: "utf8", mode: 438, flag: "w" })).flag || "w";
      if (
        (M(t) ||
          isCustomIterable(t) ||
          (oe(t, "data"), (t = A.from(t, n.encoding || "utf8"))),
        de(n.signal),
        e instanceof FileHandle)
      )
        return writeFileHandle(e, t, n.signal, n.encoding);
      checkAborted(n.signal);
      const r = await open(e, a, n.mode);
      return handleFdClose(
        writeFileHandle(r, t, n.signal, n.encoding),
        r.close
      );
    }
    function isCustomIterable(e) {
      return Se(e) && !M(e) && "string" != typeof e;
    }
    async function readFile(e, t) {
      const n = (t = G(t, { flag: "r" })).flag || "r";
      if (e instanceof FileHandle) return readFileHandle(e, t);
      checkAborted(t.signal);
      const a = await open(e, n, 438);
      return handleFdClose(readFileHandle(a, t), a.close);
    }
    n.exports = {
      exports: {
        access: async function access(e, t = v) {
          return (
            (e = Y(e)),
            (t = J(t, "access")),
            L.access(we.toNamespacedPath(e), t, Oe)
          );
        },
        copyFile: async function copyFile(e, t, n) {
          return (
            (e = Y(e, "src")),
            (t = Y(t, "dest")),
            (n = J(n, "copyFile")),
            L.copyFile(we.toNamespacedPath(e), we.toNamespacedPath(t), n, Oe)
          );
        },
        cp: async function cp(e, n, a) {
          return (
            (a = ne(a)),
            (e = we.toNamespacedPath(Y(e, "src"))),
            (n = we.toNamespacedPath(Y(n, "dest"))),
            (function lazyLoadCpPromises() {
              return (je ??= t("internal/fs/cp/cp").cpFn);
            })()(e, n, a)
          );
        },
        open: open,
        opendir: Fe(le),
        rename: async function rename(e, t) {
          return (
            (e = Y(e, "oldPath")),
            (t = Y(t, "newPath")),
            L.rename(we.toNamespacedPath(e), we.toNamespacedPath(t), Oe)
          );
        },
        truncate: async function truncate(e, t = 0) {
          const n = await open(e, "r+");
          return handleFdClose(ftruncate(n, t), n.close);
        },
        rm: async function rm(e, t) {
          return (
            (e = we.toNamespacedPath(Y(e))), (t = await Ue(e, t, !1)), B(e, t)
          );
        },
        rmdir: async function rmdir(e, t) {
          if (((e = we.toNamespacedPath(Y(e))), (t = se(t)).recursive)) {
            z();
            if ((await stat(e)).isDirectory()) return B(e, t);
          }
          return L.rmdir(e, Oe);
        },
        mkdir: async function mkdir(e, t) {
          ("number" != typeof t && "string" != typeof t) || (t = { mode: t });
          const { recursive: n = !1, mode: a = 511 } = t || be;
          return (
            (e = Y(e)),
            ue(n, "options.recursive"),
            L.mkdir(we.toNamespacedPath(e), fe(a, "mode", 511), n, Oe)
          );
        },
        readdir: async function readdir(e, t) {
          if (((t = G(t)), (e = Y(e)), t.recursive))
            return (async function readdirRecursive(e, t) {
              const n = [],
                a = [
                  [
                    e,
                    await L.readdir(
                      we.toNamespacedPath(e),
                      t.encoding,
                      !!t.withFileTypes,
                      Oe
                    ),
                  ],
                ];
              if (t.withFileTypes)
                for (; a.length > 0; ) {
                  const { 0: e, 1: r } = o(a);
                  for (const i of V(e, r))
                    if ((s(n, i), i.isDirectory())) {
                      const n = we.join(e, i.name);
                      s(a, [n, await L.readdir(n, t.encoding, !0, Oe)]);
                    }
                }
              else
                for (; a.length > 0; ) {
                  const { 0: r, 1: i } = o(a);
                  for (const o of i) {
                    const i = we.join(r, o),
                      c = L.internalModuleStat(i);
                    s(n, we.relative(e, i)),
                      1 === c &&
                        s(a, [
                          i,
                          await L.readdir(
                            we.toNamespacedPath(i),
                            t.encoding,
                            !1,
                            Oe
                          ),
                        ]);
                  }
                }
              return n;
            })(e, t);
          const n = await L.readdir(
            we.toNamespacedPath(e),
            t.encoding,
            !!t.withFileTypes,
            Oe
          );
          return t.withFileTypes ? Xe(e, n) : n;
        },
        readlink: async function readlink(e, t) {
          return (
            (t = G(t)),
            (e = Y(e, "oldPath")),
            L.readlink(we.toNamespacedPath(e), t.encoding, Oe)
          );
        },
        symlink: async function symlink(e, t, n) {
          const a = "string" == typeof n ? n : null;
          return (
            (e = Y(e, "target")),
            (t = Y(t)),
            L.symlink($(e, a, t), we.toNamespacedPath(t), Z(a), Oe)
          );
        },
        lstat: async function lstat(e, t = { bigint: !1 }) {
          e = Y(e);
          const n = await L.lstat(we.toNamespacedPath(e), t.bigint, Oe);
          return K(n);
        },
        stat: stat,
        statfs: async function statfs(e, t = { bigint: !1 }) {
          e = Y(e);
          const n = await L.statfs(we.toNamespacedPath(e), t.bigint, Oe);
          return q(n);
        },
        link: async function link(e, t) {
          return (
            (e = Y(e, "existingPath")),
            (t = Y(t, "newPath")),
            L.link(we.toNamespacedPath(e), we.toNamespacedPath(t), Oe)
          );
        },
        unlink: async function unlink(e) {
          return (e = Y(e)), L.unlink(we.toNamespacedPath(e), Oe);
        },
        chmod: async function chmod(e, t) {
          return (
            (e = Y(e)),
            (t = fe(t, "mode")),
            L.chmod(we.toNamespacedPath(e), t, Oe)
          );
        },
        lchmod: async function lchmod(e, t) {
          if (void 0 === S) throw new _("lchmod()");
          const n = await open(e, R | S);
          return handleFdClose(fchmod(n, t), n.close);
        },
        lchown: async function lchown(e, t, n) {
          return (
            (e = Y(e)),
            me(t, "uid", -1, W),
            me(n, "gid", -1, W),
            L.lchown(we.toNamespacedPath(e), t, n, Oe)
          );
        },
        chown: async function chown(e, t, n) {
          return (
            (e = Y(e)),
            me(t, "uid", -1, W),
            me(n, "gid", -1, W),
            L.chown(we.toNamespacedPath(e), t, n, Oe)
          );
        },
        utimes: async function utimes(e, t, n) {
          return (e = Y(e)), L.utimes(we.toNamespacedPath(e), ee(t), ee(n), Oe);
        },
        lutimes: async function lutimes(e, t, n) {
          return (
            (e = Y(e)), L.lutimes(we.toNamespacedPath(e), ee(t), ee(n), Oe)
          );
        },
        realpath: async function realpath(e, t) {
          return (t = G(t)), (e = Y(e)), L.realpath(e, t.encoding, Oe);
        },
        mkdtemp: async function mkdtemp(e, t) {
          let n;
          return (
            (t = G(t)),
            (e = Y(e, "prefix")),
            ce(e),
            (n =
              "string" == typeof e
                ? `${e}XXXXXX`
                : A.concat([e, A.from("XXXXXX")])),
            L.mkdtemp(n, t.encoding, Oe)
          );
        },
        writeFile: writeFile,
        appendFile: async function appendFile(e, t, n) {
          return (
            (n = G(n, { encoding: "utf8", mode: 438, flag: "a" })),
            ((n = j(n)).flag = n.flag || "a"),
            writeFile(e, t, n)
          );
        },
        readFile: readFile,
        watch: ve,
        constants: P,
      },
      FileHandle: FileHandle,
      kRef: Ee,
      kUnref: _e,
    };
  },
  "internal/fs/read_file_context": function (e, t, s, i, r, n) {
    "use strict";
    const { ArrayPrototypePush: o, MathMin: l, ReflectApply: f } = n,
      {
        constants: {
          kReadFileBufferLength: c,
          kReadFileUnknownBufferLength: a,
        },
      } = t("internal/fs/utils"),
      { Buffer: u } = t("buffer"),
      { FSReqCallback: h, close: d, read: b } = r("fs"),
      { AbortError: p, aggregateTwoErrors: g } = t("internal/errors");
    function readFileAfterRead(e, t) {
      const s = this.context;
      if (e) return s.close(e);
      if (((s.pos += t), s.pos === s.size || 0 === t)) s.close();
      else {
        if (0 === s.size) {
          const e = t === a ? s.buffer : s.buffer.slice(0, t);
          o(s.buffers, e);
        }
        s.read();
      }
    }
    function readFileAfterClose(e) {
      const t = this.context,
        s = t.callback;
      let i = null;
      if (t.err || e) return s(g(e, t.err));
      try {
        (i =
          0 === t.size
            ? u.concat(t.buffers, t.pos)
            : t.pos < t.size
            ? t.buffer.slice(0, t.pos)
            : t.buffer),
          t.encoding && (i = i.toString(t.encoding));
      } catch (e) {
        return s(e);
      }
      s(null, i);
    }
    s.exports = class ReadFileContext {
      constructor(e, t) {
        (this.fd = void 0),
          (this.isUserFd = void 0),
          (this.size = 0),
          (this.callback = e),
          (this.buffers = null),
          (this.buffer = null),
          (this.pos = 0),
          (this.encoding = t),
          (this.err = null),
          (this.signal = void 0);
      }
      read() {
        let e, t, s;
        if (this.signal?.aborted)
          return this.close(new p(void 0, { cause: this.signal?.reason }));
        0 === this.size
          ? ((e = u.allocUnsafeSlow(a)), (t = 0), (s = a), (this.buffer = e))
          : ((e = this.buffer),
            (t = this.pos),
            (s = l(c, this.size - this.pos)));
        const i = new h();
        (i.oncomplete = readFileAfterRead),
          (i.context = this),
          b(this.fd, e, t, s, -1, i);
      }
      close(e) {
        if (this.isUserFd)
          return void i.nextTick(function tick(e) {
            f(readFileAfterClose, { context: e }, [null]);
          }, this);
        const t = new h();
        (t.oncomplete = readFileAfterClose),
          (t.context = this),
          (this.err = e),
          d(this.fd, t);
      }
    };
  },
  "internal/fs/recursive_watch": function (t, e, s, i, o, n) {
    "use strict";
    const {
        ArrayPrototypePush: r,
        SafePromiseAllReturnVoid: a,
        Promise: l,
        PromisePrototypeThen: c,
        SafeMap: h,
        SafeSet: f,
        StringPrototypeStartsWith: y,
        SymbolAsyncIterator: d,
      } = n,
      { EventEmitter: m } = e("events"),
      u = e("internal/assert"),
      {
        AbortError: F,
        codes: { ERR_INVALID_ARG_VALUE: p },
      } = e("internal/errors"),
      { getValidatedPath: w } = e("internal/fs/utils"),
      { kFSWatchStart: S, StatWatcher: g } = e("internal/fs/watchers"),
      { kEmptyObject: _ } = e("internal/util"),
      { validateBoolean: v, validateAbortSignal: b } = e("internal/validators"),
      { basename: P, join: L, relative: k, resolve: E } = e("path");
    let z, A, D;
    function lazyLoadFsPromises() {
      return (A ??= e("fs/promises")), A;
    }
    function lazyLoadFsSync() {
      return (z ??= e("fs")), z;
    }
    async function traverse(t, e = new h(), s = new f()) {
      const { opendir: i } = lazyLoadFsPromises(),
        o = await i(t),
        n = [];
      for await (const i of o) {
        const o = L(t, i.name);
        e.set(o, i),
          i.isSymbolicLink()
            ? s.add(o)
            : i.isDirectory() && r(n, traverse(o, e));
      }
      return await a(n), e;
    }
    s.exports = {
      FSWatcher: class FSWatcher extends m {
        #t = null;
        #e = !1;
        #s = new h();
        #i = new f();
        #o = E();
        #n = !1;
        constructor(t = _) {
          super(), u("object" == typeof t);
          const { persistent: e, recursive: s, signal: i, encoding: o } = t;
          if (
            (null != s && v(s, "options.recursive"),
            null != e && v(e, "options.persistent"),
            null != i && b(i, "options.signal"),
            null != o && "string" != typeof o)
          )
            throw new p(o, "options.encoding");
          this.#t = { persistent: e, recursive: s, signal: i, encoding: o };
        }
        close() {
          if (this.#e) return;
          const { unwatchFile: t } = lazyLoadFsSync();
          this.#e = !0;
          for (const e of this.#s.keys()) t(e);
          this.#s.clear(), this.#i.clear(), this.emit("close");
        }
        #r(t) {
          const { unwatchFile: e } = lazyLoadFsSync();
          this.#i.delete(t);
          for (const s of this.#s.keys()) y(s, t) && e(s);
        }
        async #a(t) {
          const { opendir: e } = lazyLoadFsPromises();
          try {
            const s = await e(t);
            for await (const e of s) {
              if (this.#e) break;
              const s = L(t, e.name);
              this.#s.has(s) ||
                (this.emit("change", "rename", k(this.#o, s)),
                e.isSymbolicLink() && this.#i.add(s),
                e.isFile()
                  ? this.#l(s)
                  : (this.#s.set(s, e),
                    e.isDirectory() &&
                      !e.isSymbolicLink() &&
                      (await this.#a(s))));
            }
          } catch (t) {
            this.emit("error", t);
          }
        }
        #l(t) {
          if (this.#e) return;
          const { watchFile: e } = lazyLoadFsSync(),
            s = this.#s.get(t);
          e(t, { persistent: this.#t.persistent }, (e, i) => {
            (s &&
              !s.isDirectory() &&
              0 !== e.nlink &&
              s.mtimeMs === e.mtimeMs) ||
              (this.#s.set(t, e),
              0 === e.birthtimeMs && 0 !== i.birthtimeMs
                ? (this.#s.delete(t),
                  this.emit("change", "rename", k(this.#o, t)),
                  this.#r(t))
                : t === this.#o && this.#n
                ? this.emit("change", "change", P(t))
                : this.#i.has(t)
                ? this.emit("change", "rename", k(this.#o, t))
                : e.isDirectory() && this.#a(t));
          });
        }
        [S](t) {
          t = E(w(t));
          try {
            const e = lazyLoadFsSync().statSync(t);
            (this.#o = t),
              (this.#e = !1),
              (this.#n = e.isFile()),
              e.isDirectory()
                ? (this.#s.set(t, e),
                  c(traverse(t, this.#s, this.#i), () => {
                    for (const t of this.#s.keys()) this.#l(t);
                  }))
                : this.#l(t);
          } catch (e) {
            if ("ENOENT" === e.code) throw ((e.filename = t), e);
          }
        }
        ref() {
          this.#s.forEach((t) => {
            t instanceof g && t.ref();
          });
        }
        unref() {
          this.#s.forEach((t) => {
            t instanceof g && t.unref();
          });
        }
        [d]() {
          const { signal: t } = this.#t,
            s =
              null == t
                ? (t) => {
                    this.once("change", (e, s) => {
                      t({
                        __proto__: null,
                        value: { eventType: e, filename: s },
                      });
                    });
                  }
                : (s, i) => {
                    const onAbort = () => i(new F(void 0, { cause: t.reason }));
                    if (t.aborted) return onAbort();
                    (D ??= e("internal/event_target").kResistStopPropagation),
                      t.addEventListener("abort", onAbort, {
                        __proto__: null,
                        once: !0,
                        [D]: !0,
                      }),
                      this.once("change", (e, i) => {
                        t.removeEventListener("abort", onAbort),
                          s({
                            __proto__: null,
                            value: { eventType: e, filename: i },
                          });
                      });
                  };
          return {
            next: () => (this.#e ? { __proto__: null, done: !0 } : new l(s)),
            [d]() {
              return this;
            },
          };
        }
      },
      kFSWatchStart: S,
    };
  },
  "internal/fs/rimraf": function (r, i, n, t, e, c) {
    "use strict";
    const { ArrayPrototypeForEach: f, Promise: o, SafeSet: E } = c,
      { Buffer: u } = i("buffer"),
      a = i("fs"),
      {
        chmod: y,
        chmodSync: d,
        lstat: m,
        lstatSync: l,
        readdir: s,
        readdirSync: N,
        rmdir: S,
        rmdirSync: h,
        stat: _,
        statSync: R,
        unlink: T,
        unlinkSync: P,
      } = a,
      { sep: M } = i("path"),
      { setTimeout: O } = i("timers"),
      { sleep: D } = i("internal/util"),
      w = new E(["ENOTEMPTY", "EEXIST", "EPERM"]),
      I = new E(["EBUSY", "EMFILE", "ENFILE", "ENOTEMPTY", "EPERM"]),
      x = "win32" === t.platform,
      p = x ? fixWinEPERM : _rmdir,
      W = x ? fixWinEPERMSync : _rmdirSync,
      k = "buffer",
      B = u.from(M);
    function rimraf(r, i, n) {
      let t = 0;
      _rimraf(r, i, function CB(e) {
        if (e) {
          if (I.has(e.code) && t < i.maxRetries) {
            t++;
            const n = t * i.retryDelay;
            return O(_rimraf, n, r, i, CB);
          }
          "ENOENT" === e.code && (e = null);
        }
        n(e);
      });
    }
    function _rimraf(r, i, n) {
      m(r, (t, e) => {
        if (t) {
          if ("ENOENT" === t.code) return n(null);
          if (x && "EPERM" === t.code) return fixWinEPERM(r, i, t, n);
        } else if (e.isDirectory()) return _rmdir(r, i, t, n);
        T(r, (t) => {
          if (t) {
            if ("ENOENT" === t.code) return n(null);
            if ("EISDIR" === t.code) return _rmdir(r, i, t, n);
            if ("EPERM" === t.code) return p(r, i, t, n);
          }
          return n(t);
        });
      });
    }
    function fixWinEPERM(r, i, n, t) {
      y(r, 438, (e) => {
        if (e) return t("ENOENT" === e.code ? null : n);
        _(r, (e, c) => {
          if (e) return t("ENOENT" === e.code ? null : n);
          c.isDirectory() ? _rmdir(r, i, n, t) : T(r, t);
        });
      });
    }
    function _rmdir(r, i, n, t) {
      S(r, (e) => {
        if (e) {
          if (w.has(e.code))
            return (function _rmchildren(r, i, n) {
              const t = u.from(r);
              s(t, k, (e, c) => {
                if (e) return n(e);
                let o = c.length;
                if (0 === o) return S(r, n);
                let E = !1;
                f(c, (e) => {
                  rimraf(u.concat([t, B, e]), i, (i) => {
                    if (!E) {
                      if (i) return (E = !0), n(i);
                      o--, 0 === o && S(r, n);
                    }
                  });
                });
              });
            })(r, i, t);
          if ("ENOTDIR" === e.code) return t(n);
        }
        t(e);
      });
    }
    function rimrafSync(r, i) {
      let n;
      try {
        n = l(r);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        x && "EPERM" === n.code && fixWinEPERMSync(r, i, n);
      }
      try {
        n?.isDirectory() ? _rmdirSync(r, i, null) : _unlinkSync(r, i);
      } catch (n) {
        if ("ENOENT" === n.code) return;
        if ("EPERM" === n.code) return W(r, i, n);
        if ("EISDIR" !== n.code) throw n;
        _rmdirSync(r, i, n);
      }
    }
    function _unlinkSync(r, i) {
      const n = i.maxRetries + 1;
      for (let t = 1; t <= n; t++)
        try {
          return P(r);
        } catch (r) {
          if (I.has(r.code) && t < n && i.retryDelay > 0) D(t * i.retryDelay);
          else {
            if ("ENOENT" === r.code) return;
            if (t === n) throw r;
          }
        }
    }
    function _rmdirSync(r, i, n) {
      try {
        h(r);
      } catch (t) {
        if ("ENOENT" === t.code) return;
        if ("ENOTDIR" === t.code) throw n || t;
        if (w.has(t.code)) {
          const n = u.from(r);
          f(N(n, k), (r) => {
            rimrafSync(u.concat([n, B, r]), i);
          });
          const t = i.maxRetries + 1;
          for (let n = 1; n <= t; n++)
            try {
              return a.rmdirSync(r);
            } catch (r) {
              if (I.has(r.code) && n < t && i.retryDelay > 0)
                D(n * i.retryDelay);
              else {
                if ("ENOENT" === r.code) return;
                if (n === t) throw r;
              }
            }
        }
        throw n || t;
      }
    }
    function fixWinEPERMSync(r, i, n) {
      try {
        d(r, 438);
      } catch (r) {
        if ("ENOENT" === r.code) return;
        throw n;
      }
      let t;
      try {
        t = R(r, { throwIfNoEntry: !1 });
      } catch {
        throw n;
      }
      void 0 !== t &&
        (t.isDirectory() ? _rmdirSync(r, i, n) : _unlinkSync(r, i));
    }
    n.exports = {
      rimraf: rimraf,
      rimrafPromises: function rimrafPromises(r, i) {
        return new o((n, t) => {
          rimraf(r, i, (r) => {
            if (r) return t(r);
            n();
          });
        });
      },
      rimrafSync: rimrafSync,
    };
  },
  "internal/fs/streams": function (t, e, i, s, o, r) {
    "use strict";
    const {
        Array: n,
        FunctionPrototypeBind: a,
        MathMin: h,
        ObjectDefineProperty: l,
        ObjectSetPrototypeOf: d,
        PromisePrototypeThen: f,
        ReflectApply: p,
        Symbol: c,
      } = r,
      {
        ERR_INVALID_ARG_TYPE: u,
        ERR_METHOD_NOT_IMPLEMENTED: y,
        ERR_OUT_OF_RANGE: m,
        ERR_STREAM_DESTROYED: w,
        ERR_SYSTEM_ERROR: _,
      } = e("internal/errors").codes,
      { deprecate: S, kEmptyObject: R } = e("internal/util"),
      { validateFunction: v, validateInteger: b } = e("internal/validators"),
      { errorOrDestroy: g } = e("internal/streams/destroy"),
      W = e("fs"),
      { kRef: D, kUnref: E, FileHandle: A } = e("internal/fs/promises"),
      { Buffer: O } = e("buffer"),
      {
        copyObject: F,
        getOptions: P,
        getValidatedFd: k,
        validatePath: I,
      } = e("internal/fs/utils"),
      { Readable: T, Writable: M, finished: C } = e("stream"),
      { toPathIfFileURL: N } = e("internal/url"),
      j = c("kIoDone"),
      H = c("kIsPerformingIO"),
      U = c("kFs"),
      G = c("kHandle");
    function _construct(t) {
      const e = this;
      if ("number" != typeof e.fd)
        if (e.open !== Y && e.open !== L) {
          const i = e.emit;
          (e.emit = function (...e) {
            "open" === e[0]
              ? ((this.emit = i), t(), p(i, this, e))
              : "error" === e[0]
              ? ((this.emit = i), t(e[1]))
              : p(i, this, e);
          }),
            e.open();
        } else
          e[U].open(e.path, e.flags, e.mode, (i, s) => {
            i ? t(i) : ((e.fd = s), t(), e.emit("open", e.fd), e.emit("ready"));
          });
      else t();
    }
    const FileHandleOperations = (t) => ({
      open: (t, e, i, s) => {
        throw new y("open()");
      },
      close: (e, i) => {
        t[E](), f(t.close(), () => i(), i);
      },
      read: (e, i, s, o, r, n) => {
        f(
          t.read(i, s, o, r),
          (t) => n(null, t.bytesRead, t.buffer),
          (t) => n(t, 0, i)
        );
      },
      write: (e, i, s, o, r, n) => {
        f(
          t.write(i, s, o, r),
          (t) => n(null, t.bytesWritten, t.buffer),
          (t) => n(t, 0, i)
        );
      },
      writev: (e, i, s, o) => {
        f(
          t.writev(i, s),
          (t) => o(null, t.bytesWritten, t.buffers),
          (t) => o(t, 0, i)
        );
      },
    });
    function close(t, e, i) {
      t.fd
        ? (t[U].close(t.fd, (t) => {
            i(t || e);
          }),
          (t.fd = null))
        : i(e);
    }
    function importFd(t, e) {
      if ("number" == typeof e.fd) return (t[U] = e.fs || W), e.fd;
      if ("object" == typeof e.fd && e.fd instanceof A) {
        if (e.fs) throw new y("FileHandle with fs");
        return (
          (t[G] = e.fd),
          (t[U] = FileHandleOperations(t[G])),
          t[G][D](),
          e.fd.on("close", a(t.close, t)),
          e.fd.fd
        );
      }
      throw u("options.fd", ["number", "FileHandle"], e.fd);
    }
    function ReadStream(t, e) {
      if (!(this instanceof ReadStream)) return new ReadStream(t, e);
      if (
        (void 0 === (e = F(P(e, R))).highWaterMark && (e.highWaterMark = 65536),
        void 0 === e.autoDestroy && (e.autoDestroy = !1),
        null == e.fd
          ? ((this.fd = null),
            (this[U] = e.fs || W),
            v(this[U].open, "options.fs.open"),
            (this.path = N(t)),
            (this.flags = void 0 === e.flags ? "r" : e.flags),
            (this.mode = void 0 === e.mode ? 438 : e.mode),
            I(this.path))
          : (this.fd = k(importFd(this, e))),
        (e.autoDestroy = void 0 === e.autoClose || e.autoClose),
        v(this[U].read, "options.fs.read"),
        e.autoDestroy && v(this[U].close, "options.fs.close"),
        (this.start = e.start),
        (this.end = e.end),
        (this.pos = void 0),
        (this.bytesRead = 0),
        (this[H] = !1),
        void 0 !== this.start &&
          (b(this.start, "start", 0), (this.pos = this.start)),
        void 0 === this.end)
      )
        this.end = 1 / 0;
      else if (
        this.end !== 1 / 0 &&
        (b(this.end, "end", 0), void 0 !== this.start && this.start > this.end)
      )
        throw new m("start", `<= "end" (here: ${this.end})`, this.start);
      p(T, this, [e]);
    }
    d(ReadStream.prototype, T.prototype),
      d(ReadStream, T),
      l(ReadStream.prototype, "autoClose", {
        __proto__: null,
        get() {
          return this._readableState.autoDestroy;
        },
        set(t) {
          this._readableState.autoDestroy = t;
        },
      });
    const L = S(
      function () {},
      "ReadStream.prototype.open() is deprecated",
      "DEP0135"
    );
    function WriteStream(t, e) {
      if (!(this instanceof WriteStream)) return new WriteStream(t, e);
      if (
        (((e = F(P(e, R))).decodeStrings = !0),
        null == e.fd
          ? ((this.fd = null),
            (this[U] = e.fs || W),
            v(this[U].open, "options.fs.open"),
            (this.path = N(t)),
            (this.flags = void 0 === e.flags ? "w" : e.flags),
            (this.mode = void 0 === e.mode ? 438 : e.mode),
            I(this.path))
          : (this.fd = k(importFd(this, e))),
        (e.autoDestroy = void 0 === e.autoClose || e.autoClose),
        !this[U].write && !this[U].writev)
      )
        throw new u("options.fs.write", "function", this[U].write);
      this[U].write && v(this[U].write, "options.fs.write"),
        this[U].writev && v(this[U].writev, "options.fs.writev"),
        e.autoDestroy && v(this[U].close, "options.fs.close"),
        this[U].write || (this._write = null),
        this[U].writev || (this._writev = null),
        (this.start = e.start),
        (this.pos = void 0),
        (this.bytesWritten = 0),
        (this[H] = !1),
        void 0 !== this.start &&
          (b(this.start, "start", 0), (this.pos = this.start)),
        p(M, this, [e]),
        e.encoding && this.setDefaultEncoding(e.encoding);
    }
    (ReadStream.prototype.open = L),
      (ReadStream.prototype._construct = _construct),
      (ReadStream.prototype._read = function (t) {
        if (
          (t =
            void 0 !== this.pos
              ? h(this.end - this.pos + 1, t)
              : h(this.end - this.bytesRead + 1, t)) <= 0
        )
          return void this.push(null);
        const e = O.allocUnsafeSlow(t);
        (this[H] = !0),
          this[U].read(this.fd, e, 0, t, this.pos, (t, e, i) => {
            if (((this[H] = !1), this.destroyed)) this.emit(j, t);
            else if (t) g(this, t);
            else if (e > 0) {
              if (
                (void 0 !== this.pos && (this.pos += e),
                (this.bytesRead += e),
                e !== i.length)
              ) {
                const t = O.allocUnsafeSlow(e);
                i.copy(t, 0, 0, e), (i = t);
              }
              this.push(i);
            } else this.push(null);
          });
      }),
      (ReadStream.prototype._destroy = function (t, e) {
        this[H]
          ? this.once(j, (i) => close(this, t || i, e))
          : close(this, t, e);
      }),
      (ReadStream.prototype.close = function (t) {
        "function" == typeof t && C(this, t), this.destroy();
      }),
      l(ReadStream.prototype, "pending", {
        __proto__: null,
        get() {
          return null === this.fd;
        },
        configurable: !0,
      }),
      d(WriteStream.prototype, M.prototype),
      d(WriteStream, M),
      l(WriteStream.prototype, "autoClose", {
        __proto__: null,
        get() {
          return this._writableState.autoDestroy;
        },
        set(t) {
          this._writableState.autoDestroy = t;
        },
      });
    const Y = S(
      function () {},
      "WriteStream.prototype.open() is deprecated",
      "DEP0135"
    );
    function writeAll(t, e, i, s, o = 0) {
      this[U].write(this.fd, t, 0, e, i, (t, r, n) => {
        if (
          ("EAGAIN" === t?.code && ((t = null), (r = 0)), this.destroyed || t)
        )
          return s(t || new w("write"));
        (this.bytesWritten += r),
          (e -= r),
          (i += r),
          (o = r ? 0 : o + 1) > 5
            ? s(new _("write failed"))
            : e
            ? writeAll.call(this, n.slice(r), e, i, s, o)
            : s();
      });
    }
    function writevAll(t, e, i, s, o = 0) {
      this[U].writev(this.fd, t, this.pos, (t, r, n) => {
        if (
          ("EAGAIN" === t?.code && ((t = null), (r = 0)), this.destroyed || t)
        )
          return s(t || new w("writev"));
        (this.bytesWritten += r),
          (e -= r),
          (i += r),
          (o = r ? 0 : o + 1) > 5
            ? s(new _("writev failed"))
            : e
            ? writevAll.call(this, [O.concat(n).slice(r)], e, i, s, o)
            : s();
      });
    }
    (WriteStream.prototype.open = Y),
      (WriteStream.prototype._construct = _construct),
      (WriteStream.prototype._write = function (t, e, i) {
        (this[H] = !0),
          writeAll.call(this, t, t.length, this.pos, (t) => {
            if (((this[H] = !1), this.destroyed)) return i(t), this.emit(j, t);
            i(t);
          }),
          void 0 !== this.pos && (this.pos += t.length);
      }),
      (WriteStream.prototype._writev = function (t, e) {
        const i = t.length,
          s = new n(i);
        let o = 0;
        for (let e = 0; e < i; e++) {
          const i = t[e].chunk;
          (s[e] = i), (o += i.length);
        }
        (this[H] = !0),
          writevAll.call(this, s, o, this.pos, (t) => {
            if (((this[H] = !1), this.destroyed)) return e(t), this.emit(j, t);
            e(t);
          }),
          void 0 !== this.pos && (this.pos += o);
      }),
      (WriteStream.prototype._destroy = function (t, e) {
        this[H]
          ? this.once(j, (i) => close(this, t || i, e))
          : close(this, t, e);
      }),
      (WriteStream.prototype.close = function (t) {
        if (t) {
          if (this.closed) return void s.nextTick(t);
          this.on("close", t);
        }
        this.autoClose || this.on("finish", this.destroy), this.end();
      }),
      (WriteStream.prototype.destroySoon = WriteStream.prototype.end),
      l(WriteStream.prototype, "pending", {
        __proto__: null,
        get() {
          return null === this.fd;
        },
        configurable: !0,
      }),
      (i.exports = { ReadStream: ReadStream, WriteStream: WriteStream });
  },
  "internal/fs/sync_write_stream": function (t, e, r, o, i, n) {
    "use strict";
    const { ObjectSetPrototypeOf: s, ReflectApply: y } = n,
      { kEmptyObject: c } = e("internal/util"),
      { Writable: S } = e("stream"),
      { closeSync: a, writeSync: p } = e("fs");
    function SyncWriteStream(t, e) {
      y(S, this, [{ autoDestroy: !0 }]),
        (e = e || c),
        (this.fd = t),
        (this.readable = !1),
        (this.autoClose = void 0 === e.autoClose || e.autoClose);
    }
    s(SyncWriteStream.prototype, S.prototype),
      s(SyncWriteStream, S),
      (SyncWriteStream.prototype._write = function (t, e, r) {
        try {
          p(this.fd, t, 0, t.length);
        } catch (t) {
          return void r(t);
        }
        r();
      }),
      (SyncWriteStream.prototype._destroy = function (t, e) {
        if (null === this.fd) return e(t);
        this.autoClose && a(this.fd), (this.fd = null), e(t);
      }),
      (SyncWriteStream.prototype.destroySoon =
        SyncWriteStream.prototype.destroy),
      (r.exports = SyncWriteStream);
  },
  "internal/fs/utils": function (t, e, r, i, n, s) {
    "use strict";
    const {
        ArrayIsArray: o,
        BigInt: a,
        Date: c,
        DateNow: f,
        DatePrototypeGetTime: u,
        ErrorCaptureStackTrace: l,
        FunctionPrototypeCall: p,
        Number: h,
        NumberIsFinite: m,
        MathMin: d,
        MathRound: y,
        ObjectIs: g,
        ObjectPrototypeHasOwnProperty: S,
        ObjectSetPrototypeOf: F,
        ReflectApply: w,
        ReflectOwnKeys: I,
        RegExpPrototypeSymbolReplace: _,
        StringPrototypeEndsWith: D,
        StringPrototypeIncludes: v,
        Symbol: R,
        TypedArrayPrototypeAt: O,
        TypedArrayPrototypeIncludes: E,
      } = s,
      { Buffer: B } = e("buffer"),
      {
        codes: {
          ERR_FS_EISDIR: b,
          ERR_FS_INVALID_SYMLINK_TYPE: N,
          ERR_INCOMPATIBLE_OPTION_PAIR: T,
          ERR_INVALID_ARG_TYPE: k,
          ERR_INVALID_ARG_VALUE: M,
          ERR_OUT_OF_RANGE: P,
        },
        hideStackFrames: L,
        uvException: A,
      } = e("internal/errors"),
      {
        isArrayBufferView: C,
        isBigInt64Array: U,
        isDate: x,
        isUint8Array: V,
      } = e("internal/util/types"),
      { kEmptyObject: j, once: K } = e("internal/util"),
      { toPathIfFileURL: W } = e("internal/url"),
      {
        validateAbortSignal: Y,
        validateBoolean: z,
        validateFunction: G,
        validateInt32: X,
        validateInteger: H,
        validateObject: $,
        validateUint32: J,
      } = e("internal/validators"),
      q = e("path"),
      Q = R("type"),
      Z = R("stats"),
      tt = e("internal/assert"),
      {
        fs: {
          F_OK: et = 0,
          W_OK: rt = 0,
          R_OK: it = 0,
          X_OK: nt = 0,
          COPYFILE_EXCL: st,
          COPYFILE_FICLONE: ot,
          COPYFILE_FICLONE_FORCE: at,
          O_APPEND: ct,
          O_CREAT: ft,
          O_EXCL: ut,
          O_RDONLY: lt,
          O_RDWR: pt,
          O_SYNC: ht,
          O_TRUNC: mt,
          O_WRONLY: dt,
          S_IFBLK: yt,
          S_IFCHR: gt,
          S_IFDIR: St,
          S_IFIFO: Ft,
          S_IFLNK: wt,
          S_IFMT: It,
          S_IFREG: _t,
          S_IFSOCK: Dt,
          UV_FS_SYMLINK_DIR: vt,
          UV_FS_SYMLINK_JUNCTION: Rt,
          UV_DIRENT_UNKNOWN: Ot,
          UV_DIRENT_FILE: Et,
          UV_DIRENT_DIR: Bt,
          UV_DIRENT_LINK: bt,
          UV_DIRENT_FIFO: Nt,
          UV_DIRENT_SOCKET: Tt,
          UV_DIRENT_CHAR: kt,
          UV_DIRENT_BLOCK: Mt,
        },
        os: {
          errno: { EISDIR: Pt },
        },
      } = n("constants"),
      Lt = d(et, rt, it, nt),
      At = et | rt | it | nt,
      Ct = d(0, st, ot, at),
      Ut = st | ot | at,
      xt = "win32" === i.platform;
    let Vt;
    function lazyLoadFs() {
      return Vt || (Vt = e("fs")), Vt;
    }
    function assertEncoding(t) {
      if (t && !B.isEncoding(t)) {
        throw new M(t, "encoding", "is invalid encoding");
      }
    }
    class Dirent {
      constructor(t, e, r, i = r && join(r, t)) {
        (this.name = t), (this.parentPath = r), (this.path = i), (this[Q] = e);
      }
      isDirectory() {
        return this[Q] === Bt;
      }
      isFile() {
        return this[Q] === Et;
      }
      isBlockDevice() {
        return this[Q] === Mt;
      }
      isCharacterDevice() {
        return this[Q] === kt;
      }
      isSymbolicLink() {
        return this[Q] === bt;
      }
      isFIFO() {
        return this[Q] === Nt;
      }
      isSocket() {
        return this[Q] === Tt;
      }
    }
    class DirentFromStats extends Dirent {
      constructor(t, e, r, i) {
        super(t, null, r, i), (this[Z] = e);
      }
    }
    for (const t of I(Dirent.prototype))
      "constructor" !== t &&
        (DirentFromStats.prototype[t] = function () {
          return this[Z][t]();
        });
    const jt = B.from(q.sep);
    function join(t, e) {
      if (("string" == typeof t || V(t)) && void 0 === e) return t;
      if ("string" == typeof t && V(e)) {
        const r = B.from(q.join(t, q.sep));
        return B.concat([r, e]);
      }
      if ("string" == typeof t && "string" == typeof e) return q.join(t, e);
      if (V(t) && V(e)) return B.concat([t, jt, e]);
      throw new k("path", ["string", "Buffer"], t);
    }
    function getDirent(t, e, r, i) {
      if ("function" != typeof i) {
        if (r === Ot) {
          const r = join(t, e),
            n = lazyLoadFs().lstatSync(r);
          return new DirentFromStats(e, n, t, !0 === i ? r : t);
        }
        return !0 === i ? new Dirent(e, r, t) : new Dirent(e, r, t, t);
      }
      if (r === Ot) {
        let r;
        try {
          r = join(t, e);
        } catch (t) {
          return void i(t);
        }
        lazyLoadFs().lstat(r, (n, s) => {
          n ? i(n) : i(null, new DirentFromStats(e, s, t, r));
        });
      } else i(null, new Dirent(e, r, t));
    }
    const Kt = L((t, e, r = !0) => {
      const i = "string" == typeof t,
        n = V(t);
      if ((!i && !n) || (i && !v(t, "\0")) || (n && !E(t, 0))) return;
      const s = new M(
        e,
        t,
        "must be a string or Uint8Array without null bytes"
      );
      if (r) throw s;
      return s;
    });
    function StatsBase(t, e, r, i, n, s, o, a, c, f) {
      (this.dev = t),
        (this.mode = e),
        (this.nlink = r),
        (this.uid = i),
        (this.gid = n),
        (this.rdev = s),
        (this.blksize = o),
        (this.ino = a),
        (this.size = c),
        (this.blocks = f);
    }
    (StatsBase.prototype.isDirectory = function () {
      return this._checkModeProperty(St);
    }),
      (StatsBase.prototype.isFile = function () {
        return this._checkModeProperty(_t);
      }),
      (StatsBase.prototype.isBlockDevice = function () {
        return this._checkModeProperty(yt);
      }),
      (StatsBase.prototype.isCharacterDevice = function () {
        return this._checkModeProperty(gt);
      }),
      (StatsBase.prototype.isSymbolicLink = function () {
        return this._checkModeProperty(wt);
      }),
      (StatsBase.prototype.isFIFO = function () {
        return this._checkModeProperty(Ft);
      }),
      (StatsBase.prototype.isSocket = function () {
        return this._checkModeProperty(Dt);
      });
    const Wt = 10n ** 6n,
      Yt = 10n ** 9n,
      zt = 1e3,
      Gt = 10 ** 6;
    function msFromTimeSpec(t, e) {
      return t * zt + e / Gt;
    }
    function nsFromTimeSpecBigInt(t, e) {
      return t * Yt + e;
    }
    function dateFromMs(t) {
      return new c(y(h(t)));
    }
    function BigIntStats(t, e, r, i, n, s, o, a, c, f, u, l, p, h) {
      w(StatsBase, this, [t, e, r, i, n, s, o, a, c, f]),
        (this.atimeMs = u / Wt),
        (this.mtimeMs = l / Wt),
        (this.ctimeMs = p / Wt),
        (this.birthtimeMs = h / Wt),
        (this.atimeNs = u),
        (this.mtimeNs = l),
        (this.ctimeNs = p),
        (this.birthtimeNs = h),
        (this.atime = dateFromMs(this.atimeMs)),
        (this.mtime = dateFromMs(this.mtimeMs)),
        (this.ctime = dateFromMs(this.ctimeMs)),
        (this.birthtime = dateFromMs(this.birthtimeMs));
    }
    function Stats(t, e, r, i, n, s, o, a, c, f, u, l, h, m) {
      p(StatsBase, this, t, e, r, i, n, s, o, a, c, f),
        (this.atimeMs = u),
        (this.mtimeMs = l),
        (this.ctimeMs = h),
        (this.birthtimeMs = m),
        (this.atime = dateFromMs(u)),
        (this.mtime = dateFromMs(l)),
        (this.ctime = dateFromMs(h)),
        (this.birthtime = dateFromMs(m));
    }
    F(BigIntStats.prototype, StatsBase.prototype),
      F(BigIntStats, StatsBase),
      (BigIntStats.prototype._checkModeProperty = function (t) {
        return (
          (!xt || (t !== Ft && t !== yt && t !== Dt)) &&
          (this.mode & a(It)) === a(t)
        );
      }),
      F(Stats.prototype, StatsBase.prototype),
      F(Stats, StatsBase),
      (Stats.prototype.isFile = StatsBase.prototype.isFile),
      (Stats.prototype._checkModeProperty = function (t) {
        return (
          (!xt || (t !== Ft && t !== yt && t !== Dt)) && (this.mode & It) === t
        );
      });
    class StatFs {
      constructor(t, e, r, i, n, s, o) {
        (this.type = t),
          (this.bsize = e),
          (this.blocks = r),
          (this.bfree = i),
          (this.bavail = n),
          (this.files = s),
          (this.ffree = o);
      }
    }
    const Xt = L((t) => {
      let e = 0;
      if ("string" == typeof t)
        switch (t) {
          case "dir":
            e |= vt;
            break;
          case "junction":
            e |= Rt;
            break;
          case "file":
            break;
          default:
            throw new N(t);
        }
      return e;
    });
    const Ht = L((t, e, r) => {
        if (t < 0) throw new P("offset", ">= 0", t);
        if (e < 0) throw new P("length", ">= 0", e);
        if (t + e > r) throw new P("length", "<= " + (r - t), e);
      }),
      $t = L((t, e, r) => {
        if (t > r) throw new P("offset", `<= ${r}`, t);
        if (e > r - t) throw new P("length", "<= " + (r - t), e);
        if (e < 0) throw new P("length", ">= 0", e);
        X(e, "length", 0);
      }),
      Jt = L((t, e = "path") => {
        if ("string" != typeof t && !V(t))
          throw new k(e, ["string", "Buffer", "URL"], t);
        const r = Kt(t, e, !1);
        if (void 0 !== r) throw r;
      }),
      qt = L((t, e = "path") => {
        const r = W(t);
        return Jt(r, e), r;
      }),
      Qt = L((t, e = "fd") => (g(t, -0) ? 0 : (X(t, e, 0), t))),
      Zt = L((t, e = "buffers") => {
        if (!o(t)) throw new k(e, "ArrayBufferView[]", t);
        for (let r = 0; r < t.length; r++)
          if (!C(t[r])) throw new k(e, "ArrayBufferView[]", t);
        return t;
      });
    let te = !0;
    const ee = {
        dereference: !1,
        errorOnExist: !1,
        filter: void 0,
        force: !0,
        preserveTimestamps: !1,
        recursive: !1,
        verbatimSymlinks: !1,
      },
      re = { recursive: !1, force: !1, retryDelay: 100, maxRetries: 0 },
      ie = { retryDelay: 100, maxRetries: 0, recursive: !1 },
      ne = L((t) => {
        if (void 0 === t) return { ...ee };
        if (
          ($(t, "options"),
          (t = { ...ee, ...t }),
          z(t.dereference, "options.dereference"),
          z(t.errorOnExist, "options.errorOnExist"),
          z(t.force, "options.force"),
          z(t.preserveTimestamps, "options.preserveTimestamps"),
          z(t.recursive, "options.recursive"),
          z(t.verbatimSymlinks, "options.verbatimSymlinks"),
          (t.mode = fe(t.mode, "copyFile")),
          !0 === t.dereference && !0 === t.verbatimSymlinks)
        )
          throw new T("dereference", "verbatimSymlinks");
        return void 0 !== t.filter && G(t.filter, "options.filter"), t;
      }),
      se = L((t, e, r, i) => {
        (e = ce(e, re)),
          z(e.force, "options.force"),
          lazyLoadFs().lstat(t, (n, s) =>
            n
              ? e.force && "ENOENT" === n.code
                ? i(null, e)
                : i(n, e)
              : r && !s.isDirectory()
              ? i(!1)
              : s.isDirectory() && !e.recursive
              ? i(
                  new b({
                    code: "EISDIR",
                    message: "is a directory",
                    path: t,
                    syscall: "rm",
                    errno: Pt,
                  })
                )
              : i(null, e)
          );
      }),
      oe = L((t, e, r) => {
        if (
          ((e = ce(e, re)),
          z(e.force, "options.force"),
          !e.force || r || !e.recursive)
        ) {
          const i = lazyLoadFs()
            .lstatSync(t, { throwIfNoEntry: !e.force })
            ?.isDirectory();
          if (r && !i) return !1;
          if (i && !e.recursive)
            throw new b({
              code: "EISDIR",
              message: "is a directory",
              path: t,
              syscall: "rm",
              errno: Pt,
            });
        }
        return e;
      });
    let ae = i.noDeprecation;
    const ce = L((t, e = ie) =>
        void 0 === t
          ? e
          : ($(t, "options"),
            (t = { ...e, ...t }),
            z(t.recursive, "options.recursive"),
            X(t.retryDelay, "options.retryDelay", 0),
            J(t.maxRetries, "options.maxRetries"),
            t)
      ),
      fe = L((t, e) => {
        let r = Lt,
          i = At,
          n = et;
        return (
          "copyFile" === e
            ? ((r = Ct), (i = Ut), (n = t || 0))
            : tt("access" === e),
          null == t ? n : (H(t, "mode", r, i), t)
        );
      }),
      ue = L((t, e) => {
        if (
          "string" != typeof t &&
          ("object" != typeof t ||
            null === t ||
            "function" != typeof t.toString ||
            !S(t, "toString"))
        )
          throw new k(e, ["string", "Buffer", "TypedArray", "DataView"], t);
      }),
      le = L((t, e) => {
        if ("string" != typeof t)
          throw new k(e, ["string", "Buffer", "TypedArray", "DataView"], t);
      }),
      pe = L((t, e) => {
        if ("number" == typeof t) H(t, e);
        else {
          if ("bigint" != typeof t) throw new k(e, ["integer", "bigint"], t);
          if (!(t >= -(2n ** 63n) && t <= 2n ** 63n - 1n))
            throw new P(e, `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, t);
        }
      });
    r.exports = {
      constants: {
        kIoMaxLength: 2 ** 31 - 1,
        kMaxUserId: 2 ** 32 - 1,
        kReadFileBufferLength: 524288,
        kReadFileUnknownBufferLength: 65536,
        kWriteFileMaxChunkSize: 524288,
      },
      assertEncoding: assertEncoding,
      BigIntStats: BigIntStats,
      copyObject: function copyObject(t) {
        const e = {};
        for (const r in t) e[r] = t[r];
        return e;
      },
      Dirent: Dirent,
      emitRecursiveRmdirWarning: function emitRecursiveRmdirWarning() {
        ae ||
          (i.emitWarning(
            "In future versions of Node.js, fs.rmdir(path, { recursive: true }) will be removed. Use fs.rm(path, { recursive: true }) instead",
            "DeprecationWarning",
            "DEP0147"
          ),
          (ae = !0));
      },
      getDirent: getDirent,
      getDirents: function getDirents(t, { 0: e, 1: r }, i) {
        let n;
        if ("function" != typeof i) {
          const i = e.length;
          for (n = 0; n < i; n++) e[n] = getDirent(t, e[n], r[n]);
          return e;
        }
        {
          const s = e.length;
          let o = 0;
          for (i = K(i), n = 0; n < s; n++) {
            if (r[n] === Ot) {
              const r = e[n],
                s = n;
              let a;
              o++;
              try {
                a = join(t, r);
              } catch (t) {
                return void i(t);
              }
              lazyLoadFs().lstat(a, (n, c) => {
                n
                  ? i(n)
                  : ((e[s] = new DirentFromStats(r, c, t, a)),
                    0 == --o && i(null, e));
              });
            } else e[n] = new Dirent(e[n], r[n], t);
          }
          0 === o && i(null, e);
        }
      },
      getOptions: function getOptions(t, e = j) {
        if (null == t || "function" == typeof t) return e;
        if ("string" == typeof t) ((e = { ...e }).encoding = t), (t = e);
        else if ("object" != typeof t)
          throw new k("options", ["string", "Object"], t);
        return (
          "buffer" !== t.encoding && assertEncoding(t.encoding),
          void 0 !== t.signal && Y(t.signal, "options.signal"),
          t
        );
      },
      getValidatedFd: Qt,
      getValidatedPath: qt,
      getValidMode: fe,
      handleErrorFromBinding: function handleErrorFromBinding(t) {
        if (void 0 !== t.errno) {
          const e = A(t);
          throw (l(e, handleErrorFromBinding), e);
        }
        if (void 0 !== t.error)
          throw (l(t.error, handleErrorFromBinding), t.error);
      },
      nullCheck: Kt,
      preprocessSymlinkDestination: function preprocessSymlinkDestination(
        t,
        e,
        r
      ) {
        return xt
          ? ((t = "" + t),
            "junction" === e
              ? ((t = q.resolve(r, "..", t)), q.toNamespacedPath(t))
              : q.isAbsolute(t)
              ? q.toNamespacedPath(t)
              : _(/\//g, t, "\\"))
          : t;
      },
      realpathCacheKey: R("realpathCacheKey"),
      getStatFsFromBinding: function getStatFsFromBinding(t) {
        return new StatFs(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
      },
      getStatsFromBinding: function getStatsFromBinding(t, e = 0) {
        return U(t)
          ? new BigIntStats(
              t[0 + e],
              t[1 + e],
              t[2 + e],
              t[3 + e],
              t[4 + e],
              t[5 + e],
              t[6 + e],
              t[7 + e],
              t[8 + e],
              t[9 + e],
              nsFromTimeSpecBigInt(t[10 + e], t[11 + e]),
              nsFromTimeSpecBigInt(t[12 + e], t[13 + e]),
              nsFromTimeSpecBigInt(t[14 + e], t[15 + e]),
              nsFromTimeSpecBigInt(t[16 + e], t[17 + e])
            )
          : new Stats(
              t[0 + e],
              t[1 + e],
              t[2 + e],
              t[3 + e],
              t[4 + e],
              t[5 + e],
              t[6 + e],
              t[7 + e],
              t[8 + e],
              t[9 + e],
              msFromTimeSpec(t[10 + e], t[11 + e]),
              msFromTimeSpec(t[12 + e], t[13 + e]),
              msFromTimeSpec(t[14 + e], t[15 + e]),
              msFromTimeSpec(t[16 + e], t[17 + e])
            );
      },
      stringToFlags: function stringToFlags(t, e = "flags") {
        if ("number" == typeof t) return X(t, e), t;
        if (null == t) return lt;
        switch (t) {
          case "r":
            return lt;
          case "rs":
          case "sr":
            return lt | ht;
          case "r+":
            return pt;
          case "rs+":
          case "sr+":
            return pt | ht;
          case "w":
            return mt | ft | dt;
          case "wx":
          case "xw":
            return mt | ft | dt | ut;
          case "w+":
            return mt | ft | pt;
          case "wx+":
          case "xw+":
            return mt | ft | pt | ut;
          case "a":
            return ct | ft | dt;
          case "ax":
          case "xa":
            return ct | ft | dt | ut;
          case "as":
          case "sa":
            return ct | ft | dt | ht;
          case "a+":
            return ct | ft | pt;
          case "ax+":
          case "xa+":
            return ct | ft | pt | ut;
          case "as+":
          case "sa+":
            return ct | ft | pt | ht;
        }
        throw new M("flags", t);
      },
      stringToSymlinkType: Xt,
      Stats: Stats,
      toUnixTimestamp: function toUnixTimestamp(t, e = "time") {
        if ("string" == typeof t && +t == t) return +t;
        if (m(t)) return t < 0 ? f() / 1e3 : t;
        if (x(t)) return u(t) / 1e3;
        throw new k(e, ["Date", "Time in seconds"], t);
      },
      validateBufferArray: Zt,
      validateCpOptions: ne,
      validateOffsetLengthRead: Ht,
      validateOffsetLengthWrite: $t,
      validatePath: Jt,
      validatePosition: pe,
      validateRmOptions: se,
      validateRmOptionsSync: oe,
      validateRmdirOptions: ce,
      validateStringAfterArrayBufferView: ue,
      validatePrimitiveStringAfterArrayBufferView: le,
      warnOnNonPortableTemplate: function warnOnNonPortableTemplate(t) {
        te &&
          (("string" == typeof t && D(t, "X")) ||
            ("string" != typeof t && 88 === O(t, -1))) &&
          (i.emitWarning(
            "mkdtemp() templates ending with X are not portable. For details see: https://nodejs.org/api/fs.html"
          ),
          (te = !1));
      },
    };
  },
  "internal/fs/watchers": function (t, e, n, a, i, s) {
    "use strict";
    const {
        FunctionPrototypeCall: r,
        ObjectDefineProperty: h,
        ObjectSetPrototypeOf: o,
        Symbol: l,
      } = s,
      {
        AbortError: c,
        uvException: d,
        codes: { ERR_INVALID_ARG_VALUE: f },
      } = e("internal/errors"),
      { createDeferredPromise: u, kEmptyObject: p } = e("internal/util"),
      { kFsStatsFieldsNumber: S, StatWatcher: _ } = i("fs"),
      { FSEvent: m } = i("fs_event_wrap"),
      { UV_ENOSPC: y } = i("uv"),
      { EventEmitter: W } = e("events"),
      { getStatsFromBinding: v, getValidatedPath: g } = e("internal/fs/utils"),
      {
        defaultTriggerAsyncIdScope: w,
        symbols: { owner_symbol: F },
      } = e("internal/async_hooks"),
      { toNamespacedPath: b } = e("path"),
      {
        validateAbortSignal: k,
        validateBoolean: E,
        validateObject: A,
        validateUint32: O,
      } = e("internal/validators"),
      {
        Buffer: { isEncoding: C },
      } = e("buffer"),
      P = e("internal/assert"),
      R = l("kOldStatus"),
      N = l("kUseBigint"),
      j = l("kFSWatchStart"),
      T = l("kFSStatWatcherStart"),
      x = l("KFSStatWatcherRefCount"),
      I = l("KFSStatWatcherMaxRefCount"),
      B = l("kFSStatWatcherAddOrCleanRef");
    function emitStop(t) {
      t.emit("stop");
    }
    function StatWatcher(t) {
      r(W, this),
        (this._handle = null),
        (this[R] = -1),
        (this[N] = t),
        (this[x] = 1),
        (this[I] = 1);
    }
    function onchange(t, e) {
      const n = this[F];
      (-1 === n[R] && -1 === t && e[2] === e[16]) ||
        ((n[R] = t), n.emit("change", v(e), v(e, S)));
    }
    function FSWatcher() {
      r(W, this),
        (this._handle = new m()),
        (this._handle[F] = this),
        (this._handle.onchange = (t, e, n) => {
          if (t < 0) {
            null !== this._handle &&
              (this._handle.close(), (this._handle = null));
            const e = d({ errno: t, syscall: "watch", path: n });
            (e.filename = n), this.emit("error", e);
          } else this.emit("change", e, n);
        });
    }
    function emitCloseNT(t) {
      t.emit("close");
    }
    let D;
    o(StatWatcher.prototype, W.prototype),
      o(StatWatcher, W),
      (StatWatcher.prototype[T] = function (t, e, n) {
        if (null !== this._handle) return;
        (this._handle = new _(this[N])),
          (this._handle[F] = this),
          (this._handle.onchange = onchange),
          e || this.unref(),
          (this[R] = -1),
          (t = g(t, "filename")),
          O(n, "interval");
        const a = this._handle.start(b(t), n);
        if (a) {
          const e = d({ errno: a, syscall: "watch", path: t });
          throw ((e.filename = t), e);
        }
      }),
      (StatWatcher.prototype.start = () => {}),
      (StatWatcher.prototype.stop = function () {
        null !== this._handle &&
          (w(this._handle.getAsyncId(), a.nextTick, emitStop, this),
          this._handle.close(),
          (this._handle = null));
      }),
      (StatWatcher.prototype[B] = function (t) {
        "add" === t
          ? (this[x]++, this[I]++)
          : "clean" === t
          ? (this[I]--, this.unref())
          : "cleanAll" === t &&
            ((this[I] = 0), (this[x] = 0), this._handle?.unref());
      }),
      (StatWatcher.prototype.ref = function () {
        return (
          this[x] === this[I] ||
            (this._handle && 0 == this[x]++ && this._handle.ref()),
          this
        );
      }),
      (StatWatcher.prototype.unref = function () {
        return (
          0 === this[x] ||
            (this._handle && 0 == --this[x] && this._handle.unref()),
          this
        );
      }),
      o(FSWatcher.prototype, W.prototype),
      o(FSWatcher, W),
      (FSWatcher.prototype[j] = function (t, e, n, a) {
        if (null === this._handle) return;
        if (
          (P(this._handle instanceof m, "handle must be a FSEvent"),
          this._handle.initialized)
        )
          return;
        t = g(t, "filename");
        const i = this._handle.start(b(t), e, n, a);
        if (i) {
          const e = d({
            errno: i,
            syscall: "watch",
            path: t,
            message:
              i === y ? "System limit for number of file watchers reached" : "",
          });
          throw ((e.filename = t), e);
        }
      }),
      (FSWatcher.prototype.start = () => {}),
      (FSWatcher.prototype.close = function () {
        null !== this._handle &&
          (P(this._handle instanceof m, "handle must be a FSEvent"),
          this._handle.initialized &&
            (this._handle.close(),
            (this._handle = null),
            a.nextTick(emitCloseNT, this)));
      }),
      (FSWatcher.prototype.ref = function () {
        return this._handle && this._handle.ref(), this;
      }),
      (FSWatcher.prototype.unref = function () {
        return this._handle && this._handle.unref(), this;
      }),
      h(m.prototype, "owner", {
        __proto__: null,
        get() {
          return this[F];
        },
        set(t) {
          return (this[F] = t);
        },
      }),
      (n.exports = {
        FSWatcher: FSWatcher,
        StatWatcher: StatWatcher,
        kFSWatchStart: j,
        kFSStatWatcherStart: T,
        kFSStatWatcherAddOrCleanRef: B,
        watch: async function* watch(t, n = p) {
          const a = b(g(t));
          A(n, "options");
          const {
            persistent: i = !0,
            recursive: s = !1,
            encoding: r = "utf8",
            signal: h,
          } = n;
          if (
            (E(i, "options.persistent"),
            E(s, "options.recursive"),
            k(h, "options.signal"),
            r && !C(r))
          ) {
            throw new f(r, "encoding", "is invalid encoding");
          }
          if (h?.aborted) throw new c(void 0, { cause: h?.reason });
          const o = new m();
          let { promise: l, resolve: S, reject: _ } = u();
          const oncancel = () => {
            o.close(), _(new c(void 0, { cause: h?.reason }));
          };
          try {
            h &&
              ((D ??= e("internal/event_target").kResistStopPropagation),
              h.addEventListener("abort", oncancel, {
                __proto__: null,
                once: !0,
                [D]: !0,
              })),
              (o.onchange = (t, e, n) => {
                if (t < 0) {
                  const e = d({ errno: t, syscall: "watch", path: n });
                  return (e.filename = n), o.close(), void _(e);
                }
                S({ eventType: e, filename: n });
              });
            const n = o.start(a, i, s, r);
            if (n) {
              const e = d({
                errno: n,
                syscall: "watch",
                path: t,
                message:
                  n === y
                    ? "System limit for number of file watchers reached"
                    : "",
              });
              throw ((e.filename = t), o.close(), e);
            }
            for (; !h?.aborted; )
              yield await l, ({ promise: l, resolve: S, reject: _ } = u());
            throw new c(void 0, { cause: h?.reason });
          } finally {
            o.close(), h?.removeEventListener("abort", oncancel);
          }
        },
      });
  },
  "internal/heap_utils": function (t, s, e, a, o, r) {
    "use strict";
    const { Symbol: n } = r,
      { kUpdateTimer: i, onStreamRead: d } = s("internal/stream_base_commons"),
      { owner_symbol: m } = s("internal/async_hooks").symbols,
      { Readable: h } = s("stream"),
      _ = n("kHandle");
    e.exports = {
      HeapSnapshotStream: class HeapSnapshotStream extends h {
        constructor(t) {
          super({ autoDestroy: !0 }),
            (this[_] = t),
            (t[m] = this),
            (t.onread = d);
        }
        _read() {
          this[_] && this[_].readStart();
        }
        _destroy() {
          (this[_][m] = void 0), (this[_] = void 0);
        }
        [i]() {}
      },
    };
  },
  "internal/histogram": function (t, e, i, r, s, n) {
    "use strict";
    const {
        MapPrototypeEntries: o,
        NumberIsNaN: a,
        NumberIsInteger: h,
        NumberMAX_SAFE_INTEGER: g,
        ObjectFromEntries: m,
        ReflectConstruct: l,
        SafeMap: c,
        Symbol: d,
      } = n,
      { Histogram: H } = s("performance"),
      { customInspectSymbol: w, kEmptyObject: u } = e("internal/util"),
      { inspect: f } = e("util"),
      {
        codes: {
          ERR_ILLEGAL_CONSTRUCTOR: p,
          ERR_INVALID_ARG_VALUE: R,
          ERR_INVALID_ARG_TYPE: b,
          ERR_INVALID_THIS: I,
          ERR_OUT_OF_RANGE: _,
        },
      } = e("internal/errors"),
      {
        validateInteger: x,
        validateNumber: E,
        validateObject: v,
      } = e("internal/validators"),
      N = d("kDestroy"),
      k = d("kHandle"),
      B = d("kMap"),
      y = d("kRecordable"),
      {
        kClone: A,
        kDeserialize: D,
        makeTransferable: O,
      } = e("internal/worker/js_transferable");
    function isHistogram(t) {
      return void 0 !== t?.[k];
    }
    class Histogram {
      constructor() {
        throw new p();
      }
      [w](t, e) {
        if (t < 0) return this;
        const i = { ...e, depth: null == e.depth ? null : e.depth - 1 };
        return `Histogram ${f(
          {
            min: this.min,
            max: this.max,
            mean: this.mean,
            exceeds: this.exceeds,
            stddev: this.stddev,
            count: this.count,
            percentiles: this.percentiles,
          },
          i
        )}`;
      }
      get count() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.count();
      }
      get countBigInt() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.countBigInt();
      }
      get min() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.min();
      }
      get minBigInt() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.minBigInt();
      }
      get max() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.max();
      }
      get maxBigInt() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.maxBigInt();
      }
      get mean() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.mean();
      }
      get exceeds() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.exceeds();
      }
      get exceedsBigInt() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.exceedsBigInt();
      }
      get stddev() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[k]?.stddev();
      }
      percentile(t) {
        if (!isHistogram(this)) throw new I("Histogram");
        if ((E(t, "percentile"), a(t) || t <= 0 || t > 100))
          throw new R.RangeError("percentile", t);
        return this[k]?.percentile(t);
      }
      percentileBigInt(t) {
        if (!isHistogram(this)) throw new I("Histogram");
        if ((E(t, "percentile"), a(t) || t <= 0 || t > 100))
          throw new R.RangeError("percentile", t);
        return this[k]?.percentileBigInt(t);
      }
      get percentiles() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[B].clear(), this[k]?.percentiles(this[B]), this[B];
      }
      get percentilesBigInt() {
        if (!isHistogram(this)) throw new I("Histogram");
        return this[B].clear(), this[k]?.percentilesBigInt(this[B]), this[B];
      }
      reset() {
        if (!isHistogram(this)) throw new I("Histogram");
        this[k]?.reset();
      }
      [A]() {
        return {
          data: { handle: this[k] },
          deserializeInfo: "internal/histogram:internalHistogram",
        };
      }
      [D]({ handle: t }) {
        this[k] = t;
      }
      toJSON() {
        return {
          count: this.count,
          min: this.min,
          max: this.max,
          mean: this.mean,
          exceeds: this.exceeds,
          stddev: this.stddev,
          percentiles: m(o(this.percentiles)),
        };
      }
    }
    class RecordableHistogram extends Histogram {
      constructor() {
        throw new p();
      }
      record(t) {
        if (void 0 === this[y]) throw new I("RecordableHistogram");
        if ("bigint" != typeof t) {
          if (!h(t)) throw new b("val", ["integer", "bigint"], t);
          if (t < 1 || t > g)
            throw new _("val", "a safe integer greater than 0", t);
          this[k]?.record(t);
        } else this[k]?.record(t);
      }
      recordDelta() {
        if (void 0 === this[y]) throw new I("RecordableHistogram");
        this[k]?.recordDelta();
      }
      add(t) {
        if (void 0 === this[y]) throw new I("RecordableHistogram");
        if (void 0 === t[y]) throw new b("other", "RecordableHistogram", t);
        this[k]?.add(t[k]);
      }
      [A]() {
        return {
          data: { handle: this[k] },
          deserializeInfo: "internal/histogram:internalRecordableHistogram",
        };
      }
      [D]({ handle: t }) {
        this[k] = t;
      }
    }
    function internalHistogram(t) {
      return O(
        l(
          function () {
            (this[k] = t), (this[B] = new c());
          },
          [],
          Histogram
        )
      );
    }
    function internalRecordableHistogram(t) {
      return O(
        l(
          function () {
            (this[k] = t), (this[B] = new c()), (this[y] = !0);
          },
          [],
          RecordableHistogram
        )
      );
    }
    (internalHistogram.prototype[D] = () => {}),
      (internalRecordableHistogram.prototype[D] = () => {}),
      (i.exports = {
        Histogram: Histogram,
        RecordableHistogram: RecordableHistogram,
        internalHistogram: internalHistogram,
        internalRecordableHistogram: internalRecordableHistogram,
        isHistogram: isHistogram,
        kDestroy: N,
        kHandle: k,
        kMap: B,
        createHistogram: function createHistogram(t = u) {
          v(t, "options");
          const { lowest: e = 1, highest: i = g, figures: r = 3 } = t;
          if (
            ("bigint" != typeof e && x(e, "options.lowest", 1, g),
            "bigint" != typeof i)
          )
            x(i, "options.highest", 2 * e, g);
          else if (i < 2n * e) throw new R.RangeError("options.highest", i);
          return (
            x(r, "options.figures", 1, 5),
            internalRecordableHistogram(new H(e, i, r))
          );
        },
      });
  },
  "internal/http": function (e, t, n, r, c, a) {
    "use strict";
    const {
        Symbol: o,
        Date: i,
        DatePrototypeGetMilliseconds: s,
        DatePrototypeToUTCString: u,
      } = a,
      { setUnrefTimeout: d } = t("internal/timers"),
      { trace: E, isTraceCategoryEnabled: T } = c("trace_events"),
      { CHAR_LOWERCASE_B: l, CHAR_LOWERCASE_E: f } = t("internal/constants");
    let C;
    function resetCache() {
      C = void 0;
    }
    let D = 0;
    const _ = "node,node.http";
    n.exports = {
      kOutHeaders: o("kOutHeaders"),
      kNeedDrain: o("kNeedDrain"),
      utcDate: function utcDate() {
        return (
          C ||
            (function cache() {
              const e = new i();
              (C = u(e)), d(resetCache, 1e3 - s(e));
            })(),
          C
        );
      },
      traceBegin: function traceBegin(...e) {
        E(l, _, ...e);
      },
      traceEnd: function traceEnd(...e) {
        E(f, _, ...e);
      },
      getNextTraceEventId: function getNextTraceEventId() {
        return ++D;
      },
      isTraceHTTPEnabled: function isTraceHTTPEnabled() {
        return T("node.http");
      },
    };
  },
  "internal/http2/compat": function (e, t, s, n, r, i) {
    "use strict";
    const {
        ArrayIsArray: o,
        ArrayPrototypePush: a,
        Boolean: d,
        FunctionPrototypeBind: u,
        ObjectAssign: h,
        ObjectCreate: c,
        ObjectKeys: l,
        ObjectPrototypeHasOwnProperty: T,
        Proxy: m,
        ReflectApply: S,
        ReflectGetPrototypeOf: f,
        StringPrototypeIncludes: R,
        SafeArrayIterator: w,
        StringPrototypeToLowerCase: g,
        StringPrototypeTrim: p,
        Symbol: H,
      } = i,
      _ = t("internal/assert"),
      E = t("stream"),
      { Readable: y } = E,
      {
        constants: {
          HTTP2_HEADER_AUTHORITY: A,
          HTTP2_HEADER_CONNECTION: b,
          HTTP2_HEADER_METHOD: P,
          HTTP2_HEADER_PATH: C,
          HTTP2_HEADER_SCHEME: v,
          HTTP2_HEADER_STATUS: D,
          HTTP_STATUS_CONTINUE: k,
          HTTP_STATUS_EARLY_HINTS: O,
          HTTP_STATUS_EXPECTATION_FAILED: N,
          HTTP_STATUS_METHOD_NOT_ALLOWED: I,
          HTTP_STATUS_OK: L,
        },
      } = r("http2"),
      {
        codes: {
          ERR_HTTP2_HEADERS_SENT: q,
          ERR_HTTP2_INFO_STATUS_NOT_ALLOWED: M,
          ERR_HTTP2_INVALID_HEADER_VALUE: U,
          ERR_HTTP2_INVALID_STREAM: W,
          ERR_HTTP2_NO_SOCKET_MANIPULATION: x,
          ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED: V,
          ERR_HTTP2_STATUS_INVALID: F,
          ERR_INVALID_ARG_VALUE: j,
          ERR_INVALID_HTTP_TOKEN: K,
          ERR_STREAM_WRITE_AFTER_END: B,
        },
        hideStackFrames: G,
      } = t("internal/errors"),
      {
        validateFunction: Y,
        validateString: X,
        validateLinkHeaderValue: z,
        validateObject: J,
      } = t("internal/validators"),
      {
        kSocket: Q,
        kRequest: Z,
        kProxySocket: $,
        assertValidPseudoHeader: ee,
        getAuthority: te,
      } = t("internal/http2/util"),
      { _checkIsHttpToken: se } = t("_http_common"),
      ne = H("begin-send"),
      re = H("state"),
      ie = H("stream"),
      oe = H("response"),
      ae = H("headers"),
      de = H("rawHeaders"),
      ue = H("trailers"),
      he = H("rawTrailers"),
      ce = H("setHeader"),
      le = H("aborted");
    let Te = !1,
      me = !1;
    const Se = G((e, t) => {
      if ("" === e || "string" != typeof e || R(e, " "))
        throw new K("Header name", e);
      if (
        (function isPseudoHeader(e) {
          switch (e) {
            case D:
            case P:
            case C:
            case A:
            case v:
              return !0;
            default:
              return !1;
          }
        })(e)
      )
        throw new V();
      if (null == t) throw new U(t, e);
      isConnectionHeaderAllowed(e, t) ||
        (function connectionHeaderMessageWarn() {
          !1 === me &&
            (n.emitWarning(
              "The provided connection header is not valid, the value will be dropped from the header and will never be in use.",
              "UnsupportedWarning"
            ),
            (me = !0));
        })();
    });
    function statusMessageWarn() {
      !1 === Te &&
        (n.emitWarning(
          "Status message is not supported by HTTP/2 (RFC7540 8.1.2.4)",
          "UnsupportedWarning"
        ),
        (Te = !0));
    }
    function isConnectionHeaderAllowed(e, t) {
      return e !== b || "trailers" === t;
    }
    function onStreamData(e) {
      const t = this[Z];
      void 0 === t || t.push(e) || this.pause();
    }
    function onStreamTrailers(e, t, s) {
      const n = this[Z];
      void 0 !== n && (h(n[ue], e), a(n[he], ...new w(s)));
    }
    function onStreamEnd() {
      void 0 !== this[Z] && this[Z].push(null);
    }
    function onStreamError(e) {}
    function onRequestPause() {
      this[ie].pause();
    }
    function onRequestResume() {
      this[ie].resume();
    }
    function onStreamDrain() {
      const e = this[oe];
      void 0 !== e && e.emit("drain");
    }
    function onStreamAbortedRequest() {
      const e = this[Z];
      void 0 !== e && !1 === e[re].closed && ((e[le] = !0), e.emit("aborted"));
    }
    function onStreamAbortedResponse() {}
    function resumeStream(e) {
      e.resume();
    }
    const fe = {
      has(e, t) {
        const s = void 0 !== e.session ? e.session[Q] : e;
        return t in e || t in s;
      },
      get(e, t) {
        switch (t) {
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return u(e[t], e);
          case "writable":
          case "destroyed":
            return e[t];
          case "readable": {
            if (e.destroyed) return !1;
            const t = e[Z];
            return t ? t.readable : e.readable;
          }
          case "setTimeout": {
            const t = e.session;
            return void 0 !== t ? u(t.setTimeout, t) : u(e.setTimeout, e);
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new x();
          default: {
            const s = void 0 !== e.session ? e.session[Q] : e,
              n = s[t];
            return "function" == typeof n ? u(n, s) : n;
          }
        }
      },
      getPrototypeOf: (e) => (void 0 !== e.session ? f(e.session[Q]) : f(e)),
      set(e, t, s) {
        switch (t) {
          case "writable":
          case "readable":
          case "destroyed":
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return (e[t] = s), !0;
          case "setTimeout": {
            const t = e.session;
            return void 0 !== t ? (t.setTimeout = s) : (e.setTimeout = s), !0;
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new x();
          default:
            return ((void 0 !== e.session ? e.session[Q] : e)[t] = s), !0;
        }
      },
    };
    function onStreamCloseRequest() {
      const e = this[Z];
      if (void 0 === e) return;
      const t = e[re];
      (t.closed = !0),
        e.push(null),
        t.didRead || e._readableState.resumeScheduled || e.resume(),
        (this[$] = null),
        (this[Z] = void 0),
        e.emit("close");
    }
    function onStreamTimeout(e) {
      return function onStreamTimeout2() {
        this[e].emit("timeout");
      };
    }
    function onStreamTrailersReady() {
      this.sendTrailers(this[oe][ue]);
    }
    function onStreamCloseResponse() {
      const e = this[oe];
      if (void 0 === e) return;
      const t = e[re];
      this.headRequest === t.headRequest &&
        ((t.closed = !0),
        (this[$] = null),
        this.removeListener("wantTrailers", onStreamTrailersReady),
        (this[oe] = void 0),
        e.emit("finish"),
        e.emit("close"));
    }
    class Http2ServerResponse extends E {
      constructor(e, t) {
        super(t),
          (this[re] = {
            closed: !1,
            ending: !1,
            destroyed: !1,
            headRequest: !1,
            sendDate: !0,
            statusCode: L,
          }),
          (this[ae] = c(null)),
          (this[ue] = c(null)),
          (this[ie] = e),
          (e[$] = null),
          (e[oe] = this),
          (this.writable = !0),
          (this.req = e[Z]),
          e.on("drain", onStreamDrain),
          e.on("aborted", onStreamAbortedResponse),
          e.on("close", onStreamCloseResponse),
          e.on("wantTrailers", onStreamTrailersReady),
          e.on("timeout", onStreamTimeout(oe));
      }
      get _header() {
        return this.headersSent;
      }
      get writableEnded() {
        return this[re].ending;
      }
      get finished() {
        return this[re].ending;
      }
      get socket() {
        if (this[re].closed) return;
        const e = this[ie],
          t = e[$];
        return null === t ? (e[$] = new m(e, fe)) : t;
      }
      get connection() {
        return this.socket;
      }
      get stream() {
        return this[ie];
      }
      get headersSent() {
        return this[ie].headersSent;
      }
      get sendDate() {
        return this[re].sendDate;
      }
      set sendDate(e) {
        this[re].sendDate = d(e);
      }
      get statusCode() {
        return this[re].statusCode;
      }
      get writableCorked() {
        return this[ie].writableCorked;
      }
      get writableHighWaterMark() {
        return this[ie].writableHighWaterMark;
      }
      get writableFinished() {
        return this[ie].writableFinished;
      }
      get writableLength() {
        return this[ie].writableLength;
      }
      set statusCode(e) {
        if ((e |= 0) >= 100 && e < 200) throw new M();
        if (e < 100 || e > 599) throw new F(e);
        this[re].statusCode = e;
      }
      setTrailer(e, t) {
        X(e, "name"), (e = g(p(e))), Se(e, t), (this[ue][e] = t);
      }
      addTrailers(e) {
        const t = l(e);
        let s = "";
        for (let n = 0; n < t.length; n++) (s = t[n]), this.setTrailer(s, e[s]);
      }
      getHeader(e) {
        return X(e, "name"), (e = g(p(e))), this[ae][e];
      }
      getHeaderNames() {
        return l(this[ae]);
      }
      getHeaders() {
        const e = c(null);
        return h(e, this[ae]);
      }
      hasHeader(e) {
        return X(e, "name"), (e = g(p(e))), T(this[ae], e);
      }
      removeHeader(e) {
        if ((X(e, "name"), this[ie].headersSent)) throw new q();
        "date" !== (e = g(p(e)))
          ? delete this[ae][e]
          : (this[re].sendDate = !1);
      }
      setHeader(e, t) {
        if ((X(e, "name"), this[ie].headersSent)) throw new q();
        this[ce](e, t);
      }
      [ce](e, t) {
        (e = g(p(e))),
          Se(e, t),
          isConnectionHeaderAllowed(e, t) &&
            (":" === e[0]
              ? ee(e)
              : se(e) || this.destroy(new K("Header name", e)),
            (this[ae][e] = t));
      }
      get statusMessage() {
        return statusMessageWarn(), "";
      }
      set statusMessage(e) {
        statusMessageWarn();
      }
      flushHeaders() {
        const e = this[re];
        e.closed || this[ie].headersSent || this.writeHead(e.statusCode);
      }
      writeHead(e, t, s) {
        const n = this[re];
        if (n.closed || this.stream.destroyed) return this;
        if (this[ie].headersSent) throw new q();
        let r;
        if (
          ("string" == typeof t && statusMessageWarn(),
          void 0 === s && "object" == typeof t && (s = t),
          o(s))
        )
          if (s.length && o(s[0]))
            for (r = 0; r < s.length; r++) {
              const e = s[r];
              this[ce](e[0], e[1]);
            }
          else {
            if (s.length % 2 != 0) throw new j("headers", s);
            for (r = 0; r < s.length; r += 2) this[ce](s[r], s[r + 1]);
          }
        else if ("object" == typeof s) {
          const e = l(s);
          let t = "";
          for (r = 0; r < e.length; r++) (t = e[r]), this[ce](t, s[t]);
        }
        return (n.statusCode = e), this[ne](), this;
      }
      cork() {
        this[ie].cork();
      }
      uncork() {
        this[ie].uncork();
      }
      write(e, t, s) {
        const r = this[re];
        let i;
        if (("function" == typeof t && ((s = t), (t = "utf8")), r.ending))
          i = new B();
        else if (r.closed) i = new W();
        else if (r.destroyed) return !1;
        if (i)
          return (
            "function" == typeof s && n.nextTick(s, i), this.destroy(i), !1
          );
        const o = this[ie];
        return o.headersSent || this.writeHead(r.statusCode), o.write(e, t, s);
      }
      end(e, t, s) {
        const r = this[ie],
          i = this[re];
        return (
          "function" == typeof e
            ? ((s = e), (e = null))
            : "function" == typeof t && ((s = t), (t = "utf8")),
          (i.closed || i.ending) && i.headRequest === r.headRequest
            ? ("function" == typeof s && n.nextTick(s), this)
            : (null != e && this.write(e, t),
              (i.headRequest = r.headRequest),
              (i.ending = !0),
              "function" == typeof s &&
                (r.writableEnded
                  ? this.once("finish", s)
                  : r.once("finish", s)),
              r.headersSent || this.writeHead(this[re].statusCode),
              this[re].closed || r.destroyed
                ? S(onStreamCloseResponse, r, [])
                : r.end(),
              this)
        );
      }
      destroy(e) {
        this[re].destroyed || ((this[re].destroyed = !0), this[ie].destroy(e));
      }
      setTimeout(e, t) {
        this[re].closed || this[ie].setTimeout(e, t);
      }
      createPushResponse(e, t) {
        Y(t, "callback"),
          this[re].closed
            ? n.nextTick(t, new W())
            : this[ie].pushStream(e, {}, (e, s, n, r) => {
                e ? t(e) : t(null, new Http2ServerResponse(s));
              });
      }
      [ne]() {
        const e = this[re],
          t = this[ae];
        t[D] = e.statusCode;
        const s = {
          endStream: e.ending,
          waitForTrailers: !0,
          sendDate: e.sendDate,
        };
        this[ie].respond(t, s);
      }
      writeContinue() {
        const e = this[ie];
        return (
          !e.headersSent &&
          !this[re].closed &&
          (e.additionalHeaders({ [D]: k }), !0)
        );
      }
      writeEarlyHints(e) {
        J(e, "hints");
        const t = c(null),
          s = z(e.link);
        for (const s of l(e)) "link" !== s && (t[s] = e[s]);
        if (0 === s.length) return !1;
        const n = this[ie];
        return (
          !n.headersSent &&
          !this[re].closed &&
          (n.additionalHeaders({ ...t, [D]: O, Link: s }), !0)
        );
      }
    }
    s.exports = {
      onServerStream: function onServerStream(e, t, s, n, r, i) {
        const o = this,
          a = new e(s, n, void 0, i),
          d = new t(s);
        "CONNECT" !== n[P]
          ? void 0 === n.expect
            ? o.emit("request", a, d)
            : "100-continue" === n.expect
            ? o.listenerCount("checkContinue")
              ? o.emit("checkContinue", a, d)
              : (d.writeContinue(), o.emit("request", a, d))
            : o.listenerCount("checkExpectation")
            ? o.emit("checkExpectation", a, d)
            : ((d.statusCode = N), d.end())
          : o.emit("connect", a, d) || ((d.statusCode = I), d.end());
      },
      Http2ServerRequest: class Http2ServerRequest extends y {
        constructor(e, t, s, n) {
          super({ autoDestroy: !1, ...s }),
            (this[re] = { closed: !1, didRead: !1 }),
            (this[ae] = t),
            (this[de] = n),
            (this[ue] = {}),
            (this[he] = []),
            (this[ie] = e),
            (this[le] = !1),
            (e[$] = null),
            (e[Z] = this),
            e.on("trailers", onStreamTrailers),
            e.on("end", onStreamEnd),
            e.on("error", onStreamError),
            e.on("aborted", onStreamAbortedRequest),
            e.on("close", onStreamCloseRequest),
            e.on("timeout", onStreamTimeout(Z)),
            this.on("pause", onRequestPause),
            this.on("resume", onRequestResume);
        }
        get aborted() {
          return this[le];
        }
        get complete() {
          return (
            this[le] ||
            this.readableEnded ||
            this[re].closed ||
            this[ie].destroyed
          );
        }
        get stream() {
          return this[ie];
        }
        get headers() {
          return this[ae];
        }
        get rawHeaders() {
          return this[de];
        }
        get trailers() {
          return this[ue];
        }
        get rawTrailers() {
          return this[he];
        }
        get httpVersionMajor() {
          return 2;
        }
        get httpVersionMinor() {
          return 0;
        }
        get httpVersion() {
          return "2.0";
        }
        get socket() {
          const e = this[ie],
            t = e[$];
          return null === t ? (e[$] = new m(e, fe)) : t;
        }
        get connection() {
          return this.socket;
        }
        _read(e) {
          const t = this[re];
          _(!t.closed),
            t.didRead
              ? n.nextTick(resumeStream, this[ie])
              : ((t.didRead = !0), this[ie].on("data", onStreamData));
        }
        get method() {
          return this[ae][P];
        }
        set method(e) {
          if ((X(e, "method"), "" === p(e))) throw new j("method", e);
          this[ae][P] = e;
        }
        get authority() {
          return te(this[ae]);
        }
        get scheme() {
          return this[ae][v];
        }
        get url() {
          return this[ae][C];
        }
        set url(e) {
          this[ae][C] = e;
        }
        setTimeout(e, t) {
          return this[re].closed || this[ie].setTimeout(e, t), this;
        }
      },
      Http2ServerResponse: Http2ServerResponse,
    };
  },
  "internal/http2/core": function (e, t, s, i, n, o) {
    "use strict";
    const {
        ArrayFrom: r,
        ArrayIsArray: a,
        ArrayPrototypeForEach: d,
        ArrayPrototypePush: h,
        ArrayPrototypeUnshift: c,
        FunctionPrototypeBind: l,
        FunctionPrototypeCall: u,
        MathMin: f,
        ObjectAssign: S,
        ObjectCreate: g,
        ObjectKeys: p,
        ObjectDefineProperty: m,
        ObjectPrototypeHasOwnProperty: T,
        Promise: w,
        PromisePrototypeThen: y,
        Proxy: _,
        ReflectApply: E,
        ReflectGet: b,
        ReflectGetPrototypeOf: R,
        ReflectSet: v,
        RegExpPrototypeExec: H,
        SafeArrayIterator: P,
        SafeMap: O,
        SafeSet: A,
        StringPrototypeSlice: C,
        Symbol: N,
        SymbolDispose: k,
        TypedArrayPrototypeGetLength: I,
        Uint32Array: L,
        Uint8Array: D,
      } = o,
      {
        assertCrypto: F,
        customInspectSymbol: x,
        kEmptyObject: G,
        promisify: j,
      } = t("internal/util");
    F();
    const U = t("assert"),
      M = t("events"),
      z = t("fs"),
      W = t("http"),
      { readUInt16BE: V, readUInt32BE: q } = t("internal/buffer"),
      { URL: B } = t("internal/url"),
      K = t("net"),
      { Duplex: Q } = t("stream"),
      $ = t("tls"),
      { setImmediate: Y, setTimeout: X, clearTimeout: Z } = t("timers"),
      { kIncomingMessage: J, _checkIsHttpToken: ee } = t("_http_common"),
      { kServerResponse: te } = t("_http_server"),
      se = t("internal/js_stream_socket"),
      {
        defaultTriggerAsyncIdScope: ie,
        symbols: { async_id_symbol: ne, owner_symbol: oe },
      } = t("internal/async_hooks"),
      {
        aggregateTwoErrors: re,
        codes: {
          ERR_HTTP2_ALTSVC_INVALID_ORIGIN: ae,
          ERR_HTTP2_ALTSVC_LENGTH: de,
          ERR_HTTP2_CONNECT_AUTHORITY: he,
          ERR_HTTP2_CONNECT_PATH: ce,
          ERR_HTTP2_CONNECT_SCHEME: le,
          ERR_HTTP2_GOAWAY_SESSION: ue,
          ERR_HTTP2_HEADERS_AFTER_RESPOND: fe,
          ERR_HTTP2_HEADERS_SENT: Se,
          ERR_HTTP2_INVALID_INFO_STATUS: ge,
          ERR_HTTP2_INVALID_ORIGIN: pe,
          ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH: me,
          ERR_HTTP2_INVALID_SESSION: Te,
          ERR_HTTP2_INVALID_SETTING_VALUE: we,
          ERR_HTTP2_INVALID_STREAM: ye,
          ERR_HTTP2_MAX_PENDING_SETTINGS_ACK: _e,
          ERR_HTTP2_NESTED_PUSH: Ee,
          ERR_HTTP2_NO_MEM: be,
          ERR_HTTP2_NO_SOCKET_MANIPULATION: Re,
          ERR_HTTP2_ORIGIN_LENGTH: ve,
          ERR_HTTP2_OUT_OF_STREAMS: He,
          ERR_HTTP2_PAYLOAD_FORBIDDEN: Pe,
          ERR_HTTP2_PING_CANCEL: Oe,
          ERR_HTTP2_PING_LENGTH: Ae,
          ERR_HTTP2_PUSH_DISABLED: Ce,
          ERR_HTTP2_SEND_FILE: Ne,
          ERR_HTTP2_SEND_FILE_NOSEEK: ke,
          ERR_HTTP2_SESSION_ERROR: Ie,
          ERR_HTTP2_SETTINGS_CANCEL: Le,
          ERR_HTTP2_SOCKET_BOUND: De,
          ERR_HTTP2_SOCKET_UNBOUND: Fe,
          ERR_HTTP2_STATUS_101: xe,
          ERR_HTTP2_STATUS_INVALID: Ge,
          ERR_HTTP2_STREAM_CANCEL: je,
          ERR_HTTP2_STREAM_ERROR: Ue,
          ERR_HTTP2_STREAM_SELF_DEPENDENCY: Me,
          ERR_HTTP2_TRAILERS_ALREADY_SENT: ze,
          ERR_HTTP2_TRAILERS_NOT_READY: We,
          ERR_HTTP2_UNSUPPORTED_PROTOCOL: Ve,
          ERR_INVALID_ARG_TYPE: qe,
          ERR_INVALID_ARG_VALUE: Be,
          ERR_INVALID_CHAR: Ke,
          ERR_INVALID_HTTP_TOKEN: Qe,
          ERR_OUT_OF_RANGE: $e,
          ERR_SOCKET_CLOSED: Ye,
        },
        hideStackFrames: Xe,
        AbortError: Ze,
      } = t("internal/errors"),
      {
        isUint32: Je,
        validateAbortSignal: et,
        validateBuffer: tt,
        validateFunction: st,
        validateInt32: it,
        validateInteger: nt,
        validateNumber: ot,
        validateString: rt,
        validateUint32: at,
      } = t("internal/validators"),
      dt = t("internal/fs/promises"),
      { utcDate: ht } = t("internal/http"),
      {
        Http2ServerRequest: ct,
        Http2ServerResponse: lt,
        onServerStream: ut,
      } = t("internal/http2/compat"),
      {
        assertIsObject: ft,
        assertValidPseudoHeader: St,
        assertValidPseudoHeaderResponse: gt,
        assertValidPseudoHeaderTrailer: pt,
        assertWithinRange: mt,
        getAuthority: Tt,
        getDefaultSettings: wt,
        getSessionState: yt,
        getSettings: _t,
        getStreamState: Et,
        isPayloadMeaningless: bt,
        kSensitiveHeaders: Rt,
        kSocket: vt,
        kRequest: Ht,
        kProxySocket: Pt,
        mapToHeaders: Ot,
        NghttpError: At,
        sessionName: Ct,
        toHeaderObject: Nt,
        updateOptionsBuffer: kt,
        updateSettingsBuffer: It,
      } = t("internal/http2/util"),
      {
        writeGeneric: Lt,
        writevGeneric: Dt,
        onStreamRead: Ft,
        kAfterAsyncWrite: xt,
        kMaybeDestroy: Gt,
        kUpdateTimer: jt,
        kHandle: Ut,
        kSession: Mt,
        setStreamTimeout: zt,
      } = t("internal/stream_base_commons"),
      { kTimeout: Wt } = t("internal/timers"),
      { isArrayBufferView: Vt } = t("internal/util/types"),
      { format: qt } = t("internal/util/inspect"),
      { FileHandle: Bt } = n("fs"),
      Kt = n("http2"),
      {
        ShutdownWrap: Qt,
        kReadBytesOrError: $t,
        streamBaseState: Yt,
      } = n("stream_wrap"),
      { UV_EOF: Xt } = n("uv"),
      { StreamPipe: Zt } = n("stream_pipe"),
      { _connectionListener: Jt } = W;
    let es = t("internal/util/debuglog").debuglog("http2", (e) => {
      es = e;
    });
    const ts = es.enabled;
    function debugStream(e, t, s, ...i) {
      ts && es("Http2Stream %s [Http2Session %s]: " + s, e, Ct(t), ...new P(i));
    }
    function debugStreamObj(e, t, ...s) {
      const i = e[Mt],
        n = i ? i[As] : void 0;
      debugStream(e[us], n, t, ...new P(s));
    }
    function debugSession(e, t, ...s) {
      es("Http2Session %s: " + t, Ct(e), ...new P(s));
    }
    function debugSessionObj(e, t, ...s) {
      debugSession(e[As], t, ...new P(s));
    }
    const ss = 2 ** 32 - 1,
      is = 2 ** 32 - 1,
      ns = /^[\x09\x20-\x5b\x5d-\x7e\x80-\xff]*$/,
      { constants: os, nameForErrorCode: rs } = Kt,
      as = K.Server,
      ds = $.Server,
      hs = N("alpnProtocol"),
      cs = N("authority"),
      ls = N("encrypted"),
      us = N("id"),
      fs = N("init"),
      Ss = N("sent-info-headers"),
      gs = N("local-settings"),
      ps = N("kNativeFields"),
      ms = N("options"),
      Ts = oe,
      ws = N("origin"),
      ys = N("kPendingRequestCalls"),
      _s = N("proceed"),
      Es = N("protocol"),
      bs = N("remote-settings"),
      Rs = N("select-padding"),
      vs = N("sent-headers"),
      Hs = N("sent-trailers"),
      Ps = N("server"),
      Os = N("state"),
      As = N("type"),
      Cs = N("write-generic"),
      {
        kBitfield: Ns,
        kSessionPriorityListenerCount: ks,
        kSessionFrameErrorListenerCount: Is,
        kSessionMaxInvalidFrames: Ls,
        kSessionMaxRejectedStreams: Ds,
        kSessionUint8FieldCount: Fs,
        kSessionHasRemoteSettingsListeners: xs,
        kSessionRemoteSettingsIsUpToDate: Gs,
        kSessionHasPingListeners: js,
        kSessionHasAltsvcListeners: Us,
      } = Kt,
      {
        NGHTTP2_CANCEL: Ms,
        NGHTTP2_REFUSED_STREAM: zs,
        NGHTTP2_DEFAULT_WEIGHT: Ws,
        NGHTTP2_FLAG_END_STREAM: Vs,
        NGHTTP2_HCAT_PUSH_RESPONSE: qs,
        NGHTTP2_HCAT_RESPONSE: Bs,
        NGHTTP2_INTERNAL_ERROR: Ks,
        NGHTTP2_NO_ERROR: Qs,
        NGHTTP2_SESSION_CLIENT: $s,
        NGHTTP2_SESSION_SERVER: Ys,
        NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE: Xs,
        NGHTTP2_ERR_INVALID_ARGUMENT: Zs,
        NGHTTP2_ERR_STREAM_CLOSED: Js,
        NGHTTP2_ERR_NOMEM: ei,
        HTTP2_HEADER_AUTHORITY: ti,
        HTTP2_HEADER_DATE: si,
        HTTP2_HEADER_METHOD: ii,
        HTTP2_HEADER_PATH: ni,
        HTTP2_HEADER_PROTOCOL: oi,
        HTTP2_HEADER_SCHEME: ri,
        HTTP2_HEADER_STATUS: ai,
        HTTP2_HEADER_CONTENT_LENGTH: di,
        NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: hi,
        NGHTTP2_SETTINGS_ENABLE_PUSH: ci,
        NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: li,
        NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: ui,
        NGHTTP2_SETTINGS_MAX_FRAME_SIZE: fi,
        NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: Si,
        NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL: gi,
        HTTP2_METHOD_GET: pi,
        HTTP2_METHOD_HEAD: mi,
        HTTP2_METHOD_CONNECT: Ti,
        HTTP_STATUS_CONTINUE: wi,
        HTTP_STATUS_RESET_CONTENT: yi,
        HTTP_STATUS_OK: _i,
        HTTP_STATUS_NO_CONTENT: Ei,
        HTTP_STATUS_NOT_MODIFIED: bi,
        HTTP_STATUS_SWITCHING_PROTOCOLS: Ri,
        HTTP_STATUS_MISDIRECTED_REQUEST: vi,
        STREAM_OPTION_EMPTY_PAYLOAD: Hi,
        STREAM_OPTION_GET_TRAILERS: Pi,
      } = os,
      Oi = 2,
      Ai = 4,
      Ci = 16,
      Ni = 32;
    function emit(e, ...t) {
      E(e.emit, e, t);
    }
    function tryClose(e) {
      z.close(e, U.ifError);
    }
    function submitRstStream(e) {
      void 0 !== this[Ut] && this[Ut].rstStream(e);
    }
    function sessionListenerAdded(e) {
      switch (e) {
        case "ping":
          this[ps][Ns] |= 1 << js;
          break;
        case "altsvc":
          this[ps][Ns] |= 1 << Us;
          break;
        case "remoteSettings":
          this[ps][Ns] |= 1 << xs;
          break;
        case "priority":
          this[ps][ks]++;
          break;
        case "frameError":
          this[ps][Is]++;
      }
    }
    function sessionListenerRemoved(e) {
      switch (e) {
        case "ping":
          if (this.listenerCount(e) > 0) return;
          this[ps][Ns] &= ~(1 << js);
          break;
        case "altsvc":
          if (this.listenerCount(e) > 0) return;
          this[ps][Ns] &= ~(1 << Us);
          break;
        case "remoteSettings":
          if (this.listenerCount(e) > 0) return;
          this[ps][Ns] &= ~(1 << xs);
          break;
        case "priority":
          this[ps][ks]--;
          break;
        case "frameError":
          this[ps][Is]--;
      }
    }
    function streamListenerAdded(e) {
      const t = this[Mt];
      if (t)
        switch (e) {
          case "priority":
            t[ps][ks]++;
            break;
          case "frameError":
            t[ps][Is]++;
        }
    }
    function streamListenerRemoved(e) {
      const t = this[Mt];
      if (t)
        switch (e) {
          case "priority":
            t[ps][ks]--;
            break;
          case "frameError":
            t[ps][Is]--;
        }
    }
    function initOriginSet(e) {
      let t = e[Os].originSet;
      if (void 0 === t) {
        const s = e[vt];
        if (((e[Os].originSet = t = new A()), null != s.servername)) {
          let e = `https://${s.servername}`;
          null != s.remotePort && (e += `:${s.remotePort}`),
            t.add(new B(e).origin);
        }
      }
      return t;
    }
    function requestOnConnect(e, t) {
      const s = this[Mt];
      if (void 0 === s || s.destroyed) return;
      if (s.closed) {
        const e = new ue();
        return void this.destroy(e);
      }
      debugSessionObj(s, "connected, initializing request");
      let i = 0;
      t.endStream && (i |= Hi), t.waitForTrailers && (i |= Pi);
      const n = s[Ut].request(e, i, 0 | t.parent, 0 | t.weight, !!t.exclusive);
      if ("number" != typeof n) this[fs](n.id(), n);
      else {
        let e;
        switch (n) {
          case Xs:
            (e = new He()), this.destroy(e);
            break;
          case Zs:
            (e = new Me()), this.destroy(e);
            break;
          default:
            s.destroy(new At(n));
        }
      }
    }
    const ki = Xe((e) => {
      if (void 0 === e.weight) e.weight = Ws;
      else if ("number" != typeof e.weight)
        throw new Be("options.weight", e.weight);
      if (void 0 === e.parent) e.parent = 0;
      else if ("number" != typeof e.parent || e.parent < 0)
        throw new Be("options.parent", e.parent);
      if (void 0 === e.exclusive) e.exclusive = !1;
      else if ("boolean" != typeof e.exclusive)
        throw new Be("options.exclusive", e.exclusive);
      if (void 0 === e.silent) e.silent = !1;
      else if ("boolean" != typeof e.silent)
        throw new Be("options.silent", e.silent);
    });
    function settingsCallback(e, t, s) {
      if ((this[Os].pendingAck--, (this[gs] = void 0), t)) {
        debugSessionObj(this, "settings received");
        const t = this.localSettings;
        "function" == typeof e && e(null, t, s), this.emit("localSettings", t);
      } else
        debugSessionObj(this, "settings canceled"),
          "function" == typeof e && e(new Le());
    }
    function submitSettings(e, t) {
      this.destroyed ||
        (debugSessionObj(this, "submitting settings"),
        this[jt](),
        It(e),
        this[Ut].settings(l(settingsCallback, this, t)) ||
          this.destroy(new _e()));
    }
    function submitPriority(e) {
      this.destroyed ||
        (this[jt](),
        e.parent !== this[us] &&
          this[Ut].priority(
            0 | e.parent,
            0 | e.weight,
            !!e.exclusive,
            !!e.silent
          ));
    }
    function submitGoaway(e, t, s) {
      this.destroyed ||
        (debugSessionObj(this, "submitting goaway"),
        this[jt](),
        this[Ut].goaway(e, t, s));
    }
    const Ii = {
      get(e, t) {
        switch (t) {
          case "setTimeout":
          case "ref":
          case "unref":
            return l(e[t], e);
          case "destroy":
          case "emit":
          case "end":
          case "pause":
          case "read":
          case "resume":
          case "write":
          case "setEncoding":
          case "setKeepAlive":
          case "setNoDelay":
            throw new Re();
          default: {
            const s = e[vt];
            if (void 0 === s) throw new Fe();
            const i = s[t];
            return "function" == typeof i ? l(i, s) : i;
          }
        }
      },
      getPrototypeOf(e) {
        const t = e[vt];
        if (void 0 === t) throw new Fe();
        return R(t);
      },
      set(e, t, s) {
        switch (t) {
          case "setTimeout":
          case "ref":
          case "unref":
            return (e[t] = s), !0;
          case "destroy":
          case "emit":
          case "end":
          case "pause":
          case "read":
          case "resume":
          case "write":
          case "setEncoding":
          case "setKeepAlive":
          case "setNoDelay":
            throw new Re();
          default: {
            const i = e[vt];
            if (void 0 === i) throw new Fe();
            return (i[t] = s), !0;
          }
        }
      },
    };
    const Li = Xe((e) => {
      if (void 0 !== e) {
        if (
          (mt("headerTableSize", e.headerTableSize, 0, ss),
          mt("initialWindowSize", e.initialWindowSize, 0, ss),
          mt("maxFrameSize", e.maxFrameSize, 16384, 16777215),
          mt("maxConcurrentStreams", e.maxConcurrentStreams, 0, is),
          mt("maxHeaderListSize", e.maxHeaderListSize, 0, ss),
          mt("maxHeaderSize", e.maxHeaderSize, 0, ss),
          void 0 !== e.enablePush && "boolean" != typeof e.enablePush)
        )
          throw new we("enablePush", e.enablePush);
        if (
          void 0 !== e.enableConnectProtocol &&
          "boolean" != typeof e.enableConnectProtocol
        )
          throw new we("enableConnectProtocol", e.enableConnectProtocol);
      }
    });
    function trackAssignmentsTypedArray(e) {
      const t = I(e),
        s = new D(t);
      function copyAssigned(i) {
        for (let n = 0; n < t; n++) s[n] && (i[n] = e[n]);
      }
      return new _(e, {
        __proto__: null,
        get: (e, t, s) => ("copyAssigned" === t ? copyAssigned : b(e, t, s)),
        set: (e, t, i) => ("" + +t === t && (s[t] = 1), v(e, t, i)),
      });
    }
    function setupHandle(e, t, s) {
      if (this.destroyed)
        return void i.nextTick(emit, this, "connect", this, e);
      U(
        void 0 !== e._handle,
        "Internal HTTP/2 Failure. The socket is not connected. Please report this as a bug in Node.js"
      ),
        debugSession(t, "setting up session handle"),
        (this[Os].flags |= 1),
        kt(s);
      const n = new Kt.Http2Session(t);
      if (
        ((n[Ts] = this),
        "function" == typeof s.selectPadding && (this[Rs] = s.selectPadding),
        n.consume(e._handle),
        (this[Ut] = n),
        this[ps] && this[ps].copyAssigned(n.fields),
        (this[ps] = n.fields),
        e.encrypted
          ? ((this[hs] = e.alpnProtocol), (this[ls] = !0))
          : ((this[hs] = "h2c"), (this[ls] = !1)),
        Je(s.maxSessionInvalidFrames))
      ) {
        new L(this[ps].buffer, Ls, 1)[0] = s.maxSessionInvalidFrames;
      }
      if (Je(s.maxSessionRejectedStreams)) {
        new L(this[ps].buffer, Ds, 1)[0] = s.maxSessionRejectedStreams;
      }
      const o = "object" == typeof s.settings ? s.settings : {};
      this.settings(o),
        t === Ys && a(s.origins) && E(this.origin, this, s.origins),
        i.nextTick(emit, this, "connect", this, e);
    }
    function emitClose(e, t) {
      t && e.emit("error", t), e.emit("close");
    }
    function finishSessionClose(e, t) {
      debugSessionObj(e, "finishSessionClose");
      const s = e[vt];
      !(function cleanupSession(e) {
        const t = e[vt],
          s = e[Ut];
        (e[Pt] = void 0),
          (e[vt] = void 0),
          (e[Ut] = void 0),
          (e[ps] = trackAssignmentsTypedArray(new D(Fs))),
          s && (s.ondone = null),
          t && ((t[Mt] = void 0), (t[Ps] = void 0));
      })(e),
        s && !s.destroyed
          ? (s.on("close", () => {
              emitClose(e, t);
            }),
            e.closed && s.resume(),
            s.end((i) => {
              debugSessionObj(e, "finishSessionClose socket end", i, t),
                e.closed ||
                  Y(() => {
                    s.destroy(t);
                  });
            }))
          : i.nextTick(emitClose, e, t);
    }
    class Http2Session extends M {
      constructor(e, t, s) {
        if (
          (super(),
          (s._handle && s._handle.isStreamBase) || (s = new se(s)),
          s.on("error", socketOnError),
          s.on("close", socketOnClose),
          void 0 !== s[Mt])
        )
          throw new De();
        (s[Mt] = this),
          (this[Os] = {
            destroyCode: Qs,
            flags: 0,
            goawayCode: null,
            goawayLastStreamID: null,
            streams: new O(),
            pendingStreams: new A(),
            pendingAck: 0,
            shutdownWritableCalled: !1,
            writeQueueSize: 0,
            originSet: void 0,
          }),
          (this[ls] = void 0),
          (this[hs] = void 0),
          (this[As] = e),
          (this[Pt] = null),
          (this[vt] = s),
          (this[Wt] = null),
          (this[Ut] = void 0),
          "function" == typeof s.setNoDelay && s.setNoDelay(),
          "function" == typeof s.disableRenegotiation &&
            s.disableRenegotiation();
        const n = l(setupHandle, this, s, e, t);
        if (s.connecting || s.secureConnecting) {
          const e = s instanceof $.TLSSocket ? "secureConnect" : "connect";
          s.once(e, () => {
            try {
              n();
            } catch (e) {
              s.destroy(e);
            }
          });
        } else n();
        this[ps] || (this[ps] = trackAssignmentsTypedArray(new D(Fs))),
          this.on("newListener", sessionListenerAdded),
          this.on("removeListener", sessionListenerRemoved),
          i.nextTick(() => {
            if (s.readableLength) {
              let t;
              for (; null !== (t = s.read()); )
                debugSession(e, `${t.length} bytes already in buffer`),
                  this[Ut].receive(t);
            }
          }),
          debugSession(e, "created");
      }
      get encrypted() {
        return this[ls];
      }
      get alpnProtocol() {
        return this[hs];
      }
      get originSet() {
        if (this.encrypted && !this.destroyed) return r(initOriginSet(this));
      }
      get connecting() {
        return 0 == (1 & this[Os].flags);
      }
      get closed() {
        return !!(2 & this[Os].flags);
      }
      get destroyed() {
        return !!(4 & this[Os].flags);
      }
      [jt]() {
        this.destroyed || (this[Wt] && this[Wt].refresh());
      }
      setNextStreamID(e) {
        if (this.destroyed) throw new Te();
        if ((ot(e, "id"), e <= 0 || e > is))
          throw new $e("id", "> 0 and <= 4294967295", e);
        this[Ut].setNextStreamID(e);
      }
      setLocalWindowSize(e) {
        if (this.destroyed) throw new Te();
        it(e, "windowSize", 0);
        this[Ut].setLocalWindowSize(e) === ei && this.destroy(new be());
      }
      ping(e, t) {
        if (this.destroyed) throw new Te();
        if (
          ("function" == typeof e && ((t = e), (e = void 0)),
          e && tt(e, "payload"),
          e && 8 !== e.length)
        )
          throw new Ae();
        st(t, "callback");
        const s = (function pingCallback(e) {
          return function pingCallback2(t, s, i) {
            t ? e(null, s, i) : e(new Oe());
          };
        })(t);
        if (!this.connecting && !this.closed) return this[Ut].ping(e, s);
        i.nextTick(s, !1, 0, e);
      }
      [x](e, t) {
        if ("number" == typeof e && e < 0) return this;
        const s = {
          type: this[As],
          closed: this.closed,
          destroyed: this.destroyed,
          state: this.state,
          localSettings: this.localSettings,
          remoteSettings: this.remoteSettings,
        };
        return `Http2Session ${qt(s)}`;
      }
      get socket() {
        const e = this[Pt];
        return null === e ? (this[Pt] = new _(this, Ii)) : e;
      }
      get type() {
        return this[As];
      }
      get goawayCode() {
        return this[Os].goawayCode || Qs;
      }
      get goawayLastStreamID() {
        return this[Os].goawayLastStreamID || 0;
      }
      get pendingSettingsAck() {
        return this[Os].pendingAck > 0;
      }
      get state() {
        return this.connecting || this.destroyed ? {} : yt(this[Ut]);
      }
      get localSettings() {
        const e = this[gs];
        return void 0 !== e
          ? e
          : this.destroyed || this.connecting
          ? {}
          : (this[gs] = _t(this[Ut], !1));
      }
      get remoteSettings() {
        if (this[ps][Ns] & (1 << Gs)) {
          const e = this[bs];
          if (void 0 !== e) return e;
        }
        return this.destroyed || this.connecting
          ? {}
          : ((this[ps][Ns] |= 1 << Gs), (this[bs] = _t(this[Ut], !0)));
      }
      settings(e, t) {
        if (this.destroyed) throw new Te();
        ft(e, "settings"),
          Li(e),
          t && st(t, "callback"),
          debugSessionObj(this, "sending settings"),
          this[Os].pendingAck++;
        const s = l(submitSettings, this, { ...e }, t);
        this.connecting ? this.once("connect", s) : s();
      }
      goaway(e = Qs, t = 0, s) {
        if (this.destroyed) throw new Te();
        void 0 !== s && tt(s, "opaqueData"),
          ot(e, "code"),
          ot(t, "lastStreamID");
        const i = l(submitGoaway, this, e, t, s);
        this.connecting ? this.once("connect", i) : i();
      }
      destroy(e = Qs, t) {
        this.destroyed ||
          (debugSessionObj(this, "destroying"),
          "number" == typeof e && (e = (t = e) !== Qs ? new Ie(t) : void 0),
          void 0 === t && null != e && (t = Ks),
          (function closeSession(e, t, s) {
            debugSessionObj(e, "start closing/destroying", s);
            const i = e[Os];
            if (
              ((i.flags |= 4),
              (i.destroyCode = t),
              e.setTimeout(0),
              e.removeAllListeners("timeout"),
              i.pendingStreams.size > 0 || i.streams.size > 0)
            ) {
              const e = new je(s);
              i.pendingStreams.forEach((t) => t.destroy(e)),
                i.streams.forEach((e) => e.destroy(s));
            }
            const n = e[vt],
              o = e[Ut];
            void 0 !== o
              ? ((o.ondone = l(finishSessionClose, null, e, s)),
                o.destroy(t, n.destroyed))
              : finishSessionClose(e, s);
          })(this, t, e));
      }
      close(e) {
        this.closed ||
          this.destroyed ||
          (debugSessionObj(this, "marking session closed"),
          (this[Os].flags |= 2),
          "function" == typeof e && this.once("close", e),
          this.goaway(),
          this[Gt]());
      }
      [M.captureRejectionSymbol](e, t, ...s) {
        switch (t) {
          case "stream":
            s[0].destroy(e);
            break;
          default:
            this.destroy(e);
        }
      }
      [Gt](e) {
        if (null == e) {
          const e = this[Os];
          if (!this.closed || e.streams.size > 0 || e.pendingStreams.size > 0)
            return;
        }
        this.destroy(e);
      }
      _onTimeout() {
        callTimeout(this);
      }
      ref() {
        this[vt] && this[vt].ref();
      }
      unref() {
        this[vt] && this[vt].unref();
      }
    }
    class ServerHttp2Session extends Http2Session {
      constructor(e, t, s) {
        super(Ys, e, t),
          (this[Ps] = s),
          (this[ps][ks] = s.listenerCount("priority"));
      }
      get server() {
        return this[Ps];
      }
      altsvc(e, t) {
        if (this.destroyed) throw new Te();
        let s,
          i = 0;
        if ("string" == typeof t) {
          if (((s = new B(t).origin), "null" === s)) throw new ae();
        } else if ("number" == typeof t) {
          if (t >>> 0 !== t || 0 === t)
            throw new $e("originOrStream", `> 0 && < ${2 ** 32}`, t);
          i = t;
        } else if (void 0 !== t) {
          if (
            (null !== t && "object" == typeof t && (s = t.origin),
            "string" != typeof s)
          )
            throw new qe(
              "originOrStream",
              ["string", "number", "URL", "object"],
              t
            );
          if ("null" === s || 0 === s.length) throw new ae();
        }
        if ((rt(e, "alt"), null === H(ns, e))) throw new Ke("alt");
        if (e.length + (void 0 !== s ? s.length : 0) > 16382) throw new de();
        this[Ut].altsvc(i, s || "", e);
      }
      origin(...e) {
        if (this.destroyed) throw new Te();
        if (0 === e.length) return;
        let t = "",
          s = 0;
        const i = e.length;
        for (let n = 0; n < i; n++) {
          let i = e[n];
          if (
            ("string" == typeof i
              ? (i = new B(i).origin)
              : null != i && "object" == typeof i && (i = i.origin),
            rt(i, "origin"),
            "null" === i)
          )
            throw new pe();
          (t += `${i}\0`), (s += i.length);
        }
        if (s > 16382) throw new ve();
        this[Ut].origin(t, i);
      }
    }
    class ClientHttp2Session extends Http2Session {
      constructor(e, t) {
        super($s, e, t), (this[ys] = null);
      }
      request(e, t) {
        if ((debugSessionObj(this, "initiating request"), this.destroyed))
          throw new Te();
        if (this.closed) throw new ue();
        if ((this[jt](), null != e)) {
          const t = p(e);
          for (let e = 0; e < t.length; e++) {
            const s = t[e];
            ":" === s[0]
              ? St(s)
              : s && !ee(s) && this.destroy(new Qe("Header name", s));
          }
        }
        ft(e, "headers"),
          ft(t, "options"),
          (e = S(g(null), e)),
          (t = { ...t }),
          void 0 === e[ii] && (e[ii] = pi);
        if (e[ii] === Ti && void 0 === e[oi]) {
          if (void 0 === e[ti]) throw new he();
          if (void 0 !== e[ri]) throw new le();
          if (void 0 !== e[ni]) throw new ce();
        } else
          void 0 === Tt(e) && (e[ti] = this[cs]),
            void 0 === e[ri] && (e[ri] = C(this[Es], 0, -1)),
            void 0 === e[ni] && (e[ni] = "/");
        if ((ki(t), void 0 === t.endStream)) t.endStream = bt(e[ii]);
        else if ("boolean" != typeof t.endStream)
          throw new Be("options.endStream", t.endStream);
        const s = Ot(e),
          i = new ClientHttp2Stream(this, void 0, void 0, {});
        (i[vs] = e),
          (i[ws] = `${e[ri]}://${Tt(e)}`),
          t.endStream && i.end(),
          t.waitForTrailers && (i[Os].flags |= Ni);
        const { signal: n } = t;
        if (n) {
          et(n, "options.signal");
          const aborter = () => {
            i.destroy(new Ze(void 0, { cause: n.reason }));
          };
          if (n.aborted) aborter();
          else {
            const e = M.addAbortListener(n, aborter);
            i.once("close", e[k]);
          }
        }
        const o = l(requestOnConnect, i, s, t);
        return (
          this.connecting
            ? null !== this[ys]
              ? h(this[ys], o)
              : ((this[ys] = [o]),
                this.once("connect", () => {
                  d(this[ys], (e) => e()), (this[ys] = null);
                }))
            : o(),
          i
        );
      }
    }
    function trackWriteState(e, t) {
      const s = e[Mt];
      (e[Os].writeQueueSize += t),
        (s[Os].writeQueueSize += t),
        (s[Ut].chunksSentSinceLastWrite = 0);
    }
    function streamOnResume() {
      this.destroyed || this[Ut].readStart();
    }
    function streamOnPause() {
      this.destroyed || this.pending || this[Ut].readStop();
    }
    function afterShutdown(e) {
      const t = this.handle[Ts];
      t &&
        t.on("finish", () => {
          t[Gt]();
        }),
        this.callback();
    }
    function shutdownWritable(e) {
      const t = this[Ut];
      if (!t) return e();
      const s = this[Os];
      if (s.shutdownWritableCalled)
        return debugStreamObj(this, "shutdownWritable() already called"), e();
      s.shutdownWritableCalled = !0;
      const i = new Qt();
      (i.oncomplete = afterShutdown), (i.callback = e), (i.handle = t);
      return 1 === t.shutdown(i) ? E(afterShutdown, i, [0]) : void 0;
    }
    function finishSendTrailers(e, t) {
      if (e.destroyed) return;
      e[Os].flags &= -33;
      const s = e[Ut].trailers(t);
      s < 0 ? e.destroy(new At(s)) : e[Gt]();
    }
    const Di = 0,
      Fi = 1,
      xi = 2;
    function closeStream(e, t, s = Fi) {
      const i = e[Os];
      (i.flags |= Oi),
        (i.rstCode = t),
        e.setTimeout(0),
        e.removeAllListeners("timeout");
      const { ending: n } = e._writableState;
      if (
        (n || (e.aborted || ((i.flags |= Ci), e.emit("aborted")), e.end()),
        s !== Di)
      ) {
        const i = l(finishCloseStream, e, t);
        !n || e.writableFinished || t !== Qs || s === xi
          ? i()
          : e.once("finish", i);
      }
    }
    function finishCloseStream(e) {
      const t = l(submitRstStream, this, e);
      if (this.pending) return this.push(null), void this.once("ready", t);
      t();
    }
    class Http2Stream extends Q {
      constructor(e, t) {
        (t.allowHalfOpen = !0),
          (t.decodeStrings = !1),
          (t.autoDestroy = !1),
          super(t),
          (this[ne] = -1),
          this.cork(),
          (this[Mt] = e),
          e[Os].pendingStreams.add(this),
          (this._readableState.readingMore = !0),
          (this[Wt] = null),
          (this[Os] = {
            didRead: !1,
            flags: 0,
            rstCode: Qs,
            writeQueueSize: 0,
            trailersReady: !1,
            endAfterHeaders: !1,
          }),
          (this[Ht] = null),
          (this[Pt] = null),
          this.on("pause", streamOnPause),
          this.on("newListener", streamListenerAdded),
          this.on("removeListener", streamListenerRemoved);
      }
      [jt]() {
        this.destroyed ||
          (this[Wt] && this[Wt].refresh(), this[Mt] && this[Mt][jt]());
      }
      [fs](e, t) {
        this[Os].flags |= 1;
        const s = this[Mt];
        s[Os].pendingStreams.delete(this),
          s[Os].streams.set(e, this),
          (this[us] = e),
          (this[ne] = t.getAsyncId()),
          (t[Ts] = this),
          (this[Ut] = t),
          (t.onread = Ft),
          this.uncork(),
          this.emit("ready");
      }
      [x](e, t) {
        if ("number" == typeof e && e < 0) return this;
        const s = {
          id: this[us] || "<pending>",
          closed: this.closed,
          destroyed: this.destroyed,
          state: this.state,
          readableState: this._readableState,
          writableState: this._writableState,
        };
        return `Http2Stream ${qt(s)}`;
      }
      get bufferSize() {
        return this[Os].writeQueueSize + this.writableLength;
      }
      get endAfterHeaders() {
        return this[Os].endAfterHeaders;
      }
      get sentHeaders() {
        return this[vs];
      }
      get sentTrailers() {
        return this[Hs];
      }
      get sentInfoHeaders() {
        return this[Ss];
      }
      get pending() {
        return void 0 === this[us];
      }
      get id() {
        return this[us];
      }
      get session() {
        return this[Mt];
      }
      _onTimeout() {
        callTimeout(this, Mt);
      }
      get headersSent() {
        return !!(this[Os].flags & Ai);
      }
      get aborted() {
        return !!(this[Os].flags & Ci);
      }
      get headRequest() {
        return !!(8 & this[Os].flags);
      }
      get rstCode() {
        return this[Os].rstCode;
      }
      get state() {
        const e = this[us];
        return this.destroyed || void 0 === e ? {} : Et(this[Ut], e);
      }
      [_s]() {
        U.fail(
          "Implementors MUST implement this. Please report this as a bug in Node.js"
        );
      }
      [xt]({ bytes: e }) {
        (this[Os].writeQueueSize -= e),
          void 0 !== this.session && (this.session[Os].writeQueueSize -= e);
      }
      [Cs](e, t, s, n) {
        if (this.pending)
          return void this.once("ready", l(this[Cs], this, e, t, s, n));
        if (this.destroyed) return;
        let o;
        this[jt](), this.headersSent || this[_s]();
        let r,
          a,
          d = !0,
          h = !0;
        const done = () => {
            if (h || d) return;
            const e = re(a, r);
            e && this.destroy(e), n(e);
          },
          writeCallback = (e) => {
            (d = !1), (r = e), done();
          },
          endCheckCallback = (e) => {
            (h = !1), (a = e), done();
          };
        i.nextTick(() => {
          if (
            r ||
            !this._writableState.ending ||
            this._writableState.buffered.length ||
            this[Os].flags & Ni
          )
            return endCheckCallback();
          debugStreamObj(this, "shutting down writable on last write"),
            shutdownWritable.call(this, endCheckCallback);
        }),
          (o = e ? Dt(this, t, writeCallback) : Lt(this, t, s, writeCallback)),
          trackWriteState(this, o.bytes);
      }
      _write(e, t, s) {
        this[Cs](!1, e, t, s);
      }
      _writev(e, t) {
        this[Cs](!0, e, "", t);
      }
      _final(e) {
        this.pending
          ? this.once("ready", () => this._final(e))
          : (debugStreamObj(this, "shutting down writable on _final"),
            E(shutdownWritable, this, [e]));
      }
      _read(e) {
        this.destroyed
          ? this.push(null)
          : (this[Os].didRead ||
              ((this._readableState.readingMore = !1), (this[Os].didRead = !0)),
            this.pending
              ? this.once("ready", streamOnResume)
              : u(streamOnResume, this));
      }
      priority(e) {
        if (this.destroyed) throw new ye();
        ft(e, "options"), (e = { ...e }), ki(e);
        const t = l(submitPriority, this, e);
        this.pending ? this.once("ready", t) : t();
      }
      sendTrailers(e) {
        if (this.destroyed || this.closed) throw new ye();
        if (this[Hs]) throw new ze();
        if (!this[Os].trailersReady) throw new We();
        ft(e, "headers"),
          (e = S(g(null), e)),
          debugStreamObj(this, "sending trailers"),
          this[jt]();
        const t = Ot(e, pt);
        (this[Hs] = e), Y(finishSendTrailers, this, t);
      }
      get closed() {
        return !!(this[Os].flags & Oi);
      }
      close(e = Qs, t) {
        nt(e, "code", 0, ss),
          void 0 !== t && st(t, "callback"),
          this.closed ||
            (void 0 !== t && this.once("close", t), closeStream(this, e));
      }
      _destroy(e, t) {
        const s = this[Mt],
          i = this[Ut],
          n = this[us];
        debugStream(this[us] || "pending", s[As], "destroying stream");
        const o = this[Os],
          r = s[Os],
          a = r.goawayCode || r.destroyCode;
        let d = this.closed ? this.rstCode : a;
        null != e && (d = a || (e instanceof Ze ? Ms : Ks));
        const h = void 0 !== i;
        this.closed || closeStream(this, d, h ? xi : Di),
          this.push(null),
          h
            ? (i.destroy(), r.streams.delete(n))
            : r.pendingStreams.delete(this),
          (r.writeQueueSize -= o.writeQueueSize),
          (o.writeQueueSize = 0),
          null == e && d !== Qs && d !== Ms && (e = new Ue(rs[d] || d)),
          (this[Mt] = void 0),
          (this[Ut] = void 0),
          s[Gt](),
          t(e);
      }
      [Gt](e = Qs) {
        if (e === Qs) {
          if (this.writableFinished) {
            if (!this.readable && this.closed) return void this.destroy();
            const e = this[Os];
            !this.headersSent ||
              !this[Mt] ||
              this[Mt][As] !== Ys ||
              e.flags & Ni ||
              e.didRead ||
              null !== this.readableFlowing ||
              Y(callStreamClose, this);
          }
        } else this.destroy();
      }
    }
    function callTimeout(e, t) {
      if (!e.destroyed) {
        if (e[Os].writeQueueSize > 0) {
          const s = t ? e[t][Ut] : e[Ut],
            i = void 0 !== s ? s.chunksSentSinceLastWrite : null;
          if (null !== i && i !== s.updateChunksSent()) return void e[jt]();
        }
        e.emit("timeout");
      }
    }
    function callStreamClose(e) {
      e.close();
    }
    function processHeaders(e, t) {
      ft(e, "headers");
      const s = g(null);
      if (null != e) {
        for (const t in e) T(e, t) && (s[t] = e[t]);
        s[Rt] = e[Rt];
      }
      const i = (s[ai] = 0 | s[ai] || _i);
      if (
        ((null == t.sendDate || t.sendDate) &&
          ((null !== s[si] && void 0 !== s[si]) || (s[si] = ht())),
        i < 200 || i > 599)
      )
        throw new Ge(s[ai]);
      const n = s[Rt];
      if (void 0 !== n && !a(n)) throw new Be("headers[http2.neverIndex]", n);
      return s;
    }
    function onFileUnpipe() {
      const e = this.sink[Ts];
      e.ownsFd
        ? y(this.source.close(), void 0, l(e.destroy, e))
        : this.source.releaseFD();
    }
    function onPipedFileHandleRead() {
      const e = Yt[$t];
      e < 0 && e !== Xt && this.stream.close(Ks);
    }
    function processRespondWithFD(e, t, s, i = 0, n = -1, o = 0) {
      let r;
      e[Os].flags |= Ai;
      try {
        r = Ot(s, gt);
      } catch (t) {
        return void e.destroy(t);
      }
      (e[vs] = s), (e._final = null), e.end();
      const a = e[Ut].respond(r, o);
      a < 0 ? e.destroy(new At(a)) : ie(e[ne], startFilePipe, e, t, i, n);
    }
    function startFilePipe(e, t, s, i) {
      const n = new Bt(t, s, i);
      (n.onread = onPipedFileHandleRead), (n.stream = e);
      const o = new Zt(n, e[Ut]);
      (o.onunpipe = onFileUnpipe), o.start(), trackWriteState(e, 1);
    }
    function doSendFD(e, t, s, i, n, o, r) {
      if (o) return void this.destroy(o);
      if (this.destroyed || this.closed) return void this.destroy(new ye());
      const a = {
        offset: void 0 !== t.offset ? t.offset : 0,
        length: void 0 !== t.length ? t.length : -1,
      };
      ("function" == typeof t.statCheck &&
        !1 === E(t.statCheck, this, [r, i, a])) ||
        this[Os].flags & Ai ||
        processRespondWithFD(this, s, i, 0 | a.offset, 0 | a.length, n);
    }
    function doSendFileFD(e, t, s, i, n, o, r) {
      const a = t.onError;
      if (o) return tryClose(s), void (a ? a(o) : this.destroy(o));
      if (!r.isFile()) {
        const e = r.isDirectory();
        if (
          void 0 !== t.offset ||
          t.offset > 0 ||
          void 0 !== t.length ||
          t.length >= 0 ||
          e
        ) {
          const t = e ? new Ne() : new ke();
          return tryClose(s), void (a ? a(t) : this.destroy(t));
        }
        (t.offset = -1), (t.length = -1);
      }
      if (this.destroyed || this.closed)
        return tryClose(s), void this.destroy(new ye());
      const d = {
        offset: void 0 !== t.offset ? t.offset : 0,
        length: void 0 !== t.length ? t.length : -1,
      };
      ("function" == typeof t.statCheck &&
        !1 === E(t.statCheck, this, [r, i])) ||
      this[Os].flags & Ai
        ? tryClose(s)
        : (r.isFile() &&
            ((d.length =
              d.length < 0
                ? r.size - +d.offset
                : f(r.size - +d.offset, d.length)),
            (i[di] = d.length)),
          processRespondWithFD(this, s, i, 0 | t.offset, 0 | d.length, n));
    }
    function afterOpen(e, t, s, i, n, o) {
      const r = this[Os],
        a = t.onError;
      n
        ? a
          ? a(n)
          : this.destroy(n)
        : this.destroyed || this.closed
        ? tryClose(o)
        : ((r.fd = o), z.fstat(o, l(doSendFileFD, this, e, t, o, s, i)));
    }
    class ServerHttp2Stream extends Http2Stream {
      constructor(e, t, s, i, n) {
        super(e, i),
          (t.owner = this),
          this[fs](s, t),
          (this[Es] = n[ri]),
          (this[cs] = Tt(n));
      }
      get pushAllowed() {
        return (
          !this.destroyed &&
          !this.closed &&
          !this.session.closed &&
          !this.session.destroyed &&
          this[Mt].remoteSettings.enablePush
        );
      }
      pushStream(e, t, s) {
        if (!this.pushAllowed) throw new Ce();
        if (this[us] % 2 == 0) throw new Ee();
        const n = this[Mt];
        debugStreamObj(this, "initiating push stream"),
          this[jt](),
          "function" == typeof t && ((s = t), (t = void 0)),
          st(s, "callback"),
          ft(t, "options"),
          ((t = { ...t }).endStream = !!t.endStream),
          ft(e, "headers"),
          void 0 === (e = S(g(null), e))[ii] && (e[ii] = pi),
          void 0 === Tt(e) && (e[ti] = this[cs]),
          void 0 === e[ri] && (e[ri] = this[Es]),
          void 0 === e[ni] && (e[ni] = "/");
        let o = !1;
        e[ii] === mi && (o = t.endStream = !0);
        const r = Ot(e),
          a = t.endStream ? Hi : 0,
          d = this[Ut].pushPromise(r, a);
        let h;
        if ("number" == typeof d) {
          switch (d) {
            case Xs:
              h = new He();
              break;
            case Js:
              h = new ye();
              break;
            default:
              h = new At(d);
          }
          return void i.nextTick(s, h);
        }
        const c = d.id(),
          l = new ServerHttp2Stream(n, d, c, t, e);
        (l[vs] = e),
          l.push(null),
          t.endStream && l.end(),
          o && (l[Os].flags |= 8),
          i.nextTick(s, null, l, e, 0);
      }
      respond(e, t) {
        if (this.destroyed || this.closed) throw new ye();
        if (this.headersSent) throw new Se();
        const s = this[Os];
        ft(t, "options"),
          (t = { ...t }),
          debugStreamObj(this, "initiating response"),
          this[jt](),
          (t.endStream = !!t.endStream);
        let i = 0;
        t.endStream && (i |= Hi),
          t.waitForTrailers && ((i |= Pi), (s.flags |= Ni)),
          (e = processHeaders(e, t));
        const n = Ot(e, gt);
        (this[vs] = e), (s.flags |= Ai);
        const o = 0 | e[ai];
        (t.endStream ||
          o === Ei ||
          o === yi ||
          o === bi ||
          !0 === this.headRequest) &&
          ((t.endStream = !0), this.end());
        const r = this[Ut].respond(n, i);
        r < 0 && this.destroy(new At(r));
      }
      respondWithFD(e, t, s) {
        if (this.destroyed || this.closed) throw new ye();
        if (this.headersSent) throw new Se();
        const i = this[Mt];
        if (
          (ft(s, "options"),
          void 0 !== (s = { ...s }).offset && "number" != typeof s.offset)
        )
          throw new Be("options.offset", s.offset);
        if (void 0 !== s.length && "number" != typeof s.length)
          throw new Be("options.length", s.length);
        if (void 0 !== s.statCheck && "function" != typeof s.statCheck)
          throw new Be("options.statCheck", s.statCheck);
        let n = 0;
        if (
          (s.waitForTrailers && ((n |= Pi), (this[Os].flags |= Ni)),
          e instanceof dt.FileHandle)
        )
          e = e.fd;
        else if ("number" != typeof e)
          throw new qe("fd", ["number", "FileHandle"], e);
        debugStreamObj(this, "initiating response from fd"),
          this[jt](),
          (this.ownsFd = !1);
        const o = ((t = processHeaders(t, s))[ai] |= 0);
        if (o === Ei || o === yi || o === bi || this.headRequest)
          throw new Pe(o);
        void 0 === s.statCheck
          ? processRespondWithFD(this, e, t, s.offset, s.length, n)
          : z.fstat(e, l(doSendFD, this, i, s, e, t, n));
      }
      respondWithFile(e, t, s) {
        if (this.destroyed || this.closed) throw new ye();
        if (this.headersSent) throw new Se();
        if (
          (ft(s, "options"),
          void 0 !== (s = { ...s }).offset && "number" != typeof s.offset)
        )
          throw new Be("options.offset", s.offset);
        if (void 0 !== s.length && "number" != typeof s.length)
          throw new Be("options.length", s.length);
        if (void 0 !== s.statCheck && "function" != typeof s.statCheck)
          throw new Be("options.statCheck", s.statCheck);
        let i = 0;
        s.waitForTrailers && ((i |= Pi), (this[Os].flags |= Ni));
        const n = this[Mt];
        debugStreamObj(this, "initiating response from file"),
          this[jt](),
          (this.ownsFd = !0);
        const o = ((t = processHeaders(t, s))[ai] |= 0);
        if (o === Ei || o === yi || o === bi || this.headRequest)
          throw new Pe(o);
        z.open(e, "r", l(afterOpen, this, n, s, t, i));
      }
      additionalHeaders(e) {
        if (this.destroyed || this.closed) throw new ye();
        if (this.headersSent) throw new fe();
        if (
          (ft(e, "headers"),
          (e = S(g(null), e)),
          debugStreamObj(this, "sending additional headers"),
          null != e[ai])
        ) {
          const t = (e[ai] |= 0);
          if (t === Ri) throw new xe();
          if (t < 100 || t >= 200) throw new ge(e[ai]);
        }
        this[jt]();
        const t = Ot(e, gt);
        this[Ss] ? h(this[Ss], e) : (this[Ss] = [e]);
        const s = this[Ut].info(t);
        s < 0 && this.destroy(new At(s));
      }
    }
    ServerHttp2Stream.prototype[_s] = ServerHttp2Stream.prototype.respond;
    class ClientHttp2Stream extends Http2Stream {
      constructor(e, t, s, i) {
        super(e, i),
          (this[Os].flags |= Ai),
          void 0 !== s && this[fs](s, t),
          this.on("headers", handleHeaderContinue);
      }
    }
    function handleHeaderContinue(e) {
      e[ai] === wi && this.emit("continue");
    }
    const Gi = { configurable: !0, enumerable: !0, writable: !0, value: zt };
    function socketOnError(e) {
      const t = this[Mt];
      if (void 0 !== t) {
        if ("ECONNRESET" === e.code && null !== t[Os].goawayCode)
          return t.destroy();
        debugSessionObj(this, "socket error [%s]", e.message), t.destroy(e);
      }
    }
    function sessionOnStream(e, t, s, i) {
      void 0 !== this[Ps] && this[Ps].emit("stream", e, t, s, i);
    }
    function sessionOnPriority(e, t, s, i) {
      void 0 !== this[Ps] && this[Ps].emit("priority", e, t, s, i);
    }
    function sessionOnError(e) {
      void 0 !== this[Ps] && this[Ps].emit("sessionError", e, this);
    }
    function sessionOnTimeout() {
      if (this.destroyed || this.closed) return;
      this[Ps].emit("timeout", this) || this.destroy();
    }
    function connectionListener(e) {
      es("Http2Session server: received a connection");
      const t = this[ms] || {};
      if (!1 === e.alpnProtocol || "http/1.1" === e.alpnProtocol) {
        if (!0 === t.allowHTTP1)
          return (
            (e.server[J] = t.Http1IncomingMessage),
            (e.server[te] = t.Http1ServerResponse),
            u(Jt, this, e)
          );
        if (
          (es("Unknown protocol from %s:%s", e.remoteAddress, e.remotePort),
          !this.emit("unknownProtocol", e))
        ) {
          es("Unknown protocol timeout:  %s", t.unknownProtocolTimeout);
          const s = X(() => {
            e.destroyed ||
              (es("UnknownProtocol socket timeout, destroy socket"),
              e.destroy());
          }, t.unknownProtocolTimeout);
          s.unref(),
            e.once("close", () => Z(s)),
            e.end(
              "HTTP/1.0 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nUnknown ALPN Protocol, expected `h2` to be available.\nIf this is a HTTP request: The server was not configured with the `allowHTTP1` option or a listener for the `unknownProtocol` event.\n"
            );
        }
        return;
      }
      const s = new ServerHttp2Session(t, e, this);
      s.on("stream", sessionOnStream),
        s.on("error", sessionOnError),
        s.on("priority", sessionOnPriority),
        s[ps][ks]--,
        this.timeout && s.setTimeout(this.timeout, sessionOnTimeout),
        (e[Ps] = this),
        this.emit("session", s);
    }
    function initializeOptions(e) {
      return (
        ft(e, "options"),
        (e = { ...e }),
        ft(e.settings, "options.settings"),
        (e.settings = { ...e.settings }),
        void 0 !== e.maxSessionInvalidFrames &&
          at(e.maxSessionInvalidFrames, "maxSessionInvalidFrames"),
        void 0 !== e.maxSessionRejectedStreams &&
          at(e.maxSessionRejectedStreams, "maxSessionRejectedStreams"),
        void 0 !== e.unknownProtocolTimeout
          ? at(e.unknownProtocolTimeout, "unknownProtocolTimeout")
          : (e.unknownProtocolTimeout = 1e4),
        (e.Http1IncomingMessage = e.Http1IncomingMessage || W.IncomingMessage),
        (e.Http1ServerResponse = e.Http1ServerResponse || W.ServerResponse),
        (e.Http2ServerRequest = e.Http2ServerRequest || ct),
        (e.Http2ServerResponse = e.Http2ServerResponse || lt),
        e
      );
    }
    function initializeTLSOptions(e, t) {
      return (
        ((e = initializeOptions(e)).ALPNProtocols = ["h2"]),
        !0 === e.allowHTTP1 && h(e.ALPNProtocols, "http/1.1"),
        void 0 === t || e.servername || (e.servername = t),
        e
      );
    }
    function onErrorSecureServerSession(e, t) {
      this.emit("clientError", e, t) || t.destroy(e);
    }
    m(Http2Stream.prototype, "setTimeout", Gi),
      m(Http2Session.prototype, "setTimeout", Gi);
    class Http2SecureServer extends ds {
      constructor(e, t) {
        super((e = initializeTLSOptions(e)), connectionListener),
          (this[ms] = e),
          (this.timeout = 0),
          this.on("newListener", setupCompat),
          "function" == typeof t && this.on("request", t),
          this.on("tlsClientError", onErrorSecureServerSession);
      }
      setTimeout(e, t) {
        return (
          (this.timeout = e),
          void 0 !== t && (st(t, "callback"), this.on("timeout", t)),
          this
        );
      }
      updateSettings(e) {
        ft(e, "settings"),
          Li(e),
          (this[ms].settings = { ...this[ms].settings, ...e });
      }
    }
    class Http2Server extends as {
      constructor(e, t) {
        super((e = initializeOptions(e)), connectionListener),
          (this[ms] = e),
          (this.timeout = 0),
          this.on("newListener", setupCompat),
          "function" == typeof t && this.on("request", t);
      }
      setTimeout(e, t) {
        return (
          (this.timeout = e),
          void 0 !== t && (st(t, "callback"), this.on("timeout", t)),
          this
        );
      }
      updateSettings(e) {
        ft(e, "settings"),
          Li(e),
          (this[ms].settings = { ...this[ms].settings, ...e });
      }
    }
    function setupCompat(e) {
      "request" === e &&
        (this.removeListener("newListener", setupCompat),
        this.on(
          "stream",
          l(ut, this, this[ms].Http2ServerRequest, this[ms].Http2ServerResponse)
        ));
    }
    function socketOnClose() {
      const e = this[Mt];
      if (void 0 !== e) {
        debugSessionObj(e, "socket closed");
        const t = e.connecting ? new Ye() : null,
          s = e[Os];
        s.streams.forEach((e) => e.close(Ms)),
          s.pendingStreams.forEach((e) => e.close(Ms)),
          e.close(),
          e[Gt](t);
      }
    }
    function connect(e, t, s) {
      "function" == typeof t && ((s = t), (t = void 0)),
        ft(t, "options"),
        (t = { ...t }),
        "string" == typeof e && (e = new B(e)),
        ft(e, "authority", ["string", "Object", "URL"]);
      const i = e.protocol || t.protocol || "https:",
        n = "" + ("" !== e.port ? e.port : "http:" === e.protocol ? 80 : 443);
      let o,
        r = "localhost";
      if (
        (e.hostname
          ? ((r = e.hostname), "[" === r[0] && (r = C(r, 1, -1)))
          : e.host && (r = e.host),
        "function" == typeof t.createConnection)
      )
        o = t.createConnection(e, t);
      else
        switch (i) {
          case "http:":
            o = K.connect({ port: n, host: r, ...t });
            break;
          case "https:":
            o = $.connect(n, r, initializeTLSOptions(t, r));
            break;
          default:
            throw new Ve(i);
        }
      const a = new ClientHttp2Session(t, o);
      return (
        (a[cs] = `${t.servername || r}:${n}`),
        (a[Es] = i),
        "function" == typeof s && a.once("connect", s),
        a
      );
    }
    (Http2Server.prototype[M.captureRejectionSymbol] = function (e, t, ...s) {
      switch (t) {
        case "stream": {
          const { 0: t } = s;
          t.sentHeaders ? t.destroy(e) : (t.respond({ [ai]: 500 }), t.end());
          break;
        }
        case "request": {
          const { 1: e } = s;
          if (e.headersSent || e.finished) e.destroy();
          else {
            for (const t of e.getHeaderNames()) e.removeHeader(t);
            (e.statusCode = 500), e.end(W.STATUS_CODES[500]);
          }
          break;
        }
        default:
          c(s, e, t), E(K.Server.prototype[M.captureRejectionSymbol], this, s);
      }
    }),
      m(connect, j.custom, {
        __proto__: null,
        value: (e, t) =>
          new w((s) => {
            const i = connect(e, t, () => s(i));
          }),
      }),
      Kt.setCallbackFunctions(
        function onSessionInternalError(e, t) {
          void 0 !== this[Ts] && this[Ts].destroy(new At(e, t));
        },
        function onPriority(e, t, s, i) {
          const n = this[Ts];
          if (n.destroyed) return;
          debugStream(
            e,
            n[As],
            "priority [parent: %d, weight: %d, exclusive: %s]",
            t,
            s,
            i
          );
          const o = n[Os].streams.get(e) || n;
          o.destroyed || (o[jt](), o.emit("priority", e, t, s, i));
        },
        function onSettings() {
          const e = this[Ts];
          e.destroyed ||
            (e[jt](),
            debugSessionObj(e, "new settings received"),
            (e[bs] = void 0),
            e.emit("remoteSettings", e.remoteSettings));
        },
        function onPing(e) {
          const t = this[Ts];
          t.destroyed ||
            (t[jt](),
            debugSessionObj(t, "new ping received"),
            t.emit("ping", e));
        },
        function onSessionHeaders(e, t, s, n, o, r) {
          const a = this[Ts];
          if (a.destroyed) return;
          const d = a[As];
          a[jt](), debugStream(t, d, "headers received");
          const h = a[Os].streams,
            c = !!(n & Vs);
          let l = h.get(t);
          const u = Nt(o, r);
          if (void 0 === l) {
            if (a.closed) return e.rstStream(zs), void e.destroy();
            d === Ys
              ? ((l = new ServerHttp2Stream(a, e, t, {}, u)),
                c && l.push(null),
                u[ii] === mi && (l.end(), (l[Os].flags |= 8)))
              : ((l = new ClientHttp2Stream(a, e, t, {})),
                c && l.push(null),
                l.end()),
              c && (l[Os].endAfterHeaders = !0),
              i.nextTick(emit, a, "stream", l, u, n, o);
          } else {
            let e;
            const r = u[ai];
            e =
              s === Bs
                ? !c && void 0 !== r && r >= 100 && r < 200
                  ? "headers"
                  : "response"
                : s === qs
                ? "push"
                : void 0 !== r && r >= 200
                ? "response"
                : c
                ? "trailers"
                : "headers";
            const a = l.session;
            if (r === vi) {
              (a[Os].originSet = initOriginSet(a)).delete(l[ws]);
            }
            debugStream(t, d, "emitting stream '%s' event", e),
              i.nextTick(emit, l, e, u, n, o);
          }
          c && l.push(null);
        },
        function onFrameError(e, t, s) {
          const i = this[Ts];
          if (i.destroyed) return;
          debugSessionObj(
            i,
            "error sending frame type %d on stream %d, code: %d",
            t,
            e,
            s
          );
          const n = i[Os].streams.get(e) || i;
          n[jt](),
            n.emit("frameError", t, s, e),
            i[Os].streams.get(e).close(s),
            i.close();
        },
        function onGoawayData(e, t, s) {
          const i = this[Ts];
          if (i.destroyed) return;
          debugSessionObj(i, "goaway %d received [last stream id: %d]", e, t);
          const n = i[Os];
          (n.goawayCode = e),
            (n.goawayLastStreamID = t),
            i.emit("goaway", e, t, s),
            e === Qs ? i.close() : i.destroy(new Ie(e), Qs);
        },
        function onAltSvc(e, t, s) {
          const i = this[Ts];
          i.destroyed ||
            (debugSessionObj(
              i,
              "altsvc received: stream: %d, origin: %s, alt: %s",
              e,
              t,
              s
            ),
            i[jt](),
            i.emit("altsvc", s, t, e));
        },
        function onOrigin(e) {
          const t = this[Ts];
          if (t.destroyed) return;
          if (
            (debugSessionObj(t, "origin received: %j", e),
            t[jt](),
            !t.encrypted || t.destroyed)
          )
            return;
          const s = initOriginSet(t);
          for (let t = 0; t < e.length; t++) s.add(e[t]);
          t.emit("origin", e);
        },
        function onStreamTrailers() {
          const e = this[Ts];
          (e[Os].trailersReady = !0),
            e.destroyed ||
              e.closed ||
              e.emit("wantTrailers") ||
              e.sendTrailers({});
        },
        function onStreamClose(e) {
          const t = this[Ts];
          return (
            !(!t || t.destroyed) &&
            (debugStreamObj(
              t,
              "closed with code %d, closed %s, readable %s",
              e,
              t.closed,
              t.readable
            ),
            t.closed || closeStream(t, e, Di),
            (t[Os].fd = -1),
            t.readable && e === Qs
              ? (t.on("end", t[Gt]),
                t.push(null),
                t[Mt][As] !== Ys || t[Os].didRead || null !== t.readableFlowing
                  ? t.read(0)
                  : t.resume())
              : t.destroy(),
            !0)
          );
        }
      ),
      (s.exports = {
        connect: connect,
        constants: os,
        createServer: function createServer(e, t) {
          return (
            "function" == typeof e && ((t = e), (e = G)), new Http2Server(e, t)
          );
        },
        createSecureServer: function createSecureServer(e, t) {
          return new Http2SecureServer(e, t);
        },
        getDefaultSettings: wt,
        getPackedSettings: function getPackedSettings(e) {
          return ft(e, "settings"), Li(e), It({ ...e }), Kt.packSettings();
        },
        getUnpackedSettings: function getUnpackedSettings(e, t = G) {
          if (!Vt(e) || void 0 === e.length)
            throw new qe("buf", ["Buffer", "TypedArray"], e);
          if (e.length % 6 != 0) throw new me();
          const s = {};
          let i = 0;
          for (; i < e.length; ) {
            const t = E(V, e, [i]);
            i += 2;
            const n = E(q, e, [i]);
            switch (t) {
              case hi:
                s.headerTableSize = n;
                break;
              case ci:
                s.enablePush = 0 !== n;
                break;
              case li:
                s.maxConcurrentStreams = n;
                break;
              case ui:
                s.initialWindowSize = n;
                break;
              case fi:
                s.maxFrameSize = n;
                break;
              case Si:
                s.maxHeaderListSize = s.maxHeaderSize = n;
                break;
              case gi:
                s.enableConnectProtocol = 0 !== n;
            }
            i += 4;
          }
          return null != t && t.validate && Li(s), s;
        },
        sensitiveHeaders: Rt,
        Http2Session: Http2Session,
        Http2Stream: Http2Stream,
        ServerHttp2Session: ServerHttp2Session,
        Http2ServerRequest: ct,
        Http2ServerResponse: lt,
      });
  },
  "internal/http2/util": function (e, t, r, a, n, T) {
    "use strict";
    const {
        ArrayIsArray: E,
        ArrayPrototypeIncludes: i,
        ArrayPrototypeMap: o,
        ArrayPrototypePush: s,
        Error: _,
        MathMax: H,
        Number: S,
        ObjectCreate: R,
        ObjectDefineProperty: u,
        ObjectKeys: c,
        SafeSet: A,
        String: l,
        StringFromCharCode: P,
        StringPrototypeIncludes: m,
        StringPrototypeToLowerCase: D,
        Symbol: d,
      } = T,
      f = n("http2"),
      {
        codes: {
          ERR_HTTP2_HEADER_SINGLE_VALUE: N,
          ERR_HTTP2_INVALID_CONNECTION_HEADERS: O,
          ERR_HTTP2_INVALID_PSEUDOHEADER: g,
          ERR_HTTP2_INVALID_SETTING_VALUE: h,
          ERR_INVALID_ARG_TYPE: I,
          ERR_INVALID_HTTP_TOKEN: C,
        },
        captureLargerStackTrace: p,
        getMessage: b,
        hideStackFrames: y,
        kIsNodeError: x,
      } = t("internal/errors"),
      w = d("nodejs.http2.sensitiveHeaders"),
      L = d("socket"),
      z = d("proxySocket"),
      G = d("request"),
      {
        NGHTTP2_NV_FLAG_NONE: M,
        NGHTTP2_NV_FLAG_NO_INDEX: F,
        NGHTTP2_SESSION_CLIENT: v,
        NGHTTP2_SESSION_SERVER: k,
        HTTP2_HEADER_STATUS: $,
        HTTP2_HEADER_METHOD: U,
        HTTP2_HEADER_AUTHORITY: V,
        HTTP2_HEADER_SCHEME: W,
        HTTP2_HEADER_PATH: j,
        HTTP2_HEADER_PROTOCOL: B,
        HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: X,
        HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE: Y,
        HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: K,
        HTTP2_HEADER_AGE: Q,
        HTTP2_HEADER_AUTHORIZATION: q,
        HTTP2_HEADER_CONTENT_ENCODING: Z,
        HTTP2_HEADER_CONTENT_LANGUAGE: J,
        HTTP2_HEADER_CONTENT_LENGTH: ee,
        HTTP2_HEADER_CONTENT_LOCATION: te,
        HTTP2_HEADER_CONTENT_MD5: re,
        HTTP2_HEADER_CONTENT_RANGE: ae,
        HTTP2_HEADER_CONTENT_TYPE: ne,
        HTTP2_HEADER_COOKIE: Te,
        HTTP2_HEADER_DATE: Ee,
        HTTP2_HEADER_DNT: ie,
        HTTP2_HEADER_ETAG: oe,
        HTTP2_HEADER_EXPIRES: se,
        HTTP2_HEADER_FROM: _e,
        HTTP2_HEADER_HOST: He,
        HTTP2_HEADER_IF_MATCH: Se,
        HTTP2_HEADER_IF_NONE_MATCH: Re,
        HTTP2_HEADER_IF_MODIFIED_SINCE: ue,
        HTTP2_HEADER_IF_RANGE: ce,
        HTTP2_HEADER_IF_UNMODIFIED_SINCE: Ae,
        HTTP2_HEADER_LAST_MODIFIED: le,
        HTTP2_HEADER_LOCATION: Pe,
        HTTP2_HEADER_MAX_FORWARDS: me,
        HTTP2_HEADER_PROXY_AUTHORIZATION: De,
        HTTP2_HEADER_RANGE: de,
        HTTP2_HEADER_REFERER: fe,
        HTTP2_HEADER_RETRY_AFTER: Ne,
        HTTP2_HEADER_SET_COOKIE: Oe,
        HTTP2_HEADER_TK: ge,
        HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS: he,
        HTTP2_HEADER_USER_AGENT: Ie,
        HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS: Ce,
        HTTP2_HEADER_CONNECTION: pe,
        HTTP2_HEADER_UPGRADE: be,
        HTTP2_HEADER_HTTP2_SETTINGS: ye,
        HTTP2_HEADER_TE: xe,
        HTTP2_HEADER_TRANSFER_ENCODING: we,
        HTTP2_HEADER_KEEP_ALIVE: Le,
        HTTP2_HEADER_PROXY_CONNECTION: ze,
        HTTP2_METHOD_DELETE: Ge,
        HTTP2_METHOD_GET: Me,
        HTTP2_METHOD_HEAD: Fe,
      } = f.constants,
      ve = new A([$, U, V, W, j, B]),
      ke = new A([
        $,
        U,
        V,
        W,
        j,
        B,
        X,
        Y,
        K,
        Q,
        q,
        Z,
        J,
        ee,
        te,
        re,
        ae,
        ne,
        Ee,
        ie,
        oe,
        se,
        _e,
        He,
        Se,
        ue,
        Re,
        ce,
        Ae,
        le,
        Pe,
        me,
        De,
        de,
        fe,
        Ne,
        ge,
        he,
        Ie,
        Ce,
      ]),
      $e = new A([Ge, Me, Fe]),
      { settingsBuffer: Ue, optionsBuffer: Ve } = f,
      { sessionState: We, streamState: je } = f;
    function isIllegalConnectionSpecificHeader(e, t) {
      switch (e) {
        case pe:
        case be:
        case ye:
        case Le:
        case ze:
        case we:
          return !0;
        case xe:
          return "trailers" !== t;
        default:
          return !1;
      }
    }
    const Be = y((e) => {
        if (!ve.has(e)) throw new g(e);
      }),
      Xe = y((e) => {
        if (":status" !== e) throw new g(e);
      }),
      Ye = y((e) => {
        throw new g(e);
      }),
      Ke = [],
      Qe = P(F),
      qe = P(M);
    const Ze = y((e, t, r) => {
        if (void 0 !== e && (null === e || "object" != typeof e || E(e)))
          throw new I(t, r || "Object", e);
      }),
      Je = y((e, t, r = 0, a = 1 / 0) => {
        if (void 0 !== t && ("number" != typeof t || t < r || t > a))
          throw new h.RangeError(e, t, r, a);
      });
    r.exports = {
      assertIsObject: Ze,
      assertValidPseudoHeader: Be,
      assertValidPseudoHeaderResponse: Xe,
      assertValidPseudoHeaderTrailer: Ye,
      assertWithinRange: Je,
      getAuthority: function getAuthority(e) {
        return void 0 !== e[V] ? e[V] : void 0 !== e[He] ? e[He] : void 0;
      },
      getDefaultSettings: function getDefaultSettings() {
        (Ue[7] = 0), f.refreshDefaultSettings();
        const e = R(null),
          t = Ue[7];
        return (
          1 == (1 & t) && (e.headerTableSize = Ue[0]),
          2 == (2 & t) && (e.enablePush = 1 === Ue[1]),
          4 == (4 & t) && (e.initialWindowSize = Ue[2]),
          8 == (8 & t) && (e.maxFrameSize = Ue[3]),
          16 == (16 & t) && (e.maxConcurrentStreams = Ue[4]),
          32 == (32 & t) && (e.maxHeaderListSize = e.maxHeaderSize = Ue[5]),
          64 == (64 & t) && (e.enableConnectProtocol = 1 === Ue[6]),
          e
        );
      },
      getSessionState: function getSessionState(e) {
        return (
          e.refreshState(),
          {
            effectiveLocalWindowSize: We[0],
            effectiveRecvDataLength: We[1],
            nextStreamID: We[2],
            localWindowSize: We[3],
            lastProcStreamID: We[4],
            remoteWindowSize: We[5],
            outboundQueueSize: We[6],
            deflateDynamicTableSize: We[7],
            inflateDynamicTableSize: We[8],
          }
        );
      },
      getSettings: function getSettings(e, t) {
        return (
          t ? e.remoteSettings() : e.localSettings(),
          {
            headerTableSize: Ue[0],
            enablePush: !!Ue[1],
            initialWindowSize: Ue[2],
            maxFrameSize: Ue[3],
            maxConcurrentStreams: Ue[4],
            maxHeaderListSize: Ue[5],
            maxHeaderSize: Ue[5],
            enableConnectProtocol: !!Ue[6],
          }
        );
      },
      getStreamState: function getStreamState(e) {
        return (
          e.refreshState(),
          {
            state: je[0],
            weight: je[1],
            sumDependencyWeight: je[2],
            localClose: je[3],
            remoteClose: je[4],
            localWindowSize: je[5],
          }
        );
      },
      isPayloadMeaningless: function isPayloadMeaningless(e) {
        return $e.has(e);
      },
      kSensitiveHeaders: w,
      kSocket: L,
      kProxySocket: z,
      kRequest: G,
      mapToHeaders: function mapToHeaders(e, t = Be) {
        let r = "",
          a = "",
          n = 0;
        const T = c(e),
          s = new A();
        let _, H, S, R, u, P, d;
        const f = o(e[w] || Ke, D);
        for (_ = 0; _ < T.length; ++_) {
          if (((R = T[_]), (u = e[R]), void 0 === u || "" === R)) continue;
          if (((R = D(R)), (P = ke.has(R)), (S = E(u)), S))
            switch (u.length) {
              case 0:
                continue;
              case 1:
                (u = l(u[0])), (S = !1);
                break;
              default:
                if (P) throw new N(R);
            }
          else u = l(u);
          if (P) {
            if (s.has(R)) throw new N(R);
            s.add(R);
          }
          const o = i(f, R) ? Qe : qe;
          if (":" !== R[0]) {
            if (m(R, " ")) throw new C("Header name", R);
            if (isIllegalConnectionSpecificHeader(R, u)) throw new O(R);
            if (S) {
              for (H = 0; H < u.length; ++H) {
                r += `${R}\0${l(u[H])}\0${o}`;
              }
              n += u.length;
            } else (r += `${R}\0${u}\0${o}`), n++;
          } else {
            if (((d = t(R)), void 0 !== d)) throw d;
            (a += `${R}\0${u}\0${o}`), n++;
          }
        }
        return [a + r, n];
      },
      NghttpError: class NghttpError extends _ {
        constructor(e, t) {
          super(t ? b(t, [], null) : f.nghttp2ErrorString(e)),
            (this.code = t || "ERR_HTTP2_ERROR"),
            (this.errno = e),
            p(this),
            u(this, x, {
              __proto__: null,
              value: !0,
              enumerable: !1,
              writable: !1,
              configurable: !0,
            });
        }
        toString() {
          return `${this.name} [${this.code}]: ${this.message}`;
        }
      },
      sessionName: function sessionName(e) {
        switch (e) {
          case v:
            return "client";
          case k:
            return "server";
          default:
            return "<invalid>";
        }
      },
      toHeaderObject: function toHeaderObject(e, t) {
        const r = R(null);
        for (let t = 0; t < e.length; t += 2) {
          const a = e[t];
          let n = e[t + 1];
          a === $ && (n |= 0);
          const T = r[a];
          if (void 0 === T) r[a] = a === Oe ? [n] : n;
          else if (!ke.has(a))
            switch (a) {
              case Te:
                r[a] = `${T}; ${n}`;
                break;
              case Oe:
                s(T, n);
                break;
              default:
                r[a] = `${T}, ${n}`;
            }
        }
        return (r[w] = t), r;
      },
      updateOptionsBuffer: function updateOptionsBuffer(e) {
        let t = 0;
        "number" == typeof e.maxDeflateDynamicTableSize &&
          ((t |= 1), (Ve[0] = e.maxDeflateDynamicTableSize)),
          "number" == typeof e.maxReservedRemoteStreams &&
            ((t |= 2), (Ve[1] = e.maxReservedRemoteStreams)),
          "number" == typeof e.maxSendHeaderBlockLength &&
            ((t |= 4), (Ve[2] = e.maxSendHeaderBlockLength)),
          "number" == typeof e.peerMaxConcurrentStreams &&
            ((t |= 8), (Ve[3] = e.peerMaxConcurrentStreams)),
          "number" == typeof e.paddingStrategy &&
            ((t |= 16), (Ve[4] = e.paddingStrategy)),
          "number" == typeof e.maxHeaderListPairs &&
            ((t |= 32), (Ve[5] = e.maxHeaderListPairs)),
          "number" == typeof e.maxOutstandingPings &&
            ((t |= 64), (Ve[6] = e.maxOutstandingPings)),
          "number" == typeof e.maxOutstandingSettings &&
            ((t |= 128), (Ve[7] = H(1, e.maxOutstandingSettings))),
          "number" == typeof e.maxSessionMemory &&
            ((t |= 256), (Ve[8] = H(1, e.maxSessionMemory))),
          "number" == typeof e.maxSettings &&
            ((t |= 512), (Ve[9] = H(1, e.maxSettings))),
          (Ve[10] = t);
      },
      updateSettingsBuffer: function updateSettingsBuffer(e) {
        let t = 0;
        "number" == typeof e.headerTableSize &&
          ((t |= 1), (Ue[0] = e.headerTableSize)),
          "number" == typeof e.maxConcurrentStreams &&
            ((t |= 16), (Ue[4] = e.maxConcurrentStreams)),
          "number" == typeof e.initialWindowSize &&
            ((t |= 4), (Ue[2] = e.initialWindowSize)),
          "number" == typeof e.maxFrameSize &&
            ((t |= 8), (Ue[3] = e.maxFrameSize)),
          ("number" != typeof e.maxHeaderListSize &&
            "number" != typeof e.maxHeaderSize) ||
            ((t |= 32),
            void 0 !== e.maxHeaderSize &&
            e.maxHeaderSize !== e.maxHeaderListSize
              ? (a.emitWarning(
                  "settings.maxHeaderSize overwrite settings.maxHeaderListSize"
                ),
                (Ue[5] = e.maxHeaderSize))
              : (Ue[5] = e.maxHeaderListSize)),
          "boolean" == typeof e.enablePush &&
            ((t |= 2), (Ue[1] = S(e.enablePush))),
          "boolean" == typeof e.enableConnectProtocol &&
            ((t |= 64), (Ue[6] = S(e.enableConnectProtocol))),
          (Ue[7] = t);
      },
    };
  },
  "internal/idna": function (o, t, c, n, I, e) {
    "use strict";
    const { toASCII: i, toUnicode: s } = I("url");
    c.exports = { toASCII: i, toUnicode: s };
  },
  "internal/inspector_async_hook": function (e, s, a, i, t, n) {
    "use strict";
    let o, r;
    const { SafeSet: d } = n;
    function lazyHookCreation() {
      const e = t("inspector"),
        { createHook: a } = s("async_hooks");
      (r = t("config")),
        (o = a({
          init(s, a, i, t) {
            "PROMISE" === a
              ? this.promiseIds.add(s)
              : e.asyncTaskScheduled(a, s, !0);
          },
          before(s) {
            this.promiseIds.has(s) || e.asyncTaskStarted(s);
          },
          after(s) {
            this.promiseIds.has(s) || e.asyncTaskFinished(s);
          },
          destroy(s) {
            if (this.promiseIds.has(s)) return this.promiseIds.delete(s);
            e.asyncTaskCanceled(s);
          },
        })),
        (o.promiseIds = new d());
    }
    a.exports = {
      enable: function enable() {
        void 0 === o && lazyHookCreation(),
          r.bits < 64
            ? i.emitWarning(
                `Warning: Async stack traces in debugger are not available on ${r.bits}bit platforms. The feature is disabled.`,
                { code: "INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE" }
              )
            : o.enable();
      },
      disable: function disable() {
        void 0 === o && lazyHookCreation(), o.disable();
      },
    };
  },
  "internal/js_stream_socket": function (t, e, s, n, i, r) {
    "use strict";
    const { Symbol: o } = r,
      { setImmediate: h } = e("timers"),
      l = e("internal/assert"),
      { Socket: a } = e("net"),
      { JSStream: u } = i("js_stream"),
      d = i("uv");
    let c = e("internal/util/debuglog").debuglog("stream_socket", (t) => {
      c = t;
    });
    const { owner_symbol: S } = e("internal/async_hooks").symbols,
      { ERR_STREAM_WRAP: f } = e("internal/errors").codes,
      m = o("kCurrentWriteRequest"),
      w = o("kCurrentShutdownRequest"),
      _ = o("kPendingShutdownRequest"),
      g = o("kPendingClose");
    function isClosing() {
      return this[S].isClosing();
    }
    function onreadstart() {
      return this[S].readStart();
    }
    function onreadstop() {
      return this[S].readStop();
    }
    function onshutdown(t) {
      return this[S].doShutdown(t);
    }
    function onwrite(t, e) {
      return this[S].doWrite(t, e);
    }
    class JSStreamSocket extends a {
      constructor(t) {
        const e = new u();
        (e.close = (t) => {
          c("close"), this.doClose(t);
        }),
          (e.isClosing = isClosing),
          (e.onreadstart = onreadstart),
          (e.onreadstop = onreadstop),
          (e.onshutdown = onshutdown),
          (e.onwrite = onwrite),
          t.pause(),
          t.on("error", (t) => this.emit("error", t));
        const ondata = (e) => {
          if ("string" == typeof e || !0 === t.readableObjectMode)
            return (
              t.pause(),
              t.removeListener("data", ondata),
              void this.emit("error", new f())
            );
          c("data", e.length), this._handle && this._handle.readBuffer(e);
        };
        t.on("data", ondata),
          t.once("end", () => {
            c("end"), this._handle && this._handle.emitEOF();
          }),
          t.once("close", () => {
            this.destroy();
          }),
          super({ handle: e, manualStart: !0 }),
          (this.stream = t),
          (this[m] = null),
          (this[w] = null),
          (this[_] = null),
          (this[g] = !1),
          (this.readable = t.readable),
          (this.writable = t.writable),
          this.read(0);
      }
      static get StreamWrap() {
        return JSStreamSocket;
      }
      isClosing() {
        return !this.readable || !this.writable;
      }
      readStart() {
        return this.stream.resume(), 0;
      }
      readStop() {
        return this.stream.pause(), 0;
      }
      doShutdown(t) {
        if (null !== this[m]) return (this[_] = t), 0;
        if ((l(null === this[m]), l(null === this[w]), (this[w] = t), this[g]))
          return 0;
        const e = this._handle;
        return (
          l(null !== e),
          n.nextTick(() => {
            this.stream.end(() => {
              this.finishShutdown(e, 0);
            });
          }),
          0
        );
      }
      finishShutdown(t, e) {
        if (null === this[w]) return;
        const s = this[w];
        (this[w] = null), t.finishShutdown(s, e);
      }
      doWrite(t, e) {
        if ((l(null === this[m]), l(null === this[w]), this[g]))
          return (this[m] = t), 0;
        const s = this._handle;
        l(null !== s);
        const n = this;
        let i = e.length;
        this.stream.cork();
        for (var r = 0; r < e.length; ++r) this.stream.write(e[r], done);
        function done(t) {
          if (!t && 0 != --i) return;
          i = 0;
          let e = 0;
          t && (e = d[`UV_${t.code}`] || d.UV_EPIPE),
            h(() => {
              n.finishWrite(s, e);
            });
        }
        return this.stream.uncork(), (this[m] = t), 0;
      }
      finishWrite(t, e) {
        if (null === this[m]) return;
        const s = this[m];
        if (((this[m] = null), t.finishWrite(s, e), this[_])) {
          const t = this[_];
          (this[_] = null), this.doShutdown(t);
        }
      }
      doClose(t) {
        this[g] = !0;
        const e = this._handle;
        this.stream.destroy(),
          h(() => {
            l(null === this._handle),
              this.finishWrite(e, d.UV_ECANCELED),
              this.finishShutdown(e, d.UV_ECANCELED),
              (this[g] = !1),
              t();
          });
      }
    }
    s.exports = JSStreamSocket;
  },
  "internal/legacy/processbinding": function (r, t, e, i, s, a) {
    "use strict";
    const {
        ArrayPrototypeFilter: o,
        ArrayPrototypeIncludes: y,
        ObjectFromEntries: n,
        ObjectEntries: A,
        SafeArrayIterator: u,
      } = a,
      { types: c } = t("util");
    e.exports = {
      util: () =>
        n(
          new u(
            o(A(c), ({ 0: r }) =>
              y(
                [
                  "isArrayBuffer",
                  "isArrayBufferView",
                  "isAsyncFunction",
                  "isDataView",
                  "isDate",
                  "isExternal",
                  "isMap",
                  "isMapIterator",
                  "isNativeError",
                  "isPromise",
                  "isRegExp",
                  "isSet",
                  "isSetIterator",
                  "isTypedArray",
                  "isUint8Array",
                  "isAnyArrayBuffer",
                ],
                r
              )
            )
          )
        ),
    };
  },
  "internal/linkedlist": function (e, i, l, t, _, d) {
    "use strict";
    function remove(e) {
      e._idleNext && (e._idleNext._idlePrev = e._idlePrev),
        e._idlePrev && (e._idlePrev._idleNext = e._idleNext),
        (e._idleNext = null),
        (e._idlePrev = null);
    }
    l.exports = {
      init: function init(e) {
        return (e._idleNext = e), (e._idlePrev = e), e;
      },
      peek: function peek(e) {
        return e._idlePrev === e ? null : e._idlePrev;
      },
      remove: remove,
      append: function append(e, i) {
        (i._idleNext || i._idlePrev) && remove(i),
          (i._idleNext = e._idleNext),
          (i._idlePrev = e),
          (e._idleNext._idlePrev = i),
          (e._idleNext = i);
      },
      isEmpty: function isEmpty(e) {
        return e._idleNext === e;
      },
    };
  },
  "internal/main/check_syntax": function (e, n, t, o) {
    "use strict";
    const { URL: a } = n("internal/url"),
      { getOptionValue: l } = n("internal/options"),
      { prepareMainThreadExecution: r, markBootstrapComplete: i } = n(
        "internal/process/pre_execution"
      ),
      { readStdin: s } = n("internal/process/execution"),
      { pathToFileURL: d } = n("url"),
      {
        Module: { _resolveFilename: u },
        wrapSafe: c,
      } = n("internal/modules/cjs/loader");
    if ((r(!0), e.argv[1] && "-" !== e.argv[1])) {
      const t = n("path");
      e.argv[1] = t.resolve(e.argv[1]);
      const o = u(e.argv[1]),
        a = n("fs").readFileSync(o, "utf-8");
      i(), loadESMIfNeeded(() => checkSyntax(a, o));
    } else
      i(),
        loadESMIfNeeded(() =>
          s((e) => {
            checkSyntax(e, "[stdin]");
          })
        );
    function loadESMIfNeeded(e) {
      const { getOptionValue: t } = n("internal/options");
      if (t("--import").length > 0) {
        const { loadESM: t } = n("internal/process/esm_loader");
        t(e);
      } else e();
    }
    async function checkSyntax(e, o) {
      let r = !0;
      if ("[stdin]" === o || "[eval]" === o)
        r =
          "module" === l("--input-type") ||
          ("module" === l("--experimental-default-type") &&
            "commonjs" !== l("--input-type"));
      else {
        const { defaultResolve: e } = n("internal/modules/esm/resolve"),
          { defaultGetFormat: t } = n("internal/modules/esm/get_format"),
          { url: l } = await e(d(o).toString());
        r = "module" === (await t(new a(l)));
      }
      if (r) {
        const { ModuleWrap: n } = t("module_wrap");
        return void new n(o, void 0, e, 0, 0);
      }
      const { loadESM: i } = n("internal/process/esm_loader"),
        { handleMainPromise: s } = n("internal/modules/run_main");
      s(i((n) => c(o, e)));
    }
  },
  "internal/main/environment": function (e, t, r, n) {
    "use strict";
    const { prepareMainThreadExecution: o, markBootstrapComplete: a } = t(
      "internal/process/pre_execution"
    );
    o(), a();
  },
  "internal/main/eval_stdin": function (e, t, n, i) {
    "use strict";
    const { prepareMainThreadExecution: o, markBootstrapComplete: p } = t(
        "internal/process/pre_execution"
      ),
      { getOptionValue: r } = t("internal/options"),
      {
        evalModule: a,
        evalScript: l,
        readStdin: s,
      } = t("internal/process/execution");
    o(),
      p(),
      s((t) => {
        e._eval = t;
        const n = r("--print"),
          i = r("--import").length > 0;
        "module" === r("--input-type") ||
        ("module" === r("--experimental-default-type") &&
          "commonjs" !== r("--input-type"))
          ? a(t, n)
          : l("[stdin]", t, r("--inspect-brk"), n, i);
      });
  },
  "internal/main/eval_string": function (e, t, n, l) {
    "use strict";
    const { globalThis: i } = l,
      { prepareMainThreadExecution: o, markBootstrapComplete: a } = t(
        "internal/process/pre_execution"
      ),
      { evalModule: p, evalScript: r } = t("internal/process/execution"),
      { addBuiltinLibsToObject: s } = t("internal/modules/helpers"),
      { getOptionValue: u } = t("internal/options");
    o(), s(i, "<eval>"), a();
    const c = u("--eval"),
      m = u("--print"),
      d = u("--import").length > 0 || u("--experimental-loader").length > 0;
    "module" === u("--input-type") ||
    ("module" === u("--experimental-default-type") &&
      "commonjs" !== u("--input-type"))
      ? p(c, m)
      : r("[eval]", c, u("--inspect-brk"), m, d);
  },
  "internal/main/inspect": function (e, t, n, r) {
    "use strict";
    const { prepareMainThreadExecution: i, markBootstrapComplete: a } = t(
      "internal/process/pre_execution"
    );
    i(),
      a(),
      e.nextTick(() => {
        t("internal/debugger/inspect").start();
      });
  },
  "internal/main/mksnapshot": function (e, t, r, s) {
    "use strict";
    const {
        Error: a,
        ObjectDefineProperty: i,
        ObjectGetOwnPropertyDescriptor: n,
        ObjectSetPrototypeOf: o,
        SafeArrayIterator: l,
        SafeSet: p,
      } = s,
      c = r("mksnapshot"),
      {
        BuiltinModule: { normalizeRequirableId: u },
      } = t("internal/bootstrap/realm"),
      { compileSerializeMain: d } = c,
      { getOptionValue: m } = t("internal/options"),
      { readFileSync: _ } = t("fs"),
      f = new p(
        new l([
          "_stream_duplex",
          "_stream_passthrough",
          "_stream_readable",
          "_stream_transform",
          "_stream_wrap",
          "_stream_writable",
          "assert",
          "assert/strict",
          "buffer",
          "console",
          "constants",
          "crypto",
          "dns",
          "events",
          "fs",
          "fs/promises",
          "os",
          "path",
          "path/posix",
          "path/win32",
          "process",
          "punycode",
          "querystring",
          "stream",
          "stream/promises",
          "string_decoder",
          "sys",
          "timers",
          "timers/promises",
          "url",
          "util",
          "util/types",
          "v8",
          "zlib",
        ])
      ),
      h = new p();
    function requireForUserSnapshot(r) {
      const s = u(r);
      if (!s) {
        const e = new a(`Cannot find module '${r}'. `);
        throw ((e.code = "MODULE_NOT_FOUND"), e);
      }
      return (
        (function supportedInUserSnapshot(e) {
          return f.has(e);
        })(s) ||
          h.has(s) ||
          (e.emitWarning(
            `built-in module ${r} is not yet supported in user snapshots`
          ),
          h.add(s)),
        t(s)
      );
    }
    !(function main() {
      const { prepareMainThreadExecution: s } = t(
        "internal/process/pre_execution"
      );
      s(!0, !1);
      const l = e.argv[1],
        p = t("path"),
        c = p.resolve(l),
        u = p.dirname(c),
        f = _(l, "utf-8"),
        h = d(c, f),
        {
          initializeCallbacks: b,
          namespace: { addSerializeCallback: S, addDeserializeCallback: w },
        } = t("internal/v8/startup_snapshot");
      let y;
      b(),
        w(() => {
          void 0 !== y && i(a, "stackTraceLimit", y);
        }),
        m("--inspect-brk")
          ? r("inspector").callAndPauseOnStart(
              h,
              void 0,
              requireForUserSnapshot,
              c,
              u
            )
          : h(requireForUserSnapshot, c, u),
        S(() => {
          (y = n(a, "stackTraceLimit")),
            void 0 !== y &&
              (o(y, null),
              e._rawDebug(
                "Deleting Error.stackTraceLimit from the snapshot. It will be re-installed after deserialization"
              ),
              delete a.stackTraceLimit);
        });
    })();
  },
  "internal/main/print_help": function (e, t, o, n) {
    "use strict";
    const {
        ArrayPrototypeConcat: s,
        ArrayPrototypeSort: i,
        Boolean: r,
        MathFloor: a,
        MathMax: p,
        ObjectKeys: l,
        RegExp: c,
        RegExpPrototypeSymbolReplace: d,
        StringPrototypeLocaleCompare: h,
        StringPrototypeSlice: u,
        StringPrototypeTrimLeft: f,
        StringPrototypeRepeat: E,
        SafeMap: O,
      } = n,
      { types: _ } = o("options"),
      T = r(e.versions.openssl),
      { prepareMainThreadExecution: g, markBootstrapComplete: N } = t(
        "internal/process/pre_execution"
      ),
      S = [];
    for (const e of l(_)) S[_[e]] = e;
    const { hasIntl: m, hasSmallICU: D, hasNodeOptions: C } = o("config"),
      R = new O(
        s(
          [
            [
              "FORCE_COLOR",
              {
                helpText:
                  "when set to 'true', 1, 2, 3, or an empty string causes NO_COLOR and NODE_DISABLE_COLORS to be ignored.",
              },
            ],
            ["NO_COLOR", { helpText: "Alias for NODE_DISABLE_COLORS" }],
            [
              "NODE_DEBUG",
              {
                helpText:
                  "','-separated list of core modules that should print debug information",
              },
            ],
            [
              "NODE_DEBUG_NATIVE",
              {
                helpText:
                  "','-separated list of C++ core debug categories that should print debug output",
              },
            ],
            [
              "NODE_DISABLE_COLORS",
              { helpText: "set to 1 to disable colors in the REPL" },
            ],
            [
              "NODE_EXTRA_CA_CERTS",
              {
                helpText:
                  "path to additional CA certificates file. Only read once during process startup.",
              },
            ],
            [
              "NODE_NO_WARNINGS",
              { helpText: "set to 1 to silence process warnings" },
            ],
            [
              "NODE_PATH",
              {
                helpText: `'${
                  t("path").delimiter
                }'-separated list of directories prefixed to the module search path`,
              },
            ],
            [
              "NODE_PENDING_DEPRECATION",
              { helpText: "set to 1 to emit pending deprecation warnings" },
            ],
            [
              "NODE_PENDING_PIPE_INSTANCES",
              {
                helpText:
                  "set the number of pending pipe instance handles on Windows",
              },
            ],
            [
              "NODE_PRESERVE_SYMLINKS",
              {
                helpText:
                  "set to 1 to preserve symbolic links when resolving and caching modules",
              },
            ],
            [
              "NODE_REDIRECT_WARNINGS",
              { helpText: "write warnings to path instead of stderr" },
            ],
            [
              "NODE_REPL_HISTORY",
              { helpText: "path to the persistent REPL history file" },
            ],
            [
              "NODE_REPL_EXTERNAL_MODULE",
              {
                helpText:
                  "path to a Node.js module which will be loaded in place of the built-in REPL",
              },
            ],
            [
              "NODE_SKIP_PLATFORM_CHECK",
              {
                helpText:
                  "set to 1 to skip the check for a supported platform during Node.js startup",
              },
            ],
            [
              "NODE_TLS_REJECT_UNAUTHORIZED",
              { helpText: "set to 0 to disable TLS certificate validation" },
            ],
            [
              "NODE_V8_COVERAGE",
              { helpText: "directory to output v8 coverage JSON to" },
            ],
            ["TZ", { helpText: "specify the timezone configuration" }],
            [
              "UV_THREADPOOL_SIZE",
              {
                helpText:
                  "sets the number of threads used in libuv's threadpool",
              },
            ],
          ],
          m ? [["NODE_ICU_DATA", { helpText: "" }]] : []
        ),
        C
          ? [
              [
                "NODE_OPTIONS",
                {
                  helpText:
                    "set CLI options in the environment via a space-separated list",
                },
              ],
            ]
          : [],
        T
          ? [
              [
                "OPENSSL_CONF",
                { helpText: "load OpenSSL configuration from file" },
              ],
              [
                "SSL_CERT_DIR",
                {
                  helpText:
                    "sets OpenSSL's directory of trusted certificates when used in conjunction with --use-openssl-ca",
                },
              ],
              [
                "SSL_CERT_FILE",
                {
                  helpText:
                    "sets OpenSSL's trusted certificate file when used in conjunction with --use-openssl-ca",
                },
              ],
            ]
          : []
      );
    function indent(e, t) {
      return d(/^/gm, e, E(" ", t));
    }
    function fold(e, t) {
      return d(
        new c(`([^\n]{0,${t}})( |$)`, "g"),
        e,
        (e, t, o) => t + (" " === o ? "\n" : "")
      );
    }
    function getArgDescription(e) {
      switch (S[e]) {
        case "kNoOp":
        case "kV8Option":
        case "kBoolean":
        case void 0:
          break;
        case "kHostPort":
          return "[host:]port";
        case "kInteger":
        case "kUInteger":
        case "kString":
        case "kStringList":
          return "...";
        default:
          t("assert").fail(`unknown option type ${e}`);
      }
    }
    function format({
      options: e,
      aliases: t = new O(),
      firstColumn: o,
      secondColumn: n,
    }) {
      let s = "",
        r = 0;
      const a = i(
        [...e.entries()],
        ({ 0: e, 1: t }, { 0: o, 1: n }) => (
          t.defaultIsTrue && (e = `--no-${u(e, 2)}`),
          n.defaultIsTrue && (o = `--no-${u(o, 2)}`),
          h(e, o)
        )
      );
      for (const {
        0: i,
        1: { helpText: l, type: c, value: d, defaultIsTrue: h },
      } of a) {
        if (!l) continue;
        let a = i;
        h && (a = `--no-${u(a, 2)}`);
        const O = getArgDescription(c);
        O && (a += `=${O}`);
        for (const { 0: o, 1: n } of t) {
          n[0] === i && 1 === n.length && (a = `${o}, ${a}`);
          const t = e.get(n[0]),
            s = t ? getArgDescription(t.type) : "...";
          o === `${i}=`
            ? (a += `[=${s}]`)
            : o === `${i} <arg>` && (a += ` [${s}]`);
        }
        let _ = l;
        d === !h && (_ += " (currently set)"),
          (s += a),
          (r = p(r, a.length)),
          a.length >= o ? (s += "\n" + E(" ", o)) : (s += E(" ", o - a.length)),
          (s += f(indent(fold(_, n), o)) + "\n");
      }
      return r < o - 4
        ? format({
            options: e,
            aliases: t,
            firstColumn: r + 2,
            secondColumn: n,
          })
        : s;
    }
    g(),
      N(),
      (function print(e) {
        const { options: o, aliases: n } = t("internal/options"),
          s = p(70, 0.75 * (e.columns || 0)),
          i = a(0.4 * s),
          r = a(0.57 * s);
        o.set("-", {
          helpText:
            "script read from stdin (default if no file name is provided, interactive mode if a tty)",
        }),
          o.set("--", { helpText: "indicate the end of node options" }),
          e.write(
            "Usage: node [options] [ script.js ] [arguments]\n       node inspect [options] [ script.js | host:port ] [arguments]\n\nOptions:\n"
          ),
          e.write(
            indent(
              format({
                options: o,
                aliases: n,
                firstColumn: i,
                secondColumn: r,
              }),
              2
            )
          ),
          e.write("\nEnvironment variables:\n"),
          e.write(format({ options: R, firstColumn: i, secondColumn: r })),
          e.write("\nDocumentation can be found at https://nodejs.org/\n");
      })(e.stdout);
  },
  "internal/main/prof_process": function (e, r, o, t) {
    "use strict";
    const { prepareMainThreadExecution: n, markBootstrapComplete: p } = r(
      "internal/process/pre_execution"
    );
    n(), p(), r("internal/v8_prof_processor");
  },
  "internal/main/repl": function (e, n, o, t) {
    "use strict";
    const { prepareMainThreadExecution: r, markBootstrapComplete: i } = n(
        "internal/process/pre_execution"
      ),
      { evalScript: l } = n("internal/process/execution"),
      a = n("internal/console/global"),
      { getOptionValue: s } = n("internal/options");
    if ((r(), i(), e.env.NODE_REPL_EXTERNAL_MODULE))
      n("internal/modules/cjs/loader").Module._load(
        e.env.NODE_REPL_EXTERNAL_MODULE,
        void 0,
        !0
      );
    else {
      s("--input-type") &&
        (a.error("Cannot specify --input-type for REPL"), e.exit(1));
      n("internal/process/esm_loader").loadESM(() => {
        a.log(
          `Welcome to Node.js ${e.version}.\nType ".help" for more information.`
        );
        n("internal/repl").createInternalRepl(e.env, (n, o) => {
          if (n) throw n;
          o.on("exit", () => {
            if (o._flushing)
              return (
                o.pause(),
                o.once("flushHistory", () => {
                  e.exit();
                })
              );
            e.exit();
          });
        }),
          s("[has_eval_string]") &&
            l("[eval]", s("--eval"), s("--inspect-brk"), s("--print"));
      });
    }
  },
  "internal/main/run_main_module": function (e, t, n, o) {
    "use strict";
    const { RegExpPrototypeExec: r } = o,
      { prepareMainThreadExecution: a, markBootstrapComplete: i } = t(
        "internal/process/pre_execution"
      ),
      { getOptionValue: l } = t("internal/options"),
      u = a(!0);
    i(),
      r(/^/, ""),
      "module" === l("--experimental-default-type")
        ? t("internal/modules/run_main").executeUserEntryPoint(u)
        : t("internal/modules/cjs/loader").Module.runMain(u);
  },
  "internal/main/single_executable_application": function (e, t, n, a) {
    "use strict";
    const { prepareMainThreadExecution: r, markBootstrapComplete: i } = t(
        "internal/process/pre_execution"
      ),
      { getSingleExecutableCode: o } = n("sea"),
      { emitExperimentalWarning: l } = t("internal/util"),
      { Module: u, wrapSafe: s } = t("internal/modules/cjs/loader"),
      {
        codes: { ERR_UNKNOWN_BUILTIN_MODULE: c },
      } = t("internal/errors"),
      {
        BuiltinModule: { normalizeRequirableId: p },
      } = t("internal/bootstrap/realm");
    r(!1, !0), i(), l("Single executable application");
    const m = e.execPath,
      d = s(m, o()),
      _ = new u(m, null);
    (_.filename = m), (_.paths = u._nodeModulePaths(_.path));
    const h = _.exports;
    function customRequire(e) {
      const n = p(e);
      if (!n) throw new c(e);
      return t(n);
    }
    customRequire.main = _;
    d(h, customRequire, _, _.filename, _.path);
  },
  "internal/main/test_runner": function (t, e, n, r) {
    "use strict";
    const { prepareMainThreadExecution: o, markBootstrapComplete: i } = e(
        "internal/process/pre_execution"
      ),
      { getOptionValue: s } = e("internal/options"),
      { isUsingInspector: c } = e("internal/util/inspector"),
      { run: u } = e("internal/test_runner/runner"),
      { setupTestReporters: a } = e("internal/test_runner/utils"),
      {
        codes: { ERR_INVALID_ARG_VALUE: l },
      } = e("internal/errors"),
      {
        NumberParseInt: p,
        RegExpPrototypeExec: d,
        StringPrototypeSplit: _,
      } = r;
    let g = e("internal/util/debuglog").debuglog("test_runner", (t) => {
      g = t;
    });
    o(!1), i();
    let h,
      f,
      x = s("--test-concurrency") || !0;
    c() &&
      (t.emitWarning(
        "Using the inspector with --test forces running at a concurrency of 1. Use the inspectPort option to run with concurrency"
      ),
      (x = 1),
      (h = t.debugPort));
    const m = s("--test-shard");
    if (m) {
      if (!d(/^\d+\/\d+$/, m))
        throw (
          ((t.exitCode = 1),
          new l("--test-shard", m, "must be in the form of <index>/<total>"))
        );
      const { 0: e, 1: n } = _(m, "/");
      f = { __proto__: null, index: p(e, 10), total: p(n, 10) };
    }
    const w = {
      concurrency: x,
      inspectPort: h,
      watch: s("--watch"),
      setup: a,
      shard: f,
    };
    g("test runner configuration:", w),
      u(w).on("test:fail", (e) => {
        (void 0 !== e.todo && !1 !== e.todo) || (t.exitCode = 1);
      });
  },
  "internal/main/watch_mode": function (t, e, r, n) {
    "use strict";
    const {
        ArrayPrototypeFilter: a,
        ArrayPrototypeForEach: i,
        ArrayPrototypeJoin: o,
        ArrayPrototypeMap: c,
        ArrayPrototypePushApply: s,
        ArrayPrototypeSlice: l,
        StringPrototypeStartsWith: u,
      } = n,
      { prepareMainThreadExecution: p, markBootstrapComplete: h } = e(
        "internal/process/pre_execution"
      ),
      { triggerUncaughtException: d } = r("errors"),
      { getOptionValue: w } = e("internal/options"),
      { emitExperimentalWarning: y } = e("internal/util"),
      { FilesWatcher: g } = e("internal/watch_mode/files_watcher"),
      {
        green: f,
        blue: $,
        red: m,
        white: A,
        clear: P,
      } = e("internal/util/colors"),
      { spawn: E } = e("child_process"),
      { inspect: T } = e("util"),
      { setTimeout: v, clearTimeout: x } = e("timers"),
      { resolve: I } = e("path"),
      { once: S, on: W } = e("events");
    p(!1, !1), h();
    const _ = "SIGTERM",
      F = 0 === w("--watch-path").length,
      G = c(w("--watch-path"), (t) => I(t)),
      k = w("--watch-preserve-output"),
      M = l(t.argv, 1),
      R = T(o(M, " ")),
      C = a(
        t.execArgv,
        (t, e, r) =>
          !(
            u(t, "--watch-path") ||
            (r[e - 1] && u(r[e - 1], "--watch-path")) ||
            "--watch" === t ||
            "--watch-preserve-output" === t
          )
      );
    s(C, M);
    const N = new g({ debounce: 200, mode: F ? "filter" : "all" });
    let H, D, b;
    function start() {
      b = !1;
      const e = F ? ["inherit", "inherit", "inherit", "ipc"] : "inherit";
      (D = E(t.execPath, C, {
        stdio: e,
        env: { ...t.env, WATCH_REPORT_DEPENDENCIES: "1" },
      })),
        N.watchChildProcessModules(D),
        D.once("exit", (e) => {
          (b = !0),
            0 === e
              ? t.stdout.write(`${$}Completed running ${R}${A}\n`)
              : t.stdout.write(`${m}Failed running ${R}${A}\n`);
        });
    }
    async function killAndWait(t = _, e = !1) {
      if ((D?.removeAllListeners(), !D)) return;
      if ((D.killed || b) && !e) return;
      const r = S(D, "exit");
      D.kill(t);
      const { 0: n } = await r;
      return n;
    }
    async function stop() {
      N.clearFileFilters();
      const e = (function reportGracefulTermination() {
        let e = !1;
        return (
          x(H),
          (H = v(() => {
            (e = !0),
              t.stdout.write(`${$}Waiting for graceful termination...${A}\n`);
          }, 500).unref()),
          () => {
            x(H),
              e && t.stdout.write(`${P}${f}Gracefully restarted ${R}${A}\n`);
          }
        );
      })();
      await killAndWait(), e();
    }
    async function restart() {
      k || t.stdout.write(P),
        t.stdout.write(`${f}Restarting ${R}${A}\n`),
        await stop(),
        start();
    }
    function signalHandler(e) {
      return async () => {
        N.clear();
        const r = await killAndWait(e, !0);
        t.exit(r ?? 0);
      };
    }
    i(G, (t) => N.watchPath(t)),
      (async () => {
        y("Watch mode");
        try {
          start();
          for await (const t of W(N, "changed")) await restart();
        } catch (t) {
          d(t, !0);
        }
      })(),
      t.on("SIGTERM", signalHandler("SIGTERM")),
      t.on("SIGINT", signalHandler("SIGINT"));
  },
  "internal/main/worker_thread": function (e, t, r, n) {
    "use strict";
    const {
        ArrayPrototypeForEach: a,
        ArrayPrototypePushApply: o,
        ArrayPrototypeSplice: s,
        ObjectDefineProperty: c,
        PromisePrototypeThen: i,
        RegExpPrototypeExec: l,
        SafeWeakMap: p,
        globalThis: { Atomics: u, SharedArrayBuffer: d },
      } = n,
      {
        prepareWorkerThreadExecution: _,
        setupUserModules: g,
        markBootstrapComplete: h,
      } = t("internal/process/pre_execution"),
      { threadId: k, getEnvMessagePort: y } = r("worker"),
      w = t("internal/worker/io"),
      {
        messageTypes: {
          LOAD_SCRIPT: m,
          UP_AND_RUNNING: v,
          ERROR_MESSAGE: b,
          COULD_NOT_SERIALIZE_ERROR: E,
          STDIO_PAYLOAD: f,
          STDIO_WANTS_MORE_DATA: x,
        },
        kStdioWantsMoreDataCallback: A,
      } = w,
      { onGlobalUncaughtException: D } = t("internal/process/execution");
    let S = t("internal/util/debuglog").debuglog("worker", (e) => {
      S = e;
    });
    const O = t("internal/assert");
    _(), S(`[${k}] is setting up worker child environment`);
    const P = y();
    if (e.env.NODE_CHANNEL_FD) {
      const r = t("internal/process/worker_thread_only");
      c(e, "channel", {
        __proto__: null,
        enumerable: !1,
        get: r.unavailable("process.channel"),
      }),
        c(e, "connected", {
          __proto__: null,
          enumerable: !1,
          get: r.unavailable("process.connected"),
        }),
        (e.send = r.unavailable("process.send()")),
        (e.disconnect = r.unavailable("process.disconnect()"));
    }
    function workerOnGlobalUncaughtException(r, n) {
      S(`[${k}] gets uncaught exception`);
      let a,
        o = !1,
        s = !1;
      try {
        o = D(r, n);
      } catch (e) {
        (r = e), (s = !0);
      }
      if ((S(`[${k}] uncaught exception handled = ${o}`), o)) return !0;
      if (!e._exiting)
        try {
          (e._exiting = !0), (e.exitCode = 1), s || e.emit("exit", e.exitCode);
        } catch {}
      try {
        const { serializeError: e } = t("internal/error_serdes");
        a = e(r);
      } catch {}
      S(`[${k}] uncaught exception serialized = ${!!a}`),
        a ? P.postMessage({ type: b, error: a }) : P.postMessage({ type: E });
      const { clearAsyncIdStack: c } = t("internal/async_hooks");
      c(), e.exit();
    }
    P.on("message", (n) => {
      if (n.type === m) {
        P.unref();
        const {
          argv: a,
          cwdCounter: l,
          doEval: _,
          environmentData: h,
          filename: y,
          hasStdin: m,
          manifestSrc: b,
          manifestURL: E,
          publicPort: f,
          workerData: x,
        } = n;
        if ("internal" !== _) {
          void 0 !== a && o(e.argv, a);
          const r = t("worker_threads");
          (r.parentPort = f), (r.workerData = x);
        }
        if (
          (t("internal/worker").assignEnvironmentData(h),
          void 0 !== d && void 0 !== u)
        ) {
          let t = "",
            r = -1;
          const n = e.cwd;
          (e.cwd = function () {
            const e = u.load(l, 0);
            return e === r || ((r = e), (t = n())), t;
          }),
            (w.sharedCwdCounter = l);
        }
        b && t("internal/process/policy").setup(b, E);
        const A =
          "internal" === _ &&
          y === t("internal/modules/esm/utils").loaderWorkerId;
        switch (
          (g(A),
          m || e.stdin.push(null),
          S(
            `[${k}] starts worker script ${y} (eval = ${_}) at cwd = ${e.cwd()}`
          ),
          P.postMessage({ type: v }),
          _)
        ) {
          case "internal":
            (r("module_wrap").callbackMap = new p()), t(y)(x, f);
            break;
          case "classic": {
            const { evalScript: r } = t("internal/process/execution"),
              n = "[worker eval]";
            c(e, "_eval", {
              __proto__: null,
              configurable: !0,
              enumerable: !0,
              value: y,
            }),
              s(e.argv, 1, 0, n),
              r(n, y);
            break;
          }
          case "module": {
            const { evalModule: e } = t("internal/process/execution");
            i(e(y), void 0, (e) => {
              workerOnGlobalUncaughtException(e, !0);
            });
            break;
          }
          default:
            s(e.argv, 1, 0, y);
            t("internal/modules/cjs/loader").Module.runMain(y);
            break;
        }
      } else if (n.type === f) {
        const { stream: t, chunks: r } = n;
        a(r, ({ chunk: r, encoding: n }) => {
          e[t].push(r, n);
        });
      } else {
        O(n.type === x, `Unknown worker message type ${n.type}`);
        const { stream: t } = n;
        e[t][A]();
      }
    }),
      (e._fatalException = workerOnGlobalUncaughtException),
      h(),
      l(/^/, ""),
      P.start();
  },
  "internal/mime": function (t, e, r, s, n, o) {
    "use strict";
    const {
        FunctionPrototypeCall: a,
        ObjectDefineProperty: i,
        RegExpPrototypeExec: p,
        SafeMap: l,
        SafeStringPrototypeSearch: u,
        StringPrototypeCharAt: c,
        StringPrototypeIndexOf: y,
        StringPrototypeSlice: h,
        StringPrototypeToLowerCase: g,
        SymbolIterator: I,
      } = o,
      { ERR_INVALID_MIME_SYNTAX: M } = e("internal/errors").codes,
      f = /[^!#$%&'*+\-.^_`|~A-Za-z0-9]/g,
      S = /[^\t\u0020-~\u0080-\u00FF]/g,
      m = /[^\r\n\t ]|$/,
      w = /[\r\n\t ]*$/;
    function toASCIILower(t) {
      let e = "";
      for (let r = 0; r < t.length; r++) {
        const s = t[r];
        e += s >= "A" && s <= "Z" ? g(s) : s;
      }
      return e;
    }
    const _ = /[;=]|$/,
      b = /^(?:([\\]$)|[\\][\s\S]|[^"])*(?:(")|$)/u;
    function removeBackslashes(t) {
      let e,
        r = "";
      for (e = 0; e < t.length - 1; e++) {
        const s = t[e];
        "\\" === s ? (e++, (r += t[e])) : (r += s);
      }
      return e === t.length - 1 && (r += t[e]), r;
    }
    const encode = (t) => {
      if (0 === t.length) return '""';
      if (!(-1 !== u(t, f))) return t;
      return `"${(function escapeQuoteOrSolidus(t) {
        let e = "";
        for (let r = 0; r < t.length; r++) {
          const s = t[r];
          e += '"' === s || "\\" === s ? `\\${s}` : s;
        }
        return e;
      })(t)}"`;
    };
    class MIMEParams {
      #t = new l();
      delete(t) {
        this.#t.delete(t);
      }
      get(t) {
        const e = this.#t;
        return e.has(t) ? e.get(t) : null;
      }
      has(t) {
        return this.#t.has(t);
      }
      set(t, e) {
        const r = this.#t;
        e = `${e}`;
        const s = u((t = `${t}`), f);
        if (0 === t.length || -1 !== s) throw new M("parameter name", t, s);
        const n = u(e, S);
        if (-1 !== n) throw new M("parameter value", e, n);
        r.set(t, e);
      }
      *entries() {
        yield* this.#t.entries();
      }
      *keys() {
        yield* this.#t.keys();
      }
      *values() {
        yield* this.#t.values();
      }
      toString() {
        let t = "";
        for (const { 0: e, 1: r } of this.#t) {
          const s = encode(r);
          t.length && (t += ";"), (t += `${e}=${s}`);
        }
        return t;
      }
      static parseParametersString(t, e, r) {
        const s = r.#t,
          n = u(h(t, e), w) + e;
        for (; e < n; ) {
          e += u(h(t, e), m);
          const o = u(h(t, e), _) + e,
            a = toASCIILower(h(t, e, o));
          if ((e = o) < n) {
            const r = c(t, e);
            if (((e += 1), ";" === r)) continue;
          }
          if (e >= n) break;
          let i = null;
          if ('"' === c(t, e)) {
            const r = p(b, h(t, (e += 1)));
            e += r[0].length;
            (i = removeBackslashes(r[1] || r[2] ? h(r[0], 0, -1) : r[0])),
              r[1] && (i += "\\");
          } else {
            const r = y(t, ";", e),
              s = -1 === r ? h(t, e) : h(t, e, r);
            e += s.length;
            const n = h(s, 0, u(s, w));
            if ("" === n) continue;
            i = n;
          }
          "" !== a &&
            -1 === u(a, f) &&
            -1 === u(i, S) &&
            !1 === r.has(a) &&
            s.set(a, i),
            e++;
        }
        return s;
      }
    }
    const d = MIMEParams.prototype.toString;
    i(MIMEParams.prototype, I, {
      __proto__: null,
      configurable: !0,
      value: MIMEParams.prototype.entries,
      writable: !0,
    }),
      i(MIMEParams.prototype, "toJSON", {
        __proto__: null,
        configurable: !0,
        value: d,
        writable: !0,
      });
    const { parseParametersString: P } = MIMEParams;
    delete MIMEParams.parseParametersString;
    class MIMEType {
      #e;
      #r;
      #s;
      constructor(t) {
        const e = (function parseTypeAndSubtype(t) {
          let e = u(t, m);
          const r = y(t, "/", e),
            s = -1 === r ? h(t, e) : h(t, e, r),
            n = u(s, f);
          if ("" === s || -1 !== n || -1 === r) throw new M("type", t, n);
          e = r + 1;
          const o = toASCIILower(s),
            a = y(t, ";", e),
            i = -1 === a ? h(t, e) : h(t, e, a);
          (e += i.length), -1 !== a && (e += 1);
          const p = h(i, 0, u(i, w)),
            l = u(p, f);
          if ("" === p || -1 !== l) throw new M("subtype", t, p);
          return {
            __proto__: null,
            type: o,
            subtype: toASCIILower(p),
            parametersStringIndex: e,
          };
        })((t = `${t}`));
        (this.#e = e.type),
          (this.#r = e.subtype),
          (this.#s = new MIMEParams()),
          P(t, e.parametersStringIndex, this.#s);
      }
      get type() {
        return this.#e;
      }
      set type(t) {
        const e = u((t = `${t}`), f);
        if (0 === t.length || -1 !== e) throw new M("type", t, e);
        this.#e = toASCIILower(t);
      }
      get subtype() {
        return this.#r;
      }
      set subtype(t) {
        const e = u((t = `${t}`), f);
        if (0 === t.length || -1 !== e) throw new M("subtype", t, e);
        this.#r = toASCIILower(t);
      }
      get essence() {
        return `${this.#e}/${this.#r}`;
      }
      get params() {
        return this.#s;
      }
      toString() {
        let t = `${this.#e}/${this.#r}`;
        const e = a(d, this.#s);
        return e.length && (t += `;${e}`), t;
      }
    }
    i(MIMEType.prototype, "toJSON", {
      __proto__: null,
      configurable: !0,
      value: MIMEType.prototype.toString,
      writable: !0,
    }),
      (r.exports = { MIMEParams: MIMEParams, MIMEType: MIMEType });
  },
  "internal/modules/cjs/loader": function (e, t, o, n, r, i) {
    "use strict";
    const {
        ArrayIsArray: l,
        ArrayPrototypeFilter: s,
        ArrayPrototypeIncludes: a,
        ArrayPrototypeIndexOf: u,
        ArrayPrototypeJoin: d,
        ArrayPrototypeMap: c,
        ArrayPrototypePush: p,
        ArrayPrototypePushApply: f,
        ArrayPrototypeSlice: h,
        ArrayPrototypeSplice: _,
        ArrayPrototypeUnshift: m,
        ArrayPrototypeUnshiftApply: y,
        Boolean: g,
        Error: M,
        JSONParse: P,
        ObjectCreate: E,
        ObjectDefineProperty: v,
        ObjectFreeze: R,
        ObjectGetOwnPropertyDescriptor: x,
        ObjectGetPrototypeOf: w,
        ObjectKeys: S,
        ObjectPrototype: O,
        ObjectPrototypeHasOwnProperty: C,
        ObjectSetPrototypeOf: j,
        Proxy: b,
        ReflectApply: k,
        ReflectSet: A,
        RegExpPrototypeExec: D,
        SafeMap: F,
        SafeWeakMap: L,
        String: N,
        Symbol: U,
        StringPrototypeCharAt: q,
        StringPrototypeCharCodeAt: I,
        StringPrototypeEndsWith: T,
        StringPrototypeIndexOf: W,
        StringPrototypeRepeat: $,
        StringPrototypeSlice: B,
        StringPrototypeSplit: z,
        StringPrototypeStartsWith: H,
      } = i,
      J = new L();
    o.exports = {
      wrapSafe: wrapSafe,
      Module: Module,
      cjsParseCache: J,
      get hasLoadedAnyUserCJSModule() {
        return Se;
      },
      initializeCJS: function initializeCJS() {
        const e = G.getCanBeRequiredByUsersWithoutSchemeList();
        (Module.builtinModules = R(e)),
          fe(),
          ve().noGlobalSearchPaths || Module._initPaths();
        Module.runMain = t("internal/modules/run_main").executeUserEntryPoint;
      },
    };
    const { BuiltinModule: G } = t("internal/bootstrap/realm"),
      { maybeCacheSourceMap: V } = t("internal/source_map/source_map_cache"),
      { pathToFileURL: K, fileURLToPath: Q, isURL: X } = t("internal/url"),
      {
        pendingDeprecate: Y,
        emitExperimentalWarning: Z,
        kEmptyObject: ee,
        setOwnProperty: te,
        getLazy: oe,
      } = t("internal/util"),
      {
        internalCompileFunction: ne,
        makeContextifyScript: re,
        runScriptInThisContext: ie,
      } = t("internal/vm"),
      le = t("internal/assert"),
      se = t("fs"),
      ae = t("path"),
      { internalModuleStat: ue } = r("fs"),
      { safeGetenv: de } = r("credentials"),
      {
        privateSymbols: { require_private_symbol: ce },
      } = r("util"),
      {
        getCjsConditions: pe,
        initializeCjsConditions: fe,
        hasEsmSyntax: he,
        loadBuiltinModule: _e,
        makeRequireFunction: me,
        normalizeReferrerURL: ye,
        stripBOM: ge,
        toRealPath: Me,
      } = t("internal/modules/helpers"),
      Pe = t("internal/modules/package_json_reader"),
      { getOptionValue: Ee, getEmbedderOptions: ve } = t("internal/options"),
      Re = oe(() =>
        Ee("--experimental-policy") ? t("internal/process/policy") : null
      ),
      xe = oe(() => n.env.WATCH_REPORT_DEPENDENCIES),
      we = oe(() => t("internal/process/esm_loader").esmLoader);
    let Se = !1;
    const {
        codes: {
          ERR_INVALID_ARG_VALUE: Oe,
          ERR_INVALID_MODULE_SPECIFIER: Ce,
          ERR_REQUIRE_ESM: je,
          ERR_UNKNOWN_BUILTIN_MODULE: be,
        },
        setArrowMessage: ke,
      } = t("internal/errors"),
      { validateString: Ae } = t("internal/validators"),
      {
        CHAR_BACKWARD_SLASH: De,
        CHAR_COLON: Fe,
        CHAR_DOT: Le,
        CHAR_FORWARD_SLASH: Ne,
      } = t("internal/constants"),
      { isProxy: Ue } = t("internal/util/types"),
      { kEvaluated: qe } = r("module_wrap"),
      Ie = "win32" === n.platform,
      Te = E(null);
    let We = 0,
      $e = !1,
      Be = null;
    function internalRequire(e, t) {
      if ((Ae(t, "id"), "" === t))
        throw new Oe("id", t, "must be a non-empty string");
      We++;
      try {
        return Module._load(t, e, !1);
      } finally {
        We--;
      }
    }
    let ze = function stat(e) {
      if (((e = ae.toNamespacedPath(e)), null !== Be)) {
        const t = Be.get(e);
        if (void 0 !== t) return t;
      }
      const t = ue(e);
      return null !== Be && t >= 0 && Be.set(e, t), t;
    };
    function updateChildren(e, t, o) {
      const n = e?.children;
      !n || (o && a(n, t)) || p(n, t);
    }
    function reportModuleToWatchMode(e) {
      xe() && n.send && n.send({ "watch:require": [e] });
    }
    function reportModuleNotFoundToWatchMode(e, t) {
      xe() &&
        n.send &&
        n.send({ "watch:require": c(t, (t) => ae.resolve(`${e}${t}`)) });
    }
    v(Module, "_stat", {
      __proto__: null,
      get: () => ze,
      set: (e) => (Z("Module._stat"), (ze = e), !0),
      configurable: !0,
    });
    const He = new L();
    function Module(e = "", t) {
      let o;
      (this.id = e),
        (this.path = ae.dirname(e)),
        te(this, "exports", {}),
        He.set(this, t),
        updateChildren(t, this, !1),
        (this.filename = null),
        (this.loaded = !1),
        (this.children = []);
      const n = Re()?.manifest;
      if (n) {
        const t = K(e);
        (o = n.getDependencyMapper(t)),
          te(this, "require", me(this, o)),
          te(this.__proto__, "require", me(this, o));
      }
      this[ce] = internalRequire;
    }
    (Module._cache = { __proto__: null }),
      (Module._pathCache = { __proto__: null }),
      (Module._extensions = { __proto__: null });
    let Je = [];
    Module.globalPaths = [];
    let Ge = !1,
      wrap = function (e) {
        return Module.wrapper[0] + e + Module.wrapper[1];
      };
    let Ve = new b(
      [
        "(function (exports, require, module, __filename, __dirname) { ",
        "\n});",
      ],
      {
        __proto__: null,
        set: (e, t, o, n) => ((Ge = !0), A(e, t, o, n)),
        defineProperty: (e, t, o) => ((Ge = !0), v(e, t, o)),
      }
    );
    v(Module, "wrap", {
      __proto__: null,
      get: () => wrap,
      set(e) {
        (Ge = !0), (wrap = e);
      },
    }),
      v(Module, "wrapper", {
        __proto__: null,
        get: () => Ve,
        set(e) {
          (Ge = !0), (Ve = e);
        },
      });
    const Ke = { get: () => $e };
    v(Module.prototype, "isPreloading", Ke), v(G.prototype, "isPreloading", Ke);
    let Qe = t("internal/util/debuglog").debuglog("module", (e) => {
      Qe = e;
    });
    v(Module.prototype, "parent", {
      __proto__: null,
      get: Y(
        function getModuleParent() {
          return He.get(this);
        },
        "module.parent is deprecated due to accuracy issues. Please use require.main to find program entry point instead.",
        "DEP0144"
      ),
      set: Y(
        function setModuleParent(e) {
          He.set(this, e);
        },
        "module.parent is deprecated due to accuracy issues. Please use require.main to find program entry point instead.",
        "DEP0144"
      ),
    }),
      (Module._debug = Y(Qe, "Module._debug is deprecated.", "DEP0077")),
      (Module.isBuiltin = G.isBuiltin);
    let Xe = Pe.readPackage;
    function tryPackage(e, t, o, r) {
      const i = Xe(e).main;
      if (!i) return tryExtensions(ae.resolve(e, "index"), t, o);
      const l = ae.resolve(e, i);
      let s =
        tryFile(l, o) ||
        tryExtensions(l, t, o) ||
        tryExtensions(ae.resolve(l, "index"), t, o);
      if (!1 === s) {
        if (((s = tryExtensions(ae.resolve(e, "index"), t, o)), !s)) {
          const t = new M(
            `Cannot find module '${l}'. Please verify that the package.json has a valid "main" entry`
          );
          throw (
            ((t.code = "MODULE_NOT_FOUND"),
            (t.path = ae.resolve(e, "package.json")),
            (t.requestPath = r),
            t)
          );
        }
        {
          const t = ae.resolve(e, "package.json");
          n.emitWarning(
            `Invalid 'main' field in '${t}' of '${i}'. Please either fix that or report it to the module author`,
            "DeprecationWarning",
            "DEP0128"
          );
        }
      }
      return s;
    }
    function tryFile(e, t) {
      if (0 === ze(e))
        return Ee("--preserve-symlinks") && !t ? ae.resolve(e) : Me(e);
    }
    function tryExtensions(e, t, o) {
      for (let n = 0; n < t.length; n++) {
        const r = tryFile(e + t[n], o);
        if (r) return r;
      }
      return !1;
    }
    v(Module, "_readPackage", {
      __proto__: null,
      get: () => Xe,
      set: (e) => (Z("Module._readPackage"), (Xe = e), !0),
      configurable: !0,
    });
    const Ye = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;
    function resolveExports(e, o) {
      const { 1: n, 2: r = "" } = D(Ye, o) || ee;
      if (!n) return;
      const i = ae.resolve(e, n),
        l = Xe(i);
      if (l.exists && null != l.exports)
        try {
          const { packageExportsResolve: e } = t(
            "internal/modules/esm/resolve"
          );
          return finalizeEsmResolution(
            e(K(i + "/package.json"), "." + r, l, null, pe()),
            null,
            i
          );
        } catch (e) {
          if ("ERR_MODULE_NOT_FOUND" === e.code)
            throw createEsmNotFoundErr(o, i + "/package.json");
          throw e;
        }
    }
    Module._findPath = function (e, t, o) {
      const n = ae.isAbsolute(e);
      if (n) t = [""];
      else if (!t || 0 === t.length) return !1;
      const r = e + "\0" + d(t, "\0"),
        i = Module._pathCache[r];
      if (i) return i;
      let l;
      const s =
        e.length > 0 &&
        (I(e, e.length - 1) === Ne ||
          (I(e, e.length - 1) === Le &&
            (1 === e.length ||
              I(e, e.length - 2) === Ne ||
              (I(e, e.length - 2) === Le &&
                (2 === e.length || I(e, e.length - 3) === Ne)))));
      let a = !0;
      if (
        I(e, 0) === Le &&
        (1 === e.length ||
          I(e, 1) === Ne ||
          (Ie && I(e, 1) === De) ||
          (I(e, 1) === Le &&
            (2 === e.length || I(e, 2) === Ne || (Ie && I(e, 2) === De))))
      ) {
        const t = ae.normalize(e);
        H(t, "..") && (a = !1);
      }
      for (let i = 0; i < t.length; i++) {
        const u = t[i];
        if (a && u && ze(u) < 1) continue;
        if (!n) {
          const t = resolveExports(u, e);
          if (t) return t;
        }
        const d = ae.resolve(u, e);
        let c;
        const p = ze(d);
        if (
          (s ||
            (0 === p &&
              (c = o
                ? Ee("--preserve-symlinks-main")
                  ? ae.resolve(d)
                  : Me(d)
                : Ee("--preserve-symlinks")
                ? ae.resolve(d)
                : Me(d)),
            c ||
              (void 0 === l && (l = S(Module._extensions)),
              (c = tryExtensions(d, l, o)))),
          c ||
            1 !== p ||
            (void 0 === l && (l = S(Module._extensions)),
            (c = tryPackage(d, l, o, e))),
          c)
        )
          return (Module._pathCache[r] = c), c;
        const h = [""];
        void 0 !== l && f(h, l), reportModuleNotFoundToWatchMode(d, h);
      }
      return !1;
    };
    const Ze = [115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110],
      et = Ze.length;
    function emitCircularRequireWarning(e) {
      n.emitWarning(
        `Accessing non-existent property '${N(
          e
        )}' of module exports inside circular dependency`
      );
    }
    (Module._nodeModulePaths = Ie
      ? function (e) {
          if (
            ((e = ae.resolve(e)),
            I(e, e.length - 1) === De && I(e, e.length - 2) === Fe)
          )
            return [e + "node_modules"];
          const t = [];
          for (let o = e.length - 1, n = 0, r = e.length; o >= 0; --o) {
            const i = I(e, o);
            i === De || i === Ne || i === Fe
              ? (n !== et && p(t, B(e, 0, r) + "\\node_modules"),
                (r = o),
                (n = 0))
              : -1 !== n && (Ze[n] === i ? ++n : (n = -1));
          }
          return t;
        }
      : function (e) {
          if ("/" === (e = ae.resolve(e))) return ["/node_modules"];
          const t = [];
          for (let o = e.length - 1, n = 0, r = e.length; o >= 0; --o) {
            const i = I(e, o);
            i === Ne
              ? (n !== et && p(t, B(e, 0, r) + "/node_modules"),
                (r = o),
                (n = 0))
              : -1 !== n && (Ze[n] === i ? ++n : (n = -1));
          }
          return p(t, "/node_modules"), t;
        }),
      (Module._resolveLookupPaths = function (e, t) {
        if (G.normalizeRequirableId(e))
          return Qe("looking for %j in []", e), null;
        if (
          "." !== q(e, 0) ||
          (e.length > 1 &&
            "." !== q(e, 1) &&
            "/" !== q(e, 1) &&
            (!Ie || "\\" !== q(e, 1)))
        ) {
          let o;
          return (
            t?.paths?.length ? ((o = h(Je)), y(o, t.paths)) : (o = Je),
            Qe("looking for %j in %j", e, o),
            o.length > 0 ? o : null
          );
        }
        if (!t || !t.id || !t.filename) {
          const t = ["."];
          return Qe("looking for %j in %j", e, t), t;
        }
        Qe("RELATIVE: requested: %s from parent.id %s", e, t.id);
        const o = [ae.dirname(t.filename)];
        return Qe("looking for %j", o), o;
      });
    const tt = new b(
      {},
      {
        __proto__: null,
        get(e, t) {
          if (t in e || "__esModule" === t) return e[t];
          emitCircularRequireWarning(t);
        },
        getOwnPropertyDescriptor(e, t) {
          if (C(e, t) || "__esModule" === t) return x(e, t);
          emitCircularRequireWarning(t);
        },
      }
    );
    function getExportsForCircularRequire(e) {
      return (
        !e.exports ||
          Ue(e.exports) ||
          w(e.exports) !== O ||
          e.exports.__esModule ||
          j(e.exports, tt),
        e.exports
      );
    }
    function finalizeEsmResolution(e, o, n) {
      const { encodedSepRegEx: r } = t("internal/modules/esm/resolve");
      if (null !== D(r, e))
        throw new Ce(e, 'must not include encoded "/" or "\\" characters', o);
      const i = Q(e),
        l = tryFile(i);
      if (l) return l;
      throw createEsmNotFoundErr(i, ae.resolve(n, "package.json"));
    }
    function createEsmNotFoundErr(e, t) {
      const o = new M(`Cannot find module '${e}'`);
      return (o.code = "MODULE_NOT_FOUND"), t && (o.path = t), o;
    }
    let ot;
    (Module._load = function (e, t, o) {
      let r;
      if (t) {
        Qe("Module._load REQUEST %s parent: %s", e, t.id),
          (r = `${t.path}\0${e}`);
        const o = Te[r];
        if ((reportModuleToWatchMode(o), void 0 !== o)) {
          const e = Module._cache[o];
          if (void 0 !== e)
            return (
              updateChildren(t, e, !0),
              e.loaded ? e.exports : getExportsForCircularRequire(e)
            );
          delete Te[r];
        }
      }
      if (H(e, "node:")) {
        const t = B(e, 5);
        if (!G.canBeRequiredByUsers(t)) throw new be(e);
        return _e(t, e).exports;
      }
      const i = Module._resolveFilename(e, t, o),
        s = Module._cache[i];
      if (void 0 !== s) {
        if ((updateChildren(t, s, !0), s.loaded)) return s.exports;
        {
          const e = J.get(s);
          if (!e || e.loaded) return getExportsForCircularRequire(s);
          e.loaded = !0;
        }
      }
      if (G.canBeRequiredWithoutScheme(i)) {
        return _e(i, e).exports;
      }
      const a = s || new Module(i, t);
      o &&
        (te(n, "mainModule", a),
        te(a.require, "main", n.mainModule),
        (a.id = ".")),
        reportModuleToWatchMode(i),
        (Module._cache[i] = a),
        void 0 !== t && (Te[r] = i);
      let d = !0;
      try {
        a.load(i), (d = !1);
      } finally {
        if (d) {
          if ((delete Module._cache[i], void 0 !== t)) {
            delete Te[r];
            const e = t?.children;
            if (l(e)) {
              const t = u(e, a);
              -1 !== t && _(e, t, 1);
            }
          }
        } else
          a.exports && !Ue(a.exports) && w(a.exports) === tt && j(a.exports, O);
      }
      return a.exports;
    }),
      (Module._resolveFilename = function (e, o, r, i) {
        if (G.normalizeRequirableId(e)) return e;
        let s;
        if ("object" == typeof i && null !== i)
          if (l(i.paths)) {
            if (
              H(e, "./") ||
              H(e, "../") ||
              (Ie && H(e, ".\\")) ||
              H(e, "..\\")
            )
              s = i.paths;
            else {
              const t = new Module("", null);
              s = [];
              for (let o = 0; o < i.paths.length; o++) {
                const n = i.paths[o];
                t.paths = Module._nodeModulePaths(n);
                const r = Module._resolveLookupPaths(e, t);
                for (let e = 0; e < r.length; e++) a(s, r[e]) || p(s, r[e]);
              }
            }
          } else {
            if (void 0 !== i.paths) throw new Oe("options.paths", i.paths);
            s = Module._resolveLookupPaths(e, o);
          }
        else s = Module._resolveLookupPaths(e, o);
        if ("#" === e[0] && (o?.filename || "<repl>" === o?.id)) {
          const r = o?.filename ?? n.cwd() + ae.sep,
            i = Pe.readPackageScope(r) || { __proto__: null };
          if (null != i.data?.imports)
            try {
              const { packageImportsResolve: o } = t(
                "internal/modules/esm/resolve"
              );
              return finalizeEsmResolution(o(e, K(r), pe()), r, i.path);
            } catch (t) {
              if ("ERR_MODULE_NOT_FOUND" === t.code)
                throw createEsmNotFoundErr(e);
              throw t;
            }
        }
        const u = (function trySelfParentPath(e) {
            if (!e) return !1;
            if (e.filename) return e.filename;
            if ("<repl>" === e.id || "internal/preload" === e.id)
              try {
                return n.cwd() + ae.sep;
              } catch {
                return !1;
              }
          })(o),
          c = (function trySelf(e, o) {
            if (!e) return !1;
            const { data: n, path: r } = Pe.readPackageScope(e);
            if (!n || null == n.exports || void 0 === n.name) return !1;
            let i;
            if (o === n.name) i = ".";
            else {
              if (!H(o, `${n.name}/`)) return !1;
              i = "." + B(o, n.name.length);
            }
            try {
              const { packageExportsResolve: o } = t(
                "internal/modules/esm/resolve"
              );
              return finalizeEsmResolution(
                o(K(r + "/package.json"), i, n, K(e), pe()),
                e,
                r
              );
            } catch (e) {
              if ("ERR_MODULE_NOT_FOUND" === e.code)
                throw createEsmNotFoundErr(o, r + "/package.json");
              throw e;
            }
          })(u, e);
        if (c) {
          const t = e + "\0" + (1 === s.length ? s[0] : d(s, "\0"));
          return (Module._pathCache[t] = c), c;
        }
        const f = Module._findPath(e, s, r);
        if (f) return f;
        const h = [];
        for (let e = o; e; e = He.get(e)) p(h, e.filename || e.id);
        let _ = `Cannot find module '${e}'`;
        h.length > 0 && (_ = _ + "\nRequire stack:\n- " + d(h, "\n- "));
        const m = new M(_);
        throw ((m.code = "MODULE_NOT_FOUND"), (m.requireStack = h), m);
      }),
      (Module.prototype.load = function (e) {
        Qe("load %j for module %j", e, this.id),
          le(!this.loaded),
          (this.filename = e),
          (this.paths = Module._nodeModulePaths(ae.dirname(e)));
        const t = (function findLongestRegisteredExtension(e) {
          const t = ae.basename(e);
          let o,
            n,
            r = 0;
          for (; -1 !== (n = W(t, ".", r)); )
            if (
              ((r = n + 1), 0 !== n && ((o = B(t, n)), Module._extensions[o]))
            )
              return o;
          return ".js";
        })(e);
        if (T(e, ".mjs") && !Module._extensions[".mjs"]) throw new je(e, !0);
        Module._extensions[t](this, e), (this.loaded = !0);
        const n = we(),
          r = this.exports;
        (void 0 === o?.module || o.module.getStatus() < qe) &&
          !n.cjsCache.has(this) &&
          n.cjsCache.set(this, r);
      }),
      (Module.prototype.require = function (e) {
        if ((Ae(e, "id"), "" === e))
          throw new Oe("id", e, "must be a non-empty string");
        We++;
        try {
          return Module._load(e, this, !1);
        } finally {
          We--;
        }
      });
    let nt = !1;
    function wrapSafe(e, o, r) {
      const i = U(`cjs:${e}`);
      async function importModuleDynamically(t, o, n) {
        return we().import(t, ye(e), n);
      }
      if (Ge) {
        const t = Module.wrap(o),
          n = re(t, e, 0, 0, void 0, !1, void 0, i, importModuleDynamically);
        return (
          n.sourceMapURL && V(e, o, this, !1, void 0, n.sourceMapURL),
          ie(n, !0, !1)
        );
      }
      const l = ["exports", "require", "module", "__filename", "__dirname"];
      try {
        const t = ne(
          o,
          e,
          0,
          0,
          void 0,
          !1,
          void 0,
          void 0,
          l,
          i,
          importModuleDynamically
        );
        return (
          t.sourceMapURL && V(e, o, this, !1, void 0, t.sourceMapURL),
          t.function
        );
      } catch (e) {
        if (n.mainModule === r) {
          const { enrichCJSError: n } = t("internal/modules/esm/translators");
          n(e, o);
        }
        throw e;
      }
    }
    (Module.prototype._compile = function (e, t) {
      let o, i;
      const s = Re()?.manifest;
      s &&
        ((o = K(t)), (i = s.getDependencyMapper(o)), s.assertIntegrity(o, e));
      const a = wrapSafe(t, e, this);
      let u = null;
      if (Ee("--inspect-brk") && null == n._eval) {
        if (!ot)
          if (n.argv[1])
            try {
              ot = Module._resolveFilename(n.argv[1], null, !1);
            } catch {
              le(l(Ee("--require")));
            }
          else ot = "repl";
        ot &&
          !nt &&
          t === ot &&
          ((nt = !0), (u = r("inspector").callAndPauseOnStart));
      }
      const d = ae.dirname(t),
        c = me(this, i);
      let p;
      const f = this.exports,
        h = f,
        _ = this;
      return (
        0 === We && (Be = new F()),
        (p = u ? u(a, h, f, c, _, t, d) : k(a, h, [f, c, _, t, d])),
        (Se = !0),
        0 === We && (Be = null),
        p
      );
    }),
      (Module._extensions[".js"] = function (e, t) {
        const o = J.get(e);
        let n;
        if (
          (o?.source
            ? ((n = o.source), (o.source = void 0))
            : (n = se.readFileSync(t, "utf8")),
          T(t, ".js"))
        ) {
          const o = Pe.readPackageScope(t) || { __proto__: null };
          if ("module" === o.data?.type) {
            const r = He.get(e),
              i = r?.filename,
              l = ae.resolve(o.path, "package.json"),
              s = he(n),
              a = new je(t, s, i, l);
            if (Module._cache[i]) {
              let e;
              try {
                e = se.readFileSync(i, "utf8");
              } catch {}
              if (e) {
                const t = z(B(a.stack, W(a.stack, "    at ")), "\n", 1)[0],
                  { 1: o, 2: n } = D(/(\d+):(\d+)\)/, t) || [];
                if (o && n) {
                  const t = `${i}:${o}\n${z(e, "\n")[o - 1]}\n${$(
                    " ",
                    n - 1
                  )}^\n`;
                  ke(a, t);
                }
              }
            }
            throw a;
          }
        }
        e._compile(n, t);
      }),
      (Module._extensions[".json"] = function (e, t) {
        const o = se.readFileSync(t, "utf8"),
          n = Re()?.manifest;
        if (n) {
          const e = K(t);
          n.assertIntegrity(e, o);
        }
        try {
          te(e, "exports", P(ge(o)));
        } catch (e) {
          throw ((e.message = t + ": " + e.message), e);
        }
      }),
      (Module._extensions[".node"] = function (e, t) {
        const o = Re()?.manifest;
        if (o) {
          const e = se.readFileSync(t),
            n = K(t);
          o.assertIntegrity(n, e);
        }
        return n.dlopen(e, ae.toNamespacedPath(t));
      });
    const rt =
      "must be a file URL object, file URL string, or absolute path string";
    (Module.createRequire = function createRequire(e) {
      let t;
      if (X(e) || ("string" == typeof e && !ae.isAbsolute(e)))
        try {
          t = Q(e);
        } catch {
          throw new Oe("filename", e, rt);
        }
      else {
        if ("string" != typeof e) throw new Oe("filename", e, rt);
        t = e;
      }
      return (function createRequireFromPath(e) {
        const t = T(e, "/") || (Ie && T(e, "\\")) ? ae.join(e, "noop.js") : e,
          o = new Module(t);
        return (
          (o.filename = t),
          (o.paths = Module._nodeModulePaths(o.path)),
          me(o, null)
        );
      })(t);
    }),
      (Module._initPaths = function () {
        const e = Ie ? n.env.USERPROFILE : de("HOME"),
          t = Ie ? n.env.NODE_PATH : de("NODE_PATH"),
          o = Ie
            ? ae.resolve(n.execPath, "..")
            : ae.resolve(n.execPath, "..", ".."),
          r = [ae.resolve(o, "lib", "node")];
        e &&
          (m(r, ae.resolve(e, ".node_libraries")),
          m(r, ae.resolve(e, ".node_modules"))),
          t && y(r, s(z(t, ae.delimiter), g)),
          (Je = r),
          (Module.globalPaths = h(Je));
      }),
      (Module._preloadModules = function (e) {
        if (!l(e)) return;
        $e = !0;
        const t = new Module("internal/preload", null);
        try {
          t.paths = Module._nodeModulePaths(n.cwd());
        } catch (e) {
          if ("ENOENT" !== e.code) throw (($e = !1), e);
        }
        for (let o = 0; o < e.length; o++) internalRequire(t, e[o]);
        $e = !1;
      }),
      (Module.syncBuiltinESMExports = function syncBuiltinESMExports() {
        for (const e of G.map.values())
          G.canBeRequiredWithoutScheme(e.id) && e.syncExports();
      }),
      v(Module.prototype, "constructor", {
        __proto__: null,
        get: function () {
          return Re() ? void 0 : Module;
        },
        configurable: !1,
        enumerable: !1,
      }),
      (Module.Module = Module);
  },
  "internal/modules/esm/assert": function (t, e, r, n, o, a) {
    "use strict";
    const {
        ArrayPrototypeFilter: i,
        ArrayPrototypeIncludes: s,
        ObjectKeys: _,
        ObjectValues: l,
        ObjectPrototypeHasOwnProperty: p,
      } = a,
      { validateString: c } = e("internal/validators"),
      {
        ERR_IMPORT_ASSERTION_TYPE_FAILED: T,
        ERR_IMPORT_ASSERTION_TYPE_MISSING: y,
        ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED: R,
        ERR_IMPORT_ATTRIBUTE_UNSUPPORTED: u,
      } = e("internal/errors").codes,
      I = "javascript",
      d = {
        __proto__: null,
        builtin: I,
        commonjs: I,
        json: "json",
        module: I,
        wasm: I,
      },
      P = i(l(d), (t) => t !== I);
    function handleInvalidType(t, e) {
      if ((c(e, "type"), !s(P, e))) throw new R(e);
      throw new T(t, e);
    }
    r.exports = {
      kImplicitAssertType: I,
      validateAttributes: function validateAttributes(
        t,
        e,
        r = { __proto__: null }
      ) {
        const n = _(r);
        for (let t = 0; t < n.length; t++)
          if ("type" !== n[t]) throw new u(n[t], r[n[t]]);
        const o = d[e];
        switch (o) {
          case void 0:
            return !0;
          case I:
            return !p(r, "type") || handleInvalidType(t, r.type);
          case r.type:
            return !0;
          default:
            if (!p(r, "type")) throw new y(t, o);
            return handleInvalidType(t, r.type);
        }
      },
    };
  },
  "internal/modules/esm/create_dynamic_module": function (t, e, o, r, n, p) {
    "use strict";
    const {
      ArrayPrototypeJoin: i,
      ArrayPrototypeMap: s,
      JSONStringify: a,
      ObjectCreate: l,
      SafeSet: m,
    } = p;
    let u = e("internal/util/debuglog").debuglog("esm", (t) => {
      u = t;
    });
    function createImport(t, e) {
      const o = a(t);
      return `import * as $import_${e} from ${o};\nimport.meta.imports[${o}] = $import_${e};`;
    }
    function createExport(t, e) {
      const o = a(t);
      return `let $export_${e};\nexport { $export_${e} as ${o} };\nimport.meta.exports[${o}] = {\n  get: () => $export_${e},\n  set: (v) => $export_${e} = v,\n};`;
    }
    o.exports = (t, o, r = "", p) => {
      u("creating ESM facade for %s with exports: %j", r, o);
      const a = `\n${i(s(t, createImport), "\n")}\n${i(
          s(o, createExport),
          "\n"
        )}\nimport.meta.done();\n`,
        { ModuleWrap: $ } = n("module_wrap"),
        c = new $(`${r}`, void 0, a, 0, 0),
        _ = new m(),
        d = {
          exports: l(null),
          onReady: (t) => {
            _.add(t);
          },
        };
      t.length && (d.imports = { __proto__: null });
      const { registerModule: x } = e("internal/modules/esm/utils");
      return (
        x(c, {
          __proto__: null,
          initializeImportMeta: (t, e) => {
            (t.exports = d.exports),
              d.imports && (t.imports = d.imports),
              (t.done = () => {
                p(d), (d.onReady = (t) => t(d));
                for (const t of _) _.delete(t), t(d);
              });
          },
        }),
        { module: c, reflect: d }
      );
    };
  },
  "internal/modules/esm/fetch_module": function (e, t, n, o, r, s) {
    "use strict";
    const {
        ObjectPrototypeHasOwnProperty: c,
        PromisePrototypeThen: a,
        SafeMap: i,
        StringPrototypeEndsWith: d,
        StringPrototypeSlice: h,
        StringPrototypeStartsWith: p,
      } = s,
      {
        Buffer: { concat: u },
      } = t("buffer"),
      {
        ERR_NETWORK_IMPORT_DISALLOWED: f,
        ERR_NETWORK_IMPORT_BAD_RESPONSE: l,
        ERR_MODULE_NOT_FOUND: w,
      } = t("internal/errors").codes,
      { URL: y } = t("internal/url"),
      R = t("net"),
      { once: g } = t("events"),
      { compose: T } = t("stream"),
      P = new i();
    let m, _, E;
    function HTTPSGet(e, n) {
      const o = t("https");
      return (
        (m ??= new o.Agent({ keepAlive: !0 })), o.get(e, { agent: m, ...n })
      );
    }
    function HTTPGet(e, n) {
      const o = t("http");
      return (
        (_ ??= new o.Agent({ keepAlive: !0 })), o.get(e, { agent: _, ...n })
      );
    }
    function dnsLookup(e, n) {
      return (dnsLookup = t("dns/promises").lookup)(e, n);
    }
    function createBrotliDecompress() {
      return (
        (E ??= t("zlib")), (createBrotliDecompress = E.createBrotliDecompress)()
      );
    }
    function createUnzip() {
      return (E ??= t("zlib")), (createUnzip = E.createUnzip)();
    }
    function fetchWithRedirects(e) {
      const t = P.get(e.href);
      if (t) return t;
      const n = "http:" === e.protocol ? HTTPGet : HTTPSGet,
        o = (async () => {
          const t = n(e, { headers: { Accept: "*/*" } }),
            { 0: o } = await g(t, "response");
          try {
            const t = c(o.headers, "location");
            if (
              (function isRedirect(e) {
                switch (e) {
                  case 300:
                  case 301:
                  case 302:
                  case 303:
                  case 307:
                  case 308:
                    return !0;
                  default:
                    return !1;
                }
              })(o.statusCode) &&
              t
            ) {
              const t = new y(o.headers.location, e);
              if ("http:" !== t.protocol && "https:" !== t.protocol)
                throw new f(
                  o.headers.location,
                  e.href,
                  "cannot redirect to non-network location"
                );
              const n = await fetchWithRedirects(t);
              return P.set(e.href, n), n;
            }
            if (404 === o.statusCode) {
              const t = new w(e.href, null, e);
              throw (
                ((t.message = `Cannot find module '${e.href}', HTTP 404`), t)
              );
            }
            if (o.statusCode < 200 || o.statusCode >= 300)
              throw new f(
                o.headers.location,
                e.href,
                "cannot redirect to non-network location"
              );
            const { headers: n } = o;
            if (!n["content-type"])
              throw new l(e.href, "the 'Content-Type' header is required");
            const r = {
              resolvedHREF: e.href,
              headers: { "content-type": o.headers["content-type"] },
              body: (async () => {
                let e = o;
                "br" === o.headers["content-encoding"]
                  ? (e = T(o, createBrotliDecompress()))
                  : ("gzip" !== o.headers["content-encoding"] &&
                      "deflate" !== o.headers["content-encoding"]) ||
                    (e = T(o, createUnzip()));
                const t = await e.toArray(),
                  n = u(t);
                return (r.body = n), n;
              })(),
            };
            return P.set(e.href, r), await r.body, r;
          } finally {
            t.destroy();
          }
        })();
      return P.set(e.href, o), o;
    }
    const O = new R.BlockList();
    O.addAddress("::1", "ipv6"),
      O.addRange("127.0.0.1", "127.255.255.255"),
      (n.exports = {
        fetchModule: function fetchModule(e, { parentURL: t }) {
          const { href: n } = e,
            o = P.get(n);
          return (
            o ||
            ("http:" === e.protocol
              ? a(
                  (async function isLocalAddress(e) {
                    try {
                      p(e, "[") && d(e, "]") && (e = h(e, 1, -1));
                      const t = await dnsLookup(e, { verbatim: !0 }),
                        n = 4 === t.family ? "ipv4" : "ipv6";
                      return O.check(t.address, n);
                    } catch {}
                    return !1;
                  })(e.hostname),
                  (o) => {
                    if (!0 !== o)
                      throw new f(
                        n,
                        t,
                        "http can only be used to load local resources (use https instead)."
                      );
                    return fetchWithRedirects(e);
                  }
                )
              : fetchWithRedirects(e))
          );
        },
      });
  },
  "internal/modules/esm/formats": function (o, n, t, e, s, m) {
    "use strict";
    const { RegExpPrototypeExec: a, Uint8Array: i } = m,
      { getOptionValue: r } = n("internal/options"),
      { closeSync: l, openSync: c, readSync: u } = n("fs"),
      p = r("--experimental-wasm-modules"),
      j = {
        __proto__: null,
        ".cjs": "commonjs",
        ".js": "module",
        ".json": "json",
        ".mjs": "module",
      },
      f = {
        __proto__: null,
        ".cjs": "commonjs",
        ".js": "commonjs",
        ".json": "commonjs",
        ".mjs": "module",
        ".node": "commonjs",
      };
    p && (j[".wasm"] = f[".wasm"] = "wasm"),
      (t.exports = {
        extensionFormatMap: j,
        getFormatOfExtensionlessFile: function getFormatOfExtensionlessFile(o) {
          if (!p) return "module";
          const n = new i(4);
          let t;
          try {
            if (
              ((t = c(o)),
              u(t, n, 0, 4),
              0 === n[0] && 97 === n[1] && 115 === n[2] && 109 === n[3])
            )
              return "wasm";
          } finally {
            void 0 !== t && l(t);
          }
          return "module";
        },
        getLegacyExtensionFormat: function getLegacyExtensionFormat(o) {
          return f[o];
        },
        legacyExtensionFormatMap: f,
        mimeToFormat: function mimeToFormat(o) {
          return null !==
            a(
              /^\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?$/i,
              o
            )
            ? "module"
            : "application/json" === o
            ? "json"
            : p && "application/wasm" === o
            ? "wasm"
            : null;
        },
      });
  },
  "internal/modules/esm/get_format": function (e, t, o, n, r, l) {
    "use strict";
    const {
        RegExpPrototypeExec: u,
        ObjectPrototypeHasOwnProperty: s,
        PromisePrototypeThen: m,
        PromiseResolve: a,
        StringPrototypeIncludes: c,
        StringPrototypeCharCodeAt: i,
        StringPrototypeSlice: d,
      } = l,
      { getOptionValue: p } = t("internal/options"),
      {
        extensionFormatMap: f,
        getFormatOfExtensionlessFile: F,
        getLegacyExtensionFormat: g,
        mimeToFormat: h,
      } = t("internal/modules/esm/formats"),
      P = p("--experimental-network-imports"),
      x = p("--experimental-specifier-resolution"),
      _ = "module" === p("--experimental-default-type") ? "module" : "commonjs",
      { getPackageType: y } = t("internal/modules/esm/resolve"),
      { fileURLToPath: M } = t("internal/url"),
      { ERR_UNKNOWN_FILE_EXTENSION: j } = t("internal/errors").codes,
      E = {
        __proto__: null,
        "data:": function getDataProtocolModuleFormat(e) {
          const { 1: t } = u(
            /^([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/,
            e.pathname
          ) || [null, null, null];
          return h(t);
        },
        "file:": function getFileProtocolModuleFormat(e, t, o) {
          const n = extname(e);
          if (".js" === n) {
            const t = y(e);
            return "none" !== t
              ? t
              : "module" === _
              ? underNodeModules(e)
                ? "commonjs"
                : "module"
              : "commonjs";
          }
          if ("" === n) {
            const t = y(e);
            return "commonjs" === _
              ? "none" === t || "commonjs" === t
                ? "commonjs"
                : F(e)
              : underNodeModules(e)
              ? "module" === t
                ? F(e)
                : "commonjs"
              : "none" === t || "module" === t
              ? F(e)
              : "commonjs";
          }
          const r = f[n];
          if (r) return r;
          if ("node" !== x) {
            if (o) return;
            const t = M(e);
            throw new j(n, t);
          }
          return g(n) ?? null;
        },
        "http:": getHttpProtocolModuleFormat,
        "https:": getHttpProtocolModuleFormat,
        "node:": () => "builtin",
      };
    const N = 46,
      O = 47;
    function extname(e) {
      const { pathname: t } = e;
      for (let e = t.length - 1; e > 0; e--)
        switch (i(t, e)) {
          case O:
            return "";
          case N:
            return i(t, e - 1) === O ? "" : d(t, e);
        }
      return "";
    }
    function underNodeModules(e) {
      return "file:" === e.protocol && c(e.pathname, "/node_modules/");
    }
    function getHttpProtocolModuleFormat(e, o) {
      if (P) {
        const { fetchModule: n } = t("internal/modules/esm/fetch_module");
        return m(a(n(e, o)), (e) => h(e.headers["content-type"]));
      }
    }
    o.exports = {
      defaultGetFormat: function defaultGetFormat(e, t) {
        const o = e.protocol;
        return s(E, o) ? E[o](e, t, !1) : null;
      },
      defaultGetFormatWithoutErrors: function defaultGetFormatWithoutErrors(
        e,
        t
      ) {
        const o = e.protocol;
        return s(E, o) ? E[o](e, t, !0) : null;
      },
      extensionFormatMap: f,
      extname: extname,
    };
  },
  "internal/modules/esm/handle_process_exit": function (e, t, s, i, n, o) {
    "use strict";
    s.exports = {
      handleProcessExit: function handleProcessExit() {
        i.exitCode ??= 13;
      },
    };
  },
  "internal/modules/esm/hooks": function (e, t, r, o, i, n) {
    "use strict";
    const {
        ArrayPrototypePush: s,
        ArrayPrototypePushApply: a,
        FunctionPrototypeCall: l,
        Int32Array: c,
        ObjectAssign: d,
        ObjectDefineProperty: h,
        ObjectSetPrototypeOf: u,
        Promise: f,
        ReflectSet: p,
        SafeSet: w,
        StringPrototypeSlice: m,
        StringPrototypeStartsWith: g,
        StringPrototypeToUpperCase: k,
        globalThis: _,
      } = n,
      {
        Atomics: { load: y, wait: R, waitAsync: A },
        SharedArrayBuffer: I,
      } = _,
      {
        ERR_INTERNAL_ASSERTION: v,
        ERR_INVALID_ARG_TYPE: E,
        ERR_INVALID_ARG_VALUE: b,
        ERR_INVALID_RETURN_PROPERTY_VALUE: L,
        ERR_INVALID_RETURN_VALUE: P,
        ERR_LOADER_CHAIN_INCOMPLETE: M,
        ERR_METHOD_NOT_IMPLEMENTED: N,
        ERR_UNKNOWN_BUILTIN_MODULE: O,
        ERR_WORKER_UNSERIALIZABLE_ERROR: U,
      } = t("internal/errors").codes,
      { URL: x } = t("internal/url"),
      { canParse: S } = i("url"),
      { receiveMessageOnPort: C } = t("worker_threads"),
      { isAnyArrayBuffer: F, isArrayBufferView: T } = t("internal/util/types"),
      { validateObject: z, validateString: H } = t("internal/validators"),
      { emitExperimentalWarning: W, kEmptyObject: $ } = t("internal/util"),
      { defaultResolve: D, throwIfInvalidParentURL: j } = t(
        "internal/modules/esm/resolve"
      ),
      { getDefaultConditions: B, loaderWorkerId: V } = t(
        "internal/modules/esm/utils"
      ),
      { deserializeError: q } = t("internal/error_serdes"),
      { SHARED_MEMORY_BYTE_LENGTH: G, WORKER_TO_MAIN_THREAD_NOTIFICATION: Y } =
        t("internal/modules/esm/shared_constants");
    let K,
      Z,
      J = t("internal/util/debuglog").debuglog("esm", (e) => {
        J = e;
      }),
      Q = !1;
    function emitImportAssertionWarning() {
      Q ||
        ((Q = !0),
        o.emitWarning(
          "Use `importAttributes` instead of `importAssertions`",
          "ExperimentalWarning"
        ));
    }
    class Hooks {
      #e = {
        globalPreload: [],
        resolve: [{ fn: D, url: "node:internal/modules/esm/resolve" }],
        load: [
          {
            fn: t("internal/modules/esm/load").defaultLoad,
            url: "node:internal/modules/esm/load",
          },
        ],
      };
      #t = new w();
      allowImportMetaResolve = !1;
      async register(e, r, o) {
        const i = t("internal/process/esm_loader").esmLoader,
          n = await i.import(e, r, $);
        await this.addCustomLoader(e, n, o);
      }
      addCustomLoader(e, t, r) {
        const {
          globalPreload: o,
          initialize: i,
          resolve: n,
          load: a,
        } = (function pluckHooks({
          globalPreload: e,
          initialize: t,
          resolve: r,
          load: o,
        }) {
          const i = { __proto__: null };
          e && (i.globalPreload = e);
          r && (i.resolve = r);
          o && (i.load = o);
          t && (i.initialize = t);
          return i;
        })(t);
        if (
          (o &&
            !i &&
            (W(
              "`globalPreload` is planned for removal in favor of `initialize`. `globalPreload`"
            ),
            s(this.#e.globalPreload, { __proto__: null, fn: o, url: e })),
          n)
        ) {
          const t = this.#e.resolve[this.#e.resolve.length - 1];
          s(this.#e.resolve, { __proto__: null, fn: n, url: e, next: t });
        }
        if (a) {
          const t = this.#e.load[this.#e.load.length - 1];
          s(this.#e.load, { __proto__: null, fn: a, url: e, next: t });
        }
        return i?.(r);
      }
      initializeGlobalPreload() {
        const e = [];
        for (let r = this.#e.globalPreload.length - 1; r >= 0; r--) {
          const { MessageChannel: o } = t("internal/worker/io"),
            i = new o(),
            { port1: n, port2: a } = i;
          n.unref(), a.unref();
          const { fn: l, url: c } = this.#e.globalPreload[r],
            d = l({ port: a });
          if (null != d) {
            if ("string" != typeof d)
              throw new P("a string", `${c} globalPreload`, l);
            s(e, { code: d, port: n });
          }
        }
        return e;
      }
      async resolve(e, t, r = { __proto__: null }) {
        j(t);
        const o = this.#e.resolve,
          i = { conditions: B(), importAttributes: r, parentURL: t },
          n = {
            chainFinished: null,
            context: i,
            hookErrIdentifier: "",
            hookName: "resolve",
            shortCircuited: !1,
          },
          validateOutput = (e, t) => {
            if ("object" != typeof t || null === t)
              throw new P("an object", e, t);
          },
          s = nextHookFactory(o[o.length - 1], n, {
            validateArgs: (e, t, r) => {
              H(t, `${e} specifier`), r && z(r, `${e} context`);
            },
            validateOutput: validateOutput,
          }),
          a = await s(e, i),
          { hookErrIdentifier: l } = n;
        if (
          (validateOutput(l, a),
          !0 === a?.shortCircuit && (n.shortCircuited = !0),
          !n.chainFinished && !n.shortCircuited)
        )
          throw new M(l);
        let c;
        const { format: d, url: h } = a;
        if ("string" != typeof h) throw new L("a URL string", l, "url", h);
        if (!this.#t.has(h)) {
          if (!S(h)) throw new L("a URL string", l, "url", h);
          this.#t.add(h);
        }
        if (
          (!("importAttributes" in a) && "importAssertions" in a
            ? (emitImportAssertionWarning(), (c = a.importAssertions))
            : (c = a.importAttributes),
          null != c && "object" != typeof c)
        )
          throw new L("an object", l, "importAttributes", c);
        if (null != d && "string" != typeof d)
          throw new L("a string", l, "format", d);
        return { __proto__: null, format: d, importAttributes: c, url: h };
      }
      resolveSync(e, t, r) {
        throw new N("resolveSync()");
      }
      async load(e, r = {}) {
        const o = this.#e.load,
          i = {
            chainFinished: null,
            context: r,
            hookErrIdentifier: "",
            hookName: "load",
            shortCircuited: !1,
          },
          validateOutput = (e, t) => {
            if ("object" != typeof t || null === t)
              throw new P("an object", e, t);
          },
          n = nextHookFactory(o[o.length - 1], i, {
            validateArgs: (e, t, r) => {
              if ("string" != typeof t)
                throw new E(`${e} url`, "a URL string", t);
              if (!this.#t.has(t)) {
                if (!S(t)) throw new b(`${e} url`, t, "should be a URL string");
                this.#t.add(t);
              }
              r && z(r, `${e} context`);
            },
            validateOutput: validateOutput,
          }),
          s = await n(
            e,
            (function defineImportAssertionAlias(e) {
              return h(e, "importAssertions", {
                __proto__: null,
                configurable: !0,
                get() {
                  return emitImportAssertionWarning(), this.importAttributes;
                },
                set(e) {
                  return (
                    emitImportAssertionWarning(), p(this, "importAttributes", e)
                  );
                },
              });
            })(r)
          ),
          { hookErrIdentifier: a } = i;
        if (
          (validateOutput(a, s),
          !0 === s?.shortCircuit && (i.shortCircuited = !0),
          !i.chainFinished && !i.shortCircuited)
        )
          throw new M(a);
        const { format: l, source: c } = s;
        let d,
          u = s.responseURL;
        if ((void 0 === u && (u = e), "string" == typeof u))
          try {
            d = new x(u);
          } catch {}
        if (d?.href !== u)
          throw new L(
            "undefined or a fully resolved URL string",
            a,
            "responseURL",
            u
          );
        if (
          (null == l &&
            t("internal/modules/esm/load").throwUnknownModuleFormat(e, l),
          "string" != typeof l)
        )
          throw new L("a string", a, "format", l);
        if (null != c && "string" != typeof c && !F(c) && !T(c))
          throw L("a string, an ArrayBuffer, or a TypedArray", a, "source", c);
        return { __proto__: null, format: l, responseURL: u, source: c };
      }
      forceLoadHooks() {}
      importMetaInitialize(e, r, o) {
        return (
          (K ??= t(
            "internal/modules/esm/initialize_import_meta"
          ).initializeImportMeta),
          (e = K(e, r, o))
        );
      }
    }
    u(Hooks.prototype, null);
    class HooksProxy {
      #r;
      #o;
      #i = 0;
      #n = 0;
      #s = !1;
      #a;
      constructor() {
        const { InternalWorker: e } = t("internal/worker");
        Z ??= t("internal/worker/io").MessageChannel;
        const r = new I(G);
        let i, s;
        (this.#r = new c(r)),
          (this.#a = new f((e, t) => {
            (i = e), (s = t);
          })),
          (this.#o = new e(V, {
            stderr: !1,
            stdin: !1,
            stdout: !1,
            trackUnmanagedFds: !1,
            workerData: { lock: r },
          })),
          "spidermonkey" === n.platform
            ? this.#o.once("online", () => {
                this.#o.unref();
                const { kIsOnline: e } = t("internal/worker");
                try {
                  (this.#o[e] = !1), this.waitForWorker(), i();
                } catch (e) {
                  s(e);
                } finally {
                  this.#o[e] = !0;
                }
              })
            : (this.#o.unref(), i()),
          this.#o.on("exit", o.exit);
      }
      waitForWorker() {
        if (!this.#s) {
          const { kIsOnline: e } = t("internal/worker");
          if (!this.#o[e]) {
            J("wait for signal from worker"), R(this.#r, Y, 0);
            const e = this.#o.receiveMessageSync();
            if (null == e || "exit" === e.message.status) return;
            const { preloadScripts: t } = this.#l(e);
            this.#c(t);
          }
          this.#s = !0;
        }
      }
      onReady() {
        return this.#a;
      }
      async makeAsyncRequest(e, r, ...o) {
        await this.#a,
          this.waitForWorker(),
          (Z ??= t("internal/worker/io").MessageChannel);
        const i = new Z();
        J("post async message to worker", {
          method: e,
          args: o,
          transferList: r,
        });
        const n = [i.port2];
        let s;
        r && a(n, r),
          this.#o.postMessage(
            { __proto__: null, method: e, args: o, port: i.port2 },
            n
          ),
          0 == this.#n++ && this.#o.ref();
        do {
          J("wait for async response from worker", { method: e, args: o }),
            await A(this.#r, Y, this.#i).value,
            (this.#i = y(this.#r, Y)),
            (s = C(i.port1));
        } while (null == s);
        J("got async response from worker", { method: e, args: o }, this.#r),
          0 == --this.#n && this.#o.unref();
        const l = this.#l(s);
        return i.port1.close(), l;
      }
      makeSyncRequest(e, t, ...r) {
        let i;
        this.waitForWorker(),
          J("post sync message to worker", {
            method: e,
            args: r,
            transferList: t,
          }),
          this.#o.postMessage({ __proto__: null, method: e, args: r }, t);
        do {
          J("wait for sync response from worker", { method: e, args: r }),
            R(this.#r, Y, this.#i),
            (this.#i = y(this.#r, Y)),
            (i = this.#o.receiveMessageSync());
        } while (null == i);
        return (
          J("got sync response from worker", { method: e, args: r }),
          "never-settle" === i.message.status
            ? o.exit(13)
            : "exit" === i.message.status && o.exit(i.message.body),
          this.#l(i)
        );
      }
      #l(e) {
        if ("never-settle" === e.message.status) return new f(() => {});
        const { status: t, body: r } = e.message;
        if ("error" === t) {
          if (null == r || "object" != typeof r) throw r;
          if (r.serializationFailed || null == r.serialized) throw U();
          throw q(r.serialized);
        }
        return r;
      }
      #d = t("internal/modules/esm/initialize_import_meta")
        .initializeImportMeta;
      importMetaInitialize(e, t, r) {
        this.#d(e, t, r);
      }
      #c(e) {
        for (let r = 0; r < e.length; r++) {
          const { code: o, port: i } = e[r],
            { compileFunction: n } = t("vm"),
            s = n(o, ["getBuiltin", "port", "setImportMetaCallback"], {
              filename: "<preload>",
            });
          let a = !1,
            c = !1,
            d = this.#d;
          const { BuiltinModule: h } = t("internal/bootstrap/realm");
          try {
            l(
              s,
              _,
              (e) => {
                if (g(e, "node:")) e = m(e, 5);
                else if (!h.canBeRequiredWithoutScheme(e)) throw new O(e);
                if (h.canBeRequiredByUsers(e)) return t(e);
                throw new O(e);
              },
              i,
              (e) => {
                if (a || "function" != typeof e) throw new E("fn", e);
                c = !0;
                const t = d;
                d = (r, o) => e(r, o, t);
              }
            );
          } finally {
            (a = !0), c && (this.#d = d);
          }
        }
      }
    }
    function nextHookFactory(e, t, { validateArgs: r, validateOutput: o }) {
      const { hookName: i } = t,
        { fn: n, url: s, next: a } = e,
        l = `next${k(i[0]) + m(i, 1)}`;
      let c;
      return (
        (c = a
          ? nextHookFactory(a, t, { validateArgs: r, validateOutput: o })
          : function chainAdvancedTooFar() {
              throw new v(
                `ESM custom loader '${i}' advanced beyond the end of the chain.`
              );
            }),
        h(
          async (e = void 0, h) => {
            (t.hookErrIdentifier = `${s} '${i}'`),
              r(`${t.hookErrIdentifier} hook's ${l}()`, e, h);
            const u = `${s} '${i}' hook's ${l}()`;
            a || (t.chainFinished = !0), h && d(t.context, h);
            const f = await n(e, t.context, c);
            return (
              o(u, f), !0 === f?.shortCircuit && (t.shortCircuited = !0), f
            );
          },
          "name",
          { __proto__: null, value: l }
        )
      );
    }
    u(HooksProxy.prototype, null),
      (e.Hooks = Hooks),
      (e.HooksProxy = HooksProxy);
  },
  "internal/modules/esm/initialize_import_meta": function (e, t, r, o, n, i) {
    "use strict";
    const { getOptionValue: l } = t("internal/options"),
      a = l("--experimental-import-meta-resolve");
    r.exports = {
      initializeImportMeta: function initializeImportMeta(e, t, r) {
        const { url: o } = t;
        return (
          (r && !r.allowImportMetaResolve) ||
            (e.resolve = (function createImportMetaResolve(e, t, r) {
              return function resolve(o, n = e) {
                let i;
                r || (n = e);
                try {
                  return ({ url: i } = t.resolveSync(o, n)), i;
                } catch (e) {
                  switch (e?.code) {
                    case "ERR_UNSUPPORTED_DIR_IMPORT":
                    case "ERR_MODULE_NOT_FOUND":
                      if ((({ url: i } = e), i)) return i;
                  }
                  throw e;
                }
              };
            })(o, r, a)),
          (e.url = o),
          e
        );
      },
    };
  },
  "internal/modules/esm/load": function (t, e, o, n, r, s) {
    "use strict";
    const {
        ArrayPrototypePush: i,
        RegExpPrototypeExec: a,
        decodeURIComponent: l,
      } = s,
      { kEmptyObject: u } = e("internal/util"),
      { defaultGetFormat: p } = e("internal/modules/esm/get_format"),
      { validateAttributes: c, emitImportAssertionWarning: f } = e(
        "internal/modules/esm/assert"
      ),
      { getOptionValue: m } = e("internal/options"),
      d = m("--experimental-policy") ? e("internal/process/policy") : null,
      _ = m("--experimental-network-imports"),
      {
        Buffer: { from: h },
      } = e("buffer"),
      { URL: w } = e("internal/url"),
      {
        ERR_INVALID_URL: R,
        ERR_UNKNOWN_MODULE_FORMAT: U,
        ERR_UNSUPPORTED_ESM_URL_SCHEME: E,
      } = e("internal/errors").codes,
      b = /^[^/]+\/[^,;]+(?:[^,]*?)(;base64)?,([\s\S]*)$/;
    o.exports = {
      defaultLoad: async function defaultLoad(t, o = u) {
        let n = t,
          { importAttributes: r, format: s, source: m } = o;
        null == r &&
          !("importAttributes" in o) &&
          "importAssertions" in o &&
          (f(), (r = o.importAssertions), (o = { ...o, importAttributes: r }));
        const U = new w(t);
        return (
          (function throwIfUnsupportedURLScheme(t, e) {
            const o = t?.protocol;
            if (
              o &&
              "file:" !== o &&
              "data:" !== o &&
              "node:" !== o &&
              (!e || ("https:" !== o && "http:" !== o))
            ) {
              const o = ["file", "data", "node"];
              throw (e && i(o, "https", "http"), new E(t, o));
            }
          })(U, _),
          (s ??= await p(U, o)),
          c(t, s, r),
          "builtin" === s || "commonjs" === s
            ? (m = null)
            : null == m &&
              ({ responseURL: n, source: m } = await (async function getSource(
                t,
                o
              ) {
                const { protocol: n, href: r } = t;
                let s,
                  u = r;
                if ("file:" === n) {
                  const { readFile: o } = e("internal/fs/promises").exports;
                  s = await o(t);
                } else if ("data:" === n) {
                  const e = a(b, t.pathname);
                  if (!e) throw new R(u);
                  const { 1: o, 2: n } = e;
                  s = h(l(n), o ? "base64" : "utf8");
                } else {
                  if (!_ || ("https:" !== n && "http:" !== n)) {
                    const e = ["file", "data"];
                    throw (_ && i(e, "http", "https"), new E(t, e));
                  }
                  {
                    const { fetchModule: n } = e(
                        "internal/modules/esm/fetch_module"
                      ),
                      r = await n(t, o);
                    (s = await r.body), (u = r.resolvedHREF);
                  }
                }
                return (
                  d?.manifest && d.manifest.assertIntegrity(r, s),
                  { __proto__: null, responseURL: u, source: s }
                );
              })(U, o)),
          { __proto__: null, format: s, responseURL: n, source: m }
        );
      },
      throwUnknownModuleFormat: function throwUnknownModuleFormat(t, e) {
        const o = a(/^data:([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/, t);
        throw new U(o ? o[1] : e, t);
      },
    };
  },
  "internal/modules/esm/loader": function (e, t, o, s, r, i) {
    "use strict";
    t("internal/modules/cjs/loader");
    const {
        ArrayPrototypeJoin: a,
        ArrayPrototypeMap: n,
        ArrayPrototypeReduce: l,
        FunctionPrototypeCall: u,
        JSONStringify: d,
        ObjectSetPrototypeOf: m,
        RegExpPrototypeSymbolReplace: c,
        SafeWeakMap: p,
        encodeURIComponent: h,
        hardenRegExp: v,
      } = i,
      { ERR_UNKNOWN_MODULE_FORMAT: f } = t("internal/errors").codes,
      { getOptionValue: g } = t("internal/options"),
      { pathToFileURL: y, isURL: R } = t("internal/url"),
      { emitExperimentalWarning: w } = t("internal/util"),
      { getDefaultConditions: M } = t("internal/modules/esm/utils");
    let z, C, L, k;
    function getTranslators() {
      const { translators: e } = t("internal/modules/esm/translators");
      return e;
    }
    let _ = !1;
    class ModuleLoader {
      #e = M();
      cjsCache = new p();
      evalIndex = 0;
      #t = (function newResolveCache() {
        const { ResolveCache: e } = t("internal/modules/esm/module_map");
        return new e();
      })();
      loadCache = (function newLoadCache() {
        const { LoadCache: e } = t("internal/modules/esm/module_map");
        return new e();
      })();
      translators = getTranslators();
      allowImportMetaResolve;
      #o;
      constructor(e) {
        g("--experimental-network-imports") && w("Network Imports"),
          _ ||
            "node" !== g("--experimental-specifier-resolution") ||
            (s.emitWarning(
              "The Node.js specifier resolution flag is experimental. It could change or be removed at any time.",
              "ExperimentalWarning"
            ),
            (_ = !0)),
          this.setCustomizations(e);
      }
      setCustomizations(e) {
        (this.#o = e),
          (this.allowImportMetaResolve = !e || e.allowImportMetaResolve);
      }
      async eval(e, o = y(`${s.cwd()}/[eval${++this.evalIndex}]`).href) {
        const i = new (t("internal/modules/esm/module_job"))(
          this,
          o,
          void 0,
          (o) => {
            const { ModuleWrap: s } = r("module_wrap"),
              { registerModule: i } = t("internal/modules/esm/utils"),
              a = new s(o, void 0, e, 0, 0);
            return (
              i(a, {
                __proto__: null,
                initializeImportMeta: (e, t) =>
                  this.importMetaInitialize(e, { url: o }),
                importModuleDynamically: (e, { url: t }, o) =>
                  this.import(e, t, o),
              }),
              a
            );
          },
          !1,
          !1
        );
        this.loadCache.set(o, void 0, i);
        const { module: a } = await i.run();
        return { namespace: a.getNamespace() };
      }
      async getModuleJob(e, t, o) {
        const s = await this.resolve(e, t, o);
        return this.getJobFromResolveResult(s, t, o);
      }
      getJobFromResolveResult(e, t, o) {
        const { url: s, format: r } = e,
          i = e.importAttributes ?? o;
        let a = this.loadCache.get(s, i.type);
        return (
          "function" == typeof a && this.loadCache.set(s, void 0, (a = a())),
          void 0 === a && (a = this.#s(s, i, t, r)),
          a
        );
      }
      #s(e, o, r, i) {
        const a = void 0 === r && g("--inspect-brk");
        s.env.WATCH_REPORT_DEPENDENCIES &&
          s.send &&
          s.send({ "watch:import": [e] });
        const n = new (t("internal/modules/esm/module_job"))(
          this,
          e,
          o,
          async (e, t) => {
            const {
                format: s,
                responseURL: r,
                source: a,
              } = await this.load(e, { format: i, importAttributes: o }),
              n = getTranslators().get(s);
            if (!n) throw new f(s, r);
            return u(n, this, r, a, t);
          },
          void 0 === r,
          a
        );
        return this.loadCache.set(e, o.type, n), n;
      }
      async import(e, t, o) {
        const s = await this.getModuleJob(e, t, o),
          { module: r } = await s.run();
        return r.getNamespace();
      }
      register(e, t, o, s) {
        return (
          this.#o || this.setCustomizations(new CustomizedModuleLoader()),
          this.#o.register(`${e}`, `${t}`, o, s)
        );
      }
      resolve(e, t, o) {
        if (this.#o) return this.#o.resolve(e, t, o);
        const s = this.#t.serializeKey(e, o),
          r = this.#t.get(s, t);
        if (null != r) return r;
        const i = this.defaultResolve(e, t, o);
        return this.#t.set(s, t, i), i;
      }
      resolveSync(e, t, o) {
        return this.#o
          ? this.#o.resolveSync(e, t, o)
          : this.defaultResolve(e, t, o);
      }
      defaultResolve(e, o, s) {
        z ??= t("internal/modules/esm/resolve").defaultResolve;
        const r = {
          __proto__: null,
          conditions: this.#e,
          importAttributes: s,
          parentURL: o,
        };
        return z(e, r);
      }
      async load(e, o) {
        C ??= t("internal/modules/esm/load").defaultLoad;
        const s = this.#o ? await this.#o.load(e, o) : await C(e, o);
        return this.validateLoadResult(e, s?.format), s;
      }
      validateLoadResult(e, o) {
        null == o &&
          t("internal/modules/esm/load").throwUnknownModuleFormat(e, o);
      }
      importMetaInitialize(e, o) {
        return this.#o
          ? this.#o.importMetaInitialize(e, o, this)
          : ((L ??= t(
              "internal/modules/esm/initialize_import_meta"
            ).initializeImportMeta),
            (e = L(e, o, this)));
      }
      forceLoadHooks() {
        this.#o?.forceLoadHooks();
      }
      hooksReady() {
        return this.#o?.hooksReady();
      }
    }
    m(ModuleLoader.prototype, null);
    class CustomizedModuleLoader {
      allowImportMetaResolve = !0;
      constructor() {
        getHooksProxy();
      }
      register(e, t, o, s) {
        return "spidermonkey" === i.platform
          ? k.makeAsyncRequest("register", s, e, t, o)
          : k.makeSyncRequest("register", s, e, t, o);
      }
      resolve(e, t, o) {
        return k.makeAsyncRequest("resolve", void 0, e, t, o);
      }
      resolveSync(e, t, o) {
        return k.makeSyncRequest("resolve", void 0, e, t, o);
      }
      load(e, t) {
        return k.makeAsyncRequest("load", void 0, e, t);
      }
      importMetaInitialize(e, t, o) {
        k.importMetaInitialize(e, t, o);
      }
      forceLoadHooks() {
        k.waitForWorker();
      }
      hooksReady() {
        return k.onReady();
      }
    }
    let x = !1;
    function getHooksProxy() {
      if (!k) {
        const { HooksProxy: e } = t("internal/modules/esm/hooks");
        k = new e();
      }
      return k;
    }
    o.exports = {
      createModuleLoader: function createModuleLoader(e = !0) {
        let o = null;
        if (e && !t("internal/modules/esm/utils").isLoaderWorker()) {
          const e = g("--experimental-loader");
          if (e.length > 0) {
            if (!x) {
              const readableURIEncode = (e) =>
                l(
                  [
                    [/'/g, "%27"],
                    [/%22/g, '"'],
                    [/%2F/gi, "/"],
                  ],
                  (e, { 0: t, 1: o }) => c(v(t), e, o),
                  h(e)
                );
              s.emitWarning(
                `\`--experimental-loader\` may be removed in the future; instead use \`register()\`:\n--import 'data:text/javascript,import { register } from "node:module"; import { pathToFileURL } from "node:url"; ${a(
                  n(
                    e,
                    (e) =>
                      `register(${readableURIEncode(
                        d(e)
                      )}, pathToFileURL("./"))`
                  ),
                  "; "
                )};'`,
                "ExperimentalWarning"
              ),
                (x = !0);
            }
            o = new CustomizedModuleLoader();
          }
        }
        return new ModuleLoader(o);
      },
      getHooksProxy: getHooksProxy,
      register: function register(e, o = void 0, s) {
        const r = t("internal/process/esm_loader").esmLoader;
        null == o || "object" != typeof o || R(o) || (o = (s = o).parentURL),
          r.register(e, o ?? "data:", s?.data, s?.transferList);
      },
    };
  },
  "internal/modules/esm/module_job": function (e, t, o, s, a, i) {
    "use strict";
    const {
        ArrayPrototypeJoin: n,
        ArrayPrototypePush: r,
        ArrayPrototypeSome: l,
        FunctionPrototype: d,
        ObjectSetPrototypeOf: m,
        PromiseResolve: u,
        PromisePrototypeThen: c,
        ReflectApply: p,
        RegExpPrototypeExec: h,
        RegExpPrototypeSymbolReplace: y,
        SafePromiseAllReturnArrayLike: f,
        SafePromiseAllReturnVoid: g,
        SafeSet: P,
        StringPrototypeIncludes: S,
        StringPrototypeSplit: _,
        StringPrototypeStartsWith: k,
      } = i,
      { ModuleWrap: w } = a("module_wrap"),
      { decorateErrorStack: x, kEmptyObject: v } = t("internal/util"),
      { getSourceMapsEnabled: b } = t("internal/source_map/source_map_cache"),
      E = t("internal/assert"),
      $ = u(),
      A = d;
    let J = !1;
    const R = ["require", "module", "exports", "__filename", "__dirname"];
    class ModuleJob {
      constructor(e, t, o = { __proto__: null }, s, a, i) {
        (this.loader = e),
          (this.importAttributes = o),
          (this.isMain = a),
          (this.inspectBrk = i),
          (this.module = void 0),
          (this.modulePromise = p(s, e, [t, a]));
        (this.linked = (async () => {
          (this.module = await this.modulePromise), E(this.module instanceof w);
          const e = [],
            o = this.module.link(async (o, s) => {
              const a = await this.loader.getModuleJob(o, t, s);
              return r(e, a), a.modulePromise;
            });
          return void 0 !== o && (await g(o)), f(e);
        })()),
          c(this.linked, void 0, A),
          (this.instantiated = void 0);
      }
      instantiate() {
        return (
          void 0 === this.instantiated &&
            (this.instantiated = this._instantiate()),
          this.instantiated
        );
      }
      async _instantiate() {
        const e = new P(),
          addJobsToDependencyGraph = async (t) => {
            if (e.has(t)) return;
            e.add(t);
            const o = await t.linked;
            return g(o, addJobsToDependencyGraph);
          };
        await addJobsToDependencyGraph(this);
        try {
          if (!J && this.inspectBrk) {
            J = !0;
            (0, a("inspector").callAndPauseOnStart)(
              this.module.instantiate,
              this.module
            );
          } else this.module.instantiate();
        } catch (e) {
          if (
            (x(e), !b() && S(e.message, " does not provide an export named"))
          ) {
            const t = _(e.stack, "\n"),
              o = y(/:\d+$/, t[0], ""),
              { 1: s, 2: a } = h(
                /module '(.*)' does not provide an export named '(.+)'/,
                e.message
              ),
              { url: i } = await this.loader.resolve(s, o, v);
            let r;
            try {
              ({ format: r } = await this.loader.load(i));
            } catch {}
            if ("commonjs" === r) {
              const o = t[1],
                i = h(/{.*}/, o),
                r = i && y(/\s+as\s+/g, i, ": ");
              e.message = `Named export '${a}' not found. The requested module '${s}' is a CommonJS module, which may not support all module.exports as named exports.\nCommonJS modules can always be imported via the default export, for example using:\n\nimport pkg from '${s}';\n${
                r ? `const ${r} = pkg;\n` : ""
              }`;
              const l = _(e.stack, "\n");
              (l[3] = `SyntaxError: ${e.message}`), (e.stack = n(l, "\n"));
            }
          }
          throw e;
        }
        for (const t of e) t.instantiated = $;
      }
      async run() {
        await this.instantiate();
        try {
          await this.module.evaluate(-1, false);
        } catch (o) {
          if (
            "ReferenceError" === o?.name &&
            ((e = o.message), l(R, (t) => e === `${t} is not defined`))
          ) {
            (o.message += " in ES module scope"),
              k(o.message, "require ") &&
                (o.message += ", you can use import instead");
            const e =
              k(this.module.url, "file://") &&
              null !== h(/\.js(\?[^#]*)?(#.*)?$/, this.module.url) &&
              t("internal/modules/esm/resolve").getPackageScopeConfig(
                this.module.url
              );
            "module" === e.type &&
              (o.message += `\nThis file is being treated as an ES module because it has a '.js' file extension and '${e.pjsonPath}' contains "type": "module". To treat it as a CommonJS script, rename it to use the '.cjs' file extension.`);
          }
          throw o;
        }
        var e;
        return { __proto__: null, module: this.module };
      }
    }
    m(ModuleJob.prototype, null), (o.exports = ModuleJob);
  },
  "internal/modules/esm/module_map": function (e, t, r, s, o, n) {
    "use strict";
    const {
        ArrayPrototypeJoin: u,
        ArrayPrototypeMap: l,
        ArrayPrototypeSort: a,
        JSONStringify: i,
        ObjectCreate: p,
        ObjectKeys: c,
        SafeMap: d,
      } = n,
      { kImplicitAssertType: g } = t("internal/modules/esm/assert");
    let h = t("internal/util/debuglog").debuglog("esm", (e) => {
      h = e;
    });
    const { ERR_INVALID_ARG_TYPE: y } = t("internal/errors").codes,
      { validateString: m } = t("internal/validators");
    r.exports = {
      LoadCache: class LoadCache extends d {
        constructor(e) {
          super(e);
        }
        get(e, t = g) {
          return m(e, "url"), m(t, "type"), super.get(e)?.[t];
        }
        set(e, r = g, s) {
          m(e, "url"), m(r, "type");
          if (
            s instanceof t("internal/modules/esm/module_job") != !0 &&
            "function" != typeof s
          )
            throw new y("job", "ModuleJob", s);
          h(`Storing ${e} (${r === g ? "implicit type" : r}) in ModuleLoadMap`);
          const o = super.get(e) ?? p(null);
          return (o[r] = s), super.set(e, o);
        }
        has(e, t = g) {
          return m(e, "url"), m(t, "type"), void 0 !== super.get(e)?.[t];
        }
      },
      ResolveCache: class ResolveCache extends d {
        constructor(e) {
          super(e);
        }
        serializeKey(e, t) {
          const r = c(t);
          return 0 === r.length
            ? e + "::"
            : e +
                "::" +
                u(
                  l(a(r), (e) => i(e) + i(t[e])),
                  ","
                );
        }
        #e(e) {
          let t = super.get(e);
          return null == t && super.set(e, (t = { __proto__: null })), t;
        }
        get(e, t) {
          return this.#e(t)[e];
        }
        set(e, t, r) {
          return (this.#e(t)[e] = r), this;
        }
        has(e, t) {
          return e in this.#e(t);
        }
      },
    };
  },
  "internal/modules/esm/package_config": function (e, n, o, t, a, i) {
    "use strict";
    const { StringPrototypeEndsWith: s } = i,
      { URL: r, fileURLToPath: p } = n("internal/url"),
      c = n("internal/modules/package_json_reader");
    o.exports = {
      getPackageScopeConfig: function getPackageScopeConfig(e) {
        let n = new r("./package.json", e);
        for (;;) {
          const o = n.pathname;
          if (s(o, "node_modules/package.json")) break;
          const t = c.read(p(n), { __proto__: null, specifier: e, isESM: !0 });
          if (t.exists) return t;
          const a = n;
          if (((n = new r("../package.json", n)), n.pathname === a.pathname))
            break;
        }
        return {
          __proto__: null,
          pjsonPath: p(n),
          exists: !1,
          main: void 0,
          name: void 0,
          type: "none",
          exports: void 0,
          imports: void 0,
        };
      },
    };
  },
  "internal/modules/esm/resolve": function (e, t, n, o, r, i) {
    "use strict";
    const {
        ArrayIsArray: a,
        ArrayPrototypeJoin: s,
        ArrayPrototypeShift: l,
        JSONStringify: c,
        ObjectGetOwnPropertyNames: f,
        ObjectPrototypeHasOwnProperty: u,
        RegExp: p,
        RegExpPrototypeExec: d,
        RegExpPrototypeSymbolReplace: h,
        SafeMap: g,
        SafeSet: m,
        String: w,
        StringPrototypeEndsWith: E,
        StringPrototypeIncludes: R,
        StringPrototypeIndexOf: v,
        StringPrototypeLastIndexOf: P,
        StringPrototypeReplace: y,
        StringPrototypeSlice: x,
        StringPrototypeSplit: _,
        StringPrototypeStartsWith: S,
      } = i,
      k = t("internal/fs/utils"),
      { BuiltinModule: I } = t("internal/bootstrap/realm"),
      { realpathSync: T } = t("fs"),
      { getOptionValue: D } = t("internal/options"),
      $ = D("--pending-deprecation"),
      A = D("--experimental-policy") ? t("internal/process/policy") : null,
      { sep: N, relative: O, resolve: L, toNamespacedPath: U } = t("path"),
      j = D("--preserve-symlinks"),
      C = D("--preserve-symlinks-main"),
      W = D("--experimental-network-imports"),
      b = D("--input-type"),
      {
        URL: M,
        pathToFileURL: F,
        fileURLToPath: G,
        isURL: K,
        toPathIfFileURL: B,
      } = t("internal/url"),
      { getCWDURL: H } = t("internal/util"),
      { canParse: J } = r("url"),
      {
        ERR_INPUT_TYPE_NOT_ALLOWED: V,
        ERR_INVALID_ARG_TYPE: q,
        ERR_INVALID_MODULE_SPECIFIER: Y,
        ERR_INVALID_PACKAGE_CONFIG: z,
        ERR_INVALID_PACKAGE_TARGET: X,
        ERR_MANIFEST_DEPENDENCY_MISSING: Q,
        ERR_MODULE_NOT_FOUND: Z,
        ERR_PACKAGE_IMPORT_NOT_DEFINED: ee,
        ERR_PACKAGE_PATH_NOT_EXPORTED: te,
        ERR_UNSUPPORTED_DIR_IMPORT: ne,
        ERR_NETWORK_IMPORT_DISALLOWED: oe,
      } = t("internal/errors").codes,
      { Module: re } = t("internal/modules/cjs/loader"),
      { getPackageScopeConfig: ie } = t("internal/modules/esm/package_config"),
      { getConditionsSet: ae } = t("internal/modules/esm/utils"),
      se = t("internal/modules/package_json_reader"),
      { internalModuleStat: le } = r("fs"),
      ce = new m();
    function emitTrailingSlashPatternDeprecation(e, t, n) {
      const r = G(t);
      ce.has(r + "|" + e) ||
        (ce.add(r + "|" + e),
        o.emitWarning(
          `Use of deprecated trailing slash pattern mapping "${e}" in the "exports" field module resolution of the package at ${r}${
            n ? ` imported from ${G(n)}` : ""
          }. Mapping specifiers ending in "/" is no longer supported.`,
          "DeprecationWarning",
          "DEP0155"
        ));
    }
    const fe = /[/\\][/\\]/;
    function emitInvalidSegmentDeprecation(e, t, n, r, i, a, s) {
      if (!$) return;
      const l = G(r),
        c = null !== d(fe, s ? e : t);
      o.emitWarning(
        `Use of deprecated ${
          c ? "double slash" : "leading or trailing slash matching"
        } resolving "${e}" for module request "${t}" ${
          t !== n ? `matched to "${n}" ` : ""
        }in the "${
          i ? "imports" : "exports"
        }" field module resolution of the package at ${l}${
          a ? ` imported from ${G(a)}` : ""
        }.`,
        "DeprecationWarning",
        "DEP0166"
      );
    }
    function emitLegacyIndexDeprecation(e, t, n, r) {
      if ("module" !== Ee(e)) return;
      const i = G(e),
        a = G(new M(".", t)),
        s = G(n);
      r
        ? L(a, r) !== i &&
          o.emitWarning(
            `Package ${a} has a "main" field set to "${r}", excluding the full filename and extension to the resolved file at "${x(
              i,
              a.length
            )}", imported from ${s}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`,
            "DeprecationWarning",
            "DEP0151"
          )
        : o.emitWarning(
            `No "main" or "exports" field defined in the package.json for ${a} resolving the main entry point "${x(
              i,
              a.length
            )}", imported from ${s}.\nDefault "index" lookups for the main are deprecated for ES modules.`,
            "DeprecationWarning",
            "DEP0151"
          );
    }
    const ue = new g();
    function fileExists(e) {
      return 0 === le(U(B(e)));
    }
    function legacyMainResolve(e, t, n) {
      let o;
      if (void 0 !== t.main) {
        if (fileExists((o = new M(`./${t.main}`, e)))) return o;
        if (
          (fileExists((o = new M(`./${t.main}.js`, e))) ||
            fileExists((o = new M(`./${t.main}.json`, e))) ||
            fileExists((o = new M(`./${t.main}.node`, e))) ||
            fileExists((o = new M(`./${t.main}/index.js`, e))) ||
            fileExists((o = new M(`./${t.main}/index.json`, e))) ||
            fileExists((o = new M(`./${t.main}/index.node`, e))) ||
            (o = void 0),
          o)
        )
          return emitLegacyIndexDeprecation(o, e, n, t.main), o;
      }
      if (
        (fileExists((o = new M("./index.js", e))) ||
          fileExists((o = new M("./index.json", e))) ||
          fileExists((o = new M("./index.node", e))) ||
          (o = void 0),
        o)
      )
        return emitLegacyIndexDeprecation(o, e, n, t.main), o;
      throw new Z(G(new M(".", e)), G(n));
    }
    function resolveExtensionsWithTryExactName(e) {
      return fileExists(e) ? e : resolveExtensions(e);
    }
    const pe = [".js", ".json", ".node", ".mjs"];
    function resolveExtensions(e) {
      for (let t = 0; t < pe.length; t++) {
        const n = pe[t],
          o = new M(`${e.pathname}${n}`, e);
        if (fileExists(o)) return o;
      }
    }
    function resolveDirectoryEntry(e) {
      const t = G(e),
        n = L(t, "package.json");
      if (fileExists(n)) {
        const e = se.read(n);
        if (e.exists) {
          const { main: n } = e;
          if (null != n) {
            return resolveExtensionsWithTryExactName(F(L(t, n)));
          }
        }
      }
      return resolveExtensions(new M("index", e));
    }
    const de = /%2F|%5C/i;
    function exportsNotFound(e, t, n) {
      return new te(G(new M(".", t)), e, n && G(n));
    }
    function invalidPackageTarget(e, t, n, o, r) {
      return (
        (t = "object" == typeof t && null !== t ? c(t, null, "") : `${t}`),
        new X(G(new M(".", n)), e, t, o, r && G(r))
      );
    }
    const he =
        /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
      ge =
        /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
      me = /^\.|%|\\/,
      we = /\*/g;
    function resolvePackageTargetString(e, t, n, o, r, i, a, s, l) {
      if ("" !== t && !i && "/" !== e[e.length - 1])
        throw invalidPackageTarget(n, e, o, a, r);
      if (!S(e, "./")) {
        if (a && !S(e, "../") && !S(e, "/") && !J(e)) {
          return packageResolve(i ? h(we, e, () => t) : e + t, o, l);
        }
        throw invalidPackageTarget(n, e, o, a, r);
      }
      if (null !== d(he, x(e, 2))) {
        if (null !== d(ge, x(e, 2))) throw invalidPackageTarget(n, e, o, a, r);
        if (!s) {
          const s = i ? y(n, "*", () => t) : n + t;
          emitInvalidSegmentDeprecation(
            i ? h(we, e, () => t) : e,
            s,
            n,
            o,
            a,
            r,
            !0
          );
        }
      }
      const c = new M(e, o),
        f = c.pathname,
        u = new M(".", o).pathname;
      if (!S(f, u)) throw invalidPackageTarget(n, e, o, a, r);
      if ("" === t) return c;
      if (null !== d(he, t)) {
        const l = i ? y(n, "*", () => t) : n + t;
        if (null === d(ge, t)) {
          if (!s) {
            emitInvalidSegmentDeprecation(
              i ? h(we, e, () => t) : e,
              l,
              n,
              o,
              a,
              r,
              !1
            );
          }
        } else
          !(function throwInvalidSubpath(e, t, n, o, r) {
            const i = `request is not a valid match in pattern "${t}" for the "${
              o ? "imports" : "exports"
            }" resolution of ${G(n)}`;
            throw new Y(e, i, r && G(r));
          })(l, n, o, a, r);
      }
      return i ? new M(h(we, c.href, () => t)) : new M(t, c);
    }
    function isArrayIndex(e) {
      const t = +e;
      return `${t}` === e && t >= 0 && t < 4294967295;
    }
    function resolvePackageTarget(e, t, n, o, r, i, s, l, c) {
      if ("string" == typeof t)
        return resolvePackageTargetString(t, n, o, e, r, i, s, l, c);
      if (a(t)) {
        if (0 === t.length) return null;
        let a;
        for (let f = 0; f < t.length; f++) {
          const u = t[f];
          let p;
          try {
            p = resolvePackageTarget(e, u, n, o, r, i, s, l, c);
          } catch (e) {
            if (((a = e), "ERR_INVALID_PACKAGE_TARGET" === e.code)) continue;
            throw e;
          }
          if (void 0 !== p) {
            if (null !== p) return p;
            a = null;
          }
        }
        if (null == a) return a;
        throw a;
      }
      if ("object" != typeof t || null === t) {
        if (null === t) return null;
        throw invalidPackageTarget(o, t, e, s, r);
      }
      {
        const a = f(t);
        for (let t = 0; t < a.length; t++) {
          if (isArrayIndex(a[t]))
            throw new z(
              G(e),
              r,
              '"exports" cannot contain numeric property keys.'
            );
        }
        for (let f = 0; f < a.length; f++) {
          const u = a[f];
          if ("default" === u || c.has(u)) {
            const a = resolvePackageTarget(e, t[u], n, o, r, i, s, l, c);
            if (void 0 === a) continue;
            return a;
          }
        }
      }
    }
    function packageExportsResolve(e, t, n, o, r) {
      let i = n.exports;
      if (
        ((function isConditionalExportsMainSugar(e, t, n) {
          if ("string" == typeof e || a(e)) return !0;
          if ("object" != typeof e || null === e) return !1;
          const o = f(e);
          let r = !1,
            i = 0;
          for (let e = 0; e < o.length; e++) {
            const a = o[e],
              s = "" === a || "." !== a[0];
            if (0 == i++) r = s;
            else if (r !== s)
              throw new z(
                G(t),
                n,
                "\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only."
              );
          }
          return r;
        })(i, e, o) && (i = { ".": i }),
        u(i, t) && !R(t, "*") && !E(t, "/"))
      ) {
        const n = resolvePackageTarget(e, i[t], "", t, o, !1, !1, !1, r);
        if (null == n) throw exportsNotFound(t, e, o);
        return n;
      }
      let s,
        l = "";
      const c = f(i);
      for (let n = 0; n < c.length; n++) {
        const r = c[n],
          i = v(r, "*");
        if (-1 !== i && S(t, x(r, 0, i))) {
          E(t, "/") && emitTrailingSlashPatternDeprecation(t, e, o);
          const n = x(r, i + 1);
          t.length >= r.length &&
            E(t, n) &&
            1 === patternKeyCompare(l, r) &&
            P(r, "*") === i &&
            ((l = r), (s = x(t, i, t.length - n.length)));
        }
      }
      if (l) {
        const n = resolvePackageTarget(e, i[l], s, l, o, !0, !1, E(t, "/"), r);
        if (null == n) throw exportsNotFound(t, e, o);
        return n;
      }
      throw exportsNotFound(t, e, o);
    }
    function patternKeyCompare(e, t) {
      const n = v(e, "*"),
        o = v(t, "*"),
        r = -1 === n ? e.length : n + 1,
        i = -1 === o ? t.length : o + 1;
      return r > i
        ? -1
        : i > r || -1 === n
        ? 1
        : -1 === o || e.length > t.length
        ? -1
        : t.length > e.length
        ? 1
        : 0;
    }
    function packageImportsResolve(e, t, n) {
      if ("#" === e || S(e, "#/") || E(e, "/")) {
        throw new Y(e, "is not a valid internal imports specifier name", G(t));
      }
      let o;
      const r = ie(t);
      if (r.exists) {
        o = F(r.pjsonPath);
        const i = r.imports;
        if (i)
          if (u(i, e) && !R(e, "*")) {
            const r = resolvePackageTarget(o, i[e], "", e, t, !1, !0, !1, n);
            if (null != r) return r;
          } else {
            let r,
              a = "";
            const s = f(i);
            for (let t = 0; t < s.length; t++) {
              const n = s[t],
                o = v(n, "*");
              if (-1 !== o && S(e, x(n, 0, o))) {
                const t = x(n, o + 1);
                e.length >= n.length &&
                  E(e, t) &&
                  1 === patternKeyCompare(a, n) &&
                  P(n, "*") === o &&
                  ((a = n), (r = x(e, o, e.length - t.length)));
              }
            }
            if (a) {
              const e = resolvePackageTarget(o, i[a], r, a, t, !0, !0, !1, n);
              if (null != e) return e;
            }
          }
      }
      throw (function importNotDefined(e, t, n) {
        return new ee(e, t && G(new M(".", t)), G(n));
      })(e, o, t);
    }
    function packageResolve(e, t, n) {
      if (I.canBeRequiredWithoutScheme(e)) return new M("node:" + e);
      const {
          packageName: o,
          packageSubpath: r,
          isScoped: i,
        } = (function parsePackageName(e, t) {
          let n = v(e, "/"),
            o = !0,
            r = !1;
          "@" === e[0] &&
            ((r = !0),
            -1 === n || 0 === e.length ? (o = !1) : (n = v(e, "/", n + 1)));
          const i = -1 === n ? e : x(e, 0, n);
          if ((null !== d(me, i) && (o = !1), !o))
            throw new Y(e, "is not a valid package name", G(t));
          return {
            packageName: i,
            packageSubpath: "." + (-1 === n ? "" : x(e, n)),
            isScoped: r,
          };
        })(e, t),
        a = ie(t);
      if (a.exists) {
        const e = F(a.pjsonPath);
        if (null != a.exports && a.name === o)
          return packageExportsResolve(e, r, a, t, n);
      }
      let s,
        l = new M("./node_modules/" + o + "/package.json", t),
        c = G(l);
      do {
        if (1 !== le(U(x(c, 0, c.length - 13)))) {
          (s = c),
            (l = new M(
              (i ? "../../../../node_modules/" : "../../../node_modules/") +
                o +
                "/package.json",
              l
            )),
            (c = G(l));
          continue;
        }
        const a = se.read(c, {
          __proto__: null,
          specifier: e,
          base: t,
          isESM: !0,
        });
        return null != a.exports
          ? packageExportsResolve(l, r, a, t, n)
          : "." === r
          ? legacyMainResolve(l, a, t)
          : new M(r, l);
      } while (c.length !== s.length);
      throw new Z(o, G(t), null);
    }
    function isRelativeSpecifier(e) {
      if ("." === e[0]) {
        if (1 === e.length || "/" === e[1]) return !0;
        if ("." === e[1] && (2 === e.length || "/" === e[2])) return !0;
      }
      return !1;
    }
    function shouldBeTreatedAsRelativeOrAbsolutePath(e) {
      return "" !== e && ("/" === e[0] || isRelativeSpecifier(e));
    }
    function moduleResolve(e, n, r, i) {
      const a = "http:" === n.protocol || "https:" === n.protocol;
      let s;
      if (shouldBeTreatedAsRelativeOrAbsolutePath(e)) s = new M(e, n);
      else if (a || "#" !== e[0])
        try {
          s = new M(e);
        } catch {
          a || (s = packageResolve(e, n, r));
        }
      else s = packageImportsResolve(e, n, r);
      return "file:" !== s.protocol
        ? s
        : (function finalizeResolution(e, n, r) {
            if (null !== d(de, e.pathname))
              throw new Y(
                e.pathname,
                'must not include encoded "/" or "\\" characters',
                G(n)
              );
            let i;
            try {
              i = G(e);
            } catch (o) {
              const { setOwnProperty: r } = t("internal/util");
              throw (r(o, "input", `${e}`), r(o, "module", `${n}`), o);
            }
            if ("node" === D("--experimental-specifier-resolution")) {
              let t = resolveExtensionsWithTryExactName(e);
              if (void 0 === t) {
                if (
                  ((t = E(i, "/")
                    ? resolveDirectoryEntry(e) || e
                    : resolveDirectoryEntry(new M(`${e}/`))),
                  t === e)
                )
                  return t;
                if (void 0 === t) throw new Z(e.pathname, G(n), "module");
              }
              i = G((e = t));
            }
            const a = le(U(E(i, "/") ? x(i, -1) : i));
            if (1 === a) throw new ne(i, G(n), w(e));
            if (0 !== a)
              throw (
                (o.env.WATCH_REPORT_DEPENDENCIES &&
                  o.send &&
                  o.send({ "watch:require": [i || e.pathname] }),
                new Z(i || e.pathname, n && G(n), e))
              );
            if (!r) {
              const t = T(i, { [k.realpathCacheKey]: ue }),
                { search: n, hash: o } = e;
              ((e = F(t + (E(i, N) ? "/" : ""))).search = n), (e.hash = o);
            }
            return e;
          })(s, n, i);
    }
    function throwIfInvalidParentURL(e) {
      if (void 0 !== e && "string" != typeof e && !K(e))
        throw new q("parentURL", ["string", "URL"], e);
    }
    function defaultResolve(e, t = {}) {
      let n,
        o,
        { parentURL: r, conditions: i } = t;
      if ((throwIfInvalidParentURL(r), r && A?.manifest)) {
        const t = A.manifest.getDependencyMapper(r);
        if (t) {
          const { resolve: n, reaction: o } = t,
            a = n(e, new m(i));
          let l = !0;
          if (!0 === a) l = !1;
          else if (a) {
            return { url: a.href };
          }
          l && o(new Q(r, e, s([...i], ", ")));
        }
      }
      if (r)
        try {
          n = new M(r);
        } catch {}
      try {
        o = shouldBeTreatedAsRelativeOrAbsolutePath(e) ? new M(e, n) : new M(e);
        const t = o.protocol;
        if ("data:" === t || (W && ("https:" === t || "http:" === t)))
          return { __proto__: null, url: o.href };
      } catch {}
      const a = (function checkIfDisallowedImport(e, t, n) {
        if (n) {
          const o = n.protocol;
          if ("http:" === o || "https:" === o) {
            if (shouldBeTreatedAsRelativeOrAbsolutePath(e)) {
              const o = t?.protocol;
              if (o && "https:" !== o && "http:" !== o)
                throw new oe(
                  e,
                  n,
                  "remote imports cannot import from a local location."
                );
              return { url: t.href };
            }
            if (I.canBeRequiredWithoutScheme(e))
              throw new oe(
                e,
                n,
                "remote imports cannot import from a local location."
              );
            throw new oe(
              e,
              n,
              "only relative and absolute specifiers are supported."
            );
          }
        }
      })(e, o, n);
      if (a) return a;
      if (o && "node:" === o.protocol) return { __proto__: null, url: e };
      const l = void 0 === r;
      if (l && ((r = H().href), b)) throw new V();
      let c;
      i = ae(i);
      try {
        c = moduleResolve(e, r, i, l ? C : j);
      } catch (t) {
        throw (
          (("ERR_MODULE_NOT_FOUND" !== t.code &&
            "ERR_UNSUPPORTED_DIR_IMPORT" !== t.code) ||
            (S(e, "file://") && (e = G(e)),
            decorateErrorWithCommonJSHints(t, e, r)),
          t)
        );
      }
      return { url: c.href, format: Ee(c, t) };
    }
    function decorateErrorWithCommonJSHints(e, t, n) {
      const r = (function resolveAsCommonJS(e, t) {
        try {
          const n = G(t),
            r = new re(n, null);
          r.paths = re._nodeModulePaths(n);
          let i = re._resolveFilename(e, r, !1);
          if (isRelativeSpecifier(e))
            (i = O(n, i)), S(i, `..${N}`) || (i = `.${N}${i}`);
          else if (
            (function isBareSpecifier(e) {
              return e[0] && "/" !== e[0] && "." !== e[0];
            })(e)
          ) {
            const t = _(e, "/")[0],
              n = v(i, t);
            -1 !== n && (i = x(i, n));
          }
          return (
            "win32" === o.platform && (i = h(new p(`\\${N}`, "g"), i, "/")), i
          );
        } catch {
          return !1;
        }
      })(t, n);
      if (r) {
        const t = _(e.stack, "\n"),
          n = `Did you mean to import ${r}?`;
        (e.stack = l(t) + "\n" + n + "\n" + s(t, "\n")),
          (e.message += `\n${n}`);
      }
    }
    n.exports = {
      decorateErrorWithCommonJSHints: decorateErrorWithCommonJSHints,
      defaultResolve: defaultResolve,
      encodedSepRegEx: de,
      getPackageScopeConfig: ie,
      getPackageType: function getPackageType(e) {
        return ie(e).type;
      },
      packageExportsResolve: packageExportsResolve,
      packageImportsResolve: packageImportsResolve,
      throwIfInvalidParentURL: throwIfInvalidParentURL,
    };
    const { defaultGetFormatWithoutErrors: Ee } = t(
      "internal/modules/esm/get_format"
    );
    if (A) {
      const e = defaultResolve;
      n.exports.defaultResolve = function defaultResolve2(t, n) {
        const o = e(t, n);
        return (
          A.manifest.mightAllow(
            o.url,
            () => new Q(n.parentURL, t, n.conditions)
          ),
          o
        );
      };
    }
  },
  "internal/modules/esm/shared_constants": function (_, E, T, I, N, O) {
    "use strict";
    T.exports = {
      WORKER_TO_MAIN_THREAD_NOTIFICATION: 0,
      SHARED_MEMORY_BYTE_LENGTH: 4,
    };
  },
  "internal/modules/esm/translators": function (e, t, r, o, n, s) {
    "use strict";
    const {
      ArrayPrototypeForEach: a,
      ArrayPrototypeMap: l,
      Boolean: i,
      JSONParse: c,
      ObjectGetPrototypeOf: u,
      ObjectPrototypeHasOwnProperty: d,
      ObjectKeys: f,
      SafeArrayIterator: p,
      SafeMap: m,
      SafeSet: y,
      StringPrototypeIncludes: h,
      StringPrototypeReplaceAll: g,
      StringPrototypeSlice: S,
      StringPrototypeStartsWith: x,
      SyntaxErrorPrototype: M,
      globalThis: { WebAssembly: _ },
    } = s;
    let w = null;
    const { readFileSync: P } = t("fs"),
      { extname: E, isAbsolute: j } = t("path"),
      {
        hasEsmSyntax: N,
        loadBuiltinModule: b,
        stripBOM: A,
      } = t("internal/modules/helpers"),
      { Module: B, cjsParseCache: L } = t("internal/modules/cjs/loader"),
      { fileURLToPath: O, URL: C } = t("internal/url");
    let I = t("internal/util/debuglog").debuglog("esm", (e) => {
      I = e;
    });
    const { emitExperimentalWarning: T } = t("internal/util"),
      { ERR_UNKNOWN_BUILTIN_MODULE: J, ERR_INVALID_RETURN_PROPERTY_VALUE: R } =
        t("internal/errors").codes,
      { maybeCacheSourceMap: v } = t("internal/source_map/source_map_cache"),
      W = n("module_wrap"),
      { ModuleWrap: $ } = W,
      D = t("internal/process/esm_loader"),
      { emitWarningSync: U } = t("internal/process/warning");
    let F;
    const z = new m();
    (e.translators = z), (e.enrichCJSError = enrichCJSError);
    let V = null;
    function assertBufferSource(e, r, o) {
      if (r && "string" == typeof e) return;
      const { isArrayBufferView: n, isAnyArrayBuffer: s } =
        (function lazyTypes() {
          return null !== w ? w : (w = t("internal/util/types"));
        })();
      if (!n(e) && !s(e))
        throw new R(
          (r ? "string, " : "") + "array buffer, or typed array",
          o,
          "source",
          e
        );
    }
    function stringify(e) {
      if ("string" == typeof e) return e;
      assertBufferSource(e, !1, "transformSource");
      const { TextDecoder: r } = t("internal/encoding");
      return (V = null === V ? new r() : V), V.decode(e);
    }
    function errPath(e) {
      const t = new C(e);
      return "file:" === t.protocol ? O(t) : e;
    }
    async function importModuleDynamically(e, { url: t }, r) {
      return D.esmLoader.import(e, t, r);
    }
    function enrichCJSError(e, t, r) {
      null != e &&
        u(e) === M &&
        N(t || P(r, "utf-8")) &&
        U(
          'To load an ES module, set "type": "module" in the package.json or use the .mjs extension.'
        );
    }
    z.set("module", async function moduleStrategy(e, r, o) {
      assertBufferSource(r, !0, "load"),
        (r = stringify(r)),
        v(e, r),
        I(`Translating StandardModule ${e}`);
      const n = new $(e, void 0, r, 0, 0),
        { registerModule: s } = t("internal/modules/esm/utils");
      return (
        s(n, {
          __proto__: null,
          initializeImportMeta: (t, r) =>
            this.importMetaInitialize(t, { url: e }),
          importModuleDynamically: importModuleDynamically,
        }),
        n
      );
    });
    const K = "win32" === o.platform;
    function cjsPreparseModuleExports(e) {
      let t = B._cache[e];
      if (t) {
        const e = L.get(t);
        if (e) return { module: t, exportNames: e.exportNames };
      }
      const r = i(t);
      let o, n, s;
      r ||
        ((t = new B(e)),
        (t.filename = e),
        (t.paths = B._nodeModulePaths(t.path)),
        (B._cache[e] = t));
      try {
        o = P(e, "utf8");
      } catch {}
      try {
        ({ exports: n, reexports: s } = F(o || ""));
      } catch {
        (n = []), (s = []);
      }
      const l = new y(new p(n));
      return (
        L.set(t, { source: o, exportNames: l, loaded: r }),
        s.length && ((t.filename = e), (t.paths = B._nodeModulePaths(t.path))),
        a(s, (e) => {
          let r;
          try {
            r = B._resolveFilename(e, t);
          } catch {
            return;
          }
          const o = E(r);
          if ((".js" === o || ".cjs" === o || !B._extensions[o]) && j(r)) {
            const { exportNames: e } = cjsPreparseModuleExports(r);
            for (const t of e) l.add(t);
          }
        }),
        { module: t, exportNames: l }
      );
    }
    z.set("commonjs", async function commonjsStrategy(e, r, o) {
      I(`Translating CJSModule ${e}`);
      const n = O(new C(e));
      F ||
        (await (async function initCJSParse() {
          if (void 0 === _) F = t("internal/deps/cjs-module-lexer/lexer").parse;
          else {
            const { parse: e, init: r } = t(
              "internal/deps/cjs-module-lexer/dist/lexer"
            );
            try {
              await r(), (F = e);
            } catch {
              F = t("internal/deps/cjs-module-lexer/lexer").parse;
            }
          }
        })());
      const { module: s, exportNames: a } = cjsPreparseModuleExports(n),
        l = a.has("default") ? [...a] : ["default", ...a];
      return new $(e, void 0, l, function () {
        let t;
        if ((I(`Loading CJSModule ${e}`), D.esmLoader.cjsCache.has(s)))
          (t = D.esmLoader.cjsCache.get(s)), D.esmLoader.cjsCache.delete(s);
        else
          try {
            t = B._load(n, void 0, o);
          } catch (e) {
            throw (enrichCJSError(e, void 0, n), e);
          }
        for (const e of a) {
          if (!d(t, e) || "default" === e) continue;
          let r;
          try {
            r = t[e];
          } catch {}
          this.setExport(e, r);
        }
        this.setExport("default", t);
      });
    }),
      z.set("builtin", async function builtinStrategy(e) {
        I(`Translating BuiltinModule ${e}`);
        const t = S(e, 5),
          r = b(t, e);
        if (!x(e, "node:") || !r) throw new J(e);
        return I(`Loading BuiltinModule ${e}`), r.getESMFacade();
      }),
      z.set("json", async function jsonStrategy(e, t) {
        T("Importing JSON modules"),
          assertBufferSource(t, !0, "load"),
          I(`Loading JSONModule ${e}`);
        const r = x(e, "file:") ? O(e) : null,
          o = r && !h(e, "?") && !h(e, "#");
        let n, s;
        if (
          o &&
          ((n = K ? g(r, "/", "\\") : r), (s = B._cache[n]), s && s.loaded)
        ) {
          const t = s.exports;
          return new $(e, void 0, ["default"], function () {
            this.setExport("default", t);
          });
        }
        if (((t = stringify(t)), o && ((s = B._cache[n]), s && s.loaded))) {
          const t = s.exports;
          return new $(e, void 0, ["default"], function () {
            this.setExport("default", t);
          });
        }
        try {
          const e = c(A(t));
          s = { exports: e, loaded: !0 };
        } catch (t) {
          throw ((t.message = errPath(e) + ": " + t.message), t);
        }
        return (
          o && (B._cache[n] = s),
          new $(e, void 0, ["default"], function () {
            I(`Parsing JSONModule ${e}`), this.setExport("default", s.exports);
          })
        );
      }),
      z.set("wasm", async function (e, r) {
        let o;
        T("Importing WebAssembly modules"),
          assertBufferSource(r, !1, "load"),
          I(`Translating WASMModule ${e}`);
        try {
          o = await _.compile(r);
        } catch (t) {
          throw ((t.message = errPath(e) + ": " + t.message), t);
        }
        const n = l(_.Module.imports(o), ({ module: e }) => e),
          s = l(_.Module.exports(o), ({ name: e }) => e);
        return t("internal/modules/esm/create_dynamic_module")(n, s, e, (e) => {
          const { exports: t } = new _.Instance(o, e.imports);
          for (const r of f(t)) e.exports[r].set(t[r]);
        }).module;
      });
  },
  "internal/modules/esm/utils": function (e, t, i, o, n, r) {
    "use strict";
    const { ArrayIsArray: a, SafeSet: l, SafeWeakMap: s, ObjectFreeze: c } = r,
      {
        privateSymbols: { host_defined_option_symbol: d },
      } = n("util"),
      { default_host_defined_options: u, vm_dynamic_import_missing_flag: f } =
        n("symbols"),
      {
        ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG: _,
        ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING: m,
        ERR_INVALID_ARG_VALUE: p,
      } = t("internal/errors").codes,
      { getOptionValue: M } = t("internal/options"),
      { loadPreloadModules: C, initializeFrozenIntrinsics: I } = t(
        "internal/process/pre_execution"
      ),
      { getCWDURL: g } = t("internal/util"),
      {
        setImportModuleDynamicallyCallback: k,
        setInitializeImportMetaObjectCallback: y,
      } = n("module_wrap"),
      b = t("internal/assert");
    let D, z;
    function getDefaultConditions() {
      return b(void 0 !== D), D;
    }
    const S = new s();
    function initializeImportMetaObject(e, t) {
      if (S.has(e)) {
        const { initializeImportMeta: i, callbackReferrer: o } = S.get(e);
        void 0 !== i && (t = i(t, o));
      }
    }
    async function importModuleDynamicallyCallback(e, t, i) {
      if (S.has(e)) {
        const { importModuleDynamically: o, callbackReferrer: n } = S.get(e);
        if (void 0 !== o) return o(t, n, i);
      }
      if (e === f) throw new _();
      throw new m();
    }
    let w = !1;
    i.exports = {
      registerModule: function registerModule(e, t) {
        const i = e[d];
        i !== u && i !== f && ((t.callbackReferrer ??= e), S.set(i, t));
      },
      initializeESM: function initializeESM(e = !1) {
        (w = e),
          (function initializeDefaultConditions() {
            const e = M("--conditions"),
              t = M("--no-addons");
            (D = c(["node", "import", ...(t ? [] : ["node-addons"]), ...e])),
              (z = new l(D));
          })(),
          y(initializeImportMetaObject),
          k(importModuleDynamicallyCallback);
      },
      initializeHooks: async function initializeHooks() {
        const e = M("--experimental-loader"),
          { Hooks: i } = t("internal/modules/esm/hooks"),
          o = t("internal/process/esm_loader").esmLoader,
          n = new i();
        o.setCustomizations(n), C(), I();
        const r = g().href;
        for (let t = 0; t < e.length; t++) await n.register(e[t], r);
        const a = n.initializeGlobalPreload();
        return { __proto__: null, hooks: n, preloadScripts: a };
      },
      getDefaultConditions: getDefaultConditions,
      getConditionsSet: function getConditionsSet(e) {
        if (void 0 !== e && e !== getDefaultConditions()) {
          if (!a(e)) throw new p("conditions", e, "expected an array");
          return new l(e);
        }
        return (function getDefaultConditionsSet() {
          return b(void 0 !== z), z;
        })();
      },
      loaderWorkerId: "internal/modules/esm/worker",
      isLoaderWorker: function isLoaderWorker() {
        return w;
      },
    };
  },
  "internal/modules/esm/worker": function (e, s, r, t, o, a) {
    "use strict";
    const {
        DataViewPrototypeGetBuffer: n,
        Int32Array: c,
        PromisePrototypeThen: i,
        ReflectApply: u,
        SafeSet: l,
        TypedArrayPrototypeGetBuffer: d,
        globalThis: {
          Atomics: { add: f, notify: p },
        },
      } = a,
      g = s("internal/assert"),
      { clearImmediate: h, setImmediate: M } = s("timers"),
      { hasUncaughtExceptionCaptureCallback: y } = s(
        "internal/process/execution"
      ),
      { isArrayBuffer: m, isDataView: w, isTypedArray: k } = s("util/types"),
      { receiveMessageOnPort: x } = s("internal/worker/io"),
      { WORKER_TO_MAIN_THREAD_NOTIFICATION: A } = s(
        "internal/modules/esm/shared_constants"
      ),
      { initializeHooks: E } = s("internal/modules/esm/utils");
    function wrapMessage(e, r) {
      if (
        "success" === e ||
        null === r ||
        ("object" != typeof r && "function" != typeof r && "symbol" != typeof r)
      )
        return { status: e, body: r };
      let t, o;
      try {
        const { serializeError: e } = s("internal/error_serdes");
        t = e(r);
      } catch {
        o = !0;
      }
      return { status: e, body: { serialized: t, serializationFailed: o } };
    }
    async function customizedModuleWorker(e, s, r) {
      let o,
        a,
        c,
        _,
        F = !1;
      {
        const { exit: r } = t;
        t.exit = function (o) {
          return (
            s.postMessage(wrapMessage("exit", o ?? t.exitCode)),
            f(e, A, 1),
            p(e, A),
            u(r, this, arguments)
          );
        };
      }
      try {
        const e = await E();
        (o = e.hooks), (a = e.preloadScripts);
      } catch (e) {
        (F = !0), (c = e);
      }
      function checkForMessages() {
        _ = M(checkForMessages).unref();
        const e = x(s);
        void 0 !== e && i(handleMessage(e.message), void 0, r);
      }
      s.on("message", handleMessage),
        F
          ? s.postMessage(wrapMessage("error", c))
          : s.postMessage(
              wrapMessage("success", { preloadScripts: a }),
              a.map(({ port: e }) => e)
            ),
        f(e, A, 1),
        p(e, A);
      const I = new l();
      async function handleMessage({ method: a, args: c, port: i }) {
        let l,
          x = !1,
          E = !1;
        g("function" == typeof o[a]),
          null != i || y() || (t.on("uncaughtException", r), (E = !0)),
          s.off("message", handleMessage),
          h(_),
          (_ = M(checkForMessages).unref()),
          I.add(i ?? s);
        try {
          l = await u(o[a], o, c);
        } catch (e) {
          (x = !0), (l = e);
        }
        I.delete(i ?? s);
        try {
          (i ?? s).postMessage(
            wrapMessage(x ? "error" : "success", l),
            (function transferArrayBuffer(e, s) {
              if (!e && null != s)
                return m(s) ? [s] : k(s) ? [d(s)] : w(s) ? [n(s)] : void 0;
            })(x, l?.source)
          );
        } catch (e) {
          (i ?? s).postMessage(wrapMessage("error", e));
        }
        f(e, A, 1),
          p(e, A),
          E && t.off("uncaughtException", r),
          s.off("message", handleMessage),
          h(_),
          (_ = M(checkForMessages).unref());
      }
      t.on("beforeExit", () => {
        for (const e of I) e.postMessage(wrapMessage("never-settle"));
        I.clear(),
          f(e, A, 1),
          p(e, A),
          s.on("message", handleMessage),
          h(_),
          checkForMessages(),
          h(_),
          M(() => {});
      });
    }
    r.exports = function setupModuleWorker(e, s) {
      const r = new c(e.lock);
      function errorHandler(e, s = "unhandledRejection") {
        f(r, A, 1),
          p(r, A),
          t.off("uncaughtException", errorHandler),
          y()
            ? t._fatalException(e)
            : o("errors").triggerUncaughtException(
                e,
                "unhandledRejection" === s
              );
      }
      return i(
        customizedModuleWorker(r, s, errorHandler),
        void 0,
        errorHandler
      );
    };
  },
  "internal/modules/helpers": function (e, t, n, o, r, i) {
    "use strict";
    const {
        ArrayPrototypeForEach: l,
        ArrayPrototypeJoin: a,
        ArrayPrototypeSome: s,
        ObjectDefineProperty: u,
        ObjectPrototypeHasOwnProperty: c,
        SafeMap: d,
        SafeSet: p,
        StringPrototypeCharCodeAt: f,
        StringPrototypeIncludes: y,
        StringPrototypeSlice: m,
        StringPrototypeStartsWith: h,
      } = i,
      {
        ERR_INVALID_ARG_TYPE: _,
        ERR_MANIFEST_DEPENDENCY_MISSING: g,
        ERR_UNKNOWN_BUILTIN_MODULE: C,
      } = t("internal/errors").codes,
      { BuiltinModule: b } = t("internal/bootstrap/realm"),
      { validateString: R } = t("internal/validators"),
      P = t("fs"),
      S = t("internal/fs/utils"),
      M = t("path"),
      { pathToFileURL: E, fileURLToPath: j, URL: B } = t("internal/url"),
      { getOptionValue: q } = t("internal/options"),
      { setOwnProperty: v } = t("internal/util"),
      {
        privateSymbols: { require_private_symbol: w },
      } = r("util");
    let L = t("internal/util/debuglog").debuglog("module", (e) => {
      L = e;
    });
    const D = new d();
    let N;
    function initializeCjsConditions() {
      const e = q("--conditions"),
        t = q("--no-addons");
      N = new p(["require", "node", ...(t ? [] : ["node-addons"]), ...e]);
    }
    function getCjsConditions() {
      return void 0 === N && initializeCjsConditions(), N;
    }
    function loadBuiltinModule(e, t) {
      if (!b.canBeRequiredByUsers(e)) return;
      const n = b.map.get(e);
      return L("load built-in module %s", t), n.compileForPublicLoader(), n;
    }
    let O = null;
    const x = new d();
    n.exports = {
      addBuiltinLibsToObject: function addBuiltinLibsToObject(e, n) {
        const o = t("internal/modules/cjs/loader").Module,
          { builtinModules: r } = o,
          i = new o(n);
        l(r, (t) => {
          if (h(t, "_") || y(t, "/") || c(e, t)) return;
          const setReal = (n) => {
            delete e[t], (e[t] = n);
          };
          u(e, t, {
            __proto__: null,
            get: () => {
              const n = i.require(t);
              try {
                u(e, t, {
                  __proto__: null,
                  get: () => n,
                  set: setReal,
                  configurable: !0,
                  enumerable: !1,
                });
              } catch {}
              return n;
            },
            set: setReal,
            configurable: !0,
            enumerable: !1,
          });
        });
      },
      getCjsConditions: getCjsConditions,
      initializeCjsConditions: initializeCjsConditions,
      hasEsmSyntax: function hasEsmSyntax(e) {
        L("Checking for ESM syntax");
        const n = t("internal/deps/acorn/acorn/dist/acorn").Parser;
        let o;
        try {
          o = n.parse(e, { sourceType: "module", ecmaVersion: "latest" });
        } catch {
          return !1;
        }
        return s(
          o.body,
          (e) =>
            "ExportDefaultDeclaration" === e.type ||
            "ExportNamedDeclaration" === e.type ||
            "ImportDeclaration" === e.type ||
            "ExportAllDeclaration" === e.type
        );
      },
      loadBuiltinModule: loadBuiltinModule,
      makeRequireFunction: function makeRequireFunction(e, n) {
        const r = (function lazyModule() {
          return (O = O || t("internal/modules/cjs/loader").Module), O;
        })();
        if (e instanceof r != !0) throw new _("mod", "Module", e);
        let i;
        if (n) {
          const t = e.filename || e.id,
            o = getCjsConditions(),
            { resolve: r, reaction: l } = n;
          i = function require3(n) {
            let i = !0;
            const s = r(n, o);
            if (!0 === s) i = !1;
            else if (s) {
              const { href: t, protocol: n } = s;
              if ("node:" === n) {
                const e = s.pathname;
                if (b.canBeRequiredByUsers(e)) {
                  return loadBuiltinModule(e, t).exports;
                }
                throw new C(e);
              }
              if ("file:" === n) {
                let n = x.get(t);
                return n || ((n = j(s)), x.set(t, n)), e[w](e, n);
              }
            }
            return i && l(new g(t, n, a([...o], ", "))), e[w](e, n);
          };
        } else
          i = function require3(t) {
            return e.require(t);
          };
        function resolve(t, n) {
          return R(t, "request"), r._resolveFilename(t, e, !1, n);
        }
        return (
          (i.resolve = resolve),
          (resolve.paths = function paths(t) {
            return R(t, "request"), r._resolveLookupPaths(t, e);
          }),
          v(i, "main", o.mainModule),
          (i.extensions = r._extensions),
          (i.cache = r._cache),
          i
        );
      },
      normalizeReferrerURL: function normalizeReferrerURL(e) {
        return "string" == typeof e && M.isAbsolute(e)
          ? E(e).href
          : new B(e).href;
      },
      stripBOM: function stripBOM(e) {
        return 65279 === f(e) && (e = m(e, 1)), e;
      },
      toRealPath: function toRealPath(e) {
        return P.realpathSync(e, { [S.realpathCacheKey]: D });
      },
    };
  },
  "internal/modules/package_json_reader": function (e, t, r, a, n, o) {
    "use strict";
    const {
        JSONParse: i,
        ObjectPrototypeHasOwnProperty: s,
        SafeMap: p,
        StringPrototypeEndsWith: c,
        StringPrototypeIndexOf: l,
        StringPrototypeLastIndexOf: d,
        StringPrototypeSlice: m,
      } = o,
      { ERR_INVALID_PACKAGE_CONFIG: f } = t("internal/errors").codes,
      { internalModuleReadJSON: g } = n("fs"),
      { resolve: u, sep: y, toNamespacedPath: P } = t("path"),
      { kEmptyObject: h } = t("internal/util"),
      { fileURLToPath: x, pathToFileURL: S } = t("internal/url"),
      _ = new p(),
      O = "aix" === a.platform;
    let k;
    function read(e, { base: r, specifier: a, isESM: n } = h) {
      if (_.has(e)) return _.get(e);
      const { 0: o, 1: p } = g(P(e)),
        c = {
          __proto__: null,
          exists: !1,
          pjsonPath: e,
          main: void 0,
          name: void 0,
          type: "none",
          exports: void 0,
          imports: void 0,
        };
      if (O && !n ? p : void 0 !== o) {
        let p;
        try {
          p = i(o);
        } catch (t) {
          throw n
            ? new f(e, (r ? `"${a}" from ` : "") + x(r || a), t.message)
            : ((t.message = "Error parsing " + e + ": " + t.message),
              (t.path = e),
              t);
        }
        if (
          ((c.exists = !0),
          s(p, "name") && "string" == typeof p.name && (c.name = p.name),
          s(p, "main") && "string" == typeof p.main && (c.main = p.main),
          s(p, "exports") && (c.exports = p.exports),
          s(p, "imports") && (c.imports = p.imports),
          !s(p, "type") ||
            ("commonjs" !== p.type && "module" !== p.type) ||
            (c.type = p.type),
          void 0 === k)
        ) {
          const { getOptionValue: e } = t("internal/options");
          k = e("--experimental-policy")
            ? t("internal/process/policy").manifest
            : null;
        }
        if (null !== k) {
          const t = S(e);
          k.assertIntegrity(t, o);
        }
      }
      return _.set(e, c), c;
    }
    function readPackage(e) {
      return read(u(e, "package.json"));
    }
    r.exports = {
      read: read,
      readPackage: readPackage,
      readPackageScope: function readPackageScope(e) {
        const t = l(e, y);
        let r;
        do {
          if (((r = d(e, y)), (e = m(e, 0, r)), c(e, y + "node_modules")))
            return !1;
          const t = readPackage(e + y);
          if (t.exists) return { data: t, path: e };
        } while (r > t);
        return !1;
      },
    };
  },
  "internal/modules/run_main": function (e, n, t, r, o, i) {
    "use strict";
    const { StringPrototypeEndsWith: l } = i,
      { getOptionValue: a } = n("internal/options"),
      s = n("path");
    async function handleMainPromise(e) {
      const { handleProcessExit: t } = n(
        "internal/modules/esm/handle_process_exit"
      );
      r.on("exit", t);
      try {
        return await e;
      } finally {
        r.off("exit", t);
      }
    }
    t.exports = {
      executeUserEntryPoint: function executeUserEntryPoint(e = r.argv[1]) {
        const t = (function resolveMainPath(e) {
          const t = a("--experimental-default-type");
          let r;
          if ("module" === t) {
            if (a("--preserve-symlinks-main")) return;
            r = s.resolve(e);
          } else {
            const { Module: t } = n("internal/modules/cjs/loader");
            r = t._findPath(s.resolve(e), null, !0);
          }
          if (!r) return;
          if (!a("--preserve-symlinks-main")) {
            const { toRealPath: e } = n("internal/modules/helpers");
            try {
              r = e(r);
            } catch (e) {
              if ("module" === t && "ENOENT" === e?.code) {
                const { decorateErrorWithCommonJSHints: t } = n(
                    "internal/modules/esm/resolve"
                  ),
                  { getCWDURL: o } = n("internal/util");
                t(e, r, o());
              }
              throw e;
            }
          }
          return r;
        })(e);
        if (
          (function shouldUseESMLoader(e) {
            if ("module" === a("--experimental-default-type")) return !0;
            const t = a("--experimental-loader"),
              r = a("--import");
            if (t.length > 0 || r.length > 0) return !0;
            if ("node" === a("--experimental-specifier-resolution")) return !0;
            if (e && l(e, ".mjs")) return !0;
            if (!e || l(e, ".cjs")) return !1;
            const { readPackageScope: o } = n(
                "internal/modules/package_json_reader"
              ),
              i = o(e);
            return (
              "module" === i.data?.type ||
              "module" === a("--experimental-default-type")
            );
          })(t)
        )
          !(function runMainESM(e) {
            const { loadESM: t } = n("internal/process/esm_loader"),
              { pathToFileURL: r } = n("internal/url"),
              o = r(e).href;
            handleMainPromise(
              t((e) => e.import(o, void 0, { __proto__: null }))
            );
          })(t || e);
        else {
          const { Module: t } = n("internal/modules/cjs/loader");
          t._load(e, null, !0);
        }
      },
      handleMainPromise: handleMainPromise,
    };
  },
  "internal/net": function (e, n, i, r, t, $) {
    "use strict";
    const { RegExp: o, RegExpPrototypeTest: s, Symbol: f } = $,
      u = n("buffer").Buffer,
      { writeBuffer: l } = t("fs"),
      c = n("internal/errors"),
      a = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])",
      v = `(${a}[.]){3}${a}`,
      I = new o(`^${v}$`),
      P = "(?:[0-9a-fA-F]{1,4})",
      d = new o(
        `^((?:${P}:){7}(?:${P}|:)|(?:${P}:){6}(?:${v}|:${P}|:)|(?:${P}:){5}(?::${v}|(:${P}){1,2}|:)|(?:${P}:){4}(?:(:${P}){0,1}:${v}|(:${P}){1,3}|:)|(?:${P}:){3}(?:(:${P}){0,2}:${v}|(:${P}){1,4}|:)|(?:${P}:){2}(?:(:${P}){0,3}:${v}|(:${P}){1,5}|:)|(?:${P}:){1}(?:(:${P}){0,4}:${v}|(:${P}){1,6}|:)|(?::((?::${P}){0,5}:${v}|(?::${P}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`
      );
    function isIPv4(e) {
      return s(I, e);
    }
    function isIPv6(e) {
      return s(d, e);
    }
    i.exports = {
      kReinitializeHandle: f("reinitializeHandle"),
      isIP: function isIP(e) {
        return isIPv4(e) ? 4 : isIPv6(e) ? 6 : 0;
      },
      isIPv4: isIPv4,
      isIPv6: isIPv6,
      makeSyncWrite: function makeSyncWrite(e) {
        return function (n, i, r) {
          "buffer" !== i && (n = u.from(n, i)),
            (this._handle.bytesWritten += n.length);
          const t = {};
          if ((l(e, n, 0, n.length, null, void 0, t), void 0 !== t.errno)) {
            const e = c.uvException(t);
            return (e.errno = t.errno), r(e);
          }
          r();
        };
      },
      normalizedArgsSymbol: f("normalizedArgs"),
    };
  },
  "internal/options": function (t, n, e, i, o, r) {
    "use strict";
    const { getCLIOptions: s, getEmbedderOptions: u } = o("options");
    let g,
      a,
      c,
      d = !0;
    function getCLIOptionsFromBinding() {
      return g || ({ options: g } = s()), g;
    }
    e.exports = {
      get options() {
        return getCLIOptionsFromBinding();
      },
      get aliases() {
        return (function getAliasesFromBinding() {
          return a || ({ aliases: a } = s()), a;
        })();
      },
      getOptionValue: function getOptionValue(t) {
        const n = getCLIOptionsFromBinding();
        if (t.startsWith("--no-")) {
          const e = n.get("--" + t.slice(5));
          return e && !e.value;
        }
        return n.get(t)?.value;
      },
      getAllowUnauthorized: function getAllowUnauthorized() {
        const t = "0" === i.env.NODE_TLS_REJECT_UNAUTHORIZED;
        return (
          t &&
            d &&
            ((d = !1),
            i.emitWarning(
              "Setting the NODE_TLS_REJECT_UNAUTHORIZED environment variable to '0' makes TLS connections and HTTPS requests insecure by disabling certificate verification."
            )),
          t
        );
      },
      getEmbedderOptions: function getEmbedderOptions() {
        return c || (c = u()), c;
      },
      refreshOptions: function refreshOptions() {
        (g = void 0), (a = void 0);
      },
    };
  },
  "internal/per_context/domexception": function (r, e) {
    "use strict";
    const {
      ErrorCaptureStackTrace: o,
      ErrorPrototype: t,
      ObjectDefineProperties: E,
      ObjectDefineProperty: n,
      ObjectSetPrototypeOf: a,
      SafeWeakMap: i,
      SafeMap: _,
      SafeSet: R,
      SymbolToStringTag: s,
      TypeError: c,
    } = e;
    function throwInvalidThisError(r, e) {
      const o = new r(),
        t = "ERR_INVALID_THIS";
      throw (
        (E(o, {
          message: {
            __proto__: null,
            value: `Value of "this" must be of ${e}`,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
          toString: {
            __proto__: null,
            value() {
              return `${this.name} [${t}]: ${this.message}`;
            },
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        }),
        (o.code = t),
        o)
      );
    }
    const l = new i(),
      u = new _(),
      I = new R()
        .add("DOMStringSizeError")
        .add("NoDataAllowedError")
        .add("ValidationError");
    class DOMException {
      constructor(r = "", e = "Error") {
        if ((o(this), e && "object" == typeof e)) {
          const { name: o } = e;
          l.set(this, { message: `${r}`, name: `${o}` }),
            "cause" in e &&
              n(this, "cause", {
                __proto__: null,
                value: e.cause,
                configurable: !0,
                writable: !0,
                enumerable: !1,
              });
        } else l.set(this, { message: `${r}`, name: `${e}` });
      }
      get name() {
        const r = l.get(this);
        return void 0 === r && throwInvalidThisError(c, "DOMException"), r.name;
      }
      get message() {
        const r = l.get(this);
        return (
          void 0 === r && throwInvalidThisError(c, "DOMException"), r.message
        );
      }
      get code() {
        const r = l.get(this);
        if (
          (void 0 === r && throwInvalidThisError(c, "DOMException"),
          I.has(r.name))
        )
          return 0;
        const e = u.get(r.name);
        return void 0 === e ? 0 : e;
      }
    }
    a(DOMException.prototype, t),
      E(DOMException.prototype, {
        [s]: { __proto__: null, configurable: !0, value: "DOMException" },
        name: { __proto__: null, enumerable: !0, configurable: !0 },
        message: { __proto__: null, enumerable: !0, configurable: !0 },
        code: { __proto__: null, enumerable: !0, configurable: !0 },
      });
    for (const { 0: r, 1: e, 2: o } of [
      ["IndexSizeError", "INDEX_SIZE_ERR", 1],
      ["DOMStringSizeError", "DOMSTRING_SIZE_ERR", 2],
      ["HierarchyRequestError", "HIERARCHY_REQUEST_ERR", 3],
      ["WrongDocumentError", "WRONG_DOCUMENT_ERR", 4],
      ["InvalidCharacterError", "INVALID_CHARACTER_ERR", 5],
      ["NoDataAllowedError", "NO_DATA_ALLOWED_ERR", 6],
      ["NoModificationAllowedError", "NO_MODIFICATION_ALLOWED_ERR", 7],
      ["NotFoundError", "NOT_FOUND_ERR", 8],
      ["NotSupportedError", "NOT_SUPPORTED_ERR", 9],
      ["InUseAttributeError", "INUSE_ATTRIBUTE_ERR", 10],
      ["InvalidStateError", "INVALID_STATE_ERR", 11],
      ["SyntaxError", "SYNTAX_ERR", 12],
      ["InvalidModificationError", "INVALID_MODIFICATION_ERR", 13],
      ["NamespaceError", "NAMESPACE_ERR", 14],
      ["InvalidAccessError", "INVALID_ACCESS_ERR", 15],
      ["ValidationError", "VALIDATION_ERR", 16],
      ["TypeMismatchError", "TYPE_MISMATCH_ERR", 17],
      ["SecurityError", "SECURITY_ERR", 18],
      ["NetworkError", "NETWORK_ERR", 19],
      ["AbortError", "ABORT_ERR", 20],
      ["URLMismatchError", "URL_MISMATCH_ERR", 21],
      ["QuotaExceededError", "QUOTA_EXCEEDED_ERR", 22],
      ["TimeoutError", "TIMEOUT_ERR", 23],
      ["InvalidNodeTypeError", "INVALID_NODE_TYPE_ERR", 24],
      ["DataCloneError", "DATA_CLONE_ERR", 25],
    ]) {
      const t = { enumerable: !0, value: o };
      n(DOMException, e, t), n(DOMException.prototype, e, t), u.set(r, o);
    }
    r.DOMException = DOMException;
  },
  "internal/per_context/messageport": function (t, s) {
    "use strict";
    const { SymbolFor: e } = s;
    class MessageEvent {
      constructor(t, s, e, n) {
        (this.data = t),
          (this.target = s),
          (this.type = e),
          (this.ports = n ?? []);
      }
    }
    const n = e("nodejs.internal.kHybridDispatch"),
      i = e("nodejs.internal.kCurrentlyReceivingPorts");
    t.emitMessage = function (t, s, e) {
      if ("function" == typeof this[n]) {
        this[i] = s;
        try {
          this[n](t, e, void 0);
        } finally {
          this[i] = void 0;
        }
        return;
      }
      const o = new MessageEvent(t, this, e, s);
      "message" === e
        ? "function" == typeof this.onmessage && this.onmessage(o)
        : "function" == typeof this.onmessageerror && this.onmessageerror(o);
    };
  },
  "internal/per_context/primordials": function (e, t) {
    "use strict";
    const {
        defineProperty: o,
        getOwnPropertyDescriptor: r,
        ownKeys: n,
      } = Reflect,
      { apply: l, bind: a, call: p } = Function.prototype,
      c = a.bind(p);
    t.uncurryThis = c;
    const i = a.bind(l);
    t.applyBind = i;
    const s = [
      "ArrayOf",
      "ArrayPrototypePush",
      "ArrayPrototypeUnshift",
      "MathHypot",
      "MathMax",
      "MathMin",
      "StringFromCharCode",
      "StringFromCodePoint",
      "StringPrototypeConcat",
      "TypedArrayOf",
    ];
    function getNewKey(e) {
      return "symbol" == typeof e
        ? `Symbol${e.description[7].toUpperCase()}${e.description.slice(8)}`
        : `${e[0].toUpperCase()}${e.slice(1)}`;
    }
    function copyAccessor(e, t, r, { enumerable: n, get: l, set: a }) {
      o(e, `${t}Get${r}`, { __proto__: null, value: c(l), enumerable: n }),
        void 0 !== a &&
          o(e, `${t}Set${r}`, { __proto__: null, value: c(a), enumerable: n });
    }
    function copyPropsRenamed(e, t, l) {
      for (const a of n(e)) {
        const n = getNewKey(a),
          p = r(e, a);
        if ("get" in p) copyAccessor(t, l, n, p);
        else {
          const r = `${l}${n}`;
          o(t, r, { __proto__: null, ...p }),
            s.includes(r) &&
              o(t, `${r}Apply`, { __proto__: null, value: i(p.value, e) });
        }
      }
    }
    function copyPrototype(e, t, l) {
      for (const a of n(e)) {
        const n = getNewKey(a),
          p = r(e, a);
        if ("get" in p) copyAccessor(t, l, n, p);
        else {
          const { value: e } = p;
          "function" == typeof e && (p.value = c(e));
          const r = `${l}${n}`;
          o(t, r, { __proto__: null, ...p }),
            s.includes(r) &&
              o(t, `${r}Apply`, { __proto__: null, value: i(e) });
        }
      }
    }
    ["Proxy", "globalThis"].forEach((e) => {
      t[e] = globalThis[e];
    }),
      [decodeURI, decodeURIComponent, encodeURI, encodeURIComponent].forEach(
        (e) => {
          t[e.name] = e;
        }
      ),
      [escape, eval, unescape].forEach((e) => {
        t[e.name] = e;
      }),
      ["JSON", "Math", "Proxy", "Reflect"].forEach((e) => {
        copyPropsRenamed(globalThis[e], t, e);
      }),
      [
        "AggregateError",
        "Array",
        "ArrayBuffer",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "Boolean",
        "DataView",
        "Date",
        "Error",
        "EvalError",
        "FinalizationRegistry",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Map",
        "Number",
        "Object",
        "RangeError",
        "ReferenceError",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "SyntaxError",
        "TypeError",
        "URIError",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "WeakMap",
        "WeakRef",
        "WeakSet",
      ].forEach((e) => {
        const o = globalThis[e];
        (t[e] = o),
          copyPropsRenamed(o, t, e),
          copyPrototype(o.prototype, t, `${e}Prototype`);
      }),
      (t.SymbolDispose ??= t.SymbolFor("nodejs.dispose")),
      (t.SymbolAsyncDispose ??= t.SymbolFor("nodejs.asyncDispose")),
      ["Promise"].forEach((e) => {
        const l = globalThis[e];
        (t[e] = l),
          (function copyPropsRenamedBound(e, t, l) {
            for (const a of n(e)) {
              const n = getNewKey(a),
                p = r(e, a);
              if ("get" in p) copyAccessor(t, l, n, p);
              else {
                const { value: r } = p;
                "function" == typeof r && (p.value = r.bind(e));
                const a = `${l}${n}`;
                o(t, a, { __proto__: null, ...p }),
                  s.includes(a) &&
                    o(t, `${a}Apply`, { __proto__: null, value: i(r, e) });
              }
            }
          })(l, t, e),
          copyPrototype(l.prototype, t, `${e}Prototype`);
      }),
      [
        { name: "TypedArray", original: Reflect.getPrototypeOf(Uint8Array) },
        {
          name: "ArrayIterator",
          original: {
            prototype: Reflect.getPrototypeOf(
              Array.prototype[Symbol.iterator]()
            ),
          },
        },
        {
          name: "StringIterator",
          original: {
            prototype: Reflect.getPrototypeOf(
              String.prototype[Symbol.iterator]()
            ),
          },
        },
      ].forEach(({ name: e, original: o }) => {
        (t[e] = o),
          copyPrototype(o, t, e),
          copyPrototype(o.prototype, t, `${e}Prototype`);
      }),
      (t.IteratorPrototype = Reflect.getPrototypeOf(t.ArrayIteratorPrototype));
    const {
        Array: y,
        ArrayPrototypeForEach: u,
        ArrayPrototypeMap: f,
        FinalizationRegistry: _,
        FunctionPrototypeCall: g,
        Map: S,
        ObjectDefineProperties: P,
        ObjectDefineProperty: d,
        ObjectFreeze: R,
        ObjectSetPrototypeOf: b,
        Promise: m,
        PromisePrototypeThen: A,
        PromiseResolve: x,
        ReflectApply: h,
        ReflectConstruct: E,
        ReflectSet: v,
        ReflectGet: I,
        RegExp: F,
        RegExpPrototype: w,
        RegExpPrototypeExec: $,
        RegExpPrototypeGetDotAll: k,
        RegExpPrototypeGetFlags: M,
        RegExpPrototypeGetGlobal: O,
        RegExpPrototypeGetHasIndices: U,
        RegExpPrototypeGetIgnoreCase: G,
        RegExpPrototypeGetMultiline: C,
        RegExpPrototypeGetSource: W,
        RegExpPrototypeGetSticky: D,
        RegExpPrototypeGetUnicode: T,
        Set: N,
        SymbolIterator: j,
        SymbolMatch: B,
        SymbolMatchAll: z,
        SymbolReplace: K,
        SymbolSearch: L,
        SymbolSpecies: V,
        SymbolSplit: H,
        WeakMap: J,
        WeakRef: q,
        WeakSet: Q,
      } = t,
      createSafeIterator = (e, t) => {
        class SafeIterator {
          constructor(t) {
            this._iterator = e(t);
          }
          next() {
            return t(this._iterator);
          }
          [j]() {
            return this;
          }
        }
        return b(SafeIterator.prototype, null), SafeIterator;
      };
    (t.SafeArrayIterator = createSafeIterator(
      t.ArrayPrototypeSymbolIterator,
      t.ArrayIteratorPrototypeNext
    )),
      (t.SafeStringIterator = createSafeIterator(
        t.StringPrototypeSymbolIterator,
        t.StringIteratorPrototypeNext
      ));
    const copyProps = (e, t) => {
        u(n(e), (n) => {
          r(t, n) || o(t, n, { __proto__: null, ...r(e, n) });
        });
      },
      makeSafe = (e, t) => {
        if (j in e.prototype) {
          const l = new e();
          let a;
          u(n(e.prototype), (n) => {
            if (!r(t.prototype, n)) {
              const p = r(e.prototype, n);
              if (
                "function" == typeof p.value &&
                0 === p.value.length &&
                j in (g(p.value, l) ?? {})
              ) {
                const e = c(p.value);
                a ??= c(e(l).next);
                const t = createSafeIterator(e, a);
                p.value = function () {
                  return new t(this);
                };
              }
              o(t.prototype, n, { __proto__: null, ...p });
            }
          });
        } else copyProps(e.prototype, t.prototype);
        return copyProps(e, t), b(t.prototype, null), t;
      };
    (t.makeSafe = makeSafe),
      (t.SafeMap = makeSafe(
        S,
        class SafeMap extends S {
          constructor(e) {
            super(e);
          }
        }
      )),
      (t.SafeWeakMap = makeSafe(
        J,
        class SafeWeakMap extends J {
          constructor(e) {
            super(e);
          }
        }
      )),
      (t.SafeSet = makeSafe(
        N,
        class SafeSet extends N {
          constructor(e) {
            super(e);
          }
        }
      )),
      (t.SafeWeakSet = makeSafe(
        Q,
        class SafeWeakSet extends Q {
          constructor(e) {
            super(e);
          }
        }
      )),
      (t.SafeFinalizationRegistry = makeSafe(
        _,
        class SafeFinalizationRegistry extends _ {
          constructor(e) {
            super(e);
          }
        }
      )),
      (t.SafeWeakRef = makeSafe(
        q,
        class SafeWeakRef extends q {
          constructor(e) {
            super(e);
          }
        }
      ));
    const X = makeSafe(
      m,
      class SafePromise extends m {
        constructor(e) {
          super(e);
        }
      }
    );
    (t.SafePromisePrototypeFinally = (e, t) =>
      new m((o, r) => new X((t, o) => A(e, t, o)).finally(t).then(o, r))),
      (t.AsyncIteratorPrototype = t.ReflectGetPrototypeOf(
        t.ReflectGetPrototypeOf(async function* () {}).prototype
      ));
    const arrayToSafePromiseIterable = (e, o) =>
      new t.SafeArrayIterator(
        f(e, (e, t) => new X((r, n) => A(null == o ? e : o(e, t), r, n)))
      );
    (t.SafePromiseAll = (e, t) =>
      new m((o, r) => X.all(arrayToSafePromiseIterable(e, t)).then(o, r))),
      (t.SafePromiseAllReturnArrayLike = (e, t) =>
        new m((o, r) => {
          const { length: n } = e,
            l = y(n);
          b(l, null), 0 === n && o(l);
          let a = n;
          for (let p = 0; p < n; p++) {
            const n = null != t ? t(e[p], p) : e[p];
            A(
              x(n),
              (e) => {
                (l[p] = e), 0 == --a && o(l);
              },
              r
            );
          }
        })),
      (t.SafePromiseAllReturnVoid = (e, t) =>
        new m((o, r) => {
          let n = e.length;
          0 === n && o();
          for (let l = 0; l < e.length; l++) {
            const a = null != t ? t(e[l], l) : e[l];
            A(
              x(a),
              () => {
                0 == --n && o();
              },
              r
            );
          }
        })),
      (t.SafePromiseAllSettled = (e, t) =>
        new m((o, r) =>
          X.allSettled(arrayToSafePromiseIterable(e, t)).then(o, r)
        )),
      (t.SafePromiseAllSettledReturnVoid = async (e, o) => {
        await t.SafePromiseAllSettled(e, o);
      }),
      (t.SafePromiseAny = (e, t) =>
        new m((o, r) => X.any(arrayToSafePromiseIterable(e, t)).then(o, r))),
      (t.SafePromiseRace = (e, t) =>
        new m((o, r) => X.race(arrayToSafePromiseIterable(e, t)).then(o, r)));
    const { exec: Y, [B]: Z, [z]: ee, [K]: te, [L]: oe, [H]: re } = w;
    class RegExpLikeForStringSplitting {
      #e;
      constructor() {
        this.#e = E(F, arguments);
      }
      get lastIndex() {
        return I(this.#e, "lastIndex");
      }
      set lastIndex(e) {
        v(this.#e, "lastIndex", e);
      }
      exec() {
        return h(Y, this.#e, arguments);
      }
    }
    b(RegExpLikeForStringSplitting.prototype, null),
      (t.hardenRegExp = function hardenRegExp(e) {
        return (
          P(e, {
            [B]: { __proto__: null, configurable: !0, value: Z },
            [z]: { __proto__: null, configurable: !0, value: ee },
            [K]: { __proto__: null, configurable: !0, value: te },
            [L]: { __proto__: null, configurable: !0, value: oe },
            [H]: { __proto__: null, configurable: !0, value: re },
            constructor: {
              __proto__: null,
              configurable: !0,
              value: { [V]: RegExpLikeForStringSplitting },
            },
            dotAll: { __proto__: null, configurable: !0, value: k(e) },
            exec: { __proto__: null, configurable: !0, value: Y },
            global: { __proto__: null, configurable: !0, value: O(e) },
            hasIndices: { __proto__: null, configurable: !0, value: U(e) },
            ignoreCase: { __proto__: null, configurable: !0, value: G(e) },
            multiline: { __proto__: null, configurable: !0, value: C(e) },
            source: { __proto__: null, configurable: !0, value: W(e) },
            sticky: { __proto__: null, configurable: !0, value: D(e) },
            unicode: { __proto__: null, configurable: !0, value: T(e) },
          }),
          d(e, "flags", { __proto__: null, configurable: !0, value: M(e) }),
          e
        );
      }),
      (t.SafeStringPrototypeSearch = (e, t) => {
        t.lastIndex = 0;
        const o = $(t, e);
        return o ? o.index : -1;
      }),
      b(t, null);
  },
  "internal/perf/event_loop_delay": function (t, e, r, i, n, s) {
    "use strict";
    const { ReflectConstruct: o, SafeMap: a, Symbol: l } = s,
      {
        codes: { ERR_ILLEGAL_CONSTRUCTOR: c, ERR_INVALID_THIS: h },
      } = e("internal/errors"),
      { createELDHistogram: m } = n("performance"),
      { validateInteger: u, validateObject: E } = e("internal/validators"),
      { Histogram: d, kHandle: f, kMap: L } = e("internal/histogram"),
      { kEmptyObject: p } = e("internal/util"),
      { makeTransferable: b } = e("internal/worker/js_transferable"),
      g = l("kEnabled");
    class ELDHistogram extends d {
      constructor(t) {
        throw new c();
      }
      enable() {
        if (void 0 === this[g]) throw new h("ELDHistogram");
        return !this[g] && ((this[g] = !0), this[f].start(), !0);
      }
      disable() {
        if (void 0 === this[g]) throw new h("ELDHistogram");
        return !!this[g] && ((this[g] = !1), this[f].stop(), !0);
      }
    }
    r.exports = function monitorEventLoopDelay(t = p) {
      E(t, "options");
      const { resolution: e = 10 } = t;
      return (
        u(e, "options.resolution", 1),
        b(
          o(
            function () {
              (this[g] = !1), (this[f] = m(e)), (this[L] = new a());
            },
            [],
            ELDHistogram
          )
        )
      );
    };
  },
  "internal/perf/event_loop_utilization": function (i, t, e, n, o, l) {
    "use strict";
    const a = t("internal/perf/nodetiming"),
      { now: c } = t("internal/perf/utils");
    e.exports = function eventLoopUtilization(i, t) {
      const e = a.loopStart;
      if (e <= 0) return { idle: 0, active: 0, utilization: 0 };
      if (t) {
        const e = i.idle - t.idle,
          n = i.active - t.active;
        return { idle: e, active: n, utilization: n / (e + n) };
      }
      const n = a.idleTime,
        o = c() - e - n;
      if (!i) return { idle: n, active: o, utilization: o / (n + o) };
      const l = n - i.idle,
        r = o - i.active;
      return { idle: l, active: r, utilization: r / (l + r) };
    };
  },
  "internal/perf/nodetiming": function (e, t, o, n, r, l) {
    "use strict";
    const { ObjectDefineProperties: _, ObjectSetPrototypeOf: i } = l,
      { PerformanceEntry: a } = t("internal/perf/performance_entry"),
      { now: u, getMilestoneTimestamp: p } = t("internal/perf/utils"),
      { customInspectSymbol: m } = t("internal/util"),
      { inspect: E } = t("util"),
      {
        constants: {
          NODE_PERFORMANCE_MILESTONE_NODE_START: s,
          NODE_PERFORMANCE_MILESTONE_V8_START: O,
          NODE_PERFORMANCE_MILESTONE_LOOP_START: c,
          NODE_PERFORMANCE_MILESTONE_LOOP_EXIT: T,
          NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE: N,
          NODE_PERFORMANCE_MILESTONE_ENVIRONMENT: b,
        },
        loopIdleTime: f,
      } = r("performance");
    class PerformanceNodeTiming {
      constructor() {
        _(this, {
          name: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            value: "node",
          },
          entryType: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            value: "node",
          },
          startTime: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            value: 0,
          },
          duration: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: u,
          },
          nodeStart: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: () => p(s),
          },
          v8Start: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: () => p(O),
          },
          environment: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: () => p(b),
          },
          loopStart: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: () => p(c),
          },
          loopExit: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: () => p(T),
          },
          bootstrapComplete: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: () => p(N),
          },
          idleTime: {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get: f,
          },
        });
      }
      [m](e, t) {
        if (e < 0) return this;
        const o = { ...t, depth: null == t.depth ? null : t.depth - 1 };
        return `PerformanceNodeTiming ${E(this.toJSON(), o)}`;
      }
      toJSON() {
        return {
          name: "node",
          entryType: "node",
          startTime: this.startTime,
          duration: this.duration,
          nodeStart: this.nodeStart,
          v8Start: this.v8Start,
          bootstrapComplete: this.bootstrapComplete,
          environment: this.environment,
          loopStart: this.loopStart,
          loopExit: this.loopExit,
          idleTime: this.idleTime,
        };
      }
    }
    i(PerformanceNodeTiming.prototype, a.prototype),
      (o.exports = new PerformanceNodeTiming());
  },
  "internal/perf/observe": function (e, r, t, n, s, i) {
    "use strict";
    const {
        ArrayFrom: o,
        ArrayIsArray: a,
        ArrayPrototypeFilter: c,
        ArrayPrototypeIncludes: f,
        ArrayPrototypePush: u,
        ArrayPrototypePushApply: l,
        ArrayPrototypeSlice: y,
        ArrayPrototypeSort: p,
        Error: m,
        MathMax: h,
        MathMin: d,
        ObjectDefineProperties: b,
        ObjectFreeze: T,
        ObjectKeys: E,
        SafeMap: v,
        SafeSet: P,
        Symbol: g,
      } = i,
      {
        constants: {
          NODE_PERFORMANCE_ENTRY_TYPE_GC: O,
          NODE_PERFORMANCE_ENTRY_TYPE_HTTP2: _,
          NODE_PERFORMANCE_ENTRY_TYPE_HTTP: R,
          NODE_PERFORMANCE_ENTRY_TYPE_NET: N,
          NODE_PERFORMANCE_ENTRY_TYPE_DNS: A,
        },
        installGarbageCollectionTracking: k,
        observerCounts: w,
        removeGarbageCollectionTracking: M,
        setupObservers: D,
      } = s("performance"),
      { InternalPerformanceEntry: B, isPerformanceEntry: I } = r(
        "internal/perf/performance_entry"
      ),
      {
        codes: {
          ERR_INVALID_ARG_VALUE: C,
          ERR_INVALID_ARG_TYPE: F,
          ERR_MISSING_ARGS: S,
        },
      } = r("internal/errors"),
      { validateFunction: Y, validateObject: q } = r("internal/validators"),
      {
        customInspectSymbol: z,
        deprecate: L,
        lazyDOMException: G,
        kEmptyObject: $,
      } = r("internal/util"),
      { setImmediate: x } = r("timers"),
      { inspect: j } = r("util"),
      { now: U } = r("internal/perf/utils"),
      { convertToInt: V } = r("internal/webidl"),
      H = g("kDispatch"),
      W = g("kMaybeBuffer"),
      K = g("kDeprecatedFields"),
      J =
        "Custom PerformanceEntry accessors are deprecated. Please use the detail property.";
    let Q = !1;
    const X = T([
      "dns",
      "function",
      "gc",
      "http",
      "http2",
      "mark",
      "measure",
      "net",
      "resource",
    ]);
    let Z = [],
      ee = [],
      re = [],
      te = [];
    let ne,
      se = 250,
      ie = !1;
    const oe = T({
        mark: "performance.clearMarks",
        measure: "performance.clearMeasures",
      }),
      ae = new v(),
      ce = new P(),
      fe = new P();
    let ue = !1;
    function queuePending() {
      ue ||
        ((ue = !0),
        x(() => {
          ue = !1;
          const e = o(fe.values());
          fe.clear();
          for (const r of e) r[H]();
        }));
    }
    function getObserverType(e) {
      switch (e) {
        case "gc":
          return O;
        case "http2":
          return _;
        case "http":
          return R;
        case "net":
          return N;
        case "dns":
          return A;
      }
    }
    function maybeDecrementObserverCounts(e) {
      for (const r of e) {
        const e = getObserverType(r);
        void 0 !== e && (w[e]--, e === O && 0 === w[e] && (M(), (Q = !1)));
      }
    }
    function maybeIncrementObserverCount(e) {
      const r = getObserverType(e);
      void 0 !== r && (w[r]++, Q || r !== O || (k(), (Q = !0)));
    }
    class PerformanceObserverEntryList {
      #e = [];
      constructor(e) {
        this.#e = p(e, (e, r) => e.startTime - r.startTime);
      }
      getEntries() {
        return y(this.#e);
      }
      getEntriesByType(e) {
        return (e = `${e}`), c(this.#e, (r) => r.entryType === e);
      }
      getEntriesByName(e, r) {
        return (
          (e = `${e}`),
          c(
            this.#e,
            null != r
              ? (t) => t.name === e && t.entryType === r
              : (r) => r.name === e
          )
        );
      }
      [z](e, r) {
        if (e < 0) return this;
        const t = { ...r, depth: null == r.depth ? null : r.depth - 1 };
        return `PerformanceObserverEntryList ${j(this.#e, t)}`;
      }
    }
    function enqueue(e) {
      if (!I(e)) throw new F("entry", "PerformanceEntry", e);
      for (const r of ce) r[W](e);
    }
    function filterBufferMapByNameAndType(e, r) {
      let t;
      if ("mark" === r) t = Z;
      else if ("measure" === r) t = ee;
      else if ("resource" === r) t = re;
      else {
        if (void 0 !== r) return [];
        (t = []), l(t, Z), l(t, ee), l(t, re);
      }
      return (
        void 0 !== e
          ? (t = c(t, (r) => r.name === e))
          : void 0 !== r && (t = y(t)),
        p(t, (e, r) => e.startTime - r.startTime)
      );
    }
    D(function observerCallback(e, r, t, n, s) {
      const i = new B(e, r, t, n, s);
      if (void 0 !== s) {
        i[K] = new v();
        const e = E(s),
          r = {};
        for (let t = 0; t < e.length; t++) {
          const n = e[t];
          i[K].set(n, s[n]),
            (r[n] = {
              configurable: !0,
              enumerable: !0,
              get: L(() => i[K].get(n), J, "DEP0152"),
              set: L(
                (e) => {
                  i[K].set(n, e);
                },
                J,
                "DEP0152"
              ),
            });
        }
        b(i, r);
      }
      enqueue(i);
    }),
      (t.exports = {
        PerformanceObserver: class PerformanceObserver {
          #e = [];
          #r = new P();
          #t;
          #n;
          constructor(e) {
            Y(e, "callback"), (this.#n = e);
          }
          observe(e = $) {
            q(e, "options");
            const { entryTypes: r, type: t, buffered: n } = { ...e };
            if (void 0 === r && void 0 === t)
              throw new S("options.entryTypes", "options.type");
            if (null != r && null != t)
              throw new C(
                "options.entryTypes",
                r,
                "options.entryTypes can not set with options.type together"
              );
            switch (this.#t) {
              case void 0:
                void 0 !== r && (this.#t = 1), void 0 !== t && (this.#t = 0);
                break;
              case 0:
                if (void 0 !== r)
                  throw G(
                    "PerformanceObserver can not change to multiple observations",
                    "InvalidModificationError"
                  );
                break;
              case 1:
                if (void 0 !== t)
                  throw G(
                    "PerformanceObserver can not change to single observation",
                    "InvalidModificationError"
                  );
            }
            if (1 === this.#t) {
              if (!a(r)) throw new F("options.entryTypes", "string[]", r);
              maybeDecrementObserverCounts(this.#r), this.#r.clear();
              for (let e = 0; e < r.length; e++)
                f(X, r[e]) &&
                  (this.#r.add(r[e]), maybeIncrementObserverCount(r[e]));
            } else {
              if (!f(X, t)) return;
              if ((this.#r.add(t), maybeIncrementObserverCount(t), n)) {
                const e = filterBufferMapByNameAndType(void 0, t);
                l(this.#e, e), fe.add(this), fe.size && queuePending();
              }
            }
            this.#r.size ? ce.add(this) : this.disconnect();
          }
          disconnect() {
            maybeDecrementObserverCounts(this.#r),
              ce.delete(this),
              fe.delete(this),
              (this.#e = []),
              this.#r.clear(),
              (this.#t = void 0);
          }
          takeRecords() {
            const e = this.#e;
            return (this.#e = []), e;
          }
          static get supportedEntryTypes() {
            return X;
          }
          [W](e) {
            this.#r.has(e.entryType) &&
              (u(this.#e, e), fe.add(this), fe.size && queuePending());
          }
          [H]() {
            this.#n(new PerformanceObserverEntryList(this.takeRecords()), this);
          }
          [z](e, r) {
            if (e < 0) return this;
            const t = { ...r, depth: null == r.depth ? null : r.depth - 1 };
            return `PerformanceObserver ${j(
              {
                connected: ce.has(this),
                pending: fe.has(this),
                entryTypes: o(this.#r),
                buffer: this.#e,
              },
              t
            )}`;
          }
        },
        PerformanceObserverEntryList: PerformanceObserverEntryList,
        enqueue: enqueue,
        hasObserver: function hasObserver(e) {
          const r = getObserverType(e);
          return w[r] > 0;
        },
        clearEntriesFromBuffer: function clearEntriesFromBuffer(e, r) {
          ("mark" !== e && "measure" !== e && "resource" !== e) ||
            ("mark" === e
              ? (Z = void 0 === r ? [] : c(Z, (e) => e.name !== r))
              : "measure" === e
              ? (ee = void 0 === r ? [] : c(ee, (e) => e.name !== r))
              : (re = void 0 === r ? [] : c(re, (e) => e.name !== r)));
        },
        filterBufferMapByNameAndType: filterBufferMapByNameAndType,
        startPerf: function startPerf(e, r, t = {}) {
          e[r] = { ...t, startTime: U() };
        },
        stopPerf: function stopPerf(e, r, t = {}) {
          const n = e[r];
          if (!n) return;
          const s = n.startTime;
          enqueue(
            new B(n.name, n.type, s, U() - s, { ...n.detail, ...t.detail })
          );
        },
        bufferUserTiming: function bufferUserTiming(e) {
          const r = e.entryType;
          let t;
          if ("mark" === r) t = Z;
          else {
            if ("measure" !== r) return;
            t = ee;
          }
          u(t, e);
          const s = t.length;
          if (s > 1e6 && !ae.has(r)) {
            ae.set(r, !0);
            const e = new m(
              `Possible perf_hooks memory leak detected. ${s} ${r} entries added to the global performance entry buffer. Use ${oe[r]} to clear the buffer.`
            );
            (e.name = "MaxPerformanceEntryBufferExceededWarning"),
              (e.entryType = r),
              (e.count = s),
              n.emitWarning(e);
          }
        },
        bufferResourceTiming: function bufferResourceTiming(e) {
          re.length < se && !ie
            ? u(re, e)
            : (ie ||
                ((ie = !0),
                x(() => {
                  for (; te.length > 0; ) {
                    const e = te.length;
                    ne("resourcetimingbufferfull");
                    const r = h(d(se - re.length, te.length), 0),
                      t = te.length - r;
                    for (let e = 0; e < r; e++) u(re, te[e]);
                    e <= t && (te = []);
                  }
                  ie = !1;
                })),
              u(te, e));
        },
        setResourceTimingBufferSize: function setResourceTimingBufferSize(e) {
          (e = V("maxSize", e, 32)), (se = e);
        },
        setDispatchBufferFull: function setDispatchBufferFull(e) {
          ne = e;
        },
      });
  },
  "internal/perf/performance": function (e, r, n, t, o, i) {
    "use strict";
    const {
        ObjectDefineProperty: l,
        ObjectDefineProperties: u,
        ObjectSetPrototypeOf: a,
      } = i,
      {
        codes: { ERR_ILLEGAL_CONSTRUCTOR: _, ERR_MISSING_ARGS: c },
      } = r("internal/errors"),
      { EventTarget: m, Event: f, kTrustEvent: s } = r("internal/event_target"),
      { now: p } = r("internal/perf/utils"),
      { markResourceTiming: g } = r("internal/perf/resource_timing"),
      {
        mark: b,
        measure: v,
        clearMarkTimings: y,
      } = r("internal/perf/usertiming"),
      {
        clearEntriesFromBuffer: T,
        filterBufferMapByNameAndType: d,
        setResourceTimingBufferSize: h,
        setDispatchBufferFull: O,
      } = r("internal/perf/observe"),
      P = r("internal/perf/event_loop_utilization"),
      E = r("internal/perf/nodetiming"),
      R = r("internal/perf/timerify"),
      { customInspectSymbol: B } = r("internal/util"),
      { inspect: w } = r("util"),
      { getTimeOriginTimestamp: S } = o("performance");
    class Performance extends m {
      constructor() {
        throw new _();
      }
      [B](e, r) {
        if (e < 0) return this;
        const n = { ...r, depth: null == r.depth ? null : r.depth - 1 };
        return `Performance ${w(
          { nodeTiming: this.nodeTiming, timeOrigin: this.timeOrigin },
          n
        )}`;
      }
    }
    class InternalPerformance extends m {}
    (InternalPerformance.prototype.constructor =
      Performance.prototype.constructor),
      a(InternalPerformance.prototype, Performance.prototype),
      u(Performance.prototype, {
        clearMarks: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: function clearMarks(e) {
            void 0 !== e && (e = `${e}`), y(e), T("mark", e);
          },
        },
        clearMeasures: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: function clearMeasures(e) {
            void 0 !== e && (e = `${e}`), T("measure", e);
          },
        },
        clearResourceTimings: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: function clearResourceTimings(e) {
            void 0 !== e && (e = `${e}`), T("resource", e);
          },
        },
        eventLoopUtilization: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: P,
        },
        getEntries: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: function getEntries() {
            return d();
          },
        },
        getEntriesByName: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: function getEntriesByName(e) {
            if (0 === arguments.length) throw new c("name");
            return d((e = `${e}`), void 0);
          },
        },
        getEntriesByType: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: function getEntriesByType(e) {
            if (0 === arguments.length) throw new c("type");
            return d(void 0, (e = `${e}`));
          },
        },
        mark: { __proto__: null, configurable: !0, enumerable: !1, value: b },
        measure: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: v,
        },
        nodeTiming: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: E,
        },
        markResourceTiming: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: g,
        },
        now: { __proto__: null, configurable: !0, enumerable: !1, value: p },
        setResourceTimingBufferSize: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: h,
        },
        timerify: {
          __proto__: null,
          configurable: !0,
          enumerable: !1,
          value: R,
        },
        timeOrigin: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get() {
            const e = S();
            return (
              l(Performance.prototype, "timeOrigin", {
                __proto__: null,
                value: e,
              }),
              e
            );
          },
          set(e) {
            l(Performance.prototype, "timeOrigin", {
              __proto__: null,
              value: e,
            });
          },
        },
        toJSON: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          value: function toJSON() {
            return {
              nodeTiming: this.nodeTiming,
              timeOrigin: this.timeOrigin,
              eventLoopUtilization: this.eventLoopUtilization(),
            };
          },
        },
      });
    const k = new InternalPerformance();
    O(function dispatchBufferFull(e) {
      const r = new f(e, { [s]: !0 });
      k.dispatchEvent(r);
    }),
      (n.exports = { Performance: Performance, performance: k });
  },
  "internal/perf/performance_entry": function (t, r, e, n, o, i) {
    "use strict";
    const { ObjectSetPrototypeOf: s, Symbol: a } = i,
      {
        codes: { ERR_ILLEGAL_CONSTRUCTOR: c },
      } = r("internal/errors"),
      { customInspectSymbol: u } = r("internal/util"),
      { inspect: y } = r("util"),
      m = a("kName"),
      h = a("kType"),
      l = a("kStart"),
      p = a("kDuration"),
      f = a("kDetail");
    class PerformanceEntry {
      constructor() {
        throw new c();
      }
      get name() {
        return this[m];
      }
      get entryType() {
        return this[h];
      }
      get startTime() {
        return this[l];
      }
      get duration() {
        return this[p];
      }
      get detail() {
        return this[f];
      }
      [u](t, r) {
        if (t < 0) return this;
        const e = { ...r, depth: null == r.depth ? null : r.depth - 1 };
        return `${this.constructor.name} ${y(this.toJSON(), e)}`;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail,
        };
      }
    }
    class InternalPerformanceEntry {
      constructor(t, r, e, n, o) {
        (this[m] = t),
          (this[h] = r),
          (this[l] = e),
          (this[p] = n),
          (this[f] = o);
      }
    }
    (InternalPerformanceEntry.prototype.constructor = PerformanceEntry),
      s(InternalPerformanceEntry.prototype, PerformanceEntry.prototype),
      (e.exports = {
        InternalPerformanceEntry: InternalPerformanceEntry,
        PerformanceEntry: PerformanceEntry,
        isPerformanceEntry: function isPerformanceEntry(t) {
          return void 0 !== t?.[m];
        },
      });
  },
  "internal/perf/resource_timing": function (e, t, r, n, i, o) {
    "use strict";
    const { InternalPerformanceEntry: s } = t(
        "internal/perf/performance_entry"
      ),
      { SymbolToStringTag: a } = o,
      c = t("internal/assert"),
      { enqueue: d, bufferResourceTiming: u } = t("internal/perf/observe"),
      { Symbol: m, ObjectSetPrototypeOf: h } = o,
      S = m("kCacheMode"),
      T = m("kRequestedUrl"),
      g = m("kTimingInfo"),
      f = m("kInitiatorType"),
      {
        codes: { ERR_ILLEGAL_CONSTRUCTOR: l },
      } = t("internal/errors");
    class InternalPerformanceResourceTiming extends s {
      constructor(e, t, r, n = "") {
        super(e, "resource"),
          (this[f] = t),
          (this[T] = e),
          (this[g] = r),
          (this[S] = n);
      }
      get [a]() {
        return "PerformanceResourceTiming";
      }
      get name() {
        return this[T];
      }
      get startTime() {
        return this[g].startTime;
      }
      get duration() {
        return this[g].endTime - this[g].startTime;
      }
      get initiatorType() {
        return this[f];
      }
      get workerStart() {
        return this[g].finalServiceWorkerStartTime;
      }
      get redirectStart() {
        return this[g].redirectStartTime;
      }
      get redirectEnd() {
        return this[g].redirectEndTime;
      }
      get fetchStart() {
        return this[g].postRedirectStartTime;
      }
      get domainLookupStart() {
        return this[g].finalConnectionTimingInfo?.domainLookupStartTime;
      }
      get domainLookupEnd() {
        return this[g].finalConnectionTimingInfo?.domainLookupEndTime;
      }
      get connectStart() {
        return this[g].finalConnectionTimingInfo?.connectionStartTime;
      }
      get connectEnd() {
        return this[g].finalConnectionTimingInfo?.connectionEndTime;
      }
      get secureConnectionStart() {
        return this[g].finalConnectionTimingInfo?.secureConnectionStartTime;
      }
      get nextHopProtocol() {
        return this[g].finalConnectionTimingInfo?.ALPNNegotiatedProtocol;
      }
      get requestStart() {
        return this[g].finalNetworkRequestStartTime;
      }
      get responseStart() {
        return this[g].finalNetworkResponseStartTime;
      }
      get responseEnd() {
        return this[g].endTime;
      }
      get encodedBodySize() {
        return this[g].encodedBodySize;
      }
      get decodedBodySize() {
        return this[g].decodedBodySize;
      }
      get transferSize() {
        return "local" === this[S]
          ? 0
          : "validated" === this[S]
          ? 300
          : this[g].encodedBodySize + 300;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          initiatorType: this[f],
          nextHopProtocol: this.nextHopProtocol,
          workerStart: this.workerStart,
          redirectStart: this.redirectStart,
          redirectEnd: this.redirectEnd,
          fetchStart: this.fetchStart,
          domainLookupStart: this.domainLookupStart,
          domainLookupEnd: this.domainLookupEnd,
          connectStart: this.connectStart,
          connectEnd: this.connectEnd,
          secureConnectionStart: this.secureConnectionStart,
          requestStart: this.requestStart,
          responseStart: this.responseStart,
          responseEnd: this.responseEnd,
          transferSize: this.transferSize,
          encodedBodySize: this.encodedBodySize,
          decodedBodySize: this.decodedBodySize,
        };
      }
    }
    class PerformanceResourceTiming extends InternalPerformanceResourceTiming {
      constructor() {
        throw new l();
      }
    }
    r.exports = {
      PerformanceResourceTiming: PerformanceResourceTiming,
      markResourceTiming: function markResourceTiming(e, t, r, n, i) {
        c(
          "" === i || "local" === i,
          "cache must be an empty string or 'local'"
        );
        const o = new InternalPerformanceResourceTiming(t, r, e, i);
        return h(o, PerformanceResourceTiming.prototype), d(o), u(o), o;
      },
    };
  },
  "internal/perf/timerify": function (e, t, n, r, i, o) {
    "use strict";
    const {
        FunctionPrototypeBind: l,
        ObjectDefineProperties: a,
        MathCeil: c,
        ReflectApply: s,
        ReflectConstruct: f,
      } = o,
      { InternalPerformanceEntry: u } = t("internal/perf/performance_entry"),
      { now: m } = t("internal/perf/utils"),
      { validateFunction: p, validateObject: d } = t("internal/validators"),
      { isHistogram: _ } = t("internal/histogram"),
      {
        codes: { ERR_INVALID_ARG_TYPE: g },
      } = t("internal/errors"),
      { enqueue: y } = t("internal/perf/observe"),
      { kEmptyObject: b } = t("internal/util");
    function processComplete(e, t, n, r) {
      const i = m() - t;
      void 0 !== r && r.record(c(1e6 * i));
      const o = new u(e, "function", t, i, n);
      for (let e = 0; e < n.length; e++) o[e] = n[e];
      y(o);
    }
    n.exports = function timerify(e, t = b) {
      p(e, "fn"), d(t, "options");
      const { histogram: n } = t;
      if (void 0 !== n && (!_(n) || "function" != typeof n.record))
        throw new g("options.histogram", "RecordableHistogram", n);
      function timerified(...t) {
        const r = void 0 !== new.target,
          i = m(),
          o = r ? f(e, t, e) : s(e, this, t);
        return r || "function" != typeof o?.finally
          ? (processComplete(e.name, i, t, n), o)
          : o.finally(l(processComplete, o, e.name, i, t, n));
      }
      return (
        a(timerified, {
          length: {
            __proto__: null,
            configurable: !1,
            enumerable: !0,
            value: e.length,
          },
          name: {
            __proto__: null,
            configurable: !1,
            enumerable: !0,
            value: `timerified ${e.name}`,
          },
        }),
        timerified
      );
    };
  },
  "internal/perf/usertiming": function (e, r, t, n, o, a) {
    "use strict";
    const {
        SafeMap: i,
        SafeSet: s,
        SafeArrayIterator: u,
        SymbolToStringTag: c,
      } = a,
      { InternalPerformanceEntry: f } = r("internal/perf/performance_entry"),
      { now: l } = r("internal/perf/utils"),
      { enqueue: d, bufferUserTiming: m } = r("internal/perf/observe"),
      M = r("internal/perf/nodetiming"),
      {
        validateNumber: p,
        validateObject: v,
        validateString: k,
      } = r("internal/validators"),
      {
        codes: {
          ERR_INVALID_ARG_VALUE: w,
          ERR_PERFORMANCE_INVALID_TIMESTAMP: g,
          ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS: E,
        },
      } = r("internal/errors"),
      { structuredClone: P } = r("internal/structured_clone"),
      { kEmptyObject: S, lazyDOMException: _ } = r("internal/util"),
      h = new i(),
      R = new s(
        new u([
          "nodeStart",
          "v8Start",
          "environment",
          "loopStart",
          "loopExit",
          "bootstrapComplete",
        ])
      );
    function getMark(e) {
      if (void 0 === e) return;
      if ("number" == typeof e) {
        if (e < 0) throw new g(e);
        return e;
      }
      if (((e = `${e}`), R.has(e))) return M[e];
      const r = h.get(e);
      if (void 0 === r)
        throw _(`The "${e}" performance mark has not been set`, "SyntaxError");
      return r;
    }
    class PerformanceMark extends f {
      constructor(e, r) {
        if (((e = `${e}`), R.has(e))) throw new w("name", e);
        (r ??= S), v(r, "options");
        const t = r.startTime ?? l();
        if ((p(t, "startTime"), t < 0)) throw new g(t);
        h.set(e, t);
        let n = r.detail;
        (n = null != n ? P(n) : null), super(e, "mark", t, 0, n);
      }
      get [c]() {
        return "PerformanceMark";
      }
    }
    class PerformanceMeasure extends f {
      constructor(e, r, t, n) {
        super(e, "measure", r, t, n);
      }
      get [c]() {
        return "PerformanceMeasure";
      }
    }
    t.exports = {
      PerformanceMark: PerformanceMark,
      PerformanceMeasure: PerformanceMeasure,
      clearMarkTimings: function clearMarkTimings(e) {
        if (void 0 === e) h.clear();
        else {
          if (((e = `${e}`), R.has(e))) throw new w("name", e);
          h.delete(e);
        }
      },
      mark: function mark(e, r = S) {
        const t = new PerformanceMark(e, r);
        return d(t), m(t), t;
      },
      measure: function measure(e, r, t) {
        k(e, "name");
        const { start: n, duration: o } = (function calculateStartDuration(
          e,
          r
        ) {
          let t, n, o;
          e ??= 0;
          let a = !1;
          if (
            ("object" == typeof e &&
              (({ start: t, end: n, duration: o } = e),
              (a = void 0 !== t || void 0 !== n)),
            a)
          ) {
            if (void 0 !== r) throw new E("endMark must not be specified");
            if (void 0 === t && void 0 === n)
              throw new E("One of options.start or options.end is required");
            if (void 0 !== t && void 0 !== n && void 0 !== o)
              throw new E(
                "Must not have options.start, options.end, and options.duration specified"
              );
          }
          return (
            (n =
              void 0 !== r
                ? getMark(r)
                : a && void 0 !== n
                ? getMark(n)
                : a && void 0 !== t && void 0 !== o
                ? getMark(t) + getMark(o)
                : l()),
            (t =
              "string" == typeof e
                ? getMark(e)
                : a && void 0 !== t
                ? getMark(t)
                : a && void 0 !== o && void 0 !== n
                ? n - getMark(o)
                : 0),
            (o = n - t),
            { start: t, duration: o }
          );
        })(r, t);
        let a = r?.detail;
        a = null != a ? P(a) : null;
        const i = new PerformanceMeasure(e, n, o, a);
        return d(i), m(i), i;
      },
    };
  },
  "internal/perf/utils": function (e, n, t, i, r, o) {
    "use strict";
    const s = r("performance"),
      { milestones: m, getTimeOrigin: c } = s;
    let f = c();
    t.exports = {
      now: function now() {
        const e = i.hrtime();
        return 1e3 * e[0] + e[1] / 1e6 - f;
      },
      getMilestoneTimestamp: function getMilestoneTimestamp(e) {
        const n = m[e];
        return -1 === n ? n : n / 1e6 - f;
      },
      refreshTimeOrigin: function refreshTimeOrigin() {
        f = c();
      },
    };
  },
  "internal/policy/manifest": function (e, t, n, i, r, s) {
    "use strict";
    const {
        ArrayIsArray: o,
        ArrayPrototypeSort: c,
        ObjectCreate: l,
        ObjectEntries: a,
        ObjectFreeze: p,
        ObjectKeys: f,
        ObjectSetPrototypeOf: h,
        RegExpPrototypeExec: u,
        SafeMap: d,
        SafeSet: g,
        RegExpPrototypeSymbolReplace: y,
        StringPrototypeEndsWith: I,
        StringPrototypeStartsWith: w,
        Symbol: E,
      } = s,
      {
        ERR_MANIFEST_ASSERT_INTEGRITY: D,
        ERR_MANIFEST_INVALID_RESOURCE_FIELD: R,
        ERR_MANIFEST_INVALID_SPECIFIER: S,
        ERR_MANIFEST_UNKNOWN_ONERROR: A,
      } = t("internal/errors").codes;
    let M = t("internal/util/debuglog").debuglog("policy", (e) => {
      M = e;
    });
    const _ = t("internal/policy/sri"),
      { URL: b } = t("internal/url"),
      { internalVerifyIntegrity: N } = r("crypto"),
      O = /^\.{0,2}\//,
      { getOptionValue: F } = t("internal/options"),
      T = F("--abort-on-uncaught-exception"),
      { abort: x, exit: m, _rawDebug: v } = i,
      z = new g(["file:", "ftp:", "http:", "https:", "ws:", "wss:"]),
      C = E("cascade"),
      j = E("fall through");
    function REACTION_THROW(e) {
      throw e;
    }
    function REACTION_EXIT(e) {
      REACTION_LOG(e), T && x(), m(1);
    }
    function REACTION_LOG(e) {
      v(e.stack);
    }
    class DependencyMapperInstance {
      href;
      #e;
      #t;
      #n;
      #i = !1;
      cascade;
      allowSameHREFScope;
      constructor(e, t, n = !1, i = !1) {
        if (((this.href = e), t === j || null == t))
          (this.#e = t), (this.#t = void 0);
        else {
          const e = [],
            n = f(t);
          for (let t = 0; t < n.length; t++) {
            const i = n[t];
            if (I(i, "*")) {
              const t = u(/^([^*]*)\*([^*]*)$/);
              if (!t)
                throw new S(
                  this.href,
                  `${t}, pattern needs to have a single trailing "*" in target`
                );
              const n = t[1],
                i = t[2];
              e.push([t.slice(0, -1), [n, i]]);
            }
          }
          c(e, (e, t) => (e[0] < t[0] ? -1 : 1)), (this.#e = t), (this.#t = e);
        }
        (this.cascade = n), (this.allowSameHREFScope = i), p(this);
      }
      _resolveAlreadyNormalized(e, t, n) {
        let i = this.#e;
        if ((M(this.href, "resolving", e), i === j)) return !0;
        if (void 0 !== i && "object" == typeof i) {
          if (!0 !== this.#i) {
            const e = l(null);
            for (let t in i) {
              const r = i[t];
              (t = canonicalizeSpecifier(t, n.href)), (e[t] = r);
            }
            p(e), (i = e), (this.#e = e), (this.#i = !0);
          }
          if ((M(i), e in i == !0)) {
            const r = searchDependencies(this.href, i[e], t);
            if ((M({ to: r }), !0 === r)) return !0;
            let s;
            return (
              (s =
                k && k.has(r)
                  ? k.get(r)
                  : null !== u(O, r)
                  ? resolve(r, n.href)
                  : resolve(r)),
              s
            );
          }
        }
        const { cascade: r } = this;
        if (!0 !== r) return null;
        let s = this.#n;
        return (
          void 0 === s &&
            ((s = n.getScopeDependencyMapper(
              this.href,
              this.allowSameHREFScope
            )),
            (this.#n = s)),
          null === s ? null : s._resolveAlreadyNormalized(e, t, n)
        );
      }
    }
    const H = new DependencyMapperInstance("arbitrary dependencies", j, !1, !0),
      $ = new DependencyMapperInstance("no dependencies", null, !1, !0),
      insertDependencyMap = (e, t, n, i, r) => {
        if (void 0 !== n && "boolean" != typeof n) throw new R(e, "cascade");
        if (!0 !== t)
          if (null != t) {
            if (!objectButNotArray(t)) throw new R(e, "dependencies");
            r.set(e, new DependencyMapperInstance(e, t, n, i));
          } else r.set(e, n ? new DependencyMapperInstance(e, null, !0, i) : $);
        else r.set(e, H);
      };
    function findScopeHREF(e, t, n) {
      let i;
      if ("" !== e)
        if (null !== u(/^[^:]*[:]$/, e)) i = e;
        else {
          let r = new b(e);
          const s = r.href;
          if (
            ((i = r.protocol),
            "blob:" === i &&
              "null" !== r.origin &&
              ((r = new b(r.origin)), (i = r.protocol)),
            z.has(r.protocol))
          ) {
            let e;
            I(r.pathname, "/") || (r.pathname += "/");
            let i = r.href;
            do {
              if (t.has(i) && (n || i !== s)) return i;
              (e = i), (r = new b("..", r)), (i = r.href);
            } while (e !== i);
          }
        }
      return t.has(i) && (n || i !== e)
        ? i
        : t.has("") && (n || "" !== e)
        ? ""
        : null;
    }
    class Manifest {
      #r;
      href;
      #s;
      #o = new d();
      #c = new d();
      #l = new d();
      #a = new d();
      constructor(e, t) {
        this.href = t;
        const n = this.#l,
          i = this.#c,
          r = this.#o;
        let s = REACTION_THROW;
        if (objectButNotArray(e) && "onerror" in e) {
          const t = e.onerror;
          if ("exit" === t) s = REACTION_EXIT;
          else if ("log" === t) s = REACTION_LOG;
          else if ("throw" !== t) throw new A(t);
        }
        this.#s = s;
        const o = a(e.resources ?? l(null)),
          c = a(e.scopes ?? l(null)),
          f = e.dependencies ?? l(null);
        this.#r = new DependencyMapperInstance("default", !0 === f ? j : f, !1);
        for (let e = 0; e < o.length; e++) {
          const { 0: n, 1: s } = o[e],
            { cascade: c, dependencies: l, integrity: a } = s,
            p = resolve(n, t).href;
          if (void 0 !== a)
            if (
              (M("Manifest contains integrity for resource %s", n),
              "string" == typeof a)
            )
              i.set(p, a);
            else {
              if (!0 !== a) throw new R(p, "integrity");
              i.set(p, !0);
            }
          else i.set(p, !0 === c && C);
          insertDependencyMap(p, l, c, !0, r);
        }
        const h = this.#a;
        for (let e = 0; e < c.length; e++) {
          const { 0: i, 1: r } = c[e],
            { cascade: s, dependencies: o, integrity: l } = r,
            a = emptyOrProtocolOrResolve(i, t);
          if (void 0 !== l) {
            if ((M("Manifest contains integrity for scope %s", i), !0 !== l))
              throw new R(a, "integrity");
            h.set(a, !0);
          } else h.set(a, !0 === s && C);
          insertDependencyMap(a, o, s, !1, n);
        }
        p(this);
      }
      getDependencyMapper(e) {
        const t = `${e}`,
          n = this.#o,
          i =
            (n.has(t)
              ? n.get(t) ?? null
              : this.getScopeDependencyMapper(t, !0)) ?? this.#r;
        return {
          resolve: (e, n) => {
            const r = canonicalizeSpecifier(e, t),
              s = i._resolveAlreadyNormalized(r, n, this);
            return s === j || s;
          },
          reaction: this.#s,
        };
      }
      mightAllow(e, t) {
        const n = `${e}`;
        if ((M("Checking for entry of %s", n), w(n, "node:"))) return !0;
        if (this.#c.has(n)) return !0;
        let i = findScopeHREF(n, this.#a, !0);
        for (; null !== i; ) {
          if (this.#a.has(i)) {
            const e = this.#a.get(i);
            if (!0 === e) return !0;
            if (e !== C) break;
          }
          const e = findScopeHREF(new b("..", i), this.#a, !1);
          if (!e || e === i) break;
          i = e;
        }
        return t && this.#s(t()), !1;
      }
      assertIntegrity(e, t) {
        const n = `${e}`;
        M("Checking integrity of %s", n);
        const i = new d(),
          r = this.#c;
        if (r.has(n)) {
          const s = (function processEntry(e) {
            let t = r.get(e);
            if (!0 === t) return !0;
            if ("string" == typeof t) {
              const n = p(_.parse(t));
              r.set(e, n), (t = n);
            }
            return t;
          })(n);
          if (!0 === s) return !0;
          if (o(s))
            for (let e = 0; e < s.length; e++) {
              const { algorithm: n, value: r } = s[e],
                o = N(n, t, r);
              if (void 0 === o) return !0;
              i.set(n, o);
            }
          if (s !== C) {
            const t = new D(e, i);
            this.#s(t);
          }
        }
        let s = findScopeHREF(n, this.#a, !0);
        for (; null !== s; ) {
          if (this.#a.has(s)) {
            const e = this.#a.get(s);
            if (!0 === e) return !0;
            if (e !== C) break;
          }
          const e = findScopeHREF(s, this.#l, !1);
          if (!e) break;
          s = e;
        }
        const c = new D(e, i);
        this.#s(c);
      }
      getScopeDependencyMapper(e, t) {
        if (null === e) return this.#r;
        const n = findScopeHREF(e, this.#l, t);
        return null === n ? this.#r : this.#l.get(n);
      }
    }
    function canonicalizeSpecifier(e, t) {
      try {
        return null !== u(O, e) ? resolve(e, t).href : resolve(e).href;
      } catch {}
      return e;
    }
    h(Manifest, null),
      h(Manifest.prototype, null),
      p(Manifest),
      p(Manifest.prototype),
      (n.exports = p({ Manifest: Manifest }));
    const emptyOrProtocolOrResolve = (e, t) =>
      "" === e
        ? ""
        : I(e, ":") &&
          ((e = y(/^[\x00-\x1F\x20]|\x09\x0A\x0D|[\x00-\x1F\x20]$/g, e, "")),
          null !== u(/^[a-zA-Z][a-zA-Z+\-.]*:$/, e))
        ? e
        : resolve(e, t).href;
    let k;
    const resolve = (e, t) => {
      if (((k = k ?? new d()), k.has(e))) return k.get(e);
      if (null !== u(O, e)) {
        const n = new b(e, t);
        return k.set(n.href, n), n;
      }
      const n = new b(e);
      return k.set(e, n), n;
    };
    function objectButNotArray(e) {
      return e && "object" == typeof e && !o(e);
    }
    function searchDependencies(e, t, n) {
      if (!objectButNotArray(t)) {
        if ("string" == typeof t) return t;
        if (!0 === t) return t;
        throw new R(e, "dependencies");
      }
      {
        const i = f(t);
        for (let r = 0; r < i.length; r++) {
          const s = i[r];
          if (n.has(s)) {
            const i = searchDependencies(e, t[s], n);
            if (null != i) return i;
          }
        }
      }
      return null;
    }
  },
  "internal/policy/sri": function (e, t, o, r, n, l) {
    "use strict";
    const {
        ArrayPrototype: c,
        ObjectDefineProperty: i,
        ObjectFreeze: u,
        ObjectSeal: f,
        ObjectSetPrototypeOf: s,
        RegExp: _,
        RegExpPrototypeExec: a,
        StringPrototypeSlice: p,
      } = l,
      { ERR_SRI_PARSE: g } = t("internal/errors").codes,
      h = "[\\x20\\x09]",
      x = _(
        `(${h}*)(?:(sha(?:256|384|512))-([A-Za-z0-9+/]+[=]{0,2})(?:[?]((?:[\\x21-\\x7E]*)))?)`,
        "g"
      );
    f(x);
    const b = _(`^${h}*$`);
    f(b);
    const w = t("buffer").Buffer.from;
    o.exports = {
      parse: (e) => {
        let t,
          o = 0;
        const r = [];
        for (; null !== (t = a(x, e)); ) {
          if (t.index !== o) throw new g(e, e[o], o);
          if (r.length > 0 && "" === t[1]) throw new g(e, e[o], o);
          i(r, r.length, {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            value: u({
              __proto__: null,
              algorithm: t[2],
              value: w(t[3], "base64"),
              options: void 0 === t[4] ? null : t[4],
            }),
          }),
            (o += t[0].length);
        }
        if (o !== e.length && null === a(b, p(e, o))) throw new g(e, e[o], o);
        return s(r, c);
      },
    };
  },
  "internal/priority_queue": function (t, e, i, s, o, h) {
    "use strict";
    const { Array: r } = h;
    i.exports = class PriorityQueue {
      #t = (t, e) => t - e;
      #e = new r(64);
      #i;
      #s = 0;
      constructor(t, e) {
        void 0 !== t && (this.#t = t), void 0 !== e && (this.#i = e);
      }
      insert(t) {
        const e = this.#e,
          i = ++this.#s;
        (e[i] = t), e.length === i && (e.length *= 2), this.percolateUp(i);
      }
      peek() {
        return this.#e[1];
      }
      percolateDown(t) {
        const e = this.#t,
          i = this.#i,
          s = this.#e,
          o = this.#s,
          h = s[t];
        for (; 2 * t <= o; ) {
          let r = 2 * t + 1;
          (r > o || e(s[2 * t], s[r]) < 0) && (r = 2 * t);
          const c = s[r];
          if (e(h, c) <= 0) break;
          void 0 !== i && i(c, t), (s[t] = c), (t = r);
        }
        (s[t] = h), void 0 !== i && i(h, t);
      }
      percolateUp(t) {
        const e = this.#e,
          i = this.#t,
          s = this.#i,
          o = e[t];
        for (; t > 1; ) {
          const h = e[(t / 2) | 0];
          if (i(h, o) <= 0) break;
          (e[t] = h), void 0 !== s && s(h, t), (t = (t / 2) | 0);
        }
        (e[t] = o), void 0 !== s && s(o, t);
      }
      removeAt(t) {
        const e = this.#e,
          i = --this.#s;
        (e[t] = e[i + 1]),
          (e[i + 1] = void 0),
          i > 0 &&
            t <= i &&
            (t > 1 && this.#t(e[(t / 2) | 0], e[t]) > 0
              ? this.percolateUp(t)
              : this.percolateDown(t));
      }
      shift() {
        const t = this.#e[1];
        if (void 0 !== t) return this.removeAt(1), t;
      }
    };
  },
  "internal/process/esm_loader": function (e, t, o, a, r, n) {
    "use strict";
    const { SafePromiseAllReturnVoid: i } = n,
      { createModuleLoader: c } = t("internal/modules/esm/loader"),
      { getOptionValue: s } = t("internal/options"),
      { hasUncaughtExceptionCaptureCallback: l } = t(
        "internal/process/execution"
      ),
      { kEmptyObject: u, getCWDURL: p } = t("internal/util");
    let d;
    o.exports = {
      get esmLoader() {
        return (d ??= c(!0));
      },
      async loadESM(e) {
        d ??= c(!0);
        try {
          await d.hooksReady();
          const t = s("--import");
          if (t.length > 0) {
            const e = p().href;
            await i(t, (t) => d.import(t, e, u));
          } else d.forceLoadHooks();
          await e(d);
        } catch (e) {
          if (l()) return void a._fatalException(e);
          r("errors").triggerUncaughtException(e, !0);
        }
      },
    };
  },
  "internal/process/execution": function (n, e, t, o, r, a) {
    "use strict";
    const { Symbol: i, RegExpPrototypeExec: l, globalThis: c } = a,
      u = e("path"),
      {
        codes: {
          ERR_INVALID_ARG_TYPE: s,
          ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET: p,
          ERR_EVAL_ESM_CANNOT_PRINT: d,
        },
      } = e("internal/errors"),
      {
        executionAsyncId: h,
        clearDefaultTriggerAsyncId: m,
        clearAsyncIdStack: g,
        hasAsyncIdStack: f,
        afterHooksExist: _,
        emitAfter: E,
        popAsyncContext: x,
      } = e("internal/async_hooks"),
      { makeContextifyScript: C, runScriptInThisContext: y } = e("internal/vm"),
      { shouldAbortOnUncaughtToggle: T } = r("util");
    function tryGetCwd() {
      try {
        return o.cwd();
      } catch {
        return u.dirname(o.execPath);
      }
    }
    const A = { captureFn: null, reportFlag: !1 };
    function noop() {}
    t.exports = {
      readStdin: function readStdin(n) {
        o.stdin.setEncoding("utf8");
        let e = "";
        o.stdin.on("data", (n) => {
          e += n;
        }),
          o.stdin.on("end", () => {
            n(e);
          });
      },
      tryGetCwd: tryGetCwd,
      evalModule: function evalModule(n, t) {
        if (t) throw new d();
        const { loadESM: o } = e("internal/process/esm_loader"),
          { handleMainPromise: r } = e("internal/modules/run_main");
        return l(/^/, ""), r(o((e) => e.eval(n)));
      },
      evalScript: function evalScript(n, t, o, r, a = !1) {
        const s = e("internal/modules/cjs/loader").Module,
          { pathToFileURL: p } = e("internal/url"),
          d = tryGetCwd(),
          h = c.module,
          m = new s(n);
        (m.filename = u.join(d, n)), (m.paths = s._nodeModulePaths(d));
        const { handleMainPromise: g } = e("internal/modules/run_main"),
          f = e("internal/process/esm_loader"),
          _ = p(m.filename).href,
          { loadESM: E } = f,
          runScript = () => {
            (c.__filename = n), l(/^/, "");
            const a = m._compile(
              "\n      globalThis.module = module;\n      globalThis.exports = exports;\n      globalThis.__dirname = __dirname;\n      globalThis.require = require;\n      return (main) => main();\n    ",
              `${n}-wrapper`
            )(() => {
              const e = i(n);
              const r = C(
                t,
                n,
                0,
                0,
                void 0,
                !1,
                void 0,
                e,
                async function importModuleDynamically(n, e, t) {
                  return f.esmLoader.import(n, _, t);
                }
              );
              return y(r, !0, !!o);
            });
            if (r) {
              const { log: n } = e("internal/console/global");
              n(a);
            }
            void 0 !== h && (c.module = h);
          };
        return a ? g(E(runScript)) : runScript();
      },
      onGlobalUncaughtException: (function createOnGlobalUncaughtException() {
        return (n, t) => {
          m();
          const r = t ? "unhandledRejection" : "uncaughtException";
          if ((o.emit("uncaughtExceptionMonitor", n, r), null !== A.captureFn))
            A.captureFn(n);
          else if (!o.emit("uncaughtException", n, r)) {
            try {
              o._exiting ||
                ((o._exiting = !0), (o.exitCode = 1), o.emit("exit", 1));
            } catch {}
            return !1;
          }
          if ((e("timers").setImmediate(noop), _()))
            do {
              const n = h();
              0 === n ? x(0) : E(n);
            } while (f());
          return g(), !0;
        };
      })(),
      setUncaughtExceptionCaptureCallback:
        function setUncaughtExceptionCaptureCallback(n) {
          if (null === n)
            return (
              (A.captureFn = n),
              (T[0] = 1),
              void (o.report.reportOnUncaughtException = A.reportFlag)
            );
          if ("function" != typeof n)
            throw new s("fn", ["Function", "null"], n);
          if (null !== A.captureFn) throw new p();
          (A.captureFn = n),
            (T[0] = 0),
            (A.reportFlag = !0 === o.report.reportOnUncaughtException),
            (o.report.reportOnUncaughtException = !1);
        },
      hasUncaughtExceptionCaptureCallback:
        function hasUncaughtExceptionCaptureCallback() {
          return null !== A.captureFn;
        },
    };
  },
  "internal/process/per_thread": function (e, t, r, n, s, o) {
    "use strict";
    const {
        ArrayPrototypeEvery: i,
        ArrayPrototypeForEach: a,
        ArrayPrototypeIncludes: l,
        ArrayPrototypeMap: u,
        ArrayPrototypePush: c,
        ArrayPrototypeSplice: p,
        BigUint64Array: y,
        Float64Array: f,
        NumberMAX_SAFE_INTEGER: g,
        ObjectFreeze: m,
        ObjectDefineProperty: h,
        ReflectApply: d,
        RegExpPrototypeExec: S,
        SafeArrayIterator: _,
        Set: v,
        SetPrototypeEntries: w,
        SetPrototypeValues: E,
        StringPrototypeEndsWith: A,
        StringPrototypeReplace: R,
        StringPrototypeSlice: P,
        StringPrototypeStartsWith: x,
        Symbol: I,
        SymbolIterator: N,
        Uint32Array: U,
      } = o,
      {
        errnoException: F,
        codes: {
          ERR_ASSERTION: V,
          ERR_INVALID_ARG_TYPE: b,
          ERR_INVALID_ARG_VALUE: B,
          ERR_OUT_OF_RANGE: k,
          ERR_UNKNOWN_SIGNAL: C,
        },
      } = t("internal/errors"),
      T = t("internal/util/inspect").format,
      {
        validateArray: D,
        validateNumber: O,
        validateObject: G,
      } = t("internal/validators"),
      M = s("constants").os.signals,
      z = I("internal properties");
    const H = s("process_methods");
    let j, L;
    function refreshHrtimeBuffer() {
      (j = new U(H.hrtimeBuffer)), (L = new y(H.hrtimeBuffer, 0, 1));
    }
    refreshHrtimeBuffer();
    const W = /_/g,
      $ = /^--?/,
      K = /=.*$/;
    let X;
    r.exports = {
      toggleTraceCategoryState: function toggleTraceCategoryState(e) {
        e
          ? (X || (X = t("internal/trace_events_async_hooks").createHook()),
            X.enable())
          : X && X.disable();
      },
      assert: function assert(e, t) {
        if (!e) throw new V(t || "assertion error");
      },
      buildAllowedFlags: function buildAllowedFlags() {
        const {
            envSettings: { kAllowedInEnvvar: e },
            types: { kBoolean: r },
          } = s("options"),
          { options: n, aliases: o } = t("internal/options"),
          y = [];
        for (const { 0: t, 1: s } of n)
          if (s.envVarSettings === e && (c(y, t), s.type === r)) {
            const e = `--no-${t.slice(2)}`;
            c(y, e);
          }
        function isAccepted(t) {
          if (!x(t, "-") || "--" === t) return !0;
          const r = o.get(t);
          return r
            ? (r[0] === t && p(r, 0, 1), i(r, isAccepted))
            : n.get(t).envVarSettings === e;
        }
        for (const { 0: e, 1: t } of o)
          if (i(t, isAccepted)) {
            let t = e;
            A(t, "=") && (t = P(t, 0, t.length - 1)),
              A(t, " <arg>") && (t = P(t, 0, t.length - 4)),
              c(y, t);
          }
        const f = u(y, (e) => R(e, $, ""));
        class NodeEnvironmentFlagsSet extends v {
          constructor(e) {
            super(), (this[z] = { array: e });
          }
          add() {
            return this;
          }
          delete() {
            return !1;
          }
          clear() {}
          has(e) {
            return (
              "string" == typeof e &&
              ((e = R(e, W, "-")),
              null !== S($, e)
                ? ((e = R(e, K, "")), l(this[z].array, e))
                : l(f, e))
            );
          }
          entries() {
            return (
              (this[z].set ??= new v(new _(this[z].array))), w(this[z].set)
            );
          }
          forEach(e, t = void 0) {
            a(this[z].array, (r) => d(e, t, [r, r, this]));
          }
          get size() {
            return this[z].array.length;
          }
          values() {
            return (
              (this[z].set ??= new v(new _(this[z].array))), E(this[z].set)
            );
          }
        }
        const g = NodeEnvironmentFlagsSet.prototype.values;
        return (
          h(NodeEnvironmentFlagsSet.prototype, N, {
            __proto__: null,
            value: g,
          }),
          h(NodeEnvironmentFlagsSet.prototype, "keys", {
            __proto__: null,
            value: g,
          }),
          m(NodeEnvironmentFlagsSet.prototype.constructor),
          m(NodeEnvironmentFlagsSet.prototype),
          m(new NodeEnvironmentFlagsSet(y))
        );
      },
      wrapProcessMethods: function wrapProcessMethods(e) {
        const { cpuUsage: r, memoryUsage: s, rss: o, resourceUsage: i } = e,
          a = new f(2);
        function previousValueIsValid(e) {
          return "number" == typeof e && e <= g && e >= 0;
        }
        const l = new f(5);
        function memoryUsage() {
          return (
            s(l),
            {
              rss: l[0],
              heapTotal: l[1],
              heapUsed: l[2],
              external: l[3],
              arrayBuffers: l[4],
            }
          );
        }
        memoryUsage.rss = o;
        const u = new f(16);
        return {
          _rawDebug: function _rawDebug(...t) {
            e._rawDebug(d(T, null, t));
          },
          cpuUsage: function cpuUsage(e) {
            if (e) {
              if (!previousValueIsValid(e.user))
                throw (
                  (G(e, "prevValue"),
                  O(e.user, "prevValue.user"),
                  new B.RangeError("prevValue.user", e.user))
                );
              if (!previousValueIsValid(e.system))
                throw (
                  (O(e.system, "prevValue.system"),
                  new B.RangeError("prevValue.system", e.system))
                );
            }
            return (
              r(a),
              e
                ? { user: a[0] - e.user, system: a[1] - e.system }
                : { user: a[0], system: a[1] }
            );
          },
          resourceUsage: function resourceUsage() {
            return (
              i(u),
              {
                userCPUTime: u[0],
                systemCPUTime: u[1],
                maxRSS: u[2],
                sharedMemorySize: u[3],
                unsharedDataSize: u[4],
                unsharedStackSize: u[5],
                minorPageFault: u[6],
                majorPageFault: u[7],
                swappedOut: u[8],
                fsRead: u[9],
                fsWrite: u[10],
                ipcSent: u[11],
                ipcReceived: u[12],
                signalsCount: u[13],
                voluntaryContextSwitches: u[14],
                involuntaryContextSwitches: u[15],
              }
            );
          },
          memoryUsage: memoryUsage,
          kill: function kill(e, t) {
            let r;
            if (e != (0 | e)) throw new b("pid", "number", e);
            if (t === (0 | t)) r = n._kill(e, t);
            else {
              if (!M[(t = t || "SIGTERM")]) throw new C(t);
              r = n._kill(e, M[t]);
            }
            if (r) throw F(r, "kill");
            return !0;
          },
          exit: function exit(e) {
            const { handleProcessExit: r } = t(
              "internal/modules/esm/handle_process_exit"
            );
            n.off("exit", r),
              (e || 0 === e) && (n.exitCode = e),
              n._exiting ||
                ((n._exiting = !0), n.emit("exit", n.exitCode || 0)),
              n.reallyExit(n.exitCode || 0);
          },
        };
      },
      hrtime: function hrtime(e) {
        if ((H.hrtime(), void 0 !== e)) {
          if ((D(e, "time"), 2 !== e.length)) throw new k("time", 2, e.length);
          const t = 4294967296 * j[0] + j[1] - e[0],
            r = j[2] - e[1],
            n = r < 0;
          return [n ? t - 1 : t, n ? r + 1e9 : r];
        }
        return [4294967296 * j[0] + j[1], j[2]];
      },
      hrtimeBigInt: function hrtimeBigInt() {
        return H.hrtimeBigInt(), L[0];
      },
      refreshHrtimeBuffer: refreshHrtimeBuffer,
    };
  },
  "internal/process/policy": function (n, e, t, i, r, o) {
    "use strict";
    const { JSONParse: s, ObjectFreeze: l, ReflectSetPrototypeOf: c } = o,
      { ERR_ACCESS_DENIED: d, ERR_MANIFEST_TDZ: f } =
        e("internal/errors").codes,
      { Manifest: u } = e("internal/policy/manifest");
    let _, g, w;
    t.exports = l({
      __proto__: null,
      setup(n, e) {
        if (((g = n), (w = e), null === n)) return void (_ = null);
        const t = s(
          n,
          (n, e) => (e && "object" == typeof e && (c(e, null), l(e)), e)
        );
        (_ = new u(t, e)),
          (i.binding = function binding(n) {
            throw new d("process.binding");
          }),
          (i._linkedBinding = function _linkedBinding(n) {
            throw new d("process._linkedBinding");
          });
      },
      get manifest() {
        if (void 0 === _) throw new f();
        return _;
      },
      get src() {
        if (void 0 === g) throw new f();
        return g;
      },
      get url() {
        if (void 0 === w) throw new f();
        return w;
      },
      assertIntegrity(n, e) {
        this.manifest.assertIntegrity(n, e);
      },
    });
  },
  "internal/process/pre_execution": function (e, n, t, i, r, a) {
    "use strict";
    const {
        NumberParseInt: o,
        ObjectDefineProperties: s,
        ObjectDefineProperty: l,
        SafeMap: c,
        StringPrototypeStartsWith: p,
        Symbol: u,
        SymbolDispose: d,
        SymbolAsyncDispose: f,
        globalThis: _,
      } = a,
      { getOptionValue: g, refreshOptions: b } = n("internal/options"),
      { reconnectZeroFillToggle: y } = n("internal/buffer"),
      {
        defineOperation: m,
        exposeInterface: h,
        exposeLazyInterfaces: v,
        defineReplaceableLazyAttribute: E,
        setupCoverageHooks: S,
      } = n("internal/util"),
      { ERR_MANIFEST_ASSERT_INTEGRITY: A } = n("internal/errors").codes,
      O = n("internal/assert"),
      {
        namespace: { addSerializeCallback: D, isBuildingSnapshot: P },
      } = n("internal/v8/startup_snapshot");
    function prepareExecution(e) {
      const { expandArgv1: t, initializeModules: a, isMainThread: z } = e;
      !(function refreshRuntimeOptions() {
        b();
      })(),
        y();
      const C = (function patchProcessObject(e) {
        let t;
        if (
          (r("process_methods").patchProcessObject(i),
          n("internal/process/per_thread").refreshHrtimeBuffer(),
          l(i, "argv0", {
            __proto__: null,
            enumerable: !0,
            configurable: g("--build-snapshot"),
            value: i.argv[0],
          }),
          (i.exitCode = void 0),
          (i._exiting = !1),
          (i.argv[0] = i.execPath),
          e && i.argv[1] && !p(i.argv[1], "-"))
        ) {
          const e = n("path");
          try {
            (t = e.resolve(i.argv[1])), (i.argv[1] = t);
          } catch {}
        }
        const a = n("internal/console/global"),
          { initializeGlobalConsole: o } = n("internal/console/constructor");
        return (
          o(a),
          addReadOnlyProcessAlias("_eval", "--eval"),
          addReadOnlyProcessAlias("_print_eval", "--print"),
          addReadOnlyProcessAlias("_syntax_check_only", "--check"),
          addReadOnlyProcessAlias("_forceRepl", "--interactive"),
          addReadOnlyProcessAlias("_preload_modules", "--require"),
          addReadOnlyProcessAlias("noDeprecation", "--no-deprecation"),
          addReadOnlyProcessAlias("noProcessWarnings", "--no-warnings"),
          addReadOnlyProcessAlias("traceProcessWarnings", "--trace-warnings"),
          addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation"),
          addReadOnlyProcessAlias("profProcess", "--prof-process"),
          addReadOnlyProcessAlias("traceDeprecation", "--trace-deprecation"),
          addReadOnlyProcessAlias("_breakFirstLine", "--inspect-brk", !1),
          addReadOnlyProcessAlias(
            "_breakNodeFirstLine",
            "--inspect-brk-node",
            !1
          ),
          t
        );
      })(t);
      if (
        ((function setupTraceCategoryState() {
          const { isTraceCategoryEnabled: e } = r("trace_events"),
            { toggleTraceCategoryState: t } = n("internal/process/per_thread");
          t(e("node.async_hooks"));
        })(),
        (function setupPerfHooks() {
          n("internal/perf/utils").refreshTimeOrigin();
        })(),
        (function setupInspectorHooks() {
          if (r("config").hasInspector) {
            const { enable: e, disable: t } = n(
              "internal/inspector_async_hook"
            );
            r("inspector").registerAsyncHook(e, t);
          }
        })(),
        (function setupWarningHandler() {
          const { onWarning: e, resetForSerialization: t } = n(
            "internal/process/warning"
          );
          g("--warnings") &&
            "1" !== i.env.NODE_NO_WARNINGS &&
            (i.on("warning", e),
            P() &&
              D(() => {
                i.removeListener("warning", e), t();
              }));
        })(),
        (function setupFetch() {
          if (
            i.config.variables.node_no_browser_globals ||
            g("--no-experimental-fetch")
          )
            return;
          let e;
          function lazyUndici() {
            return e || ((e = n("internal/deps/undici/undici")), e);
          }
          async function fetch(e, n = void 0) {
            return lazyUndici().fetch(e, n);
          }
          function lazyInterface(e) {
            return {
              configurable: !0,
              enumerable: !1,
              get: () => lazyUndici()[e],
              set(n) {
                h(_, e, n);
              },
            };
          }
          m(_, "fetch", fetch),
            s(_, {
              FormData: lazyInterface("FormData"),
              Headers: lazyInterface("Headers"),
              Request: lazyInterface("Request"),
              Response: lazyInterface("Response"),
            }),
            r("wasm_web_api").setImplementation((e, t) => {
              n("internal/wasm_web_api").wasmStreamingCallback(e, t);
            });
        })(),
        (function setupWebCrypto() {
          if (
            i.config.variables.node_no_browser_globals ||
            !g("--experimental-global-webcrypto")
          )
            return;
          r("config").hasOpenSSL &&
            (E(_, "internal/crypto/webcrypto", ["crypto"], !1),
            v(_, "internal/crypto/webcrypto", [
              "Crypto",
              "CryptoKey",
              "SubtleCrypto",
            ]));
        })(),
        (function setupCustomEvent() {
          if (
            i.config.variables.node_no_browser_globals ||
            !g("--experimental-global-customevent")
          )
            return;
          const { CustomEvent: e } = n("internal/event_target");
          h(_, "CustomEvent", e);
        })(),
        (function setupCodeCoverage() {
          i.env.NODE_V8_COVERAGE &&
            !g("--experimental-test-coverage") &&
            (i.env.NODE_V8_COVERAGE = S(i.env.NODE_V8_COVERAGE));
        })(),
        (function setupDebugEnv() {
          n("internal/util/debuglog").initializeDebugEnv(i.env.NODE_DEBUG),
            g("--expose-internals") &&
              n("internal/bootstrap/realm").BuiltinModule.exposeInternals();
        })(),
        (function initializeReport() {
          l(i, "report", {
            __proto__: null,
            enumerable: !0,
            configurable: !0,
            get() {
              const { report: e } = n("internal/process/report");
              return e;
            },
          });
        })(),
        (function initializeSourceMapsHandlers() {
          const { setSourceMapsEnabled: e } = n(
            "internal/source_map/source_map_cache"
          );
          e(g("--enable-source-maps"));
        })(),
        (function initializeDeprecations() {
          const { deprecate: e } = n("internal/util"),
            t = g("--pending-deprecation"),
            a = r("util"),
            o = n("internal/util/types");
          for (const n of [
            "isArrayBuffer",
            "isArrayBufferView",
            "isAsyncFunction",
            "isDataView",
            "isDate",
            "isExternal",
            "isMap",
            "isMapIterator",
            "isNativeError",
            "isPromise",
            "isRegExp",
            "isSet",
            "isSetIterator",
            "isTypedArray",
            "isUint8Array",
            "isAnyArrayBuffer",
          ])
            a[n] = t
              ? e(
                  o[n],
                  `Accessing native typechecking bindings of Node directly is deprecated. Please use \`util.types.${n}\` instead.`,
                  "DEP0103"
                )
              : o[n];
          const { noBrowserGlobals: s } = r("config");
          s &&
            l(i, "_noBrowserGlobals", {
              __proto__: null,
              writable: !1,
              enumerable: !0,
              configurable: !0,
              value: s,
            });
          t &&
            ((i.binding = e(
              i.binding,
              "process.binding() is deprecated. Please use public APIs instead.",
              "DEP0111"
            )),
            (i._tickCallback = e(
              i._tickCallback,
              "process._tickCallback() is deprecated",
              "DEP0134"
            )));
        })(),
        n("internal/dns/utils").initializeDns(),
        (function setupSymbolDisposePolyfill() {
          "symbol" != typeof u.dispose &&
            l(u, "dispose", {
              __proto__: null,
              configurable: !1,
              enumerable: !1,
              value: d,
              writable: !1,
            });
          "symbol" != typeof u.asyncDispose &&
            l(u, "asyncDispose", {
              __proto__: null,
              configurable: !1,
              enumerable: !1,
              value: f,
              writable: !1,
            });
        })(),
        z)
      ) {
        O(r("worker").isMainThread);
        const e = (function readPolicyFromDisk() {
          const e = g("--experimental-policy");
          if (e) {
            i.emitWarning("Policies are experimental.", "ExperimentalWarning");
            const { pathToFileURL: t, URL: r } = n("internal/url");
            let a;
            if (n("path").isAbsolute(e)) a = t(e);
            else {
              const n = t(i.cwd());
              (n.pathname += "/"), (a = new r(e, n));
            }
            const o = n("fs").readFileSync(a, "utf8"),
              s = g("--policy-integrity");
            if (s) {
              const e = n("internal/policy/sri"),
                { createHash: t, timingSafeEqual: i } = n("crypto"),
                r = new c(),
                l = e.parse(s);
              let p = !1;
              for (let e = 0; e < l.length; e++) {
                const { algorithm: n, value: a } = l[e],
                  s = t(n);
                s.update(o);
                const c = s.digest();
                if (c.length === a.length && i(c, a)) {
                  p = !0;
                  break;
                }
                r.set(n, c.toString("base64"));
              }
              if (!p) throw new A(a, r);
            }
            return { manifestSrc: o, manifestURL: a.href };
          }
        })();
        e && n("internal/process/policy").setup(e.manifestSrc, e.manifestURL),
          (function setupStacktracePrinterOnSigint() {
            if (!g("--trace-sigint")) return;
            const { SigintWatchdog: e } = n("internal/watchdog");
            new e().start();
          })(),
          (function initializeReportSignalHandlers() {
            if (g("--report-on-signal")) {
              const { addSignalHandler: e } = n("internal/process/report");
              e();
            }
          })(),
          (function initializeHeapSnapshotSignalHandlers() {
            const e = g("--heapsnapshot-signal");
            if (!e) return;
            n("internal/validators").validateSignalName(e);
            const { writeHeapSnapshot: t } = n("v8");
            function doWriteHeapSnapshot() {
              t();
            }
            i.on(e, doWriteHeapSnapshot),
              P() &&
                D(() => {
                  i.removeListener(e, doWriteHeapSnapshot);
                });
          })(),
          (function setupChildProcessIpcChannel() {
            if (i.env.NODE_CHANNEL_FD) {
              const e = n("internal/assert"),
                t = o(i.env.NODE_CHANNEL_FD, 10);
              e(t >= 0), delete i.env.NODE_CHANNEL_FD;
              const r = i.env.NODE_CHANNEL_SERIALIZATION_MODE || "json";
              delete i.env.NODE_CHANNEL_SERIALIZATION_MODE,
                n("child_process")._forkChild(t, r),
                e(i.send);
            }
          })(),
          (function initializeClusterIPC() {
            if (i.argv[1] && i.env.NODE_UNIQUE_ID) {
              n("cluster")._setupWorker(), delete i.env.NODE_UNIQUE_ID;
            }
          })(),
          n("internal/v8/startup_snapshot").runDeserializeCallbacks();
      } else O(!r("worker").isMainThread), O(!a);
      return a && setupUserModules(), C;
    }
    function setupUserModules(e = !1) {
      !(function initializeCJSLoader() {
        const { initializeCJS: e } = n("internal/modules/cjs/loader");
        e();
      })(),
        (function initializeESMLoader(e) {
          const { initializeESM: t } = n("internal/modules/esm/utils");
          if ((t(e), g("--experimental-vm-modules"))) {
            const {
                Module: e,
                SourceTextModule: t,
                SyntheticModule: i,
              } = n("internal/vm/module"),
              r = n("vm");
            (r.Module = e), (r.SourceTextModule = t), (r.SyntheticModule = i);
          }
        })(e);
      const t = n("internal/modules/cjs/loader");
      O(!t.hasLoadedAnyUserCJSModule),
        e || (loadPreloadModules(), initializeFrozenIntrinsics());
    }
    function addReadOnlyProcessAlias(e, n, t = !0) {
      const r = g(n);
      r &&
        l(i, e, {
          __proto__: null,
          writable: !1,
          configurable: !0,
          enumerable: t,
          value: r,
        });
    }
    function initializeFrozenIntrinsics() {
      g("--frozen-intrinsics") &&
        (i.emitWarning(
          "The --frozen-intrinsics flag is experimental",
          "ExperimentalWarning"
        ),
        n("internal/freeze_intrinsics")());
    }
    function loadPreloadModules() {
      const e = g("--require");
      if (e && e.length > 0) {
        const {
          Module: { _preloadModules: t },
        } = n("internal/modules/cjs/loader");
        t(e);
      }
    }
    t.exports = {
      setupUserModules: setupUserModules,
      prepareMainThreadExecution: function prepareMainThreadExecution(
        e = !1,
        n = !0
      ) {
        return prepareExecution({
          expandArgv1: e,
          initializeModules: n,
          isMainThread: !0,
        });
      },
      prepareWorkerThreadExecution: function prepareWorkerThreadExecution() {
        prepareExecution({
          expandArgv1: !1,
          initializeModules: !1,
          isMainThread: !1,
        });
      },
      markBootstrapComplete: function markBootstrapComplete() {
        r("performance").markBootstrapComplete();
      },
      loadPreloadModules: loadPreloadModules,
      initializeFrozenIntrinsics: initializeFrozenIntrinsics,
    };
  },
  "internal/process/promises": function (e, n, t, r, o, i) {
    "use strict";
    const {
        ArrayPrototypePush: a,
        ArrayPrototypeShift: c,
        Error: s,
        ObjectDefineProperty: d,
        ObjectPrototypeHasOwnProperty: l,
        SafeWeakMap: h,
      } = i,
      {
        tickInfo: u,
        promiseRejectEvents: {
          kPromiseRejectWithNoHandler: m,
          kPromiseHandlerAddedAfterReject: j,
          kPromiseResolveAfterResolved: g,
          kPromiseRejectAfterResolved: R,
        },
        setPromiseRejectCallback: f,
      } = o("task_queue"),
      { deprecate: k } = n("internal/util"),
      { noSideEffectsToString: p, triggerUncaughtException: w } = o("errors"),
      {
        pushAsyncContext: y,
        popAsyncContext: b,
        symbols: { async_id_symbol: W, trigger_async_id_symbol: E },
      } = n("internal/async_hooks"),
      { isErrorStackTraceLimitWritable: T } = n("internal/errors"),
      v = 1,
      _ = new h(),
      P = [],
      H = [];
    let U = 0;
    const L = 0,
      A = 1,
      S = 2,
      x = 3,
      C = 4;
    let D;
    function setHasRejectionToWarn(e) {
      u[v] = e ? 1 : 0;
    }
    function isErrorLike(e) {
      return "object" == typeof e && null !== e && l(e, "stack");
    }
    function promiseRejectHandler(e, t, o) {
      switch (
        (void 0 === D &&
          (D = (function getUnhandledRejectionsMode() {
            const { getOptionValue: e } = n("internal/options");
            switch (e("--unhandled-rejections")) {
              case "none":
                return L;
              case "warn":
                return A;
              case "strict":
                return S;
              case "throw":
              default:
                return x;
              case "warn-with-error-code":
                return C;
            }
          })()),
        e)
      ) {
        case m:
          !(function unhandledRejection(e, n) {
            const emit = (e, n, t) =>
              t.domain
                ? t.domain.emit("error", e)
                : r.emit("unhandledRejection", e, n);
            _.set(e, {
              reason: n,
              uid: ++U,
              warned: !1,
              domain: r.domain,
              emit: emit,
            }),
              a(P, e),
              setHasRejectionToWarn(!0);
          })(t, o);
          break;
        case j:
          !(function handledRejection(e) {
            const n = _.get(e);
            if (void 0 !== n && (_.delete(e), n.warned)) {
              const { uid: t } = n,
                r = new s(
                  `Promise rejection was handled asynchronously (rejection id: ${t})`
                );
              return (
                (r.name = "PromiseRejectionHandledWarning"),
                (r.id = t),
                a(H, { promise: e, warning: r }),
                void setHasRejectionToWarn(!0)
              );
            }
            0 === _.size && 0 === H.length && setHasRejectionToWarn(!1);
          })(t);
          break;
        case g:
          resolveError("resolve", t, o);
          break;
        case R:
          resolveError("reject", t, o);
      }
    }
    const N = k(
      () => {},
      "The multipleResolves event has been deprecated.",
      "DEP0160"
    );
    function resolveError(e, n, t) {
      r.nextTick(() => {
        r.emit("multipleResolves", e, n, t) && N();
      });
    }
    const O = "UnhandledPromiseRejectionWarning";
    function emitUnhandledRejectionWarning(e, n) {
      const t = getErrorWithoutStack(
        O,
        `Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag \`--unhandled-rejections=strict\` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: ${e})`
      );
      try {
        isErrorLike(n)
          ? ((t.stack = n.stack), r.emitWarning(n.stack, O))
          : r.emitWarning(p(n), O);
      } catch {
        try {
          r.emitWarning(p(n), O);
        } catch {}
      }
      r.emitWarning(t);
    }
    function getErrorWithoutStack(e, n) {
      const t = s.stackTraceLimit;
      T() && (s.stackTraceLimit = 0);
      const r = new s(n);
      return (
        T() && (s.stackTraceLimit = t),
        d(r, "name", {
          __proto__: null,
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0,
        }),
        r
      );
    }
    function generateUnhandledRejectionError(e) {
      const n = getErrorWithoutStack(
        "UnhandledPromiseRejection",
        `This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason "${p(
          e
        )}".`
      );
      return (n.code = "ERR_UNHANDLED_REJECTION"), n;
    }
    t.exports = {
      hasRejectionToWarn: function hasRejectionToWarn() {
        return 1 === u[v];
      },
      setHasRejectionToWarn: setHasRejectionToWarn,
      listenForRejections: function listenForRejections() {
        f(promiseRejectHandler);
      },
      processPromiseRejections: function processPromiseRejections() {
        let e = H.length > 0;
        for (; H.length > 0; ) {
          const { promise: e, warning: n } = c(H);
          r.emit("rejectionHandled", e) || r.emitWarning(n);
        }
        let n = P.length;
        for (; n--; ) {
          const n = c(P),
            t = _.get(n);
          if (void 0 === t) continue;
          t.warned = !0;
          const { reason: o, uid: i, emit: a } = t;
          let s = !0;
          const { [W]: d, [E]: l } = n;
          void 0 !== d && y(d, l, n);
          try {
            switch (D) {
              case S: {
                const e = isErrorLike(o)
                  ? o
                  : generateUnhandledRejectionError(o);
                w(e, !0), void 0 !== d && y(n[W], n[E], n);
                a(o, n, t) || emitUnhandledRejectionWarning(i, o);
                break;
              }
              case L:
                a(o, n, t);
                break;
              case A:
                a(o, n, t), emitUnhandledRejectionWarning(i, o);
                break;
              case x:
                if (!a(o, n, t)) {
                  const e = isErrorLike(o)
                    ? o
                    : generateUnhandledRejectionError(o);
                  w(e, !0), (s = !1);
                }
                break;
              case C:
                a(o, n, t) ||
                  (emitUnhandledRejectionWarning(i, o), (r.exitCode = 1));
                break;
            }
          } finally {
            s && void 0 !== d && b(d);
          }
          e = !0;
        }
        return e || 0 !== P.length;
      },
    };
  },
  "internal/process/report": function (e, t, r, n, a, i) {
    "use strict";
    const { ERR_SYNTHETIC: o } = t("internal/errors").codes,
      {
        validateBoolean: l,
        validateObject: g,
        validateSignalName: d,
        validateString: s,
      } = t("internal/validators"),
      p = a("report"),
      { JSONParse: c } = i,
      S = {
        writeReport: (e, t) => (
          "object" == typeof e && null !== e
            ? ((t = e), (e = void 0))
            : void 0 !== e && s(e, "file"),
          void 0 === t ? (t = new o()) : g(t, "err"),
          p.writeReport("JavaScript API", "API", e, t)
        ),
        getReport: (e) => (
          void 0 === e ? (e = new o()) : g(e, "err"), c(p.getReport(e))
        ),
        get directory() {
          return p.getDirectory();
        },
        set directory(e) {
          s(e, "directory"), p.setDirectory(e);
        },
        get filename() {
          return p.getFilename();
        },
        set filename(e) {
          s(e, "filename"), p.setFilename(e);
        },
        get compact() {
          return p.getCompact();
        },
        set compact(e) {
          l(e, "compact"), p.setCompact(e);
        },
        get signal() {
          return p.getSignal();
        },
        set signal(e) {
          d(e, "signal"),
            removeSignalHandler(),
            addSignalHandler(e),
            p.setSignal(e);
        },
        get reportOnFatalError() {
          return p.shouldReportOnFatalError();
        },
        set reportOnFatalError(e) {
          l(e, "trigger"), p.setReportOnFatalError(e);
        },
        get reportOnSignal() {
          return p.shouldReportOnSignal();
        },
        set reportOnSignal(e) {
          l(e, "trigger"),
            p.setReportOnSignal(e),
            removeSignalHandler(),
            addSignalHandler();
        },
        get reportOnUncaughtException() {
          return p.shouldReportOnUncaughtException();
        },
        set reportOnUncaughtException(e) {
          l(e, "trigger"), p.setReportOnUncaughtException(e);
        },
      };
    function addSignalHandler(e) {
      p.shouldReportOnSignal() &&
        ("string" != typeof e && (e = p.getSignal()), n.on(e, signalHandler));
    }
    function removeSignalHandler() {
      const e = p.getSignal();
      e && n.removeListener(e, signalHandler);
    }
    function signalHandler(e) {
      p.writeReport(e, "Signal", null, "");
    }
    r.exports = { addSignalHandler: addSignalHandler, report: S };
  },
  "internal/process/signal": function (n, t, i, s, o, e) {
    "use strict";
    const { FunctionPrototypeBind: a, SafeMap: r } = e,
      { errnoException: g } = t("internal/errors"),
      { signals: l } = o("constants").os;
    let c;
    const f = new r();
    i.exports = {
      startListeningIfSignal: function startListeningIfSignal(n) {
        if (
          (function isSignal(n) {
            return "string" == typeof n && void 0 !== l[n];
          })(n) &&
          !f.has(n)
        ) {
          void 0 === c && (c = o("signal_wrap").Signal);
          const t = new c();
          t.unref(), (t.onsignal = a(s.emit, s, n, n));
          const i = l[n],
            e = t.start(i);
          if (e) throw (t.close(), g(e, "uv_signal_start"));
          f.set(n, t);
        }
      },
      stopListeningIfSignal: function stopListeningIfSignal(n) {
        const t = f.get(n);
        void 0 !== t && 0 === s.listenerCount(n) && (t.close(), f.delete(n));
      },
    };
  },
  "internal/process/task_queues": function (e, s, t, c, n, i) {
    "use strict";
    const { Array: a, FunctionPrototypeBind: o } = i,
      {
        tickInfo: r,
        runMicrotasks: l,
        setTickCallback: u,
        enqueueMicrotask: k,
      } = n("task_queue"),
      {
        setHasRejectionToWarn: d,
        hasRejectionToWarn: h,
        listenForRejections: y,
        processPromiseRejections: f,
      } = s("internal/process/promises"),
      {
        getDefaultTriggerAsyncId: T,
        newAsyncId: b,
        initHooksExist: g,
        destroyHooksExist: p,
        emitInit: _,
        emitBefore: m,
        emitAfter: x,
        emitDestroy: A,
        symbols: { async_id_symbol: j, trigger_async_id_symbol: M },
      } = s("internal/async_hooks"),
      R = s("internal/fixed_queue"),
      { validateFunction: w } = s("internal/validators"),
      { AsyncResource: S } = s("async_hooks"),
      q = 0;
    function hasTickScheduled() {
      return 1 === r[q];
    }
    function setHasTickScheduled(e) {
      r[q] = e ? 1 : 0;
    }
    const H = new R();
    function runNextTicks() {
      hasTickScheduled() || h() || l(),
        (hasTickScheduled() || h()) && processTicksAndRejections();
    }
    function processTicksAndRejections() {
      let e;
      do {
        for (; null !== (e = H.shift()); ) {
          const s = e[j];
          m(s, e[M], e);
          try {
            const s = e.callback;
            if (void 0 === e.args) s();
            else {
              const t = e.args;
              switch (t.length) {
                case 1:
                  s(t[0]);
                  break;
                case 2:
                  s(t[0], t[1]);
                  break;
                case 3:
                  s(t[0], t[1], t[2]);
                  break;
                case 4:
                  s(t[0], t[1], t[2], t[3]);
                  break;
                default:
                  s(...t);
              }
            }
          } finally {
            p() && A(s);
          }
          x(s);
        }
        l();
      } while (!H.isEmpty() || f());
      setHasTickScheduled(!1), d(!1);
    }
    function nextTick(e) {
      if ((w(e, "callback"), c._exiting)) return;
      let s;
      switch (arguments.length) {
        case 1:
          break;
        case 2:
          s = [arguments[1]];
          break;
        case 3:
          s = [arguments[1], arguments[2]];
          break;
        case 4:
          s = [arguments[1], arguments[2], arguments[3]];
          break;
        default:
          s = new a(arguments.length - 1);
          for (let e = 1; e < arguments.length; e++) s[e - 1] = arguments[e];
      }
      H.isEmpty() && setHasTickScheduled(!0);
      const t = b(),
        n = T(),
        i = { [j]: t, [M]: n, callback: e, args: s };
      g() && _(t, "TickObject", n, i), H.push(i);
    }
    function runMicrotask() {
      this.runInAsyncScope(() => {
        const e = this.callback;
        try {
          e();
        } finally {
          this.emitDestroy();
        }
      });
    }
    const I = { requireManualDestroy: !0 };
    t.exports = {
      setupTaskQueue: () => (
        y(),
        u(processTicksAndRejections),
        { nextTick: nextTick, runNextTicks: runNextTicks }
      ),
      queueMicrotask: function queueMicrotask(e) {
        w(e, "callback");
        const s = new S("Microtask", I);
        (s.callback = e), k(o(runMicrotask, s));
      },
    };
  },
  "internal/process/warning": function (n, t, e, i, r, o) {
    "use strict";
    const {
        ArrayIsArray: a,
        Error: c,
        ErrorPrototypeToString: s,
        ErrorCaptureStackTrace: g,
        String: d,
      } = o,
      l = t("internal/assert"),
      {
        codes: { ERR_INVALID_ARG_TYPE: f },
        isErrorStackTraceLimitWritable: u,
      } = t("internal/errors"),
      { validateString: p } = t("internal/validators");
    let w,
      y,
      m,
      W,
      v,
      O = !1;
    function writeOut(n) {
      v || (v = t("internal/console/global").error), v(n);
    }
    function closeFdOnExit() {
      try {
        w.closeSync(y);
      } catch {}
    }
    function doEmitWarning(n) {
      i.emit("warning", n);
    }
    function createWarningObject(n, t, e, r, o) {
      l("string" == typeof n);
      const a = c.stackTraceLimit;
      return (
        u() && (c.stackTraceLimit = 0),
        (n = new c(n)),
        u() && (c.stackTraceLimit = a),
        (n.name = d(t || "Warning")),
        void 0 !== e && (n.code = e),
        void 0 !== o && (n.detail = o),
        g(n, r || i.emitWarning),
        n
      );
    }
    e.exports = {
      emitWarning: function emitWarning(n, t, e, r) {
        let o;
        if (
          (null === t || "object" != typeof t || a(t)
            ? "function" == typeof t && ((r = t), (e = void 0), (t = "Warning"))
            : ((r = t.ctor),
              (e = t.code),
              "string" == typeof t.detail && (o = t.detail),
              (t = t.type || "Warning")),
          void 0 !== t && p(t, "type"),
          "function" == typeof e
            ? ((r = e), (e = void 0))
            : void 0 !== e && p(e, "code"),
          "string" == typeof n)
        )
          n = createWarningObject(n, t, e, r, o);
        else if (!(n instanceof c))
          throw new f("warning", ["Error", "string"], n);
        if ("DeprecationWarning" === n.name) {
          if (i.noDeprecation) return;
          if (i.throwDeprecation)
            return i.nextTick(() => {
              throw n;
            });
        }
        i.nextTick(doEmitWarning, n);
      },
      emitWarningSync: function emitWarningSync(n, t, e, r) {
        i.emit("warning", createWarningObject(n, t, e, r));
      },
      onWarning: function onWarning(n) {
        if (!(n instanceof c)) return;
        const e = "DeprecationWarning" === n.name;
        if (e && i.noDeprecation) return;
        const r = i.traceProcessWarnings || (e && i.traceDeprecation);
        let o = `(${i.release.name}:${i.pid}) `;
        if (
          (n.code && (o += `[${n.code}] `),
          r && n.stack
            ? (o += `${n.stack}`)
            : (o += "function" == typeof n.toString ? `${n.toString()}` : s(n)),
          "string" == typeof n.detail && (o += `\n${n.detail}`),
          !r && !O)
        ) {
          const n = e ? "--trace-deprecation" : "--trace-warnings";
          (o += `\n(Use \`${t("path").basename(
            i.argv0 || "node",
            ".exe"
          )} ${n} ...\` to show where the warning was created)`),
            (O = !0);
        }
        if (
          (function lazyOption() {
            return (
              void 0 === m &&
                ((W = t("internal/options")),
                "" !== W.getOptionValue("--diagnostic-dir") &&
                  (m = W.getOptionValue("--diagnostic-dir")),
                (m =
                  "" !== W.getOptionValue("--redirect-warnings")
                    ? W.getOptionValue("--redirect-warnings")
                    : "")),
              m
            );
          })()
        )
          return (function writeToFile(n) {
            if (void 0 === y) {
              w = t("fs");
              try {
                y = w.openSync(m, "a");
              } catch {
                return writeOut(n);
              }
              i.on("exit", closeFdOnExit);
            }
            w.appendFile(y, `${n}\n`, (t) => {
              t && writeOut(n);
            });
          })(o);
        writeOut(o);
      },
      resetForSerialization: function resetForSerialization() {
        void 0 !== y && i.removeListener("exit", closeFdOnExit),
          (y = void 0),
          (m = void 0),
          (O = !1);
      },
    };
  },
  "internal/process/worker_thread_only": function (n, a, e, r, l, i) {
    "use strict";
    const {
      codes: { ERR_WORKER_UNSUPPORTED_OPERATION: o },
    } = a("internal/errors");
    e.exports = {
      unavailable: function unavailable(n) {
        function unavailableInWorker() {
          throw new o(n);
        }
        return (unavailableInWorker.disabled = !0), unavailableInWorker;
      },
    };
  },
  "internal/promise_hooks": function (t, e, o, n, r, a) {
    "use strict";
    const {
        ArrayPrototypeIndexOf: s,
        ArrayPrototypeSlice: i,
        ArrayPrototypeSplice: c,
        ArrayPrototypePush: l,
        FunctionPrototypeBind: f,
      } = a,
      { setPromiseHooks: u } = r("async_wrap"),
      { triggerUncaughtException: k } = r("errors"),
      { kEmptyObject: y } = e("internal/util"),
      { validatePlainFunction: m } = e("internal/validators"),
      p = { init: [], before: [], after: [], settled: [] };
    function initAll(t, e) {
      const o = i(p.init),
        n = [];
      for (let r = 0; r < o.length; r++) {
        const a = o[r];
        try {
          a(t, e);
        } catch (t) {
          l(n, t);
        }
      }
      for (let t = 0; t < n.length; t++) {
        k(n[t], !1);
      }
    }
    function makeRunHook(t) {
      return (e) => {
        const o = i(t),
          n = [];
        for (let t = 0; t < o.length; t++) {
          const r = o[t];
          try {
            r(e);
          } catch (t) {
            l(n, t);
          }
        }
        for (let t = 0; t < n.length; t++) {
          k(n[t], !1);
        }
      };
    }
    const h = makeRunHook(p.before),
      d = makeRunHook(p.after),
      H = makeRunHook(p.settled);
    function maybeFastPath(t, e) {
      return t.length > 1 ? e : t[0];
    }
    function update() {
      const t = maybeFastPath(p.init, initAll),
        e = maybeFastPath(p.before, h),
        o = maybeFastPath(p.after, d),
        n = maybeFastPath(p.settled, H);
      u(t, e, o, n);
    }
    function stop(t, e) {
      const o = s(t, e);
      o >= 0 && (c(t, o, 1), update());
    }
    function makeUseHook(t) {
      const e = p[t];
      return (o) => (m(o, `${t}Hook`), l(e, o), update(), f(stop, null, e, o));
    }
    const P = makeUseHook("init"),
      b = makeUseHook("before"),
      g = makeUseHook("after"),
      F = makeUseHook("settled");
    o.exports = {
      createHook: function createHook({
        init: t,
        before: e,
        after: o,
        settled: n,
      } = y) {
        const r = [];
        return (
          t && l(r, P(t)),
          e && l(r, b(e)),
          o && l(r, g(o)),
          n && l(r, F(n)),
          () => {
            for (const t of r) t();
          }
        );
      },
      onInit: P,
      onBefore: b,
      onAfter: g,
      onSettled: F,
    };
  },
  "internal/querystring": function (e, t, r, o, n, i) {
    "use strict";
    const {
        Array: c,
        Int8Array: f,
        NumberPrototypeToString: s,
        StringPrototypeCharCodeAt: a,
        StringPrototypeSlice: l,
        StringPrototypeToUpperCase: u,
      } = i,
      { ERR_INVALID_URI: p } = t("internal/errors").codes,
      S = new c(256);
    for (let e = 0; e < 256; ++e)
      S[e] = "%" + u((e < 16 ? "0" : "") + s(e, 16));
    const y = new f([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0,
    ]);
    r.exports = {
      encodeStr: function encodeStr(e, t, r) {
        const o = e.length;
        if (0 === o) return "";
        let n = "",
          i = 0,
          c = 0;
        e: for (; c < o; c++) {
          let f = a(e, c);
          for (; f < 128; ) {
            if (
              (1 !== t[f] &&
                (i < c && (n += l(e, i, c)), (i = c + 1), (n += r[f])),
              ++c === o)
            )
              break e;
            f = a(e, c);
          }
          if ((i < c && (n += l(e, i, c)), f < 2048)) {
            (i = c + 1), (n += r[192 | (f >> 6)] + r[128 | (63 & f)]);
            continue;
          }
          if (f < 55296 || f >= 57344) {
            (i = c + 1),
              (n +=
                r[224 | (f >> 12)] +
                r[128 | ((f >> 6) & 63)] +
                r[128 | (63 & f)]);
            continue;
          }
          if ((++c, c >= o)) throw new p();
          (i = c + 1),
            (f = 65536 + (((1023 & f) << 10) | (1023 & a(e, c)))),
            (n +=
              r[240 | (f >> 18)] +
              r[128 | ((f >> 12) & 63)] +
              r[128 | ((f >> 6) & 63)] +
              r[128 | (63 & f)]);
        }
        return 0 === i ? e : i < o ? n + l(e, i) : n;
      },
      hexTable: S,
      isHexTable: y,
    };
  },
  "internal/readline/callbacks": function (n, e, r, t, o, i) {
    "use strict";
    const { NumberIsNaN: l } = i,
      {
        codes: { ERR_INVALID_ARG_VALUE: c, ERR_INVALID_CURSOR_POS: u },
      } = e("internal/errors"),
      { validateFunction: a } = e("internal/validators"),
      { CSI: f } = e("internal/readline/utils"),
      {
        kClearLine: s,
        kClearScreenDown: w,
        kClearToLineBeginning: k,
        kClearToLineEnd: d,
      } = f;
    r.exports = {
      clearLine: function clearLine(n, e, r) {
        if ((void 0 !== r && a(r, "callback"), null == n))
          return "function" == typeof r && t.nextTick(r, null), !0;
        const o = e < 0 ? k : e > 0 ? d : s;
        return n.write(o, r);
      },
      clearScreenDown: function clearScreenDown(n, e) {
        return (
          void 0 !== e && a(e, "callback"),
          null == n
            ? ("function" == typeof e && t.nextTick(e, null), !0)
            : n.write(w, e)
        );
      },
      cursorTo: function cursorTo(n, e, r, o) {
        if (
          (void 0 !== o && a(o, "callback"),
          "function" == typeof r && ((o = r), (r = void 0)),
          l(e))
        )
          throw new c("x", e);
        if (l(r)) throw new c("y", r);
        if (null == n || ("number" != typeof e && "number" != typeof r))
          return "function" == typeof o && t.nextTick(o, null), !0;
        if ("number" != typeof e) throw new u();
        const i = "number" != typeof r ? f`${e + 1}G` : f`${r + 1};${e + 1}H`;
        return n.write(i, o);
      },
      moveCursor: function moveCursor(n, e, r, o) {
        if ((void 0 !== o && a(o, "callback"), null == n || (!e && !r)))
          return "function" == typeof o && t.nextTick(o, null), !0;
        let i = "";
        return (
          e < 0 ? (i += f`${-e}D`) : e > 0 && (i += f`${e}C`),
          r < 0 ? (i += f`${-r}A`) : r > 0 && (i += f`${r}B`),
          n.write(i, o)
        );
      },
    };
  },
  "internal/readline/emitKeypressEvents": function (e, t, n, r, o, s) {
    "use strict";
    const { SafeStringIterator: i, Symbol: a } = s,
      { charLengthAt: c, CSI: l, emitKeys: d } = t("internal/readline/utils"),
      { kSawKeyPress: u } = t("internal/readline/interface"),
      { clearTimeout: f, setTimeout: w } = t("timers"),
      { kEscape: m } = l,
      { StringDecoder: p } = t("string_decoder"),
      L = a("keypress-decoder"),
      y = a("escape-decoder"),
      g = 500;
    n.exports = function emitKeypressEvents(e, t = {}) {
      if (e[L]) return;
      (e[L] = new p("utf8")), (e[y] = d(e)), e[y].next();
      const triggerEscape = () => e[y].next(""),
        { escapeCodeTimeout: n = g } = t;
      let r;
      function onData(o) {
        if (e.listenerCount("keypress") > 0) {
          const s = e[L].write(o);
          if (s) {
            f(r), (t[u] = c(s, 0) === s.length), (t.isCompletionEnabled = !1);
            let o = 0;
            for (const a of new i(s)) {
              (o += a.length), o === s.length && (t.isCompletionEnabled = !0);
              try {
                e[y].next(a),
                  o === s.length && a === m && (r = w(triggerEscape, n));
              } catch (t) {
                throw ((e[y] = d(e)), e[y].next(), t);
              }
            }
          }
        } else
          e.removeListener("data", onData), e.on("newListener", onNewListener);
      }
      function onNewListener(t) {
        "keypress" === t &&
          (e.on("data", onData),
          e.removeListener("newListener", onNewListener));
      }
      e.listenerCount("keypress") > 0
        ? e.on("data", onData)
        : e.on("newListener", onNewListener);
    };
  },
  "internal/readline/interface": function (t, s, i, e, r, h) {
    "use strict";
    const {
        ArrayFrom: o,
        ArrayPrototypeFilter: n,
        ArrayPrototypeIndexOf: l,
        ArrayPrototypeJoin: c,
        ArrayPrototypeMap: a,
        ArrayPrototypePop: u,
        ArrayPrototypePush: p,
        ArrayPrototypeReverse: d,
        ArrayPrototypeSplice: f,
        ArrayPrototypeShift: y,
        ArrayPrototypeUnshift: m,
        DateNow: g,
        FunctionPrototypeCall: k,
        MathCeil: b,
        MathFloor: w,
        MathMax: S,
        MathMaxApply: _,
        NumberIsFinite: P,
        NumberIsNaN: v,
        ObjectSetPrototypeOf: C,
        RegExpPrototypeExec: I,
        StringPrototypeCodePointAt: L,
        StringPrototypeEndsWith: x,
        StringPrototypeRepeat: R,
        StringPrototypeSlice: T,
        StringPrototypeStartsWith: A,
        StringPrototypeTrim: D,
        Symbol: z,
        SymbolDispose: E,
        SymbolAsyncIterator: W,
        SafeStringIterator: M,
      } = h,
      { codes: N } = s("internal/errors"),
      { ERR_INVALID_ARG_VALUE: O, ERR_USE_AFTER_CLOSE: G } = N,
      {
        validateAbortSignal: F,
        validateArray: H,
        validateString: q,
        validateUint32: K,
      } = s("internal/validators"),
      { kEmptyObject: U } = s("internal/util"),
      {
        inspect: j,
        getStringWidth: Q,
        stripVTControlCharacters: V,
      } = s("internal/util/inspect"),
      J = s("events"),
      {
        charLengthAt: Y,
        charLengthLeft: $,
        commonPrefix: B,
        kSubstringSearch: X,
      } = s("internal/readline/utils");
    let Z;
    const {
        clearScreenDown: tt,
        cursorTo: st,
        moveCursor: it,
      } = s("internal/readline/callbacks"),
      { StringDecoder: et } = s("string_decoder");
    let rt;
    const ht = /\r?\n|\r(?!\n)/g,
      ot = z("line object stream"),
      nt = z("kQuestionCancel"),
      lt = z("_addHistory"),
      ct = z("_beforeEdit"),
      at = z("_decoder"),
      ut = z("_deleteLeft"),
      pt = z("_deleteLineLeft"),
      dt = z("_deleteLineRight"),
      ft = z("_deleteRight"),
      yt = z("_deleteWordLeft"),
      mt = z("_deleteWordRight"),
      gt = z("_getDisplayPos"),
      kt = z("_historyNext"),
      bt = z("_historyPrev"),
      wt = z("_insertString"),
      St = z("_line"),
      _t = z("_line_buffer"),
      Pt = z("_killRing"),
      vt = z("_killRingCursor"),
      Ct = z("_moveCursor"),
      It = z("_normalWrite"),
      Lt = z("_oldPrompt"),
      xt = z("_onLine"),
      Rt = z("_previousKey"),
      Tt = z("_prompt"),
      At = z("_pushToKillRing"),
      Dt = z("_pushToUndoStack"),
      zt = z("_questionCallback"),
      Et = z("_redo"),
      Wt = z("_redoStack"),
      Mt = z("_refreshLine"),
      Nt = z("_sawKeyPress"),
      Ot = z("_sawReturnAt"),
      Gt = z("_setRawMode"),
      Ft = z("_tabComplete"),
      Ht = z("_tabCompleter"),
      qt = z("_ttyWrite"),
      Kt = z("_undo"),
      Ut = z("_undoStack"),
      jt = z("_wordLeft"),
      Qt = z("_wordRight"),
      Vt = z("_writeToOutput"),
      Jt = z("_yank"),
      Yt = z("_yanking"),
      $t = z("_yankPop");
    function InterfaceConstructor(t, i, r, h) {
      let o, n;
      (this[Ot] = 0),
        (this.isCompletionEnabled = !0),
        (this[Nt] = !1),
        (this[Rt] = null),
        (this.escapeCodeTimeout = 500),
        (this.tabSize = 8),
        k(J, this);
      let l,
        c,
        a = !1,
        u = "> ";
      if (t?.input) {
        if (
          ((i = t.output),
          (r = t.completer),
          (h = t.terminal),
          (o = t.history),
          (n = t.historySize),
          (c = t.signal),
          void 0 !== t.tabSize &&
            (K(t.tabSize, "tabSize", !0), (this.tabSize = t.tabSize)),
          (a = t.removeHistoryDuplicates),
          void 0 !== t.prompt && (u = t.prompt),
          void 0 !== t.escapeCodeTimeout)
        ) {
          if (!P(t.escapeCodeTimeout))
            throw new O("input.escapeCodeTimeout", this.escapeCodeTimeout);
          this.escapeCodeTimeout = t.escapeCodeTimeout;
        }
        c && F(c, "options.signal"), (l = t.crlfDelay), (t = t.input);
      }
      if (void 0 !== r && "function" != typeof r) throw new O("completer", r);
      if (
        (void 0 === o ? (o = []) : H(o, "history"),
        void 0 === n && (n = 30),
        "number" != typeof n || v(n) || n < 0)
      )
        throw new O.RangeError("historySize", n);
      void 0 === h && null != i && (h = !!i.isTTY);
      const p = this;
      function onerror(t) {
        p.emit("error", t);
      }
      function ondata(t) {
        p[It](t);
      }
      function onend() {
        "string" == typeof p[_t] && p[_t].length > 0 && p.emit("line", p[_t]),
          p.close();
      }
      function ontermend() {
        "string" == typeof p.line &&
          p.line.length > 0 &&
          p.emit("line", p.line),
          p.close();
      }
      function onkeypress(t, s) {
        if ((p[qt](t, s), s && s.sequence)) {
          const t = L(s.sequence, 0);
          t >= 55296 && t <= 57343 && p[Mt]();
        }
      }
      function onresize() {
        p[Mt]();
      }
      if (
        ((this.line = ""),
        (this[X] = null),
        (this.output = i),
        (this.input = t),
        (this[Ut] = []),
        (this[Wt] = []),
        (this.history = o),
        (this.historySize = n),
        (this[Pt] = []),
        (this[vt] = 0),
        (this.removeHistoryDuplicates = !!a),
        (this.crlfDelay = l ? S(100, l) : 100),
        (this.completer = r),
        this.setPrompt(u),
        (this.terminal = !!h),
        (this[ot] = void 0),
        t.on("error", onerror),
        this.terminal)
      ) {
        let onSelfCloseWithTerminal = function () {
          t.removeListener("keypress", onkeypress),
            t.removeListener("error", onerror),
            t.removeListener("end", ontermend),
            null != i && i.removeListener("resize", onresize);
        };
        (Z ??= s("internal/readline/emitKeypressEvents")),
          Z(t, this),
          t.on("keypress", onkeypress),
          t.on("end", ontermend),
          this[Gt](!0),
          (this.terminal = !0),
          (this.cursor = 0),
          (this.historyIndex = -1),
          null != i && i.on("resize", onresize),
          p.once("close", onSelfCloseWithTerminal);
      } else {
        let onSelfCloseWithoutTerminal = function () {
          t.removeListener("data", ondata),
            t.removeListener("error", onerror),
            t.removeListener("end", onend);
        };
        t.on("data", ondata),
          t.on("end", onend),
          p.once("close", onSelfCloseWithoutTerminal),
          (this[at] = new et("utf8"));
      }
      if (c) {
        const onAborted = () => p.close();
        if (c.aborted) e.nextTick(onAborted);
        else {
          const t = J.addAbortListener(c, onAborted);
          p.once("close", t[E]);
        }
      }
      (this.line = ""), t.resume();
    }
    C(InterfaceConstructor.prototype, J.prototype), C(InterfaceConstructor, J);
    i.exports = {
      Interface: class Interface extends InterfaceConstructor {
        constructor(t, s, i, e) {
          super(t, s, i, e);
        }
        get columns() {
          return this.output && this.output.columns
            ? this.output.columns
            : 1 / 0;
        }
        setPrompt(t) {
          this[Tt] = t;
        }
        getPrompt() {
          return this[Tt];
        }
        [Gt](t) {
          const s = this.input.isRaw;
          return (
            "function" == typeof this.input.setRawMode &&
              this.input.setRawMode(t),
            s
          );
        }
        prompt(t) {
          this.paused && this.resume(),
            this.terminal && "dumb" !== e.env.TERM
              ? (t || (this.cursor = 0), this[Mt]())
              : this[Vt](this[Tt]);
        }
        question(t, s) {
          if (this.closed) throw new G("readline");
          this[zt] ||
            ((this[Lt] = this[Tt]), this.setPrompt(t), (this[zt] = s)),
            this.prompt();
        }
        [xt](t) {
          if (this[zt]) {
            const s = this[zt];
            (this[zt] = null), this.setPrompt(this[Lt]), s(t);
          } else this.emit("line", t);
        }
        [ct](t, s) {
          this[Dt](t, s);
        }
        [nt]() {
          this[zt] &&
            ((this[zt] = null), this.setPrompt(this[Lt]), this.clearLine());
        }
        [Vt](t) {
          q(t, "stringToWrite"),
            null !== this.output &&
              void 0 !== this.output &&
              this.output.write(t);
        }
        [lt]() {
          if (0 === this.line.length) return "";
          if (0 === this.historySize) return this.line;
          if (0 === D(this.line).length) return this.line;
          if (0 === this.history.length || this.history[0] !== this.line) {
            if (this.removeHistoryDuplicates) {
              const t = l(this.history, this.line);
              -1 !== t && f(this.history, t, 1);
            }
            m(this.history, this.line),
              this.history.length > this.historySize && u(this.history);
          }
          this.historyIndex = -1;
          const t = this.history[0];
          return this.emit("history", this.history), t;
        }
        [Mt]() {
          const t = this[Tt] + this.line,
            s = this[gt](t),
            i = s.cols,
            e = s.rows,
            r = this.getCursorPos(),
            h = this.prevRows || 0;
          h > 0 && it(this.output, 0, -h),
            st(this.output, 0),
            tt(this.output),
            this[Vt](t),
            0 === i && this[Vt](" "),
            st(this.output, r.cols);
          const o = e - r.rows;
          o > 0 && it(this.output, 0, -o), (this.prevRows = r.rows);
        }
        close() {
          this.closed ||
            (this.pause(),
            this.terminal && this[Gt](!1),
            (this.closed = !0),
            this.emit("close"));
        }
        pause() {
          if (!this.paused)
            return (
              this.input.pause(), (this.paused = !0), this.emit("pause"), this
            );
        }
        resume() {
          if (this.paused)
            return (
              this.input.resume(), (this.paused = !1), this.emit("resume"), this
            );
        }
        write(t, s) {
          this.paused && this.resume(),
            this.terminal ? this[qt](t, s) : this[It](t);
        }
        [It](t) {
          if (void 0 === t) return;
          let s = this[at].write(t);
          this[Ot] &&
            g() - this[Ot] <= this.crlfDelay &&
            (10 === L(s) && (s = T(s, 1)), (this[Ot] = 0));
          let i = I(ht, s);
          if (null !== i) {
            this[_t] &&
              ((s = this[_t] + s),
              (this[_t] = null),
              (ht.lastIndex = 0),
              (i = I(ht, s))),
              (this[Ot] = x(s, "\r") ? g() : 0);
            const t = [0, i.index, ht.lastIndex];
            let e;
            for (; null !== (e = I(ht, s)); ) p(t, e.index, ht.lastIndex);
            const r = t.length - 1;
            this[_t] = T(s, t[r]);
            for (let i = 1; i < r; i += 2) this[xt](T(s, t[i - 1], t[i]));
          } else s && (this[_t] ? (this[_t] += s) : (this[_t] = s));
        }
        [wt](t) {
          if (
            (this[ct](this.line, this.cursor), this.cursor < this.line.length)
          ) {
            const s = T(this.line, 0, this.cursor),
              i = T(this.line, this.cursor, this.line.length);
            (this.line = s + t + i), (this.cursor += t.length), this[Mt]();
          } else {
            const s = this.getCursorPos();
            (this.line += t), (this.cursor += t.length);
            const i = this.getCursorPos();
            s.rows < i.rows ? this[Mt]() : this[Vt](t);
          }
        }
        async [Ft](t) {
          this.pause();
          const s = T(this.line, 0, this.cursor);
          let i;
          try {
            i = await this.completer(s);
          } catch (t) {
            return void this[Vt](`Tab completion error: ${j(t)}`);
          } finally {
            this.resume();
          }
          this[Ht](t, i);
        }
        [Ht](t, { 0: s, 1: i }) {
          if (!s || 0 === s.length) return;
          const e = B(n(s, (t) => "" !== t));
          if (A(e, i) && e.length > i.length)
            return void this[wt](T(e, i.length));
          if (!A(i, e))
            return (
              (this.line =
                T(this.line, 0, this.cursor - i.length) +
                e +
                T(this.line, this.cursor, this.line.length)),
              (this.cursor = this.cursor - i.length + e.length),
              void this._refreshLine()
            );
          if (!t) return;
          this[ct](this.line, this.cursor);
          const r = a(s, (t) => Q(t)),
            h = _(r) + 2;
          let o = w(this.columns / h) || 1;
          o === 1 / 0 && (o = 1);
          let l = "\r\n",
            c = 0,
            u = 0;
          for (let t = 0; t < s.length; t++) {
            const i = s[t];
            "" === i || c === o
              ? ((l += "\r\n"), (c = 0), (u = 0))
              : (l += R(" ", u)),
              "" !== i ? ((l += i), (u = h - r[t]), c++) : (l += "\r\n");
          }
          0 !== c && (l += "\r\n\r\n"), this[Vt](l), this[Mt]();
        }
        [jt]() {
          if (this.cursor > 0) {
            const t = T(this.line, 0, this.cursor),
              s = c(d(o(t)), ""),
              i = I(/^\s*(?:[^\w\s]+|\w+)?/, s);
            this[Ct](-i[0].length);
          }
        }
        [Qt]() {
          if (this.cursor < this.line.length) {
            const t = T(this.line, this.cursor),
              s = I(/^(?:\s+|[^\w\s]+|\w+)\s*/, t);
            this[Ct](s[0].length);
          }
        }
        [ut]() {
          if (this.cursor > 0 && this.line.length > 0) {
            this[ct](this.line, this.cursor);
            const t = $(this.line, this.cursor);
            (this.line =
              T(this.line, 0, this.cursor - t) +
              T(this.line, this.cursor, this.line.length)),
              (this.cursor -= t),
              this[Mt]();
          }
        }
        [ft]() {
          if (this.cursor < this.line.length) {
            this[ct](this.line, this.cursor);
            const t = Y(this.line, this.cursor);
            (this.line =
              T(this.line, 0, this.cursor) +
              T(this.line, this.cursor + t, this.line.length)),
              this[Mt]();
          }
        }
        [yt]() {
          if (this.cursor > 0) {
            this[ct](this.line, this.cursor);
            let t = T(this.line, 0, this.cursor);
            const s = c(d(o(t)), ""),
              i = I(/^\s*(?:[^\w\s]+|\w+)?/, s);
            (t = T(t, 0, t.length - i[0].length)),
              (this.line = t + T(this.line, this.cursor, this.line.length)),
              (this.cursor = t.length),
              this[Mt]();
          }
        }
        [mt]() {
          if (this.cursor < this.line.length) {
            this[ct](this.line, this.cursor);
            const t = T(this.line, this.cursor),
              s = I(/^(?:\s+|\W+|\w+)\s*/, t);
            (this.line = T(this.line, 0, this.cursor) + T(t, s[0].length)),
              this[Mt]();
          }
        }
        [pt]() {
          this[ct](this.line, this.cursor);
          const t = T(this.line, 0, this.cursor);
          (this.line = T(this.line, this.cursor)),
            (this.cursor = 0),
            this[At](t),
            this[Mt]();
        }
        [dt]() {
          this[ct](this.line, this.cursor);
          const t = T(this.line, this.cursor);
          (this.line = T(this.line, 0, this.cursor)), this[At](t), this[Mt]();
        }
        [At](t) {
          if (t && t !== this[Pt][0])
            for (m(this[Pt], t), this[vt] = 0; this[Pt].length > 32; )
              u(this[Pt]);
        }
        [Jt]() {
          this[Pt].length > 0 &&
            ((this[Yt] = !0), this[wt](this[Pt][this[vt]]));
        }
        [$t]() {
          if (this[Yt] && this[Pt].length > 1) {
            const t = this[Pt][this[vt]];
            this[vt]++, this[vt] >= this[Pt].length && (this[vt] = 0);
            const s = this[Pt][this[vt]],
              i = T(this.line, 0, this.cursor - t.length),
              e = T(this.line, this.cursor);
            (this.line = i + s + e),
              (this.cursor = i.length + s.length),
              this[Mt]();
          }
        }
        clearLine() {
          this[Ct](1 / 0),
            this[Vt]("\r\n"),
            (this.line = ""),
            (this.cursor = 0),
            (this.prevRows = 0);
        }
        [St]() {
          const t = this[lt]();
          (this[Ut] = []), (this[Wt] = []), this.clearLine(), this[xt](t);
        }
        [Dt](t, s) {
          p(this[Ut], { text: t, cursor: s }) > 2048 && y(this[Ut]);
        }
        [Kt]() {
          if (this[Ut].length <= 0) return;
          p(this[Wt], { text: this.line, cursor: this.cursor });
          const t = u(this[Ut]);
          (this.line = t.text), (this.cursor = t.cursor), this[Mt]();
        }
        [Et]() {
          if (this[Wt].length <= 0) return;
          p(this[Ut], { text: this.line, cursor: this.cursor });
          const t = u(this[Wt]);
          (this.line = t.text), (this.cursor = t.cursor), this[Mt]();
        }
        [kt]() {
          if (this.historyIndex >= 0) {
            this[ct](this.line, this.cursor);
            const t = this[X] || "";
            let s = this.historyIndex - 1;
            for (
              ;
              s >= 0 &&
              (!A(this.history[s], t) || this.line === this.history[s]);

            )
              s--;
            (this.line = -1 === s ? t : this.history[s]),
              (this.historyIndex = s),
              (this.cursor = this.line.length),
              this[Mt]();
          }
        }
        [bt]() {
          if (this.historyIndex < this.history.length && this.history.length) {
            this[ct](this.line, this.cursor);
            const t = this[X] || "";
            let s = this.historyIndex + 1;
            for (
              ;
              s < this.history.length &&
              (!A(this.history[s], t) || this.line === this.history[s]);

            )
              s++;
            s === this.history.length
              ? (this.line = t)
              : (this.line = this.history[s]),
              (this.historyIndex = s),
              (this.cursor = this.line.length),
              this[Mt]();
          }
        }
        [gt](t) {
          let s = 0;
          const i = this.columns;
          let e = 0;
          t = V(t);
          for (const r of new M(t)) {
            if ("\n" === r) {
              (e += b(s / i) || 1), (s = 0);
              continue;
            }
            if ("\t" === r) {
              s += this.tabSize - (s % this.tabSize);
              continue;
            }
            const t = Q(r, !1);
            0 === t || 1 === t ? (s += t) : ((s + 1) % i == 0 && s++, (s += 2));
          }
          const r = s % i;
          return (e += (s - r) / i), { cols: r, rows: e };
        }
        getCursorPos() {
          const t = this[Tt] + T(this.line, 0, this.cursor);
          return this[gt](t);
        }
        [Ct](t) {
          if (0 === t) return;
          const s = this.getCursorPos();
          (this.cursor += t),
            this.cursor < 0
              ? (this.cursor = 0)
              : this.cursor > this.line.length &&
                (this.cursor = this.line.length);
          const i = this.getCursorPos();
          if (s.rows === i.rows) {
            const t = i.cols - s.cols;
            it(this.output, t, 0);
          } else this[Mt]();
        }
        [qt](t, s) {
          const i = this[Rt];
          if (
            ((s = s || U),
            (this[Rt] = s),
            (s.meta && "y" === s.name) || (this[Yt] = !1),
            ("up" !== s.name && "down" !== s.name) ||
            s.ctrl ||
            s.meta ||
            s.shift
              ? null !== this[X] &&
                ((this[X] = null),
                this.history.length === this.historyIndex &&
                  (this.historyIndex = -1))
              : null === this[X] && (this[X] = T(this.line, 0, this.cursor)),
            "string" == typeof s.sequence)
          )
            switch (L(s.sequence, 0)) {
              case 31:
                return void this[Kt]();
              case 30:
                return void this[Et]();
            }
          if ("escape" !== s.name)
            if (s.ctrl && s.shift)
              switch (s.name) {
                case "backspace":
                  this[pt]();
                  break;
                case "delete":
                  this[dt]();
              }
            else if (s.ctrl)
              switch (s.name) {
                case "c":
                  this.listenerCount("SIGINT") > 0
                    ? this.emit("SIGINT")
                    : this.close();
                  break;
                case "h":
                  this[ut]();
                  break;
                case "d":
                  0 === this.cursor && 0 === this.line.length
                    ? this.close()
                    : this.cursor < this.line.length && this[ft]();
                  break;
                case "u":
                  this[pt]();
                  break;
                case "k":
                  this[dt]();
                  break;
                case "a":
                  this[Ct](-1 / 0);
                  break;
                case "e":
                  this[Ct](1 / 0);
                  break;
                case "b":
                  this[Ct](-$(this.line, this.cursor));
                  break;
                case "f":
                  this[Ct](+Y(this.line, this.cursor));
                  break;
                case "l":
                  st(this.output, 0, 0), tt(this.output), this[Mt]();
                  break;
                case "n":
                  this[kt]();
                  break;
                case "p":
                  this[bt]();
                  break;
                case "y":
                  this[Jt]();
                  break;
                case "z":
                  if ("win32" === e.platform) break;
                  this.listenerCount("SIGTSTP") > 0
                    ? this.emit("SIGTSTP")
                    : (e.once("SIGCONT", () => {
                        this.paused || (this.pause(), this.emit("SIGCONT")),
                          this[Gt](!0),
                          this[Mt]();
                      }),
                      this[Gt](!1),
                      e.kill(e.pid, "SIGTSTP"));
                  break;
                case "w":
                case "backspace":
                  this[yt]();
                  break;
                case "delete":
                  this[mt]();
                  break;
                case "left":
                  this[jt]();
                  break;
                case "right":
                  this[Qt]();
              }
            else if (s.meta)
              switch (s.name) {
                case "b":
                  this[jt]();
                  break;
                case "f":
                  this[Qt]();
                  break;
                case "d":
                case "delete":
                  this[mt]();
                  break;
                case "backspace":
                  this[yt]();
                  break;
                case "y":
                  this[$t]();
              }
            else
              switch (
                (this[Ot] && "enter" !== s.name && (this[Ot] = 0), s.name)
              ) {
                case "return":
                  (this[Ot] = g()), this[St]();
                  break;
                case "enter":
                  (0 === this[Ot] || g() - this[Ot] > this.crlfDelay) &&
                    this[St](),
                    (this[Ot] = 0);
                  break;
                case "backspace":
                  this[ut]();
                  break;
                case "delete":
                  this[ft]();
                  break;
                case "left":
                  this[Ct](-$(this.line, this.cursor));
                  break;
                case "right":
                  this[Ct](+Y(this.line, this.cursor));
                  break;
                case "home":
                  this[Ct](-1 / 0);
                  break;
                case "end":
                  this[Ct](1 / 0);
                  break;
                case "up":
                  this[bt]();
                  break;
                case "down":
                  this[kt]();
                  break;
                case "tab":
                  if (
                    "function" == typeof this.completer &&
                    this.isCompletionEnabled
                  ) {
                    const t = i && "tab" === i.name;
                    this[Ft](t);
                    break;
                  }
                default:
                  if ("string" == typeof t && t) {
                    let s;
                    ht.lastIndex = 0;
                    let i = 0;
                    for (; null !== (s = I(ht, t)); )
                      this[wt](T(t, i, s.index)),
                        ({ lastIndex: i } = ht),
                        this[St](),
                        (ht.lastIndex = i);
                    this[wt](T(t, i));
                  }
              }
        }
        [W]() {
          if (void 0 === this[ot]) {
            void 0 === rt && (rt = s("stream").Readable);
            const t = new rt({
                objectMode: !0,
                read: () => {
                  this.resume();
                },
                destroy: (t, s) => {
                  this.off("line", lineListener),
                    this.off("close", closeListener),
                    this.close(),
                    s(t);
                },
              }),
              lineListener = (s) => {
                t.push(s) || this.pause();
              },
              closeListener = () => {
                t.push(null);
              },
              errorListener = (s) => {
                t.destroy(s);
              };
            this.on("error", errorListener),
              this.on("line", lineListener),
              this.on("close", closeListener),
              (this[ot] = t);
          }
          return this[ot][W]();
        }
      },
      InterfaceConstructor: InterfaceConstructor,
      kAddHistory: lt,
      kDecoder: at,
      kDeleteLeft: ut,
      kDeleteLineLeft: pt,
      kDeleteLineRight: dt,
      kDeleteRight: ft,
      kDeleteWordLeft: yt,
      kDeleteWordRight: mt,
      kGetDisplayPos: gt,
      kHistoryNext: kt,
      kHistoryPrev: bt,
      kInsertString: wt,
      kLine: St,
      kLine_buffer: _t,
      kMoveCursor: Ct,
      kNormalWrite: It,
      kOldPrompt: Lt,
      kOnLine: xt,
      kPreviousKey: Rt,
      kPrompt: Tt,
      kQuestionCallback: zt,
      kQuestionCancel: nt,
      kRefreshLine: Mt,
      kSawKeyPress: Nt,
      kSawReturnAt: Ot,
      kSetRawMode: Gt,
      kTabComplete: Ft,
      kTabCompleter: Ht,
      kTtyWrite: qt,
      kWordLeft: jt,
      kWordRight: Qt,
      kWriteToOutput: Vt,
    };
  },
  "internal/readline/promises": function (t, i, o, e, r, s) {
    "use strict";
    const { ArrayPrototypeJoin: n, ArrayPrototypePush: a, Promise: m } = s,
      { CSI: l } = i("internal/readline/utils"),
      { validateBoolean: u, validateInteger: h } = i("internal/validators"),
      { isWritable: d } = i("internal/streams/utils"),
      {
        codes: { ERR_INVALID_ARG_TYPE: c },
      } = i("internal/errors"),
      {
        kClearToLineBeginning: C,
        kClearToLineEnd: w,
        kClearLine: k,
        kClearScreenDown: T,
      } = l;
    o.exports = {
      Readline: class Readline {
        #t = !1;
        #i;
        #o = [];
        constructor(t, i = void 0) {
          if (!d(t)) throw new c("stream", "Writable", t);
          (this.#i = t),
            null != i?.autoCommit &&
              (u(i.autoCommit, "options.autoCommit"), (this.#t = i.autoCommit));
        }
        cursorTo(t, i = void 0) {
          h(t, "x"), null != i && h(i, "y");
          const o = null == i ? l`${t + 1}G` : l`${i + 1};${t + 1}H`;
          return (
            this.#t ? e.nextTick(() => this.#i.write(o)) : a(this.#o, o), this
          );
        }
        moveCursor(t, i) {
          if (t || i) {
            h(t, "dx"), h(i, "dy");
            let o = "";
            t < 0 ? (o += l`${-t}D`) : t > 0 && (o += l`${t}C`),
              i < 0 ? (o += l`${-i}A`) : i > 0 && (o += l`${i}B`),
              this.#t ? e.nextTick(() => this.#i.write(o)) : a(this.#o, o);
          }
          return this;
        }
        clearLine(t) {
          h(t, "dir", -1, 1);
          const i = t < 0 ? C : t > 0 ? w : k;
          return (
            this.#t ? e.nextTick(() => this.#i.write(i)) : a(this.#o, i), this
          );
        }
        clearScreenDown() {
          return (
            this.#t ? e.nextTick(() => this.#i.write(T)) : a(this.#o, T), this
          );
        }
        commit() {
          return new m((t) => {
            this.#i.write(n(this.#o, ""), t), (this.#o = []);
          });
        }
        rollback() {
          return (this.#o = []), this;
        }
      },
    };
  },
  "internal/readline/utils": function (e, a, n, t, r, c) {
    "use strict";
    const {
        ArrayPrototypeSlice: s,
        ArrayPrototypeSort: m,
        RegExpPrototypeExec: i,
        StringFromCharCode: l,
        StringPrototypeCharCodeAt: o,
        StringPrototypeCodePointAt: k,
        StringPrototypeSlice: b,
        StringPrototypeToLowerCase: f,
        Symbol: h,
      } = c,
      d = 65536,
      g = "",
      p = h("kSubstringSearch");
    function CSI(e, ...a) {
      let n = `${g}[`;
      for (let t = 0; t < e.length; t++)
        (n += e[t]), t < a.length && (n += a[t]);
      return n;
    }
    function charLengthAt(e, a) {
      return e.length <= a ? 1 : k(e, a) >= d ? 2 : 1;
    }
    (CSI.kEscape = g),
      (CSI.kClearToLineBeginning = CSI`1K`),
      (CSI.kClearToLineEnd = CSI`0K`),
      (CSI.kClearLine = CSI`2K`),
      (CSI.kClearScreenDown = CSI`0J`),
      (n.exports = {
        charLengthAt: charLengthAt,
        charLengthLeft: function charLengthLeft(e, a) {
          return a <= 0
            ? 0
            : (a > 1 && k(e, a - 2) >= d) || k(e, a - 1) >= d
            ? 2
            : 1;
        },
        commonPrefix: function commonPrefix(e) {
          if (0 === e.length) return "";
          if (1 === e.length) return e[0];
          const a = m(s(e)),
            n = a[0],
            t = a[a.length - 1];
          for (let e = 0; e < n.length; e++)
            if (n[e] !== t[e]) return b(n, 0, e);
          return n;
        },
        emitKeys: function* emitKeys(e) {
          for (;;) {
            let a = yield,
              n = a,
              t = !1;
            const r = {
              sequence: null,
              name: void 0,
              ctrl: !1,
              meta: !1,
              shift: !1,
            };
            if (
              (a === g &&
                ((t = !0), (n += a = yield), a === g && (n += a = yield)),
              !t || ("O" !== a && "[" !== a))
            )
              "\r" === a
                ? ((r.name = "return"), (r.meta = t))
                : "\n" === a
                ? ((r.name = "enter"), (r.meta = t))
                : "\t" === a
                ? ((r.name = "tab"), (r.meta = t))
                : "\b" === a || "" === a
                ? ((r.name = "backspace"), (r.meta = t))
                : a === g
                ? ((r.name = "escape"), (r.meta = t))
                : " " === a
                ? ((r.name = "space"), (r.meta = t))
                : !t && a <= ""
                ? ((r.name = l(o(a) + o("a") - 1)), (r.ctrl = !0))
                : null !== i(/^[0-9A-Za-z]$/, a)
                ? ((r.name = f(a)),
                  (r.shift = null !== i(/^[A-Z]$/, a)),
                  (r.meta = t))
                : t && ((r.name = a.length ? void 0 : "escape"), (r.meta = !0));
            else {
              let e = a,
                t = 0;
              if ("O" === a)
                (n += a = yield),
                  a >= "0" &&
                    a <= "9" &&
                    ((t = (a >> 0) - 1), (n += a = yield)),
                  (e += a);
              else if ("[" === a) {
                (n += a = yield), "[" === a && ((e += a), (n += a = yield));
                const r = n.length - 1;
                a >= "0" &&
                  a <= "9" &&
                  ((n += a = yield),
                  a >= "0" &&
                    a <= "9" &&
                    ((n += a = yield),
                    a >= "0" && a <= "9" && (n += a = yield))),
                  ";" === a &&
                    ((n += a = yield), a >= "0" && a <= "9" && (n += yield));
                const c = b(n, r);
                let s;
                (s = i(/^(?:(\d\d?)(?:;(\d))?([~^$])|(\d{3}~))$/, c))
                  ? s[4]
                    ? (e += s[4])
                    : ((e += s[1] + s[3]), (t = (s[2] || 1) - 1))
                  : (s = i(/^((\d;)?(\d))?([A-Za-z])$/, c))
                  ? ((e += s[4]), (t = (s[3] || 1) - 1))
                  : (e += c);
              }
              switch (
                ((r.ctrl = !!(4 & t)),
                (r.meta = !!(10 & t)),
                (r.shift = !!(1 & t)),
                (r.code = e),
                e)
              ) {
                case "[P":
                case "OP":
                case "[11~":
                case "[[A":
                  r.name = "f1";
                  break;
                case "[Q":
                case "OQ":
                case "[12~":
                case "[[B":
                  r.name = "f2";
                  break;
                case "[R":
                case "OR":
                case "[13~":
                case "[[C":
                  r.name = "f3";
                  break;
                case "[S":
                case "OS":
                case "[14~":
                case "[[D":
                  r.name = "f4";
                  break;
                case "[200~":
                  r.name = "paste-start";
                  break;
                case "[201~":
                  r.name = "paste-end";
                  break;
                case "[[E":
                case "[15~":
                  r.name = "f5";
                  break;
                case "[17~":
                  r.name = "f6";
                  break;
                case "[18~":
                  r.name = "f7";
                  break;
                case "[19~":
                  r.name = "f8";
                  break;
                case "[20~":
                  r.name = "f9";
                  break;
                case "[21~":
                  r.name = "f10";
                  break;
                case "[23~":
                  r.name = "f11";
                  break;
                case "[24~":
                  r.name = "f12";
                  break;
                case "[A":
                case "OA":
                  r.name = "up";
                  break;
                case "[B":
                case "OB":
                  r.name = "down";
                  break;
                case "[C":
                case "OC":
                  r.name = "right";
                  break;
                case "[D":
                case "OD":
                  r.name = "left";
                  break;
                case "[E":
                case "OE":
                  r.name = "clear";
                  break;
                case "[F":
                case "OF":
                case "[4~":
                case "[8~":
                  r.name = "end";
                  break;
                case "[H":
                case "OH":
                case "[1~":
                case "[7~":
                  r.name = "home";
                  break;
                case "[2~":
                  r.name = "insert";
                  break;
                case "[3~":
                  r.name = "delete";
                  break;
                case "[5~":
                case "[[5~":
                  r.name = "pageup";
                  break;
                case "[6~":
                case "[[6~":
                  r.name = "pagedown";
                  break;
                case "[a":
                  (r.name = "up"), (r.shift = !0);
                  break;
                case "[b":
                  (r.name = "down"), (r.shift = !0);
                  break;
                case "[c":
                  (r.name = "right"), (r.shift = !0);
                  break;
                case "[d":
                  (r.name = "left"), (r.shift = !0);
                  break;
                case "[e":
                  (r.name = "clear"), (r.shift = !0);
                  break;
                case "[2$":
                  (r.name = "insert"), (r.shift = !0);
                  break;
                case "[3$":
                  (r.name = "delete"), (r.shift = !0);
                  break;
                case "[5$":
                  (r.name = "pageup"), (r.shift = !0);
                  break;
                case "[6$":
                  (r.name = "pagedown"), (r.shift = !0);
                  break;
                case "[7$":
                  (r.name = "home"), (r.shift = !0);
                  break;
                case "[8$":
                  (r.name = "end"), (r.shift = !0);
                  break;
                case "Oa":
                  (r.name = "up"), (r.ctrl = !0);
                  break;
                case "Ob":
                  (r.name = "down"), (r.ctrl = !0);
                  break;
                case "Oc":
                  (r.name = "right"), (r.ctrl = !0);
                  break;
                case "Od":
                  (r.name = "left"), (r.ctrl = !0);
                  break;
                case "Oe":
                  (r.name = "clear"), (r.ctrl = !0);
                  break;
                case "[2^":
                  (r.name = "insert"), (r.ctrl = !0);
                  break;
                case "[3^":
                  (r.name = "delete"), (r.ctrl = !0);
                  break;
                case "[5^":
                  (r.name = "pageup"), (r.ctrl = !0);
                  break;
                case "[6^":
                  (r.name = "pagedown"), (r.ctrl = !0);
                  break;
                case "[7^":
                  (r.name = "home"), (r.ctrl = !0);
                  break;
                case "[8^":
                  (r.name = "end"), (r.ctrl = !0);
                  break;
                case "[Z":
                  (r.name = "tab"), (r.shift = !0);
                  break;
                default:
                  r.name = "undefined";
              }
            }
            (r.sequence = n),
              0 === n.length || (void 0 === r.name && !t)
                ? charLengthAt(n, 0) === n.length && e.emit("keypress", n, r)
                : e.emit("keypress", t ? void 0 : n, r);
          }
        },
        kSubstringSearch: p,
        CSI: CSI,
      });
  },
  "internal/repl": function (e, t, r, n, i, o) {
    "use strict";
    const { Number: E, NumberIsNaN: s, NumberParseInt: l, ObjectCreate: _ } = o,
      a = t("repl"),
      { kStandaloneREPL: O } = t("internal/repl/utils");
    (r.exports = _(a)),
      (r.exports.createInternalRepl = function createRepl(e, t, r) {
        "function" == typeof t && ((r = t), (t = null));
        (t = {
          [O]: !0,
          ignoreUndefined: !1,
          useGlobal: !0,
          breakEvalOnSigint: !0,
          ...t,
        }),
          l(e.NODE_NO_READLINE) && (t.terminal = !1);
        e.NODE_REPL_MODE &&
          (t.replMode = {
            strict: a.REPL_MODE_STRICT,
            sloppy: a.REPL_MODE_SLOPPY,
          }[e.NODE_REPL_MODE.toLowerCase().trim()]);
        void 0 === t.replMode && (t.replMode = a.REPL_MODE_SLOPPY);
        const i = E(e.NODE_REPL_HISTORY_SIZE);
        !s(i) && i > 0 ? (t.historySize = i) : (t.historySize = 1e3);
        const o = a.start(t),
          _ = "terminal" in t ? t.terminal : n.stdout.isTTY;
        o.setupHistory(_ ? e.NODE_REPL_HISTORY : "", r);
      });
  },
  "internal/repl/await": function (e, t, n, a, r, o) {
    "use strict";
    const {
        ArrayPrototypeForEach: s,
        ArrayPrototypeIncludes: i,
        ArrayPrototypeJoin: c,
        ArrayPrototypePop: l,
        ArrayPrototypePush: p,
        FunctionPrototype: d,
        ObjectKeys: u,
        RegExpPrototypeSymbolReplace: y,
        StringPrototypeEndsWith: m,
        StringPrototypeIncludes: h,
        StringPrototypeIndexOf: S,
        StringPrototypeRepeat: b,
        StringPrototypeSplit: f,
        StringPrototypeStartsWith: g,
        SyntaxError: w,
      } = o,
      P = t("internal/deps/acorn/acorn/dist/acorn").Parser,
      v = t("internal/deps/acorn/acorn-walk/dist/walk"),
      { Recoverable: x } = t("internal/repl");
    function isTopLevelDeclaration(e) {
      return e.ancestors[e.ancestors.length - 2] === e.body;
    }
    const A = {
        ClassDeclaration(e, t, n) {
          isTopLevelDeclaration(t) &&
            (t.prepend(e, `${e.id.name}=`),
            p(t.hoistedDeclarationStatements, `let ${e.id.name}; `)),
            v.base.ClassDeclaration(e, t, n);
        },
        ForOfStatement(e, t, n) {
          !0 === e.await && (t.containsAwait = !0),
            v.base.ForOfStatement(e, t, n);
        },
        FunctionDeclaration(e, t, n) {
          t.prepend(e, `this.${e.id.name} = ${e.id.name}; `),
            p(t.hoistedDeclarationStatements, `var ${e.id.name}; `);
        },
        FunctionExpression: d,
        ArrowFunctionExpression: d,
        MethodDefinition: d,
        AwaitExpression(e, t, n) {
          (t.containsAwait = !0), v.base.AwaitExpression(e, t, n);
        },
        ReturnStatement(e, t, n) {
          (t.containsReturn = !0), v.base.ReturnStatement(e, t, n);
        },
        VariableDeclaration(e, t, n) {
          const a = e.kind,
            r = i(
              ["ForOfStatement", "ForInStatement"],
              t.ancestors[t.ancestors.length - 2].type
            );
          if ("var" === a || isTopLevelDeclaration(t)) {
            let registerVariableDeclarationIdentifiers = function (e) {
              switch (e.type) {
                case "Identifier":
                  p(n["var" === a ? 0 : 1][1], e.name);
                  break;
                case "ObjectPattern":
                  s(e.properties, (e) => {
                    registerVariableDeclarationIdentifiers(e.value);
                  });
                  break;
                case "ArrayPattern":
                  s(e.elements, (e) => {
                    registerVariableDeclarationIdentifiers(e);
                  });
              }
            };
            t.replace(
              e.start,
              e.start + a.length + (r ? 1 : 0),
              "var" === a && r
                ? ""
                : "void" + (1 === e.declarations.length ? "" : " (")
            ),
              r ||
                (s(e.declarations, (e) => {
                  t.prepend(e, "("), t.append(e, e.init ? ")" : "=undefined)");
                }),
                1 !== e.declarations.length &&
                  t.append(e.declarations[e.declarations.length - 1], ")"));
            const n = [
              ["var", []],
              ["let", []],
            ];
            s(e.declarations, (e) => {
              registerVariableDeclarationIdentifiers(e.id);
            }),
              s(n, ({ 0: e, 1: n }) => {
                n.length > 0 &&
                  p(t.hoistedDeclarationStatements, `${e} ${c(n, ", ")}; `);
              });
          }
          v.base.VariableDeclaration(e, t, n);
        },
      },
      D = {};
    for (const e of u(v.base)) {
      const t = A[e] || v.base[e];
      D[e] = (e, n, a) => {
        const r = e !== n.ancestors[n.ancestors.length - 1];
        r && p(n.ancestors, e), t(e, n, a), r && l(n.ancestors);
      };
    }
    n.exports = {
      processTopLevelAwait: function processTopLevelAwait(e) {
        const t = "(async () => { ",
          n = `${t}${e} })()`,
          a = f(n, "");
        let r;
        try {
          r = P.parse(n, { ecmaVersion: "latest" });
        } catch (t) {
          if (g(t.message, "Unterminated ")) throw new x(t);
          const n = S(e, "await"),
            a = t.pos - 15;
          if (n > a) return null;
          if (a === n + 6 && h(t.message, "Expecting Unicode escape sequence"))
            return null;
          if (a === n + 7 && h(t.message, "Unexpected token")) return null;
          const r = t.loc.line,
            o = 1 === r ? t.loc.column - 15 : t.loc.column;
          let s =
            "\n" +
            f(e, "\n")[r - 1] +
            "\n" +
            b(" ", o) +
            "^\n\n" +
            y(/ \([^)]+\)/, t.message, "");
          throw (
            (m(s, "Unexpected token") &&
              (s += " '" + (e[t.pos - 15] ?? e[e.length - 1]) + "'"),
            new w(s))
          );
        }
        const o = r.body[0].expression.callee.body,
          s = {
            body: o,
            ancestors: [],
            hoistedDeclarationStatements: [],
            replace(e, t, n) {
              for (let n = e; n < t; n++) a[n] = "";
              e === t && (n += a[e]), (a[e] = n);
            },
            prepend(e, t) {
              a[e.start] = t + a[e.start];
            },
            append(e, t) {
              a[e.end - 1] += t;
            },
            containsAwait: !1,
            containsReturn: !1,
          };
        if ((v.recursive(o, s, D), !s.containsAwait || s.containsReturn))
          return null;
        for (let e = o.body.length - 1; e >= 0; e--) {
          const t = o.body[e];
          if ("EmptyStatement" !== t.type) {
            "ExpressionStatement" === t.type &&
              (s.prepend(t.expression, "{ value: ("),
              s.prepend(t, "return "),
              s.append(t.expression, ") }"));
            break;
          }
        }
        return c(s.hoistedDeclarationStatements, "") + c(a, "");
      },
    };
  },
  "internal/repl/history": function (t, e, n, o, i, r) {
    "use strict";
    const {
        ArrayPrototypeJoin: s,
        Boolean: l,
        FunctionPrototype: u,
        RegExpPrototypeSymbolSplit: h,
        StringPrototypeTrim: f,
      } = r,
      { Interface: y } = e("readline"),
      a = e("path"),
      c = e("fs"),
      p = e("os");
    let _ = e("internal/util/debuglog").debuglog("repl", (t) => {
      _ = t;
    });
    const { clearTimeout: d, setTimeout: g } = e("timers"),
      H = u;
    function _writeToOutput(t, e) {
      t._writeToOutput(e), t._refreshLine();
    }
    function _replHistoryMessage() {
      return (
        0 === this.history.length &&
          _writeToOutput(
            this,
            "\nPersistent history support disabled. Set the NODE_REPL_HISTORY environment\nvariable to a valid, user-writable path to enable.\n"
          ),
        (this._historyPrev = y.prototype._historyPrev),
        this._historyPrev()
      );
    }
    n.exports = function setupHistory(t, e, n) {
      "string" == typeof e && (e = f(e));
      if ("" === e) return (t._historyPrev = _replHistoryMessage), n(null, t);
      if (!e)
        try {
          e = a.join(p.homedir(), ".node_repl_history");
        } catch (e) {
          return (
            _writeToOutput(
              t,
              "\nError: Could not get the home directory.\nREPL session history will not be persisted.\n"
            ),
            _(e.stack),
            (t._historyPrev = _replHistoryMessage),
            n(null, t)
          );
        }
      let o = null,
        i = !1,
        r = !1;
      function onclose(t) {
        if (t) return n(t);
        c.readFile(e, "utf8", onread);
      }
      function onread(o, i) {
        if (o) return n(o);
        (t.history = i ? h(/[\n\r]+/, i, t.historySize) : []),
          c.open(e, "r+", onhandle);
      }
      function onhandle(e, o) {
        if (e) return n(e);
        c.ftruncate(o, 0, (e) => {
          (t._historyHandle = o),
            t.on("line", online),
            t.once("exit", onexit),
            t.once("flushHistory", function () {
              t.resume(), n(null, t);
            }),
            flushHistory();
        });
      }
      function online(e) {
        (t._flushing = !0), o && d(o), (o = g(flushHistory, 15));
      }
      function flushHistory() {
        if (((o = null), i)) return void (r = !0);
        i = !0;
        const e = s(t.history, p.EOL);
        c.write(t._historyHandle, e, 0, "utf8", onwritten);
      }
      function onwritten(e, n) {
        (i = !1),
          r
            ? ((r = !1), online())
            : ((t._flushing = l(o)), t._flushing || t.emit("flushHistory"));
      }
      function onexit() {
        t._flushing
          ? t.once("flushHistory", onexit)
          : (t.off("line", online), c.close(t._historyHandle, H));
      }
      t.pause(),
        c.open(e, "a+", 384, function oninit(e, o) {
          if (e)
            return (
              _writeToOutput(
                t,
                "\nError: Could not open history file.\nREPL session history will not be persisted.\n"
              ),
              _(e.stack),
              (t._historyPrev = _replHistoryMessage),
              t.resume(),
              n(null, t)
            );
          c.close(o, onclose);
        });
    };
  },
  "internal/repl/utils": function (e, t, r, n, o, s) {
    "use strict";
    const {
        ArrayPrototypeFilter: i,
        ArrayPrototypeIncludes: c,
        ArrayPrototypeMap: l,
        Boolean: a,
        FunctionPrototypeBind: u,
        MathMin: p,
        RegExpPrototypeExec: h,
        SafeSet: y,
        SafeStringIterator: g,
        StringPrototypeEndsWith: d,
        StringPrototypeIndexOf: P,
        StringPrototypeLastIndexOf: S,
        StringPrototypeReplaceAll: f,
        StringPrototypeSlice: m,
        StringPrototypeStartsWith: w,
        StringPrototypeToLowerCase: $,
        StringPrototypeTrim: x,
        Symbol: _,
      } = s,
      { tokTypes: v, Parser: E } = t("internal/deps/acorn/acorn/dist/acorn"),
      { sendInspectorCommand: R } = t("internal/util/inspector"),
      { ERR_INSPECTOR_NOT_AVAILABLE: I } = t("internal/errors").codes,
      {
        clearLine: T,
        clearScreenDown: k,
        cursorTo: b,
        moveCursor: D,
      } = t("internal/readline/callbacks"),
      { commonPrefix: A, kSubstringSearch: L } = t("internal/readline/utils"),
      { getStringWidth: C, inspect: O } = t("internal/util/inspect");
    let M = t("internal/util/debuglog").debuglog("repl", (e) => {
      M = e;
    });
    const N = _("repl-strict");
    r.exports = {
      REPL_MODE_SLOPPY: _("repl-sloppy"),
      REPL_MODE_STRICT: N,
      isRecoverableError: function isRecoverableError(e, t) {
        if (null !== h(/^\s*\{/, t) && isRecoverableError(e, `(${t}`))
          return !0;
        let r = !1;
        const n = E.extend(
          (e) =>
            class extends e {
              constructor(e, t, r) {
                super(e, t, r);
              }
              nextToken() {
                super.nextToken(), this.type === v.eof && (r = !0);
              }
              raise(e, t) {
                switch (t) {
                  case "Unterminated template":
                  case "Unterminated comment":
                    r = !0;
                    break;
                  case "Unterminated string constant": {
                    const e = m(this.input, this.lastTokStart, this.pos);
                    null !== h(/\\(?:\r\n?|\n|\u2028|\u2029)$/, e) && (r = !0);
                  }
                }
                super.raise(e, t);
              }
            }
        );
        try {
          return n.parse(t, { ecmaVersion: "latest" }), !1;
        } catch {
          return r;
        }
      },
      kStandaloneREPL: _("kStandaloneREPL"),
      setupPreview: function setupPreview(e, t, r, n) {
        return { showPreview() {}, clearPreview() {} };
      },
      setupReverseSearch: function setupReverseSearch(e) {
        if ("dumb" === n.env.TERM) return { reverseSearch: () => !1 };
        const t = new y(),
          r = { r: "bck-i-search: ", s: "fwd-i-search: " };
        let o,
          s = !1,
          i = -1,
          c = "",
          l = -1,
          a = "r",
          u = -1,
          p = -1;
        function checkAndSetDirectionKey(e) {
          return !!r[e] && (a !== e && (t.clear(), (a = e)), !0);
        }
        function goToNextHistoryIndex() {
          t.add(e.history[i]), (i += "r" === a ? 1 : -1), (l = -1);
        }
        function search() {
          if ("" !== c) {
            for (
              "r" === a
                ? i < 0 && (i = 0)
                : i >= e.history.length && (i = e.history.length - 1);
              i >= 0 && i < e.history.length;

            ) {
              let n = e.history[i];
              if (t.has(n)) i += "r" === a ? 1 : -1;
              else {
                if (
                  ("r" === a
                    ? (-1 === l && (l = n.length), (l = S(n, c, l - 1)))
                    : (l = P(n, c, l + 1)),
                  -1 !== l)
                ) {
                  if (e.useColors) {
                    const e = m(n, 0, l),
                      t = m(n, l + c.length);
                    n = `${e}[4m${c}[24m${t}`;
                  }
                  return (
                    print(n, `${r[a]}${c}_`, l),
                    (u = i),
                    (p = l),
                    void (
                      (("r" === a && 0 === l) ||
                        ("s" === a && n.length === l + c.length)) &&
                      goToNextHistoryIndex()
                    )
                  );
                }
                goToNextHistoryIndex();
              }
            }
            print(e.line, `failed-${r[a]}${c}_`);
          } else print(e.line, `${r[a]}_`);
        }
        function print(t, r, n = e.cursor) {
          let i = 0;
          if (-1 !== u) {
            const t = m(e.history[u], 0, p);
            (i = e._getDisplayPos(`${e.getPrompt()}${t}`).rows),
              b(e.output, o.cols);
          } else
            s &&
              "" !== e.line &&
              ((i = e.getCursorPos().rows), b(e.output, o.cols));
          0 !== i && D(e.output, 0, -i),
            s
              ? (k(e.output), e.output.write(`${t}\n${r}`))
              : e.output.write(`\n${r}`),
            (u = -1);
          const c = e.getPrompt(),
            l = c + m(t, 0, n),
            a = e._getDisplayPos(l),
            h = e._getDisplayPos(`${c}${t}`),
            y = e._getDisplayPos(r);
          (i = -1 - (y.rows - (0 === y.cols ? 1 : 0)) - (h.rows - a.rows)),
            D(e.output, 0, i),
            b(e.output, a.cols);
        }
        function reset(r) {
          if (
            ((s = void 0 !== r),
            !s &&
              (-1 !== u &&
                ((e.line = e.history[u]), (e.cursor = p), (e.historyIndex = u)),
              (u = -1),
              b(e.output, o.cols),
              D(e.output, 0, o.rows),
              k(e.output),
              "" !== e.line &&
                (e.output.write(e.line), e.line.length !== e.cursor)))
          ) {
            const { cols: t, rows: r } = e.getCursorPos();
            b(e.output, t), D(e.output, 0, r);
          }
          (c = r || ""), (l = -1), (i = e.historyIndex), t.clear();
        }
        return {
          reverseSearch: function reverseSearch(t, n) {
            if (s)
              if (n.ctrl && checkAndSetDirectionKey(n.name)) search();
              else if (
                "backspace" === n.name ||
                (n.ctrl && ("h" === n.name || "w" === n.name))
              )
                reset(m(c, 0, c.length - 1)), search();
              else {
                if ((n.ctrl && "c" === n.name) || "escape" === n.name)
                  return (u = -1), reset(), !0;
                n.ctrl ||
                n.meta ||
                "return" === n.name ||
                "enter" === n.name ||
                "string" != typeof t ||
                "" === t
                  ? (reset(), (e[L] = ""))
                  : (reset(`${c}${t}`), search());
              }
            else
              n.ctrl &&
                checkAndSetDirectionKey(n.name) &&
                ((i = e.historyIndex),
                (o = e._getDisplayPos(`${e.getPrompt()}`)),
                print(e.line, `${r[a]}_`),
                (s = !0));
            return s;
          },
        };
      },
    };
  },
  "internal/socket_list": function (e, t, n, s, i, c) {
    "use strict";
    const { ERR_CHILD_CLOSED_BEFORE_REPLY: o } = t("internal/errors").codes,
      h = t("events");
    n.exports = {
      SocketListSend: class SocketListSend extends h {
        constructor(e, t) {
          super(),
            (this.key = t),
            (this.child = e),
            e.once("exit", () => this.emit("exit", this));
        }
        _request(e, t, n, s) {
          const i = this;
          if (!this.child.connected) return onclose();
          function onclose() {
            i.child.removeListener("internalMessage", onreply), s(new o());
          }
          function onreply(e) {
            e.cmd === t &&
              e.key === i.key &&
              (i.child.removeListener("disconnect", onclose),
              i.child.removeListener("internalMessage", onreply),
              s(null, e));
          }
          this.child._send(e, void 0, n),
            this.child.once("disconnect", onclose),
            this.child.on("internalMessage", onreply);
        }
        close(e) {
          this._request(
            { cmd: "NODE_SOCKET_NOTIFY_CLOSE", key: this.key },
            "NODE_SOCKET_ALL_CLOSED",
            !0,
            e
          );
        }
        getConnections(e) {
          this._request(
            { cmd: "NODE_SOCKET_GET_COUNT", key: this.key },
            "NODE_SOCKET_COUNT",
            !1,
            (t, n) => {
              if (t) return e(t);
              e(null, n.count);
            }
          );
        }
      },
      SocketListReceive: class SocketListReceive extends h {
        constructor(e, t) {
          function onempty(e) {
            e.child.connected &&
              e.child._send(
                { cmd: "NODE_SOCKET_ALL_CLOSED", key: e.key },
                void 0,
                !0
              );
          }
          super(),
            (this.connections = 0),
            (this.key = t),
            (this.child = e),
            this.child.on("internalMessage", (e) => {
              if (e.key === this.key)
                if ("NODE_SOCKET_NOTIFY_CLOSE" === e.cmd) {
                  if (0 === this.connections) return onempty(this);
                  this.once("empty", onempty);
                } else if ("NODE_SOCKET_GET_COUNT" === e.cmd) {
                  if (!this.child.connected) return;
                  this.child._send({
                    cmd: "NODE_SOCKET_COUNT",
                    key: this.key,
                    count: this.connections,
                  });
                }
            });
        }
        add(e) {
          this.connections++,
            e.socket.once("close", () => {
              this.connections--,
                0 === this.connections && this.emit("empty", this);
            });
        }
      },
    };
  },
  "internal/socketaddress": function (t, e, s, o, r, i) {
    "use strict";
    const { ObjectSetPrototypeOf: d, Symbol: l } = i,
      { SocketAddress: a, AF_INET: n, AF_INET6: c } = r("block_list"),
      {
        validateObject: p,
        validateString: f,
        validatePort: h,
        validateUint32: k,
      } = e("internal/validators"),
      {
        codes: { ERR_INVALID_ARG_VALUE: u },
      } = e("internal/errors"),
      { customInspectSymbol: v, kEmptyObject: S } = e("internal/util"),
      { inspect: b } = e("internal/util/inspect"),
      {
        JSTransferable: y,
        kClone: A,
        kDeserialize: w,
      } = e("internal/worker/js_transferable"),
      m = l("kHandle"),
      I = l("kDetail");
    class SocketAddress extends y {
      static isSocketAddress(t) {
        return void 0 !== t?.[m];
      }
      constructor(t = S) {
        super(), p(t, "options");
        let { family: e = "ipv4" } = t;
        const {
          address: s = "ipv4" === e ? "127.0.0.1" : "::",
          port: o = 0,
          flowlabel: r = 0,
        } = t;
        let i;
        switch (
          ("function" == typeof e?.toLowerCase && (e = e.toLowerCase()), e)
        ) {
          case "ipv4":
            i = n;
            break;
          case "ipv6":
            i = c;
            break;
          default:
            throw new u("options.family", t.family);
        }
        f(s, "options.address"),
          h(o, "options.port"),
          k(r, "options.flowlabel", !1),
          (this[m] = new a(s, o, i, r)),
          (this[I] = this[m].detail({
            address: void 0,
            port: void 0,
            family: void 0,
            flowlabel: void 0,
          }));
      }
      get address() {
        return this[I].address;
      }
      get port() {
        return this[I].port;
      }
      get family() {
        return this[I].family === n ? "ipv4" : "ipv6";
      }
      get flowlabel() {
        return this[m].flowlabel();
      }
      [v](t, e) {
        if (t < 0) return this;
        const s = { ...e, depth: null == e.depth ? null : e.depth - 1 };
        return `SocketAddress ${b(this.toJSON(), s)}`;
      }
      [A]() {
        return {
          data: { handle: this[m] },
          deserializeInfo: "internal/socketaddress:InternalSocketAddress",
        };
      }
      [w]({ handle: t }) {
        (this[m] = t),
          (this[I] = t.detail({
            address: void 0,
            port: void 0,
            family: void 0,
            flowlabel: void 0,
          }));
      }
      toJSON() {
        return {
          address: this.address,
          port: this.port,
          family: this.family,
          flowlabel: this.flowlabel,
        };
      }
    }
    class InternalSocketAddress extends y {
      constructor(t) {
        super(),
          (this[m] = t),
          (this[I] = this[m]?.detail({
            address: void 0,
            port: void 0,
            family: void 0,
            flowlabel: void 0,
          }));
      }
    }
    (InternalSocketAddress.prototype.constructor =
      SocketAddress.prototype.constructor),
      d(InternalSocketAddress.prototype, SocketAddress.prototype),
      (s.exports = {
        SocketAddress: SocketAddress,
        InternalSocketAddress: InternalSocketAddress,
        kHandle: m,
      });
  },
  "internal/source_map/prepare_stack_trace": function (e, r, t, n, o, i) {
    "use strict";
    const {
      ArrayPrototypeIndexOf: a,
      ArrayPrototypeJoin: c,
      ArrayPrototypeMap: u,
      ErrorPrototypeToString: l,
      RegExpPrototypeSymbolSplit: s,
      StringPrototypeRepeat: g,
      StringPrototypeSlice: f,
      StringPrototypeStartsWith: m,
      SafeStringIterator: p,
    } = i;
    let y = r("internal/util/debuglog").debuglog("source_map", (e) => {
      y = e;
    });
    const { getStringWidth: S } = r("internal/util/inspect"),
      { readFileSync: $ } = r("fs"),
      { findSourceMap: d } = r("internal/source_map/source_map_cache"),
      {
        kNoOverride: N,
        overrideStackTrace: E,
        maybeOverridePrepareStackTrace: b,
        kIsNodeError: P,
      } = r("internal/errors"),
      { fileURLToPath: h } = r("internal/url"),
      { setGetSourceMapErrorSource: v } = o("errors");
    function getErrorSource(e, r, t, n) {
      const o = m(r, "file://") ? h(r) : r,
        i = (function getOriginalSource(e, r) {
          let t;
          const n = a(e.sources, r);
          if (e.sourcesContent?.[n]) t = e.sourcesContent[n];
          else if (m(r, "file://")) {
            y(`read source of ${r} from filesystem`);
            const e = h(r);
            try {
              t = $(e, "utf8");
            } catch (e) {
              y(e);
            }
          }
          return t;
        })(e.payload, r);
      if ("string" != typeof i) return;
      const c = s(/\r?\n/, i, t + 1)[t];
      if (!c) return;
      let u = "";
      for (const e of new p(f(c, 0, n + 1)))
        u += "\t" === e ? "\t" : g(" ", S(e));
      u = f(u, 0, -1);
      return `${o}:${t + 1}\n${c}\n${u}^\n\n`;
    }
    v(function getSourceMapErrorSource(e, r, t) {
      const n = d(e);
      if (void 0 === n) return;
      const {
        originalLine: o,
        originalColumn: i,
        originalSource: a,
      } = n.findEntry(r - 1, t);
      return getErrorSource(n, a, o, i);
    }),
      (t.exports = {
        prepareStackTrace: (e, r, t) => {
          if (E.has(r)) {
            const e = E.get(r);
            return E.delete(r), e(r, t);
          }
          const n = b(e, r, t);
          if (n !== N) return n;
          let o, i, a;
          if (
            ((o = P in r ? `${r.name} [${r.code}]: ${r.message}` : l(r)),
            0 === t.length)
          )
            return o;
          const s = c(
            u(t, (e, r) => {
              const n = 0 !== r ? "\n    at " : "";
              try {
                let o = e.getFileName();
                void 0 === o && (o = e.getEvalOrigin());
                const c = o === a ? i : d(o);
                if (((i = c), (a = o), c)) {
                  const {
                    originalLine: o,
                    originalColumn: i,
                    originalSource: a,
                  } = c.findEntry(
                    e.getLineNumber() - 1,
                    e.getColumnNumber() - 1
                  );
                  if (a && void 0 !== o && void 0 !== i) {
                    const u = (function getOriginalSymbolName(e, r, t) {
                        const n = e.findEntry(
                          r[t].getEnclosingLineNumber() - 1,
                          r[t].getEnclosingColumnNumber() - 1
                        );
                        if (n.name) return n.name;
                        const o = r[t].getFileName(),
                          i = r[t + 1];
                        if (i && o === i.getFileName()) {
                          const { name: r } = e.findEntry(
                            i.getLineNumber() - 1,
                            i.getColumnNumber() - 1
                          );
                          return r;
                        }
                      })(c, t, r),
                      l = e.getFunctionName() ?? e.getMethodName(),
                      s = e.getTypeName(),
                      g = `${null !== s && "global" !== s ? `${s}.` : ""}${
                        l || "<anonymous>"
                      }`,
                      f = u && u !== g ? `${u}` : `${g}`,
                      p = !(!u && !g);
                    return `${n}${f}${p ? " (" : ""}${
                      m(a, "file://") ? h(a) : a
                    }:${o + 1}:${i + 1}${p ? ")" : ""}`;
                  }
                }
              } catch (e) {
                y(e);
              }
              return `${n}${e}`;
            }),
            ""
          );
          return `${o}\n    at ${s}`;
        },
      });
  },
  "internal/source_map/source_map": function (e, t, n, o, r, i) {
    "use strict";
    const {
        ArrayIsArray: s,
        ArrayPrototypePush: a,
        ArrayPrototypeSlice: p,
        ArrayPrototypeSort: c,
        ObjectPrototypeHasOwnProperty: l,
        StringPrototypeCharAt: u,
      } = i,
      { validateObject: d } = t("internal/validators");
    let g;
    class StringCharIterator {
      constructor(e) {
        (this._string = e), (this._position = 0);
      }
      next() {
        return u(this._string, this._position++);
      }
      peek() {
        return u(this._string, this._position);
      }
      hasNext() {
        return this._position < this._string.length;
      }
    }
    function isSeparator(e) {
      return "," === e || ";" === e;
    }
    function decodeVLQ(e) {
      let t,
        n = 0,
        o = 0;
      do {
        (t = g[e.next()]), (n += (31 & t) << o), (o += 5);
      } while (32 & t);
      const r = 1 & n;
      return (n >>>= 1), r ? -n | (1 << 31) : n;
    }
    function cloneSourceMapV3(e) {
      d(e, "payload"), (e = { ...e });
      for (const t in e) l(e, t) && s(e[t]) && (e[t] = p(e[t]));
      return e;
    }
    function compareSourceMapEntry(e, t) {
      const { 0: n, 1: o } = e,
        { 0: r, 1: i } = t;
      return n !== r ? n - r : o - i;
    }
    n.exports = {
      SourceMap: class SourceMap {
        #e;
        #t = [];
        #n = {};
        #o = {};
        constructor(e) {
          if (!g) {
            const e =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            g = {};
            for (let t = 0; t < e.length; ++t) g[e[t]] = t;
          }
          (this.#e = cloneSourceMapV3(e)), this.#r();
        }
        get payload() {
          return cloneSourceMapV3(this.#e);
        }
        #r = () => {
          this.#e.sections ? this.#i(this.#e.sections) : this.#s(this.#e, 0, 0),
            c(this.#t, compareSourceMapEntry);
        };
        #i = (e) => {
          for (let t = 0; t < e.length; ++t) {
            const n = e[t];
            this.#s(n.map, n.offset.line, n.offset.column);
          }
        };
        findEntry(e, t) {
          let n = 0,
            o = this.#t.length;
          for (; o > 1; ) {
            const r = o >> 1,
              i = n + r,
              s = this.#t[i];
            e < s[0] || (e === s[0] && t < s[1])
              ? (o = r)
              : ((n = i), (o -= r));
          }
          const r = this.#t[n];
          return !n && r && (e < r[0] || (e === r[0] && t < r[1]))
            ? {}
            : r
            ? {
                generatedLine: r[0],
                generatedColumn: r[1],
                originalSource: r[2],
                originalLine: r[3],
                originalColumn: r[4],
                name: r[5],
              }
            : {};
        }
        findOrigin(e, t) {
          const n = this.findEntry(e - 1, t - 1);
          if (
            void 0 === n.originalSource ||
            void 0 === n.originalLine ||
            void 0 === n.originalColumn ||
            void 0 === n.generatedLine ||
            void 0 === n.generatedColumn
          )
            return {};
          const o = e - n.generatedLine,
            r = t - n.generatedColumn;
          return {
            name: n.name,
            fileName: n.originalSource,
            lineNumber: n.originalLine + o,
            columnNumber: n.originalColumn + r,
          };
        }
        #s(e, t, n) {
          let o = 0,
            r = 0,
            i = 0,
            s = 0;
          const p = [],
            c = {};
          for (let t = 0; t < e.sources.length; ++t) {
            const n = e.sources[t];
            (c[n] = n),
              a(p, n),
              (this.#n[n] = !0),
              e.sourcesContent &&
                e.sourcesContent[t] &&
                (this.#o[n] = e.sourcesContent[t]);
          }
          const l = new StringCharIterator(e.mappings);
          let u = p[o];
          for (;;) {
            if ("," === l.peek()) l.next();
            else {
              for (; ";" === l.peek(); ) (t += 1), (n = 0), l.next();
              if (!l.hasNext()) break;
            }
            if (((n += decodeVLQ(l)), isSeparator(l.peek()))) {
              a(this.#t, [t, n]);
              continue;
            }
            const c = decodeVLQ(l);
            let d;
            c && ((o += c), (u = p[o])),
              (r += decodeVLQ(l)),
              (i += decodeVLQ(l)),
              isSeparator(l.peek()) ||
                ((s += decodeVLQ(l)), (d = e.names?.[s])),
              a(this.#t, [t, n, u, r, i, d]);
          }
        }
      },
    };
  },
  "internal/source_map/source_map_cache": function (e, t, r, n, a, o) {
    "use strict";
    const {
      ArrayPrototypeMap: c,
      JSONParse: u,
      ObjectCreate: l,
      ObjectKeys: s,
      ObjectGetOwnPropertyDescriptor: i,
      ObjectPrototypeHasOwnProperty: p,
      RegExpPrototypeExec: f,
      RegExpPrototypeSymbolSplit: S,
      SafeMap: b,
      StringPrototypeSplit: g,
    } = o;
    function ObjectGetValueSafe(e, t) {
      const r = i(e, t);
      return p(r, "value") ? r.value : void 0;
    }
    const { Buffer: d } = t("buffer");
    let h = t("internal/util/debuglog").debuglog("source_map", (e) => {
      h = e;
    });
    const { validateBoolean: M } = t("internal/validators"),
      { setSourceMapsEnabled: m, setPrepareStackTraceCallback: L } =
        a("errors"),
      { getLazy: y } = t("internal/util"),
      R = y(() => {
        const { IterableWeakMap: e } = t("internal/util/iterable_weak_map");
        return new e();
      }),
      O = new b(),
      U = new b(),
      C = /^\w+:\/\//,
      E = /\/[*/]#\s+sourceMappingURL=(?<sourceMappingURL>[^\s]+)/g,
      j = /\/[*/]#\s+sourceURL=(?<sourceURL>[^\s]+)/g,
      { fileURLToPath: _, pathToFileURL: v, URL: w } = t("internal/url");
    let G,
      V = !1;
    function getSourceMapsEnabled() {
      return V;
    }
    function extractSourceURLMagicComment(e) {
      let t, r;
      for (; (t = f(j, e)); ) r = t;
      if (null == r) return null;
      let n = r.groups.sourceURL;
      return null != n && null === f(C, n) && (n = v(n).href), n;
    }
    function maybeCacheSourceMap(e, r, a, o, c, l) {
      const s = getSourceMapsEnabled();
      if (!n.env.NODE_V8_COVERAGE && !s) return;
      try {
        const { normalizeReferrerURL: r } = t("internal/modules/helpers");
        e = r(e);
      } catch (e) {
        return void h(e);
      }
      if (
        (void 0 === l &&
          (l = (function extractSourceMapURLMagicComment(e) {
            let t, r;
            for (; (t = f(E, e)); ) r = t;
            return null == r ? null : r.groups.sourceMappingURL;
          })(r)),
        "string" != typeof l)
      )
        return;
      void 0 === c && (c = extractSourceURLMagicComment(r));
      const i = (function dataFromUrl(e, r) {
          try {
            const t = new w(r);
            return "data:" === t.protocol
              ? (function sourceMapFromDataUrl(e, t) {
                  const { 0: r, 1: n } = g(t, ","),
                    a = g(r, ";"),
                    o = a[0],
                    c = "base64" === a[a.length - 1];
                  if ("application/json" !== o)
                    return h(`unknown content-type ${o}`), null;
                  {
                    const t = c ? d.from(n, "base64").toString("utf8") : n;
                    try {
                      return sourcesToAbsolute(e, u(t));
                    } catch (e) {
                      return h(e), null;
                    }
                  }
                })(e, t.pathname)
              : (h(`unknown protocol ${t.protocol}`), null);
          } catch (n) {
            h(n);
            return (function sourceMapFromFile(e) {
              try {
                const r = t("fs").readFileSync(_(e), "utf8");
                return sourcesToAbsolute(e, u(r));
              } catch (e) {
                return h(e), null;
              }
            })(new w(r, e).href);
          }
        })(e, l),
        p = i ? null : l;
      if (a)
        R().set(a, {
          filename: e,
          lineLengths: lineLengths(r),
          data: i,
          url: p,
          sourceURL: c,
        });
      else if (o) {
        const t = {
          lineLengths: lineLengths(r),
          data: i,
          url: p,
          sourceURL: c,
        };
        U.set(e, t), c && U.set(c, t);
      } else {
        const t = {
          lineLengths: lineLengths(r),
          data: i,
          url: p,
          sourceURL: c,
        };
        O.set(e, t), c && O.set(c, t);
      }
    }
    function lineLengths(e) {
      return c(S(/\n|\u2028|\u2029/, e), (e) => e.length);
    }
    function sourcesToAbsolute(e, t) {
      return (
        (t.sources = t.sources.map(
          (r) => ((r = (t.sourceRoot || "") + r), new w(r, e).href)
        )),
        (t.sourceRoot = ""),
        t
      );
    }
    r.exports = {
      findSourceMap: function findSourceMap(e) {
        null === f(C, e) && (e = v(e).href),
          G || (G = t("internal/source_map/source_map").SourceMap);
        let r = O.get(e) ?? U.get(e);
        if (void 0 === r)
          for (const t of R()) {
            const n = ObjectGetValueSafe(t, "filename"),
              a = ObjectGetValueSafe(t, "sourceURL");
            (e !== n && e !== a) ||
              (r = { data: ObjectGetValueSafe(t, "data") });
          }
        if (r && r.data) return new G(r.data);
      },
      getSourceMapsEnabled: getSourceMapsEnabled,
      setSourceMapsEnabled: function setSourceMapsEnabled(e) {
        if ((M(e, "val"), m(e), e)) {
          const { prepareStackTrace: e } = t(
            "internal/source_map/prepare_stack_trace"
          );
          L(e);
        } else if (void 0 !== V) {
          const { prepareStackTrace: e } = t("internal/errors");
          L(e);
        }
        V = e;
      },
      maybeCacheSourceMap: maybeCacheSourceMap,
      maybeCacheGeneratedSourceMap: function maybeCacheGeneratedSourceMap(e) {
        const t = getSourceMapsEnabled();
        if (!n.env.NODE_V8_COVERAGE && !t) return;
        const r = extractSourceURLMagicComment(e);
        if (null !== r)
          try {
            maybeCacheSourceMap(r, e, null, !0, r);
          } catch (e) {
            h(e);
          }
      },
      sourceMapCacheToObject: function sourceMapCacheToObject() {
        const e = l(null);
        for (const { 0: t, 1: r } of O) e[t] = r;
        if (
          ((function appendCJSCache(e) {
            for (const t of R())
              e[ObjectGetValueSafe(t, "filename")] = {
                lineLengths: ObjectGetValueSafe(t, "lineLengths"),
                data: ObjectGetValueSafe(t, "data"),
                url: ObjectGetValueSafe(t, "url"),
              };
          })(e),
          0 !== s(e).length)
        )
          return e;
      },
    };
  },
  "internal/stream_base_commons": function (e, t, r, n, i, s) {
    "use strict";
    const { Array: a, Symbol: c } = s,
      { Buffer: o } = t("buffer"),
      { FastBuffer: l } = t("internal/buffer"),
      {
        WriteWrap: f,
        kReadBytesOrError: u,
        kArrayBufferOffset: d,
        kBytesWritten: h,
        kLastWriteWasAsync: k,
        streamBaseState: y,
      } = i("stream_wrap"),
      { UV_EOF: m } = i("uv"),
      { errnoException: b } = t("internal/errors"),
      { owner_symbol: p } = t("internal/async_hooks").symbols,
      {
        kTimeout: W,
        setUnrefTimeout: w,
        getTimerDuration: B,
      } = t("internal/timers"),
      { isUint8Array: g } = t("internal/util/types"),
      { clearTimeout: S } = t("timers"),
      { validateFunction: _ } = t("internal/validators"),
      v = c("kMaybeDestroy"),
      A = c("kUpdateTimer"),
      T = c("kAfterAsyncWrite"),
      D = c("kHandle"),
      U = c("kSession");
    let G = t("internal/util/debuglog").debuglog("stream", (e) => {
      G = e;
    });
    const C = c("kBuffer"),
      E = c("kBufferGen"),
      F = c("kBufferCb");
    function onWriteComplete(e) {
      G("onWriteComplete", e, this.error);
      const t = this.handle[p];
      if (t.destroyed)
        "function" == typeof this.callback && this.callback(null);
      else if (e < 0) {
        const r = b(e, "write", this.error);
        "function" == typeof this.callback ? this.callback(r) : t.destroy(r);
      } else
        t[A](),
          t[T](this),
          "function" == typeof this.callback && this.callback(null);
    }
    function createWriteWrap(e, t) {
      const r = new f();
      return (
        (r.handle = e),
        (r.oncomplete = onWriteComplete),
        (r.async = !1),
        (r.bytes = 0),
        (r.buffer = null),
        (r.callback = t),
        r
      );
    }
    function afterWriteDispatched(e, t, r) {
      if (((e.bytes = y[h]), (e.async = !!y[k]), 0 !== t))
        return r(b(t, "write", e.error));
      e.async || "function" != typeof e.callback || e.callback();
    }
    r.exports = {
      writevGeneric: function writevGeneric(e, t, r) {
        const n = createWriteWrap(e[D], r),
          i = t.allBuffers;
        let s;
        if (i) {
          s = t;
          for (let e = 0; e < t.length; e++) t[e] = t[e].chunk;
        } else {
          s = new a(t.length << 1);
          for (let e = 0; e < t.length; e++) {
            const r = t[e];
            (s[2 * e] = r.chunk), (s[2 * e + 1] = r.encoding);
          }
        }
        const c = n.handle.writev(n, s, i);
        return 0 === c && (n._chunks = s), afterWriteDispatched(n, c, r), n;
      },
      writeGeneric: function writeGeneric(e, t, r, n) {
        const i = createWriteWrap(e[D], n),
          s = (function handleWriteReq(e, t, r) {
            const { handle: n } = e;
            switch (r) {
              case "buffer": {
                const r = n.writeBuffer(e, t);
                return y[k] && (e.buffer = t), r;
              }
              case "latin1":
              case "binary":
                return n.writeLatin1String(e, t);
              case "utf8":
              case "utf-8":
                return n.writeUtf8String(e, t);
              case "ascii":
                return n.writeAsciiString(e, t);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return n.writeUcs2String(e, t);
              default: {
                const i = o.from(t, r),
                  s = n.writeBuffer(e, i);
                return y[k] && (e.buffer = i), s;
              }
            }
          })(i, t, r);
        return afterWriteDispatched(i, s, n), i;
      },
      onStreamRead: function onStreamRead(e) {
        const t = y[u],
          r = this,
          n = this[p];
        if ((n[A](), t > 0 && !n.destroyed)) {
          let i, s;
          const a = n[C];
          if (a) {
            s = !1 !== n[F](t, a);
            const e = n[E];
            if (null !== e) {
              const t = e();
              g(t) && (n[C] = i = t);
            }
          } else {
            const r = y[d],
              i = new l(e, r, t);
            s = n.push(i);
          }
          if (!s && ((r.reading = !1), !n.destroyed)) {
            const e = r.readStop();
            e && n.destroy(b(e, "read"));
          }
          return i;
        }
        0 !== t &&
          (t === m
            ? n._readableState.endEmitted
              ? n[v] && n[v]()
              : (n[v] && n.on("end", n[v]), n.push(null), n.read(0))
            : n.destroy(b(t, "read")));
      },
      kAfterAsyncWrite: T,
      kMaybeDestroy: v,
      kUpdateTimer: A,
      kHandle: D,
      kSession: U,
      setStreamTimeout: function setStreamTimeout(e, t) {
        return (
          this.destroyed ||
            ((this.timeout = e),
            (e = B(e, "msecs")),
            S(this[W]),
            0 === e
              ? void 0 !== t &&
                (_(t, "callback"), this.removeListener("timeout", t))
              : ((this[W] = w(this._onTimeout.bind(this), e)),
                this[U] && this[U][A](),
                void 0 !== t && (_(t, "callback"), this.once("timeout", t)))),
          this
        );
      },
      kBuffer: C,
      kBufferCb: F,
      kBufferGen: E,
    };
  },
  "internal/streams/add-abort-signal": function (e, t, r, o, n, a) {
    "use strict";
    const { SymbolDispose: i } = a,
      { AbortError: s, codes: d } = t("internal/errors"),
      {
        isNodeStream: l,
        isWebStream: b,
        kControllerErrorFunction: c,
      } = t("internal/streams/utils"),
      u = t("internal/streams/end-of-stream"),
      { ERR_INVALID_ARG_TYPE: S } = d;
    let f;
    (r.exports.addAbortSignal = function addAbortSignal(e, t) {
      if (
        (((e, t) => {
          if ("object" != typeof e || !("aborted" in e))
            throw new S(t, "AbortSignal", e);
        })(e, "signal"),
        !l(t) && !b(t))
      )
        throw new S(
          "stream",
          ["ReadableStream", "WritableStream", "Stream"],
          t
        );
      return r.exports.addAbortSignalNoValidate(e, t);
    }),
      (r.exports.addAbortSignalNoValidate = function (e, r) {
        if ("object" != typeof e || !("aborted" in e)) return r;
        const o = l(r)
          ? () => {
              r.destroy(new s(void 0, { cause: e.reason }));
            }
          : () => {
              r[c](new s(void 0, { cause: e.reason }));
            };
        if (e.aborted) o();
        else {
          f ??= t("events").addAbortListener;
          const n = f(e, o);
          u(r, n[i]);
        }
        return r;
      });
  },
  "internal/streams/buffer_list": function (t, e, h, n, i, s) {
    "use strict";
    const {
        StringPrototypeSlice: a,
        SymbolIterator: l,
        TypedArrayPrototypeSet: r,
        Uint8Array: d,
      } = s,
      { Buffer: u } = e("buffer"),
      { inspect: o } = e("internal/util/inspect");
    h.exports = class BufferList {
      constructor() {
        (this.head = null), (this.tail = null), (this.length = 0);
      }
      push(t) {
        const e = { data: t, next: null };
        this.length > 0 ? (this.tail.next = e) : (this.head = e),
          (this.tail = e),
          ++this.length;
      }
      unshift(t) {
        const e = { data: t, next: this.head };
        0 === this.length && (this.tail = e), (this.head = e), ++this.length;
      }
      shift() {
        if (0 === this.length) return;
        const t = this.head.data;
        return (
          1 === this.length
            ? (this.head = this.tail = null)
            : (this.head = this.head.next),
          --this.length,
          t
        );
      }
      clear() {
        (this.head = this.tail = null), (this.length = 0);
      }
      join(t) {
        if (0 === this.length) return "";
        let e = this.head,
          h = "" + e.data;
        for (; null !== (e = e.next); ) h += t + e.data;
        return h;
      }
      concat(t) {
        if (0 === this.length) return u.alloc(0);
        const e = u.allocUnsafe(t >>> 0);
        let h = this.head,
          n = 0;
        for (; h; ) r(e, h.data, n), (n += h.data.length), (h = h.next);
        return e;
      }
      consume(t, e) {
        const h = this.head.data;
        if (t < h.length) {
          const e = h.slice(0, t);
          return (this.head.data = h.slice(t)), e;
        }
        return t === h.length
          ? this.shift()
          : e
          ? this._getString(t)
          : this._getBuffer(t);
      }
      first() {
        return this.head.data;
      }
      *[l]() {
        for (let t = this.head; t; t = t.next) yield t.data;
      }
      _getString(t) {
        let e = "",
          h = this.head,
          n = 0;
        do {
          const i = h.data;
          if (!(t > i.length)) {
            t === i.length
              ? ((e += i),
                ++n,
                h.next ? (this.head = h.next) : (this.head = this.tail = null))
              : ((e += a(i, 0, t)), (this.head = h), (h.data = a(i, t)));
            break;
          }
          (e += i), (t -= i.length), ++n;
        } while (null !== (h = h.next));
        return (this.length -= n), e;
      }
      _getBuffer(t) {
        const e = u.allocUnsafe(t),
          h = t;
        let n = this.head,
          i = 0;
        do {
          const s = n.data;
          if (!(t > s.length)) {
            t === s.length
              ? (r(e, s, h - t),
                ++i,
                n.next ? (this.head = n.next) : (this.head = this.tail = null))
              : (r(e, new d(s.buffer, s.byteOffset, t), h - t),
                (this.head = n),
                (n.data = s.slice(t)));
            break;
          }
          r(e, s, h - t), (t -= s.length), ++i;
        } while (null !== (n = n.next));
        return (this.length -= i), e;
      }
      [o.custom](t, e) {
        return o(this, { ...e, depth: 0, customInspect: !1 });
      }
    };
  },
  "internal/streams/compose": function (e, t, n, r, i, a) {
    "use strict";
    const { pipeline: o } = t("internal/streams/pipeline"),
      l = t("internal/streams/duplex"),
      { destroyer: s } = t("internal/streams/destroy"),
      {
        isNodeStream: c,
        isReadable: f,
        isWritable: u,
        isWebStream: d,
        isTransformStream: b,
        isWritableStream: m,
        isReadableStream: w,
      } = t("internal/streams/utils"),
      {
        AbortError: h,
        codes: { ERR_INVALID_ARG_VALUE: _, ERR_MISSING_ARGS: y },
      } = t("internal/errors"),
      p = t("internal/streams/end-of-stream");
    n.exports = function compose(...e) {
      if (0 === e.length) throw new y("streams");
      if (1 === e.length) return l.from(e[0]);
      const t = [...e];
      if (
        ("function" == typeof e[0] && (e[0] = l.from(e[0])),
        "function" == typeof e[e.length - 1])
      ) {
        const t = e.length - 1;
        e[t] = l.from(e[t]);
      }
      for (let n = 0; n < e.length; ++n)
        if (c(e[n]) || d(e[n])) {
          if (n < e.length - 1 && !(f(e[n]) || w(e[n]) || b(e[n])))
            throw new _(`streams[${n}]`, t[n], "must be readable");
          if (n > 0 && !(u(e[n]) || m(e[n]) || b(e[n])))
            throw new _(`streams[${n}]`, t[n], "must be writable");
        }
      let n, r, i, a, R;
      const g = e[0],
        S = o(e, function onfinished(e) {
          const t = a;
          (a = null), t ? t(e) : e ? R.destroy(e) : I || A || R.destroy();
        }),
        A = !!(u(g) || m(g) || b(g)),
        I = !!(f(S) || w(S) || b(S));
      if (
        ((R = new l({
          writableObjectMode: !!g?.writableObjectMode,
          readableObjectMode: !!S?.readableObjectMode,
          writable: A,
          readable: I,
        })),
        A)
      ) {
        if (c(g))
          (R._write = function (e, t, r) {
            g.write(e, t) ? r() : (n = r);
          }),
            (R._final = function (e) {
              g.end(), (r = e);
            }),
            g.on("drain", function () {
              if (n) {
                const e = n;
                (n = null), e();
              }
            });
        else if (d(g)) {
          const e = (b(g) ? g.writable : g).getWriter();
          (R._write = async function (t, n, r) {
            try {
              await e.ready, e.write(t).catch(() => {}), r();
            } catch (e) {
              r(e);
            }
          }),
            (R._final = async function (t) {
              try {
                await e.ready, e.close().catch(() => {}), (r = t);
              } catch (e) {
                t(e);
              }
            });
        }
        const e = b(S) ? S.readable : S;
        p(e, () => {
          if (r) {
            const e = r;
            (r = null), e();
          }
        });
      }
      if (I)
        if (c(S))
          S.on("readable", function () {
            if (i) {
              const e = i;
              (i = null), e();
            }
          }),
            S.on("end", function () {
              R.push(null);
            }),
            (R._read = function () {
              for (;;) {
                const e = S.read();
                if (null === e) return void (i = R._read);
                if (!R.push(e)) return;
              }
            });
        else if (d(S)) {
          const e = (b(S) ? S.readable : S).getReader();
          R._read = async function () {
            for (;;)
              try {
                const { value: t, done: n } = await e.read();
                if (!R.push(t)) return;
                if (n) return void R.push(null);
              } catch {
                return;
              }
          };
        }
      return (
        (R._destroy = function (e, t) {
          e || null === a || (e = new h()),
            (i = null),
            (n = null),
            (r = null),
            null === a ? t(e) : ((a = t), c(S) && s(S, e));
        }),
        R
      );
    };
  },
  "internal/streams/destroy": function (e, t, r, o, s, n) {
    "use strict";
    const {
        aggregateTwoErrors: i,
        codes: { ERR_MULTIPLE_CALLBACK: c },
        AbortError: d,
      } = t("internal/errors"),
      { Symbol: a } = n,
      {
        kIsDestroyed: l,
        isDestroyed: u,
        isFinished: y,
        isServerRequest: f,
      } = t("internal/streams/utils"),
      m = a("kDestroy"),
      _ = a("kConstruct");
    function checkError(e, t, r) {
      e &&
        (e.stack,
        t && !t.errored && (t.errored = e),
        r && !r.errored && (r.errored = e));
    }
    function _destroy(e, t, r) {
      let s = !1;
      function onDestroy(t) {
        if (s) return;
        s = !0;
        const n = e._readableState,
          i = e._writableState;
        checkError(t, i, n),
          i && (i.closed = !0),
          n && (n.closed = !0),
          "function" == typeof r && r(t),
          t ? o.nextTick(emitErrorCloseNT, e, t) : o.nextTick(emitCloseNT, e);
      }
      try {
        e._destroy(t || null, onDestroy);
      } catch (e) {
        onDestroy(e);
      }
    }
    function emitErrorCloseNT(e, t) {
      emitErrorNT(e, t), emitCloseNT(e);
    }
    function emitCloseNT(e) {
      const t = e._readableState,
        r = e._writableState;
      r && (r.closeEmitted = !0),
        t && (t.closeEmitted = !0),
        (r?.emitClose || t?.emitClose) && e.emit("close");
    }
    function emitErrorNT(e, t) {
      const r = e._readableState,
        o = e._writableState;
      o?.errorEmitted ||
        r?.errorEmitted ||
        (o && (o.errorEmitted = !0),
        r && (r.errorEmitted = !0),
        e.emit("error", t));
    }
    function errorOrDestroy(e, t, r) {
      const s = e._readableState,
        n = e._writableState;
      if (n?.destroyed || s?.destroyed) return this;
      s?.autoDestroy || n?.autoDestroy
        ? e.destroy(t)
        : t &&
          (t.stack,
          n && !n.errored && (n.errored = t),
          s && !s.errored && (s.errored = t),
          r ? o.nextTick(emitErrorNT, e, t) : emitErrorNT(e, t));
    }
    function constructNT(e) {
      let t = !1;
      function onConstruct(r) {
        if (t) return void errorOrDestroy(e, r ?? new c());
        t = !0;
        const o = e._readableState,
          s = e._writableState,
          n = s || o;
        o && (o.constructed = !0),
          s && (s.constructed = !0),
          n.destroyed ? e.emit(m, r) : r ? errorOrDestroy(e, r, !0) : e.emit(_);
      }
      try {
        e._construct((e) => {
          o.nextTick(onConstruct, e);
        });
      } catch (e) {
        o.nextTick(onConstruct, e);
      }
    }
    function isRequest(e) {
      return e?.setHeader && "function" == typeof e.abort;
    }
    function emitCloseLegacy(e) {
      e.emit("close");
    }
    function emitErrorCloseLegacy(e, t) {
      e.emit("error", t), o.nextTick(emitCloseLegacy, e);
    }
    r.exports = {
      construct: function construct(e, t) {
        if ("function" != typeof e._construct) return;
        const r = e._readableState,
          s = e._writableState;
        r && (r.constructed = !1),
          s && (s.constructed = !1),
          e.once(_, t),
          e.listenerCount(_) > 1 || o.nextTick(constructNT, e);
      },
      destroyer: function destroyer(e, t) {
        e &&
          !u(e) &&
          (t || y(e) || (t = new d()),
          f(e)
            ? ((e.socket = null), e.destroy(t))
            : isRequest(e)
            ? e.abort()
            : isRequest(e.req)
            ? e.req.abort()
            : "function" == typeof e.destroy
            ? e.destroy(t)
            : "function" == typeof e.close
            ? e.close()
            : t
            ? o.nextTick(emitErrorCloseLegacy, e, t)
            : o.nextTick(emitCloseLegacy, e),
          e.destroyed || (e[l] = !0));
      },
      destroy: function destroy(e, t) {
        const r = this._readableState,
          o = this._writableState,
          s = o || r;
        return o?.destroyed || r?.destroyed
          ? ("function" == typeof t && t(), this)
          : (checkError(e, o, r),
            o && (o.destroyed = !0),
            r && (r.destroyed = !0),
            s.constructed
              ? _destroy(this, e, t)
              : this.once(m, function (r) {
                  _destroy(this, i(r, e), t);
                }),
            this);
      },
      undestroy: function undestroy() {
        const e = this._readableState,
          t = this._writableState;
        e &&
          ((e.constructed = !0),
          (e.closed = !1),
          (e.closeEmitted = !1),
          (e.destroyed = !1),
          (e.errored = null),
          (e.errorEmitted = !1),
          (e.reading = !1),
          (e.ended = !1 === e.readable),
          (e.endEmitted = !1 === e.readable)),
          t &&
            ((t.constructed = !0),
            (t.destroyed = !1),
            (t.closed = !1),
            (t.closeEmitted = !1),
            (t.errored = null),
            (t.errorEmitted = !1),
            (t.finalCalled = !1),
            (t.prefinished = !1),
            (t.ended = !1 === t.writable),
            (t.ending = !1 === t.writable),
            (t.finished = !1 === t.writable));
      },
      errorOrDestroy: errorOrDestroy,
    };
  },
  "internal/streams/duplex": function (e, t, r, a, l, o) {
    "use strict";
    const {
      ObjectDefineProperties: i,
      ObjectGetOwnPropertyDescriptor: p,
      ObjectKeys: n,
      ObjectSetPrototypeOf: _,
    } = o;
    r.exports = Duplex;
    const b = t("internal/streams/readable"),
      s = t("internal/streams/writable");
    _(Duplex.prototype, b.prototype), _(Duplex, b);
    {
      const e = n(s.prototype);
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        Duplex.prototype[r] || (Duplex.prototype[r] = s.prototype[r]);
      }
    }
    function Duplex(e) {
      if (!(this instanceof Duplex)) return new Duplex(e);
      b.call(this, e),
        s.call(this, e),
        e
          ? ((this.allowHalfOpen = !1 !== e.allowHalfOpen),
            !1 === e.readable &&
              ((this._readableState.readable = !1),
              (this._readableState.ended = !0),
              (this._readableState.endEmitted = !0)),
            !1 === e.writable &&
              ((this._writableState.writable = !1),
              (this._writableState.ending = !0),
              (this._writableState.ended = !0),
              (this._writableState.finished = !0)))
          : (this.allowHalfOpen = !0);
    }
    let d, u;
    function lazyWebStreams() {
      return void 0 === d && (d = t("internal/webstreams/adapters")), d;
    }
    i(Duplex.prototype, {
      writable: { __proto__: null, ...p(s.prototype, "writable") },
      writableHighWaterMark: {
        __proto__: null,
        ...p(s.prototype, "writableHighWaterMark"),
      },
      writableObjectMode: {
        __proto__: null,
        ...p(s.prototype, "writableObjectMode"),
      },
      writableBuffer: { __proto__: null, ...p(s.prototype, "writableBuffer") },
      writableLength: { __proto__: null, ...p(s.prototype, "writableLength") },
      writableFinished: {
        __proto__: null,
        ...p(s.prototype, "writableFinished"),
      },
      writableCorked: { __proto__: null, ...p(s.prototype, "writableCorked") },
      writableEnded: { __proto__: null, ...p(s.prototype, "writableEnded") },
      writableNeedDrain: {
        __proto__: null,
        ...p(s.prototype, "writableNeedDrain"),
      },
      destroyed: {
        __proto__: null,
        get() {
          return (
            void 0 !== this._readableState &&
            void 0 !== this._writableState &&
            this._readableState.destroyed &&
            this._writableState.destroyed
          );
        },
        set(e) {
          this._readableState &&
            this._writableState &&
            ((this._readableState.destroyed = e),
            (this._writableState.destroyed = e));
        },
      },
    }),
      (Duplex.fromWeb = function (e, t) {
        return lazyWebStreams().newStreamDuplexFromReadableWritablePair(e, t);
      }),
      (Duplex.toWeb = function (e) {
        return lazyWebStreams().newReadableWritablePairFromDuplex(e);
      }),
      (Duplex.from = function (e) {
        return u || (u = t("internal/streams/duplexify")), u(e, "body");
      });
  },
  "internal/streams/duplexify": function (e, t, r, n, a, i) {
    "use strict";
    const {
        isReadable: l,
        isWritable: o,
        isIterable: d,
        isNodeStream: u,
        isReadableNodeStream: s,
        isWritableNodeStream: b,
        isDuplexNodeStream: f,
        isReadableStream: c,
        isWritableStream: w,
      } = t("internal/streams/utils"),
      y = t("internal/streams/end-of-stream"),
      {
        AbortError: p,
        codes: { ERR_INVALID_ARG_TYPE: _, ERR_INVALID_RETURN_VALUE: m },
      } = t("internal/errors"),
      { destroyer: h } = t("internal/streams/destroy"),
      x = t("internal/streams/duplex"),
      S = t("internal/streams/readable"),
      D = t("internal/streams/writable"),
      { createDeferredPromise: R } = t("internal/util"),
      j = t("internal/streams/from"),
      { isBlob: A } = t("internal/blob"),
      { AbortController: I } = t("internal/abort_controller"),
      { FunctionPrototypeCall: v } = i;
    class Duplexify extends x {
      constructor(e) {
        super(e),
          !1 === e?.readable &&
            ((this._readableState.readable = !1),
            (this._readableState.ended = !0),
            (this._readableState.endEmitted = !0)),
          !1 === e?.writable &&
            ((this._writableState.writable = !1),
            (this._writableState.ending = !0),
            (this._writableState.ended = !0),
            (this._writableState.finished = !0));
      }
    }
    function _duplexify(e) {
      const t =
          e.readable && "function" != typeof e.readable.read
            ? S.wrap(e.readable)
            : e.readable,
        r = e.writable;
      let n,
        a,
        i,
        d,
        u,
        s = !!l(t),
        b = !!o(r);
      function onfinished(e) {
        const t = d;
        (d = null), t ? t(e) : e && u.destroy(e);
      }
      return (
        (u = new Duplexify({
          readableObjectMode: !!t?.readableObjectMode,
          writableObjectMode: !!r?.writableObjectMode,
          readable: s,
          writable: b,
        })),
        b &&
          (y(r, (e) => {
            (b = !1), e && h(t, e), onfinished(e);
          }),
          (u._write = function (e, t, a) {
            r.write(e, t) ? a() : (n = a);
          }),
          (u._final = function (e) {
            r.end(), (a = e);
          }),
          r.on("drain", function () {
            if (n) {
              const e = n;
              (n = null), e();
            }
          }),
          r.on("finish", function () {
            if (a) {
              const e = a;
              (a = null), e();
            }
          })),
        s &&
          (y(t, (e) => {
            (s = !1), e && h(t, e), onfinished(e);
          }),
          t.on("readable", function () {
            if (i) {
              const e = i;
              (i = null), e();
            }
          }),
          t.on("end", function () {
            u.push(null);
          }),
          (u._read = function () {
            for (;;) {
              const e = t.read();
              if (null === e) return void (i = u._read);
              if (!u.push(e)) return;
            }
          })),
        (u._destroy = function (e, l) {
          e || null === d || (e = new p()),
            (i = null),
            (n = null),
            (a = null),
            null === d ? l(e) : ((d = l), h(r, e), h(t, e));
        }),
        u
      );
    }
    r.exports = function duplexify(e, t) {
      if (f(e)) return e;
      if (s(e)) return _duplexify({ readable: e });
      if (b(e)) return _duplexify({ writable: e });
      if (u(e)) return _duplexify({ writable: !1, readable: !1 });
      if (c(e)) return _duplexify({ readable: S.fromWeb(e) });
      if (w(e)) return _duplexify({ writable: D.fromWeb(e) });
      if ("function" == typeof e) {
        const {
          value: r,
          write: a,
          final: i,
          destroy: l,
        } = (function fromAsyncGen(e) {
          let { promise: t, resolve: r } = R();
          const a = new I(),
            i = a.signal,
            l = e(
              (async function* () {
                for (;;) {
                  const e = t;
                  t = null;
                  const { chunk: a, done: l, cb: o } = await e;
                  if ((n.nextTick(o), l)) return;
                  if (i.aborted) throw new p(void 0, { cause: i.reason });
                  ({ promise: t, resolve: r } = R()), yield a;
                }
              })(),
              { signal: i }
            );
          return {
            value: l,
            write(e, t, n) {
              const a = r;
              (r = null), a({ chunk: e, done: !1, cb: n });
            },
            final(e) {
              const t = r;
              (r = null), t({ done: !0, cb: e });
            },
            destroy(e, t) {
              a.abort(), t(e);
            },
          };
        })(e);
        if (d(r))
          return j(Duplexify, r, {
            objectMode: !0,
            write: a,
            final: i,
            destroy: l,
          });
        const o = r?.then;
        if ("function" == typeof o) {
          let e;
          const t = v(
            o,
            r,
            (e) => {
              if (null != e) throw new m("nully", "body", e);
            },
            (t) => {
              h(e, t);
            }
          );
          return (e = new Duplexify({
            objectMode: !0,
            readable: !1,
            write: a,
            final(e) {
              i(async () => {
                try {
                  await t, n.nextTick(e, null);
                } catch (t) {
                  n.nextTick(e, t);
                }
              });
            },
            destroy: l,
          }));
        }
        throw new m("Iterable, AsyncIterable or AsyncFunction", t, r);
      }
      if (A(e)) return duplexify(e.arrayBuffer());
      if (d(e)) return j(Duplexify, e, { objectMode: !0, writable: !1 });
      if (c(e?.readable) && w(e?.writable)) return Duplexify.fromWeb(e);
      if ("object" == typeof e?.writable || "object" == typeof e?.readable) {
        return _duplexify({
          readable: e?.readable
            ? s(e?.readable)
              ? e?.readable
              : duplexify(e.readable)
            : void 0,
          writable: e?.writable
            ? b(e?.writable)
              ? e?.writable
              : duplexify(e.writable)
            : void 0,
        });
      }
      const r = e?.then;
      if ("function" == typeof r) {
        let t;
        return (
          v(
            r,
            e,
            (e) => {
              null != e && t.push(e), t.push(null);
            },
            (e) => {
              h(t, e);
            }
          ),
          (t = new Duplexify({ objectMode: !0, writable: !1, read() {} }))
        );
      }
      throw new _(
        t,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise",
        ],
        e
      );
    };
  },
  "internal/streams/end-of-stream": function (e, t, r, n, o, i) {
    "use strict";
    const { AbortError: a, codes: s } = t("internal/errors"),
      { ERR_INVALID_ARG_TYPE: l, ERR_STREAM_PREMATURE_CLOSE: c } = s,
      { kEmptyObject: d, once: b } = t("internal/util"),
      {
        validateAbortSignal: m,
        validateFunction: u,
        validateObject: p,
        validateBoolean: f,
      } = t("internal/validators"),
      { Promise: v, PromisePrototypeThen: L, SymbolDispose: R } = i,
      {
        isClosed: E,
        isReadable: S,
        isReadableNodeStream: g,
        isReadableStream: w,
        isReadableFinished: y,
        isReadableErrored: h,
        isWritable: T,
        isWritableNodeStream: _,
        isWritableStream: k,
        isWritableFinished: x,
        isWritableErrored: q,
        isNodeStream: A,
        willEmitClose: W,
        kIsClosedPromise: P,
      } = t("internal/streams/utils");
    let N;
    const nop = () => {};
    function eos(e, r, o) {
      if (
        (2 === arguments.length
          ? ((o = r), (r = d))
          : null == r
          ? (r = d)
          : p(r, "options"),
        u(o, "callback"),
        m(r.signal, "options.signal"),
        (o = b(o)),
        w(e) || k(e))
      )
        return (function eosWeb(e, r, o) {
          let i = !1,
            s = nop;
          if (r.signal)
            if (
              ((s = () => {
                (i = !0), o.call(e, new a(void 0, { cause: r.signal.reason }));
              }),
              r.signal.aborted)
            )
              n.nextTick(s);
            else {
              N ??= t("events").addAbortListener;
              const n = N(r.signal, s),
                i = o;
              o = b((...t) => {
                n[R](), i.apply(e, t);
              });
            }
          const resolverFn = (...t) => {
            i || n.nextTick(() => o.apply(e, t));
          };
          return L(e[P].promise, resolverFn, resolverFn), nop;
        })(e, r, o);
      if (!A(e))
        throw new l(
          "stream",
          ["ReadableStream", "WritableStream", "Stream"],
          e
        );
      const i = r.readable ?? g(e),
        s = r.writable ?? _(e),
        f = e._writableState,
        v = e._readableState,
        onlegacyfinish = () => {
          e.writable || onfinish();
        };
      let C = W(e) && g(e) === i && _(e) === s,
        F = x(e, !1);
      const onfinish = () => {
        (F = !0),
          e.destroyed && (C = !1),
          (!C || (e.readable && !i)) && ((i && !I) || o.call(e));
      };
      let I = y(e, !1);
      const onend = () => {
          (I = !0),
            e.destroyed && (C = !1),
            (!C || (e.writable && !s)) && ((s && !F) || o.call(e));
        },
        onerror = (t) => {
          o.call(e, t);
        };
      let D = E(e);
      const onclose = () => {
          D = !0;
          const t = q(e) || h(e);
          return t && "boolean" != typeof t
            ? o.call(e, t)
            : i && !I && g(e, !0) && !y(e, !1)
            ? o.call(e, new c())
            : !s || F || x(e, !1)
            ? void o.call(e)
            : o.call(e, new c());
        },
        onclosed = () => {
          D = !0;
          const t = q(e) || h(e);
          if (t && "boolean" != typeof t) return o.call(e, t);
          o.call(e);
        },
        onrequest = () => {
          e.req.on("finish", onfinish);
        };
      !(function isRequest(e) {
        return e.setHeader && "function" == typeof e.abort;
      })(e)
        ? s &&
          !f &&
          (e.on("end", onlegacyfinish), e.on("close", onlegacyfinish))
        : (e.on("complete", onfinish),
          C || e.on("abort", onclose),
          e.req ? onrequest() : e.on("request", onrequest)),
        C || "boolean" != typeof e.aborted || e.on("aborted", onclose),
        e.on("end", onend),
        e.on("finish", onfinish),
        !1 !== r.error && e.on("error", onerror),
        e.on("close", onclose),
        D
          ? n.nextTick(onclose)
          : f?.errorEmitted || v?.errorEmitted
          ? C || n.nextTick(onclosed)
          : (i || (C && !S(e)) || (!F && !1 !== T(e))) &&
            (s || (C && !T(e)) || (!I && !1 !== S(e)))
          ? v && e.req && e.aborted && n.nextTick(onclosed)
          : n.nextTick(onclosed);
      const cleanup = () => {
        (o = nop),
          e.removeListener("aborted", onclose),
          e.removeListener("complete", onfinish),
          e.removeListener("abort", onclose),
          e.removeListener("request", onrequest),
          e.req && e.req.removeListener("finish", onfinish),
          e.removeListener("end", onlegacyfinish),
          e.removeListener("close", onlegacyfinish),
          e.removeListener("finish", onfinish),
          e.removeListener("end", onend),
          e.removeListener("error", onerror),
          e.removeListener("close", onclose);
      };
      if (r.signal && !D) {
        const abort = () => {
          const t = o;
          cleanup(), t.call(e, new a(void 0, { cause: r.signal.reason }));
        };
        if (r.signal.aborted) n.nextTick(abort);
        else {
          N ??= t("events").addAbortListener;
          const n = N(r.signal, abort),
            i = o;
          o = b((...t) => {
            n[R](), i.apply(e, t);
          });
        }
      }
      return cleanup;
    }
    (r.exports = eos),
      (r.exports.finished = function finished(e, t) {
        let r = !1;
        return (
          null === t && (t = d),
          t?.cleanup && (f(t.cleanup, "cleanup"), (r = t.cleanup)),
          new v((n, o) => {
            const i = eos(e, t, (e) => {
              r && i(), e ? o(e) : n();
            });
          })
        );
      });
  },
  "internal/streams/from": function (t, e, n, o, r, i) {
    "use strict";
    const {
        PromisePrototypeThen: c,
        SymbolAsyncIterator: a,
        SymbolIterator: f,
      } = i,
      { Buffer: s } = e("buffer"),
      { ERR_INVALID_ARG_TYPE: u, ERR_STREAM_NULL_VALUES: l } =
        e("internal/errors").codes;
    n.exports = function from(t, e, n) {
      let r, i;
      if ("string" == typeof e || e instanceof s)
        return new t({
          objectMode: !0,
          ...n,
          read() {
            this.push(e), this.push(null);
          },
        });
      if (e && e[a]) (i = !0), (r = e[a]());
      else {
        if (!e || !e[f]) throw new u("iterable", ["Iterable"], e);
        (i = !1), (r = e[f]());
      }
      const h = new t({ objectMode: !0, highWaterMark: 1, ...n });
      let w = !1;
      return (
        (h._read = function () {
          w ||
            ((w = !0),
            (async function next() {
              for (;;) {
                try {
                  const { value: t, done: e } = i ? await r.next() : r.next();
                  if (e) h.push(null);
                  else {
                    const e = t && "function" == typeof t.then ? await t : t;
                    if (null === e) throw ((w = !1), new l());
                    if (h.push(e)) continue;
                    w = !1;
                  }
                } catch (t) {
                  h.destroy(t);
                }
                break;
              }
            })());
        }),
        (h._destroy = function (t, e) {
          c(
            (async function close(t) {
              const e = null != t,
                n = "function" == typeof r.throw;
              if (e && n) {
                const { value: e, done: n } = await r.throw(t);
                if ((await e, n)) return;
              }
              if ("function" == typeof r.return) {
                const { value: t } = await r.return();
                await t;
              }
            })(t),
            () => o.nextTick(e, t),
            (n) => o.nextTick(e, n || t)
          );
        }),
        h
      );
    };
  },
  "internal/streams/lazy_transform": function (t, e, r, a, n, o) {
    "use strict";
    const {
        ObjectDefineProperties: i,
        ObjectDefineProperty: s,
        ObjectSetPrototypeOf: l,
      } = o,
      _ = e("stream"),
      { getDefaultEncoding: u } = e("internal/crypto/util");
    function LazyTransform(t) {
      this._options = t;
    }
    function makeGetter(t) {
      return function () {
        return (
          _.Transform.call(this, this._options),
          (this._writableState.decodeStrings = !1),
          (this._options && this._options.defaultEncoding) ||
            (this._writableState.defaultEncoding = u()),
          this[t]
        );
      };
    }
    function makeSetter(t) {
      return function (e) {
        s(this, t, {
          __proto__: null,
          value: e,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        });
      };
    }
    (r.exports = LazyTransform),
      l(LazyTransform.prototype, _.Transform.prototype),
      l(LazyTransform, _.Transform),
      i(LazyTransform.prototype, {
        _readableState: {
          __proto__: null,
          get: makeGetter("_readableState"),
          set: makeSetter("_readableState"),
          configurable: !0,
          enumerable: !0,
        },
        _writableState: {
          __proto__: null,
          get: makeGetter("_writableState"),
          set: makeSetter("_writableState"),
          configurable: !0,
          enumerable: !0,
        },
      });
  },
  "internal/streams/legacy": function (e, n, r, o, t, s) {
    "use strict";
    const { ArrayIsArray: i, ObjectSetPrototypeOf: p } = s,
      a = n("events");
    function Stream(e) {
      a.call(this, e);
    }
    function prependListener(e, n, r) {
      if ("function" == typeof e.prependListener)
        return e.prependListener(n, r);
      e._events && e._events[n]
        ? i(e._events[n])
          ? e._events[n].unshift(r)
          : (e._events[n] = [r, e._events[n]])
        : e.on(n, r);
    }
    p(Stream.prototype, a.prototype),
      p(Stream, a),
      (Stream.prototype.pipe = function (e, n) {
        const r = this;
        function ondata(n) {
          e.writable && !1 === e.write(n) && r.pause && r.pause();
        }
        function ondrain() {
          r.readable && r.resume && r.resume();
        }
        r.on("data", ondata),
          e.on("drain", ondrain),
          e._isStdio ||
            (n && !1 === n.end) ||
            (r.on("end", onend), r.on("close", onclose));
        let o = !1;
        function onend() {
          o || ((o = !0), e.end());
        }
        function onclose() {
          o || ((o = !0), "function" == typeof e.destroy && e.destroy());
        }
        function onerror(e) {
          cleanup(),
            0 === a.listenerCount(this, "error") && this.emit("error", e);
        }
        function cleanup() {
          r.removeListener("data", ondata),
            e.removeListener("drain", ondrain),
            r.removeListener("end", onend),
            r.removeListener("close", onclose),
            r.removeListener("error", onerror),
            e.removeListener("error", onerror),
            r.removeListener("end", cleanup),
            r.removeListener("close", cleanup),
            e.removeListener("close", cleanup);
        }
        return (
          prependListener(r, "error", onerror),
          prependListener(e, "error", onerror),
          r.on("end", cleanup),
          r.on("close", cleanup),
          e.on("close", cleanup),
          e.emit("pipe", r),
          e
        );
      }),
      (r.exports = { Stream: Stream, prependListener: prependListener });
  },
  "internal/streams/operators": function (n, t, e, i, o, a) {
    "use strict";
    const { AbortController: r, AbortSignal: s } = t(
        "internal/abort_controller"
      ),
      {
        codes: {
          ERR_INVALID_ARG_VALUE: l,
          ERR_INVALID_ARG_TYPE: c,
          ERR_MISSING_ARGS: u,
          ERR_OUT_OF_RANGE: f,
        },
        AbortError: d,
      } = t("internal/errors"),
      {
        validateAbortSignal: h,
        validateInteger: g,
        validateObject: w,
      } = t("internal/validators"),
      { kWeakHandler: y, kResistStopPropagation: p } = t(
        "internal/event_target"
      ),
      { finished: m } = t("internal/streams/end-of-stream"),
      b = t("internal/streams/compose"),
      { addAbortSignalNoValidate: A } = t("internal/streams/add-abort-signal"),
      { isWritable: I, isNodeStream: R } = t("internal/streams/utils"),
      { deprecate: v } = t("internal/util"),
      {
        ArrayPrototypePush: P,
        Boolean: E,
        MathFloor: _,
        Number: F,
        NumberIsNaN: k,
        Promise: N,
        PromiseReject: M,
        PromiseResolve: S,
        PromisePrototypeThen: O,
        Symbol: x,
      } = a,
      G = x("kEmpty"),
      W = x("kEof");
    function map(n, t) {
      if ("function" != typeof n)
        throw new c("fn", ["Function", "AsyncFunction"], n);
      null != t && w(t, "options"),
        null != t?.signal && h(t.signal, "options.signal");
      let e = 1;
      null != t?.concurrency && (e = _(t.concurrency));
      let i = e - 1;
      return (
        null != t?.highWaterMark && (i = _(t.highWaterMark)),
        g(e, "options.concurrency", 1),
        g(i, "options.highWaterMark", 0),
        (i += e),
        async function* map2() {
          const o = s.any([t?.signal].filter(E)),
            a = this,
            r = [],
            l = { signal: o };
          let c,
            u,
            f = !1,
            h = 0;
          function onCatch() {
            (f = !0), afterItemProcessed();
          }
          function afterItemProcessed() {
            (h -= 1), maybeResume();
          }
          function maybeResume() {
            u && !f && h < e && r.length < i && (u(), (u = null));
          }
          !(async function pump() {
            try {
              for await (let t of a) {
                if (f) return;
                if (o.aborted) throw new d();
                try {
                  if (((t = n(t, l)), t === G)) continue;
                  t = S(t);
                } catch (n) {
                  t = M(n);
                }
                (h += 1),
                  O(t, afterItemProcessed, onCatch),
                  r.push(t),
                  c && (c(), (c = null)),
                  !f &&
                    (r.length >= i || h >= e) &&
                    (await new N((n) => {
                      u = n;
                    }));
              }
              r.push(W);
            } catch (n) {
              const t = M(n);
              O(t, afterItemProcessed, onCatch), r.push(t);
            } finally {
              (f = !0), c && (c(), (c = null));
            }
          })();
          try {
            for (;;) {
              for (; r.length > 0; ) {
                const n = await r[0];
                if (n === W) return;
                if (o.aborted) throw new d();
                n !== G && (yield n), r.shift(), maybeResume();
              }
              await new N((n) => {
                c = n;
              });
            }
          } finally {
            (f = !0), u && (u(), (u = null));
          }
        }.call(this)
      );
    }
    async function some(n, t = void 0) {
      for await (const e of filter.call(this, n, t)) return !0;
      return !1;
    }
    function filter(n, t) {
      if ("function" != typeof n)
        throw new c("fn", ["Function", "AsyncFunction"], n);
      return map.call(
        this,
        async function filterFn(t, e) {
          return (await n(t, e)) ? t : G;
        },
        t
      );
    }
    class ReduceAwareErrMissingArgs extends u {
      constructor() {
        super("reduce"),
          (this.message =
            "Reduce of an empty stream requires an initial value");
      }
    }
    function toIntegerOrInfinity(n) {
      if (((n = F(n)), k(n))) return 0;
      if (n < 0) throw new f("number", ">= 0", n);
      return n;
    }
    (e.exports.streamReturningOperators = {
      asIndexedPairs: v(function asIndexedPairs(n = void 0) {
        return (
          null != n && w(n, "options"),
          null != n?.signal && h(n.signal, "options.signal"),
          async function* asIndexedPairs2() {
            let t = 0;
            for await (const e of this) {
              if (n?.signal?.aborted) throw new d({ cause: n.signal.reason });
              yield [t++, e];
            }
          }.call(this)
        );
      }, "readable.asIndexedPairs will be removed in a future version."),
      drop: function drop(n, t = void 0) {
        return (
          null != t && w(t, "options"),
          null != t?.signal && h(t.signal, "options.signal"),
          (n = toIntegerOrInfinity(n)),
          async function* drop2() {
            if (t?.signal?.aborted) throw new d();
            for await (const e of this) {
              if (t?.signal?.aborted) throw new d();
              n-- <= 0 && (yield e);
            }
          }.call(this)
        );
      },
      filter: filter,
      flatMap: function flatMap(n, t) {
        const e = map.call(this, n, t);
        return async function* flatMap2() {
          for await (const n of e) yield* n;
        }.call(this);
      },
      map: map,
      take: function take(n, t = void 0) {
        return (
          null != t && w(t, "options"),
          null != t?.signal && h(t.signal, "options.signal"),
          (n = toIntegerOrInfinity(n)),
          async function* take2() {
            if (t?.signal?.aborted) throw new d();
            for await (const e of this) {
              if (t?.signal?.aborted) throw new d();
              if ((n-- > 0 && (yield e), n <= 0)) return;
            }
          }.call(this)
        );
      },
      compose: function compose(n, t) {
        if (
          (null != t && w(t, "options"),
          null != t?.signal && h(t.signal, "options.signal"),
          R(n) && !I(n))
        )
          throw new l("stream", n, "must be writable");
        const e = b(this, n);
        return t?.signal && A(t.signal, e), e;
      },
    }),
      (e.exports.promiseReturningOperators = {
        every: async function every(n, t = void 0) {
          if ("function" != typeof n)
            throw new c("fn", ["Function", "AsyncFunction"], n);
          return !(await some.call(this, async (...t) => !(await n(...t)), t));
        },
        forEach: async function forEach(n, t) {
          if ("function" != typeof n)
            throw new c("fn", ["Function", "AsyncFunction"], n);
          for await (const e of map.call(
            this,
            async function forEachFn(t, e) {
              return await n(t, e), G;
            },
            t
          ));
        },
        reduce: async function reduce(n, t, e) {
          if ("function" != typeof n)
            throw new c("reducer", ["Function", "AsyncFunction"], n);
          null != e && w(e, "options"),
            null != e?.signal && h(e.signal, "options.signal");
          let i = arguments.length > 1;
          if (e?.signal?.aborted) {
            const n = new d(void 0, { cause: e.signal.reason });
            throw (this.once("error", () => {}), await m(this.destroy(n)), n);
          }
          const o = new r(),
            a = o.signal;
          if (e?.signal) {
            const n = { once: !0, [y]: this, [p]: !0 };
            e.signal.addEventListener("abort", () => o.abort(), n);
          }
          let s = !1;
          try {
            for await (const o of this) {
              if (((s = !0), e?.signal?.aborted)) throw new d();
              i ? (t = await n(t, o, { signal: a })) : ((t = o), (i = !0));
            }
            if (!s && !i) throw new ReduceAwareErrMissingArgs();
          } finally {
            o.abort();
          }
          return t;
        },
        toArray: async function toArray(n) {
          null != n && w(n, "options"),
            null != n?.signal && h(n.signal, "options.signal");
          const t = [];
          for await (const e of this) {
            if (n?.signal?.aborted)
              throw new d(void 0, { cause: n.signal.reason });
            P(t, e);
          }
          return t;
        },
        some: some,
        find: async function find(n, t) {
          for await (const e of filter.call(this, n, t)) return e;
        },
      });
  },
  "internal/streams/passthrough": function (s, t, o, r, n, h) {
    "use strict";
    const { ObjectSetPrototypeOf: a } = h;
    o.exports = PassThrough;
    const e = t("internal/streams/transform");
    function PassThrough(s) {
      if (!(this instanceof PassThrough)) return new PassThrough(s);
      e.call(this, s);
    }
    a(PassThrough.prototype, e.prototype),
      a(PassThrough, e),
      (PassThrough.prototype._transform = function (s, t, o) {
        o(null, s);
      });
  },
  "internal/streams/pipeline": function (e, n, t, r, a, i) {
    "use strict";
    const {
        ArrayIsArray: o,
        Promise: l,
        SymbolAsyncIterator: s,
        SymbolDispose: c,
      } = i,
      d = n("internal/streams/end-of-stream"),
      { once: f } = n("internal/util"),
      p = n("internal/streams/destroy"),
      b = n("internal/streams/duplex"),
      {
        aggregateTwoErrors: m,
        codes: {
          ERR_INVALID_ARG_TYPE: u,
          ERR_INVALID_RETURN_VALUE: h,
          ERR_MISSING_ARGS: R,
          ERR_STREAM_DESTROYED: w,
          ERR_STREAM_PREMATURE_CLOSE: y,
        },
        AbortError: E,
      } = n("internal/errors"),
      { validateFunction: A, validateAbortSignal: I } = n(
        "internal/validators"
      ),
      {
        isIterable: T,
        isReadable: S,
        isReadableNodeStream: _,
        isNodeStream: g,
        isTransformStream: N,
        isWebStream: M,
        isReadableStream: k,
        isReadableFinished: L,
      } = n("internal/streams/utils"),
      { AbortController: v } = n("internal/abort_controller");
    let x, D, P;
    function destroyer(e, n, t) {
      let r = !1;
      e.on("close", () => {
        r = !0;
      });
      return {
        destroy: (n) => {
          r || ((r = !0), p.destroyer(e, n || new w("pipe")));
        },
        cleanup: d(e, { readable: n, writable: t }, (e) => {
          r = !e;
        }),
      };
    }
    function makeAsyncIterable(e) {
      if (T(e)) return e;
      if (_(e))
        return (async function* fromReadable(e) {
          D || (D = n("internal/streams/readable"));
          yield* D.prototype[s].call(e);
        })(e);
      throw new u("val", ["Readable", "Iterable", "AsyncIterable"], e);
    }
    async function pumpToNode(e, n, t, { end: r }) {
      let a,
        i = null;
      const resume = (e) => {
          if ((e && (a = e), i)) {
            const e = i;
            (i = null), e();
          }
        },
        wait = () =>
          new l((e, n) => {
            a
              ? n(a)
              : (i = () => {
                  a ? n(a) : e();
                });
          });
      n.on("drain", resume);
      const o = d(n, { readable: !1 }, resume);
      try {
        n.writableNeedDrain && (await wait());
        for await (const t of e) n.write(t) || (await wait());
        r && (n.end(), await wait()), t();
      } catch (e) {
        t(a !== e ? m(a, e) : e);
      } finally {
        o(), n.off("drain", resume);
      }
    }
    async function pumpToWeb(e, n, t, { end: r }) {
      N(n) && (n = n.writable);
      const a = n.getWriter();
      try {
        for await (const n of e) await a.ready, a.write(n).catch(() => {});
        await a.ready, r && (await a.close()), t();
      } catch (e) {
        try {
          await a.abort(e), t(e);
        } catch (e) {
          t(e);
        }
      }
    }
    function pipelineImpl(e, t, a) {
      if ((1 === e.length && o(e[0]) && (e = e[0]), e.length < 2))
        throw new R("streams");
      const i = new v(),
        l = i.signal,
        s = a?.signal,
        d = [];
      function abort() {
        finishImpl(new E());
      }
      let f, p, m;
      I(s, "options.signal"),
        (P ??= n("events").addAbortListener),
        s && (f = P(s, abort));
      const w = [];
      let y,
        A = 0;
      function finish(e) {
        finishImpl(e, 0 == --A);
      }
      function finishImpl(e, n) {
        if (
          (!e || (p && "ERR_STREAM_PREMATURE_CLOSE" !== p.code) || (p = e),
          p || n)
        ) {
          for (; w.length; ) w.shift()(p);
          f?.[c](),
            i.abort(),
            n && (p || d.forEach((e) => e()), r.nextTick(t, p, m));
        }
      }
      for (let t = 0; t < e.length; t++) {
        const i = e[t],
          o = t < e.length - 1,
          s = t > 0,
          c = o || !1 !== a?.end,
          f = t === e.length - 1;
        if (g(i)) {
          let onError = function (e) {
            e &&
              "AbortError" !== e.name &&
              "ERR_STREAM_PREMATURE_CLOSE" !== e.code &&
              finish(e);
          };
          if (c) {
            const { destroy: e, cleanup: n } = destroyer(i, o, s);
            w.push(e), S(i) && f && d.push(n);
          }
          i.on("error", onError),
            S(i) &&
              f &&
              d.push(() => {
                i.removeListener("error", onError);
              });
        }
        if (0 === t)
          if ("function" == typeof i) {
            if (((y = i({ signal: l })), !T(y)))
              throw new h("Iterable, AsyncIterable or Stream", "source", y);
          } else y = T(i) || _(i) || N(i) ? i : b.from(i);
        else if ("function" == typeof i)
          if (
            ((y = N(y) ? makeAsyncIterable(y?.readable) : makeAsyncIterable(y)),
            (y = i(y, { signal: l })),
            o)
          ) {
            if (!T(y, !0))
              throw new h("AsyncIterable", `transform[${t - 1}]`, y);
          } else {
            x || (x = n("internal/streams/passthrough"));
            const e = new x({ objectMode: !0 }),
              t = y?.then;
            if ("function" == typeof t)
              A++,
                t.call(
                  y,
                  (n) => {
                    (m = n),
                      null != n && e.write(n),
                      c && e.end(),
                      r.nextTick(finish);
                  },
                  (n) => {
                    e.destroy(n), r.nextTick(finish, n);
                  }
                );
            else if (T(y, !0)) A++, pumpToNode(y, e, finish, { end: c });
            else {
              if (!k(y) && !N(y))
                throw new h("AsyncIterable or Promise", "destination", y);
              {
                const n = y.readable || y;
                A++, pumpToNode(n, e, finish, { end: c });
              }
            }
            y = e;
            const { destroy: a, cleanup: i } = destroyer(y, !1, !0);
            w.push(a), f && d.push(i);
          }
        else if (g(i)) {
          if (_(y)) {
            A += 2;
            const e = pipe(y, i, finish, { end: c });
            S(i) && f && d.push(e);
          } else if (N(y) || k(y)) {
            const e = y.readable || y;
            A++, pumpToNode(e, i, finish, { end: c });
          } else {
            if (!T(y))
              throw new u(
                "val",
                [
                  "Readable",
                  "Iterable",
                  "AsyncIterable",
                  "ReadableStream",
                  "TransformStream",
                ],
                y
              );
            A++, pumpToNode(y, i, finish, { end: c });
          }
          y = i;
        } else if (M(i)) {
          if (_(y)) A++, pumpToWeb(makeAsyncIterable(y), i, finish, { end: c });
          else if (k(y) || T(y)) A++, pumpToWeb(y, i, finish, { end: c });
          else {
            if (!N(y))
              throw new u(
                "val",
                [
                  "Readable",
                  "Iterable",
                  "AsyncIterable",
                  "ReadableStream",
                  "TransformStream",
                ],
                y
              );
            A++, pumpToWeb(y.readable, i, finish, { end: c });
          }
          y = i;
        } else y = b.from(i);
      }
      return (l?.aborted || s?.aborted) && r.nextTick(abort), y;
    }
    function pipe(e, n, t, { end: a }) {
      let i = !1;
      if (
        (n.on("close", () => {
          i || t(new y());
        }),
        e.pipe(n, { end: !1 }),
        a)
      ) {
        let endFn = function () {
          (i = !0), n.end();
        };
        L(e) ? r.nextTick(endFn) : e.once("end", endFn);
      } else t();
      return (
        d(e, { readable: !0, writable: !1 }, (n) => {
          const r = e._readableState;
          n &&
          "ERR_STREAM_PREMATURE_CLOSE" === n.code &&
          r &&
          r.ended &&
          !r.errored &&
          !r.errorEmitted
            ? e.once("end", t).once("error", t)
            : t(n);
        }),
        d(n, { readable: !1, writable: !0 }, t)
      );
    }
    t.exports = {
      pipelineImpl: pipelineImpl,
      pipeline: function pipeline(...e) {
        return pipelineImpl(
          e,
          f(
            (function popCallback(e) {
              return A(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
            })(e)
          )
        );
      },
    };
  },
  "internal/streams/readable": function (e, t, a, r, n, i) {
    "use strict";
    const {
      ArrayPrototypeIndexOf: o,
      NumberIsInteger: d,
      NumberIsNaN: s,
      NumberParseInt: l,
      ObjectDefineProperties: u,
      ObjectKeys: b,
      ObjectSetPrototypeOf: c,
      Promise: p,
      SafeSet: h,
      SymbolAsyncDispose: f,
      SymbolAsyncIterator: m,
      Symbol: g,
    } = i;
    (a.exports = Readable), (Readable.ReadableState = ReadableState);
    const _ = t("events"),
      { Stream: R, prependListener: y } = t("internal/streams/legacy"),
      { Buffer: w } = t("buffer"),
      { addAbortSignal: S } = t("internal/streams/add-abort-signal"),
      M = t("internal/streams/end-of-stream");
    let D = t("internal/util/debuglog").debuglog("stream", (e) => {
      D = e;
    });
    const k = t("internal/streams/buffer_list"),
      E = t("internal/streams/destroy"),
      { getHighWaterMark: W, getDefaultHighWaterMark: L } = t(
        "internal/streams/state"
      ),
      {
        aggregateTwoErrors: T,
        codes: {
          ERR_INVALID_ARG_TYPE: A,
          ERR_METHOD_NOT_IMPLEMENTED: v,
          ERR_OUT_OF_RANGE: B,
          ERR_STREAM_PUSH_AFTER_EOF: N,
          ERR_STREAM_UNSHIFT_AFTER_END_EVENT: j,
        },
        AbortError: O,
      } = t("internal/errors"),
      { validateObject: x } = t("internal/validators"),
      C = g("kPaused"),
      { StringDecoder: I } = t("string_decoder"),
      F = t("internal/streams/from");
    c(Readable.prototype, R.prototype), c(Readable, R);
    const nop = () => {},
      { errorOrDestroy: P } = E,
      H = 1,
      U = 16,
      z = 32,
      G = 64,
      V = 2048,
      K = 4096,
      Y = 65536;
    function makeBitMapDescriptor(e) {
      return {
        enumerable: !1,
        get() {
          return 0 != (this.state & e);
        },
        set(t) {
          t ? (this.state |= e) : (this.state &= ~e);
        },
      };
    }
    function ReadableState(e, t, a) {
      "boolean" != typeof a && (a = t instanceof R.Duplex),
        (this.state = V | K | U | z),
        e && e.objectMode && (this.state |= H),
        a && e && e.readableObjectMode && (this.state |= H),
        (this.highWaterMark = e
          ? W(this, e, "readableHighWaterMark", a)
          : L(!1)),
        (this.buffer = new k()),
        (this.length = 0),
        (this.pipes = []),
        (this.flowing = null),
        (this[C] = null),
        e && !1 === e.emitClose && (this.state &= ~V),
        e && !1 === e.autoDestroy && (this.state &= ~K),
        (this.errored = null),
        (this.defaultEncoding = (e && e.defaultEncoding) || "utf8"),
        (this.awaitDrainWriters = null),
        (this.decoder = null),
        (this.encoding = null),
        e &&
          e.encoding &&
          ((this.decoder = new I(e.encoding)), (this.encoding = e.encoding));
    }
    function Readable(e) {
      if (!(this instanceof Readable)) return new Readable(e);
      const t = this instanceof R.Duplex;
      (this._readableState = new ReadableState(e, this, t)),
        e &&
          ("function" == typeof e.read && (this._read = e.read),
          "function" == typeof e.destroy && (this._destroy = e.destroy),
          "function" == typeof e.construct && (this._construct = e.construct),
          e.signal && !t && S(e.signal, this)),
        R.call(this, e),
        E.construct(this, () => {
          this._readableState.needReadable &&
            maybeReadMore(this, this._readableState);
        });
    }
    function readableAddChunk(e, t, a, r) {
      D("readableAddChunk", t);
      const n = e._readableState;
      let i;
      if (
        (0 == (n.state & H) &&
          ("string" == typeof t
            ? ((a = a || n.defaultEncoding),
              n.encoding !== a &&
                (r && n.encoding
                  ? (t = w.from(t, a).toString(n.encoding))
                  : ((t = w.from(t, a)), (a = ""))))
            : t instanceof w
            ? (a = "")
            : R._isUint8Array(t)
            ? ((t = R._uint8ArrayToBuffer(t)), (a = ""))
            : null != t &&
              (i = new A("chunk", ["string", "Buffer", "Uint8Array"], t))),
        i)
      )
        P(e, i);
      else if (null === t)
        (n.state &= -9),
          (function onEofChunk(e, t) {
            if ((D("onEofChunk"), t.ended)) return;
            if (t.decoder) {
              const e = t.decoder.end();
              e &&
                e.length &&
                (t.buffer.push(e), (t.length += t.objectMode ? 1 : e.length));
            }
            (t.ended = !0),
              t.sync
                ? emitReadable(e)
                : ((t.needReadable = !1),
                  (t.emittedReadable = !0),
                  emitReadable_(e));
          })(e, n);
      else if (0 != (n.state & H) || (t && t.length > 0))
        if (r)
          if (0 != (4 & n.state)) P(e, new j());
          else {
            if (n.destroyed || n.errored) return !1;
            addChunk(e, n, t, !0);
          }
        else if (n.ended) P(e, new N());
        else {
          if (n.destroyed || n.errored) return !1;
          (n.state &= -9),
            n.decoder && !a
              ? ((t = n.decoder.write(t)),
                n.objectMode || 0 !== t.length
                  ? addChunk(e, n, t, !1)
                  : maybeReadMore(e, n))
              : addChunk(e, n, t, !1);
        }
      else r || ((n.state &= -9), maybeReadMore(e, n));
      return !n.ended && (n.length < n.highWaterMark || 0 === n.length);
    }
    function addChunk(e, t, a, r) {
      t.flowing && 0 === t.length && !t.sync && e.listenerCount("data") > 0
        ? (0 != (t.state & Y)
            ? t.awaitDrainWriters.clear()
            : (t.awaitDrainWriters = null),
          (t.dataEmitted = !0),
          e.emit("data", a))
        : ((t.length += t.objectMode ? 1 : a.length),
          r ? t.buffer.unshift(a) : t.buffer.push(a),
          0 != (t.state & G) && emitReadable(e)),
        maybeReadMore(e, t);
    }
    u(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(H),
      ended: makeBitMapDescriptor(2),
      endEmitted: makeBitMapDescriptor(4),
      reading: makeBitMapDescriptor(8),
      constructed: makeBitMapDescriptor(U),
      sync: makeBitMapDescriptor(z),
      needReadable: makeBitMapDescriptor(G),
      emittedReadable: makeBitMapDescriptor(128),
      readableListening: makeBitMapDescriptor(256),
      resumeScheduled: makeBitMapDescriptor(512),
      errorEmitted: makeBitMapDescriptor(1024),
      emitClose: makeBitMapDescriptor(V),
      autoDestroy: makeBitMapDescriptor(K),
      destroyed: makeBitMapDescriptor(8192),
      closed: makeBitMapDescriptor(16384),
      closeEmitted: makeBitMapDescriptor(32768),
      multiAwaitDrain: makeBitMapDescriptor(Y),
      readingMore: makeBitMapDescriptor(1 << 17),
      dataEmitted: makeBitMapDescriptor(1 << 18),
    }),
      (Readable.prototype.destroy = E.destroy),
      (Readable.prototype._undestroy = E.undestroy),
      (Readable.prototype._destroy = function (e, t) {
        t(e);
      }),
      (Readable.prototype[_.captureRejectionSymbol] = function (e) {
        this.destroy(e);
      }),
      (Readable.prototype[f] = function () {
        let e;
        return (
          this.destroyed ||
            ((e = this.readableEnded ? null : new O()), this.destroy(e)),
          new p((t, a) => M(this, (r) => (r && r !== e ? a(r) : t(null))))
        );
      }),
      (Readable.prototype.push = function (e, t) {
        return readableAddChunk(this, e, t, !1);
      }),
      (Readable.prototype.unshift = function (e, t) {
        return readableAddChunk(this, e, t, !0);
      }),
      (Readable.prototype.isPaused = function () {
        const e = this._readableState;
        return !0 === e[C] || !1 === e.flowing;
      }),
      (Readable.prototype.setEncoding = function (e) {
        const t = new I(e);
        (this._readableState.decoder = t),
          (this._readableState.encoding = this._readableState.decoder.encoding);
        const a = this._readableState.buffer;
        let r = "";
        for (const e of a) r += t.write(e);
        return (
          a.clear(),
          "" !== r && a.push(r),
          (this._readableState.length = r.length),
          this
        );
      });
    function howMuchToRead(e, t) {
      return e <= 0 || (0 === t.length && t.ended)
        ? 0
        : 0 != (t.state & H)
        ? 1
        : s(e)
        ? t.flowing && t.length
          ? t.buffer.first().length
          : t.length
        : e <= t.length
        ? e
        : t.ended
        ? t.length
        : 0;
    }
    function emitReadable(e) {
      const t = e._readableState;
      D("emitReadable", t.needReadable, t.emittedReadable),
        (t.needReadable = !1),
        t.emittedReadable ||
          (D("emitReadable", t.flowing),
          (t.emittedReadable = !0),
          r.nextTick(emitReadable_, e));
    }
    function emitReadable_(e) {
      const t = e._readableState;
      D("emitReadable_", t.destroyed, t.length, t.ended),
        t.destroyed ||
          t.errored ||
          (!t.length && !t.ended) ||
          (e.emit("readable"), (t.emittedReadable = !1)),
        (t.needReadable =
          !t.flowing && !t.ended && t.length <= t.highWaterMark),
        flow(e);
    }
    function maybeReadMore(e, t) {
      !t.readingMore &&
        t.constructed &&
        ((t.readingMore = !0), r.nextTick(maybeReadMore_, e, t));
    }
    function maybeReadMore_(e, t) {
      for (
        ;
        !t.reading &&
        !t.ended &&
        (t.length < t.highWaterMark || (t.flowing && 0 === t.length));

      ) {
        const a = t.length;
        if ((D("maybeReadMore read 0"), e.read(0), a === t.length)) break;
      }
      t.readingMore = !1;
    }
    function updateReadableListening(e) {
      const t = e._readableState;
      (t.readableListening = e.listenerCount("readable") > 0),
        t.resumeScheduled && !1 === t[C]
          ? (t.flowing = !0)
          : e.listenerCount("data") > 0
          ? e.resume()
          : t.readableListening || (t.flowing = null);
    }
    function nReadingNextTick(e) {
      D("readable nexttick read 0"), e.read(0);
    }
    function resume_(e, t) {
      D("resume", t.reading),
        t.reading || e.read(0),
        (t.resumeScheduled = !1),
        e.emit("resume"),
        flow(e),
        t.flowing && !t.reading && e.read(0);
    }
    function flow(e) {
      const t = e._readableState;
      for (D("flow", t.flowing); t.flowing && null !== e.read(); );
    }
    function streamToAsyncIterator(e, t) {
      "function" != typeof e.read && (e = Readable.wrap(e, { objectMode: !0 }));
      const a = (async function* createAsyncIterator(e, t) {
        let a,
          r = nop;
        function next(t) {
          this === e ? (r(), (r = nop)) : (r = t);
        }
        e.on("readable", next);
        const n = M(e, { writable: !1 }, (e) => {
          (a = e ? T(a, e) : null), r(), (r = nop);
        });
        try {
          for (;;) {
            const t = e.destroyed ? null : e.read();
            if (null !== t) yield t;
            else {
              if (a) throw a;
              if (null === a) return;
              await new p(next);
            }
          }
        } catch (e) {
          throw ((a = T(a, e)), a);
        } finally {
          (!a && !1 === t?.destroyOnReturn) ||
          (void 0 !== a && !e._readableState.autoDestroy)
            ? (e.off("readable", next), n())
            : E.destroyer(e, null);
        }
      })(e, t);
      return (a.stream = e), a;
    }
    function fromList(e, t) {
      if (0 === t.length) return null;
      let a;
      return (
        t.objectMode
          ? (a = t.buffer.shift())
          : !e || e >= t.length
          ? ((a = t.decoder
              ? t.buffer.join("")
              : 1 === t.buffer.length
              ? t.buffer.first()
              : t.buffer.concat(t.length)),
            t.buffer.clear())
          : (a = t.buffer.consume(e, t.decoder)),
        a
      );
    }
    function endReadable(e) {
      const t = e._readableState;
      D("endReadable", t.endEmitted),
        t.endEmitted || ((t.ended = !0), r.nextTick(endReadableNT, t, e));
    }
    function endReadableNT(e, t) {
      if (
        (D("endReadableNT", e.endEmitted, e.length),
        !e.errored && !e.closeEmitted && !e.endEmitted && 0 === e.length)
      )
        if (
          ((e.endEmitted = !0),
          t.emit("end"),
          t.writable && !1 === t.allowHalfOpen)
        )
          r.nextTick(endWritableNT, t);
        else if (e.autoDestroy) {
          const e = t._writableState;
          (!e || (e.autoDestroy && (e.finished || !1 === e.writable))) &&
            t.destroy();
        }
    }
    function endWritableNT(e) {
      e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    let q;
    function lazyWebStreams() {
      return void 0 === q && (q = t("internal/webstreams/adapters")), q;
    }
    (Readable.prototype.read = function (e) {
      D("read", e), void 0 === e ? (e = NaN) : d(e) || (e = l(e, 10));
      const t = this._readableState,
        a = e;
      if (
        (e > t.highWaterMark &&
          (t.highWaterMark = (function computeNewHighWaterMark(e) {
            if (e > 1073741824) throw new B("size", "<= 1GiB", e);
            return (
              e--,
              (e |= e >>> 1),
              (e |= e >>> 2),
              (e |= e >>> 4),
              (e |= e >>> 8),
              (e |= e >>> 16),
              ++e
            );
          })(e)),
        0 !== e && (t.state &= -129),
        0 === e &&
          t.needReadable &&
          ((0 !== t.highWaterMark
            ? t.length >= t.highWaterMark
            : t.length > 0) ||
            t.ended))
      )
        return (
          D("read: emitReadable", t.length, t.ended),
          0 === t.length && t.ended ? endReadable(this) : emitReadable(this),
          null
        );
      if (0 === (e = howMuchToRead(e, t)) && t.ended)
        return 0 === t.length && endReadable(this), null;
      let r,
        n = 0 != (t.state & G);
      if (
        (D("need readable", n),
        (0 === t.length || t.length - e < t.highWaterMark) &&
          ((n = !0), D("length less than watermark", n)),
        t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
      )
        (n = !1), D("reading, ended or constructing", n);
      else if (n) {
        D("do read"), (t.state |= 8 | z), 0 === t.length && (t.state |= G);
        try {
          this._read(t.highWaterMark);
        } catch (e) {
          P(this, e);
        }
        (t.state &= ~z), t.reading || (e = howMuchToRead(a, t));
      }
      return (
        (r = e > 0 ? fromList(e, t) : null),
        null === r
          ? ((t.needReadable = t.length <= t.highWaterMark), (e = 0))
          : ((t.length -= e),
            t.multiAwaitDrain
              ? t.awaitDrainWriters.clear()
              : (t.awaitDrainWriters = null)),
        0 === t.length &&
          (t.ended || (t.needReadable = !0),
          a !== e && t.ended && endReadable(this)),
        null === r ||
          t.errorEmitted ||
          t.closeEmitted ||
          ((t.dataEmitted = !0), this.emit("data", r)),
        r
      );
    }),
      (Readable.prototype._read = function (e) {
        throw new v("_read()");
      }),
      (Readable.prototype.pipe = function (e, t) {
        const a = this,
          n = this._readableState;
        1 === n.pipes.length &&
          (n.multiAwaitDrain ||
            ((n.multiAwaitDrain = !0),
            (n.awaitDrainWriters = new h(
              n.awaitDrainWriters ? [n.awaitDrainWriters] : []
            )))),
          n.pipes.push(e),
          D("pipe count=%d opts=%j", n.pipes.length, t);
        const i =
          (!t || !1 !== t.end) && e !== r.stdout && e !== r.stderr
            ? onend
            : unpipe;
        function onunpipe(t, r) {
          D("onunpipe"),
            t === a &&
              r &&
              !1 === r.hasUnpiped &&
              ((r.hasUnpiped = !0),
              (function cleanup() {
                D("cleanup"),
                  e.removeListener("close", onclose),
                  e.removeListener("finish", onfinish),
                  o && e.removeListener("drain", o);
                e.removeListener("error", onerror),
                  e.removeListener("unpipe", onunpipe),
                  a.removeListener("end", onend),
                  a.removeListener("end", unpipe),
                  a.removeListener("data", ondata),
                  (d = !0),
                  o &&
                    n.awaitDrainWriters &&
                    (!e._writableState || e._writableState.needDrain) &&
                    o();
              })());
        }
        function onend() {
          D("onend"), e.end();
        }
        let o;
        n.endEmitted ? r.nextTick(i) : a.once("end", i),
          e.on("unpipe", onunpipe);
        let d = !1;
        function pause() {
          d ||
            (1 === n.pipes.length && n.pipes[0] === e
              ? (D("false write response, pause", 0),
                (n.awaitDrainWriters = e),
                (n.multiAwaitDrain = !1))
              : n.pipes.length > 1 &&
                n.pipes.includes(e) &&
                (D("false write response, pause", n.awaitDrainWriters.size),
                n.awaitDrainWriters.add(e)),
            a.pause()),
            o ||
              ((o = (function pipeOnDrain(e, t) {
                return function pipeOnDrainFunctionResult() {
                  const a = e._readableState;
                  a.awaitDrainWriters === t
                    ? (D("pipeOnDrain", 1), (a.awaitDrainWriters = null))
                    : a.multiAwaitDrain &&
                      (D("pipeOnDrain", a.awaitDrainWriters.size),
                      a.awaitDrainWriters.delete(t)),
                    (a.awaitDrainWriters && 0 !== a.awaitDrainWriters.size) ||
                      !e.listenerCount("data") ||
                      e.resume();
                };
              })(a, e)),
              e.on("drain", o));
        }
        function ondata(t) {
          D("ondata");
          const a = e.write(t);
          D("dest.write", a), !1 === a && pause();
        }
        function onerror(t) {
          if (
            (D("onerror", t),
            unpipe(),
            e.removeListener("error", onerror),
            0 === e.listenerCount("error"))
          ) {
            const a = e._writableState || e._readableState;
            a && !a.errorEmitted ? P(e, t) : e.emit("error", t);
          }
        }
        function onclose() {
          e.removeListener("finish", onfinish), unpipe();
        }
        function onfinish() {
          D("onfinish"), e.removeListener("close", onclose), unpipe();
        }
        function unpipe() {
          D("unpipe"), a.unpipe(e);
        }
        return (
          a.on("data", ondata),
          y(e, "error", onerror),
          e.once("close", onclose),
          e.once("finish", onfinish),
          e.emit("pipe", a),
          !0 === e.writableNeedDrain
            ? pause()
            : n.flowing || (D("pipe resume"), a.resume()),
          e
        );
      }),
      (Readable.prototype.unpipe = function (e) {
        const t = this._readableState;
        if (0 === t.pipes.length) return this;
        if (!e) {
          const e = t.pipes;
          (t.pipes = []), this.pause();
          for (let t = 0; t < e.length; t++)
            e[t].emit("unpipe", this, { hasUnpiped: !1 });
          return this;
        }
        const a = o(t.pipes, e);
        return (
          -1 === a ||
            (t.pipes.splice(a, 1),
            0 === t.pipes.length && this.pause(),
            e.emit("unpipe", this, { hasUnpiped: !1 })),
          this
        );
      }),
      (Readable.prototype.on = function (e, t) {
        const a = R.prototype.on.call(this, e, t),
          n = this._readableState;
        return (
          "data" === e
            ? ((n.readableListening = this.listenerCount("readable") > 0),
              !1 !== n.flowing && this.resume())
            : "readable" === e &&
              (n.endEmitted ||
                n.readableListening ||
                ((n.readableListening = n.needReadable = !0),
                (n.flowing = !1),
                (n.emittedReadable = !1),
                D("on readable", n.length, n.reading),
                n.length
                  ? emitReadable(this)
                  : n.reading || r.nextTick(nReadingNextTick, this))),
          a
        );
      }),
      (Readable.prototype.addListener = Readable.prototype.on),
      (Readable.prototype.removeListener = function (e, t) {
        const a = R.prototype.removeListener.call(this, e, t);
        return "readable" === e && r.nextTick(updateReadableListening, this), a;
      }),
      (Readable.prototype.off = Readable.prototype.removeListener),
      (Readable.prototype.removeAllListeners = function (e) {
        const t = R.prototype.removeAllListeners.apply(this, arguments);
        return (
          ("readable" !== e && void 0 !== e) ||
            r.nextTick(updateReadableListening, this),
          t
        );
      }),
      (Readable.prototype.resume = function () {
        const e = this._readableState;
        return (
          e.flowing ||
            (D("resume"),
            (e.flowing = !e.readableListening),
            (function resume(e, t) {
              t.resumeScheduled ||
                ((t.resumeScheduled = !0), r.nextTick(resume_, e, t));
            })(this, e)),
          (e[C] = !1),
          this
        );
      }),
      (Readable.prototype.pause = function () {
        return (
          D("call pause flowing=%j", this._readableState.flowing),
          !1 !== this._readableState.flowing &&
            (D("pause"),
            (this._readableState.flowing = !1),
            this.emit("pause")),
          (this._readableState[C] = !0),
          this
        );
      }),
      (Readable.prototype.wrap = function (e) {
        let t = !1;
        e.on("data", (a) => {
          !this.push(a) && e.pause && ((t = !0), e.pause());
        }),
          e.on("end", () => {
            this.push(null);
          }),
          e.on("error", (e) => {
            P(this, e);
          }),
          e.on("close", () => {
            this.destroy();
          }),
          e.on("destroy", () => {
            this.destroy();
          }),
          (this._read = () => {
            t && e.resume && ((t = !1), e.resume());
          });
        const a = b(e);
        for (let t = 1; t < a.length; t++) {
          const r = a[t];
          void 0 === this[r] &&
            "function" == typeof e[r] &&
            (this[r] = e[r].bind(e));
        }
        return this;
      }),
      (Readable.prototype[m] = function () {
        return streamToAsyncIterator(this);
      }),
      (Readable.prototype.iterator = function (e) {
        return void 0 !== e && x(e, "options"), streamToAsyncIterator(this, e);
      }),
      u(Readable.prototype, {
        readable: {
          __proto__: null,
          get() {
            const e = this._readableState;
            return !(
              !e ||
              !1 === e.readable ||
              e.destroyed ||
              e.errorEmitted ||
              e.endEmitted
            );
          },
          set(e) {
            this._readableState && (this._readableState.readable = !!e);
          },
        },
        readableDidRead: {
          __proto__: null,
          enumerable: !1,
          get: function () {
            return this._readableState.dataEmitted;
          },
        },
        readableAborted: {
          __proto__: null,
          enumerable: !1,
          get: function () {
            return !(
              !1 === this._readableState.readable ||
              (!this._readableState.destroyed &&
                !this._readableState.errored) ||
              this._readableState.endEmitted
            );
          },
        },
        readableHighWaterMark: {
          __proto__: null,
          enumerable: !1,
          get: function () {
            return this._readableState.highWaterMark;
          },
        },
        readableBuffer: {
          __proto__: null,
          enumerable: !1,
          get: function () {
            return this._readableState && this._readableState.buffer;
          },
        },
        readableFlowing: {
          __proto__: null,
          enumerable: !1,
          get: function () {
            return this._readableState.flowing;
          },
          set: function (e) {
            this._readableState && (this._readableState.flowing = e);
          },
        },
        readableLength: {
          __proto__: null,
          enumerable: !1,
          get() {
            return this._readableState.length;
          },
        },
        readableObjectMode: {
          __proto__: null,
          enumerable: !1,
          get() {
            return !!this._readableState && this._readableState.objectMode;
          },
        },
        readableEncoding: {
          __proto__: null,
          enumerable: !1,
          get() {
            return this._readableState ? this._readableState.encoding : null;
          },
        },
        errored: {
          __proto__: null,
          enumerable: !1,
          get() {
            return this._readableState ? this._readableState.errored : null;
          },
        },
        closed: {
          __proto__: null,
          get() {
            return !!this._readableState && this._readableState.closed;
          },
        },
        destroyed: {
          __proto__: null,
          enumerable: !1,
          get() {
            return !!this._readableState && this._readableState.destroyed;
          },
          set(e) {
            this._readableState && (this._readableState.destroyed = e);
          },
        },
        readableEnded: {
          __proto__: null,
          enumerable: !1,
          get() {
            return !!this._readableState && this._readableState.endEmitted;
          },
        },
      }),
      u(ReadableState.prototype, {
        pipesCount: {
          __proto__: null,
          get() {
            return this.pipes.length;
          },
        },
        paused: {
          __proto__: null,
          get() {
            return !1 !== this[C];
          },
          set(e) {
            this[C] = !!e;
          },
        },
      }),
      (Readable._fromList = fromList),
      (Readable.from = function (e, t) {
        return F(Readable, e, t);
      }),
      (Readable.fromWeb = function (e, t) {
        return lazyWebStreams().newStreamReadableFromReadableStream(e, t);
      }),
      (Readable.toWeb = function (e, t) {
        return lazyWebStreams().newReadableStreamFromStreamReadable(e, t);
      }),
      (Readable.wrap = function (e, t) {
        return new Readable({
          objectMode: e.readableObjectMode ?? e.objectMode ?? !0,
          ...t,
          destroy(t, a) {
            E.destroyer(e, t), a(t);
          },
        }).wrap(e);
      });
  },
  "internal/streams/state": function (t, e, r, a, n, i) {
    "use strict";
    const { MathFloor: o, NumberIsInteger: u } = i,
      { validateInteger: g } = e("internal/validators"),
      { ERR_INVALID_ARG_VALUE: l } = e("internal/errors").codes;
    let h = 16384,
      M = 16;
    function getDefaultHighWaterMark(t) {
      return t ? M : h;
    }
    r.exports = {
      getHighWaterMark: function getHighWaterMark(t, e, r, a) {
        const n = (function highWaterMarkFrom(t, e, r) {
          return null != t.highWaterMark ? t.highWaterMark : e ? t[r] : null;
        })(e, a, r);
        if (null != n) {
          if (!u(n) || n < 0) {
            throw new l(a ? `options.${r}` : "options.highWaterMark", n);
          }
          return o(n);
        }
        return getDefaultHighWaterMark(t.objectMode);
      },
      getDefaultHighWaterMark: getDefaultHighWaterMark,
      setDefaultHighWaterMark: function setDefaultHighWaterMark(t, e) {
        g(e, "value", 0), t ? (M = e) : (h = e);
      },
    };
  },
  "internal/streams/transform": function (t, r, n, s, i, a) {
    "use strict";
    const { ObjectSetPrototypeOf: e, Symbol: o } = a;
    n.exports = Transform;
    const { ERR_METHOD_NOT_IMPLEMENTED: h } = r("internal/errors").codes,
      l = r("internal/streams/duplex"),
      { getHighWaterMark: f } = r("internal/streams/state");
    e(Transform.prototype, l.prototype), e(Transform, l);
    const u = o("kCallback");
    function Transform(t) {
      if (!(this instanceof Transform)) return new Transform(t);
      const r = t ? f(this, t, "readableHighWaterMark", !0) : null;
      0 === r &&
        (t = {
          ...t,
          highWaterMark: null,
          readableHighWaterMark: r,
          writableHighWaterMark: t.writableHighWaterMark || 0,
        }),
        l.call(this, t),
        (this._readableState.sync = !1),
        (this[u] = null),
        t &&
          ("function" == typeof t.transform && (this._transform = t.transform),
          "function" == typeof t.flush && (this._flush = t.flush)),
        this.on("prefinish", prefinish);
    }
    function final(t) {
      "function" != typeof this._flush || this.destroyed
        ? (this.push(null), t && t())
        : this._flush((r, n) => {
            r
              ? t
                ? t(r)
                : this.destroy(r)
              : (null != n && this.push(n), this.push(null), t && t());
          });
    }
    function prefinish() {
      this._final !== final && final.call(this);
    }
    (Transform.prototype._final = final),
      (Transform.prototype._transform = function (t, r, n) {
        throw new h("_transform()");
      }),
      (Transform.prototype._write = function (t, r, n) {
        const s = this._readableState,
          i = this._writableState,
          a = s.length;
        this._transform(t, r, (t, r) => {
          t
            ? n(t)
            : (null != r && this.push(r),
              i.ended || a === s.length || s.length < s.highWaterMark
                ? n()
                : (this[u] = n));
        });
      }),
      (Transform.prototype._read = function () {
        if (this[u]) {
          const t = this[u];
          (this[u] = null), t();
        }
      });
  },
  "internal/streams/utils": function (e, t, r, o, i, n) {
    "use strict";
    const { SymbolAsyncIterator: a, SymbolIterator: l, SymbolFor: d } = n,
      s = d("nodejs.stream.destroyed"),
      u = d("nodejs.stream.errored"),
      b = d("nodejs.stream.readable"),
      f = d("nodejs.stream.writable"),
      c = d("nodejs.stream.disturbed"),
      S = d("nodejs.webstream.isClosedPromise"),
      m = d("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(e, t = !1) {
      return !(
        !e ||
        "function" != typeof e.pipe ||
        "function" != typeof e.on ||
        (t &&
          ("function" != typeof e.pause || "function" != typeof e.resume)) ||
        (e._writableState && !1 === e._readableState?.readable) ||
        (e._writableState && !e._readableState)
      );
    }
    function isWritableNodeStream(e) {
      return !(
        !e ||
        "function" != typeof e.write ||
        "function" != typeof e.on ||
        (e._readableState && !1 === e._writableState?.writable)
      );
    }
    function isNodeStream(e) {
      return (
        e &&
        (e._readableState ||
          e._writableState ||
          ("function" == typeof e.write && "function" == typeof e.on) ||
          ("function" == typeof e.pipe && "function" == typeof e.on))
      );
    }
    function isReadableStream(e) {
      return !(
        !e ||
        isNodeStream(e) ||
        "function" != typeof e.pipeThrough ||
        "function" != typeof e.getReader ||
        "function" != typeof e.cancel
      );
    }
    function isWritableStream(e) {
      return !(
        !e ||
        isNodeStream(e) ||
        "function" != typeof e.getWriter ||
        "function" != typeof e.abort
      );
    }
    function isTransformStream(e) {
      return !(
        !e ||
        isNodeStream(e) ||
        "object" != typeof e.readable ||
        "object" != typeof e.writable
      );
    }
    function isDestroyed(e) {
      if (!isNodeStream(e)) return null;
      const t = e._writableState,
        r = e._readableState,
        o = t || r;
      return !!(e.destroyed || e[s] || o?.destroyed);
    }
    function isWritableEnded(e) {
      if (!isWritableNodeStream(e)) return null;
      if (!0 === e.writableEnded) return !0;
      const t = e._writableState;
      return !t?.errored && ("boolean" != typeof t?.ended ? null : t.ended);
    }
    function isReadableFinished(e, t) {
      if (!isReadableNodeStream(e)) return null;
      const r = e._readableState;
      return (
        !r?.errored &&
        ("boolean" != typeof r?.endEmitted
          ? null
          : !!(r.endEmitted || (!1 === t && !0 === r.ended && 0 === r.length)))
      );
    }
    function isReadable(e) {
      return e && null != e[b]
        ? e[b]
        : "boolean" != typeof e?.readable
        ? null
        : !isDestroyed(e) &&
          isReadableNodeStream(e) &&
          e.readable &&
          !isReadableFinished(e);
    }
    function isWritable(e) {
      return e && null != e[f]
        ? e[f]
        : "boolean" != typeof e?.writable
        ? null
        : !isDestroyed(e) &&
          isWritableNodeStream(e) &&
          e.writable &&
          !isWritableEnded(e);
    }
    function isOutgoingMessage(e) {
      return (
        "boolean" == typeof e._closed &&
        "boolean" == typeof e._defaultKeepAlive &&
        "boolean" == typeof e._removedConnection &&
        "boolean" == typeof e._removedContLen
      );
    }
    function isServerResponse(e) {
      return "boolean" == typeof e._sent100 && isOutgoingMessage(e);
    }
    r.exports = {
      isDestroyed: isDestroyed,
      kIsDestroyed: s,
      isDisturbed: function isDisturbed(e) {
        return !(!e || !(e[c] ?? (e.readableDidRead || e.readableAborted)));
      },
      kIsDisturbed: c,
      isErrored: function isErrored(e) {
        return !(
          !e ||
          !(
            e[u] ??
            e.readableErrored ??
            e.writableErrored ??
            e._readableState?.errorEmitted ??
            e._writableState?.errorEmitted ??
            e._readableState?.errored ??
            e._writableState?.errored
          )
        );
      },
      kIsErrored: u,
      isReadable: isReadable,
      kIsReadable: b,
      kIsClosedPromise: S,
      kControllerErrorFunction: m,
      kIsWritable: f,
      isClosed: function isClosed(e) {
        if (!isNodeStream(e)) return null;
        if ("boolean" == typeof e.closed) return e.closed;
        const t = e._writableState,
          r = e._readableState;
        return "boolean" == typeof t?.closed || "boolean" == typeof r?.closed
          ? t?.closed || r?.closed
          : "boolean" == typeof e._closed && isOutgoingMessage(e)
          ? e._closed
          : null;
      },
      isDuplexNodeStream: function isDuplexNodeStream(e) {
        return !(
          !e ||
          "function" != typeof e.pipe ||
          !e._readableState ||
          "function" != typeof e.on ||
          "function" != typeof e.write
        );
      },
      isFinished: function isFinished(e, t) {
        return isNodeStream(e)
          ? !!isDestroyed(e) ||
              ((!1 === t?.readable || !isReadable(e)) &&
                (!1 === t?.writable || !isWritable(e)))
          : null;
      },
      isIterable: function isIterable(e, t) {
        return (
          null != e &&
          (!0 === t
            ? "function" == typeof e[a]
            : !1 === t
            ? "function" == typeof e[l]
            : "function" == typeof e[a] || "function" == typeof e[l])
        );
      },
      isReadableNodeStream: isReadableNodeStream,
      isReadableStream: isReadableStream,
      isReadableEnded: function isReadableEnded(e) {
        if (!isReadableNodeStream(e)) return null;
        if (!0 === e.readableEnded) return !0;
        const t = e._readableState;
        return (
          !(!t || t.errored) && ("boolean" != typeof t?.ended ? null : t.ended)
        );
      },
      isReadableFinished: isReadableFinished,
      isReadableErrored: function isReadableErrored(e) {
        return isNodeStream(e)
          ? e.readableErrored
            ? e.readableErrored
            : e._readableState?.errored ?? null
          : null;
      },
      isNodeStream: isNodeStream,
      isWebStream: function isWebStream(e) {
        return (
          isReadableStream(e) || isWritableStream(e) || isTransformStream(e)
        );
      },
      isWritable: isWritable,
      isWritableNodeStream: isWritableNodeStream,
      isWritableStream: isWritableStream,
      isWritableEnded: isWritableEnded,
      isWritableFinished: function isWritableFinished(e, t) {
        if (!isWritableNodeStream(e)) return null;
        if (!0 === e.writableFinished) return !0;
        const r = e._writableState;
        return (
          !r?.errored &&
          ("boolean" != typeof r?.finished
            ? null
            : !!(r.finished || (!1 === t && !0 === r.ended && 0 === r.length)))
        );
      },
      isWritableErrored: function isWritableErrored(e) {
        return isNodeStream(e)
          ? e.writableErrored
            ? e.writableErrored
            : e._writableState?.errored ?? null
          : null;
      },
      isServerRequest: function isServerRequest(e) {
        return (
          "boolean" == typeof e._consuming &&
          "boolean" == typeof e._dumped &&
          void 0 === e.req?.upgradeOrConnect
        );
      },
      isServerResponse: isServerResponse,
      willEmitClose: function willEmitClose(e) {
        if (!isNodeStream(e)) return null;
        const t = e._writableState,
          r = e._readableState,
          o = t || r;
        return (
          (!o && isServerResponse(e)) ||
          !!(o && o.autoDestroy && o.emitClose && !1 === o.closed)
        );
      },
      isTransformStream: isTransformStream,
    };
  },
  "internal/streams/writable": function (e, t, r, i, n, o) {
    "use strict";
    const {
      ArrayPrototypeSlice: s,
      Error: l,
      FunctionPrototypeSymbolHasInstance: a,
      ObjectDefineProperty: f,
      ObjectDefineProperties: c,
      ObjectSetPrototypeOf: d,
      StringPrototypeToLowerCase: u,
      Symbol: h,
      SymbolHasInstance: b,
    } = o;
    (r.exports = Writable), (Writable.WritableState = WritableState);
    const _ = t("events"),
      w = t("internal/streams/legacy").Stream,
      { Buffer: p } = t("buffer"),
      g = t("internal/streams/destroy"),
      { addAbortSignal: y } = t("internal/streams/add-abort-signal"),
      { getHighWaterMark: S, getDefaultHighWaterMark: W } = t(
        "internal/streams/state"
      ),
      {
        ERR_INVALID_ARG_TYPE: E,
        ERR_METHOD_NOT_IMPLEMENTED: k,
        ERR_MULTIPLE_CALLBACK: m,
        ERR_STREAM_CANNOT_PIPE: T,
        ERR_STREAM_DESTROYED: M,
        ERR_STREAM_ALREADY_FINISHED: R,
        ERR_STREAM_NULL_VALUES: D,
        ERR_STREAM_WRITE_AFTER_END: I,
        ERR_UNKNOWN_ENCODING: B,
      } = t("internal/errors").codes,
      { errorOrDestroy: A } = g;
    function nop() {}
    d(Writable.prototype, w.prototype), d(Writable, w);
    const N = h("kOnFinished");
    function WritableState(e, t, r) {
      "boolean" != typeof r && (r = t instanceof w.Duplex),
        (this.objectMode = !(!e || !e.objectMode)),
        r &&
          (this.objectMode = this.objectMode || !(!e || !e.writableObjectMode)),
        (this.highWaterMark = e
          ? S(this, e, "writableHighWaterMark", r)
          : W(!1)),
        (this.finalCalled = !1),
        (this.needDrain = !1),
        (this.ending = !1),
        (this.ended = !1),
        (this.finished = !1),
        (this.destroyed = !1);
      const i = !(!e || !1 !== e.decodeStrings);
      (this.decodeStrings = !i),
        (this.defaultEncoding = (e && e.defaultEncoding) || "utf8"),
        (this.length = 0),
        (this.writing = !1),
        (this.corked = 0),
        (this.sync = !0),
        (this.bufferProcessing = !1),
        (this.onwrite = onwrite.bind(void 0, t)),
        (this.writecb = null),
        (this.writelen = 0),
        (this.afterWriteTickInfo = null),
        resetBuffer(this),
        (this.pendingcb = 0),
        (this.constructed = !0),
        (this.prefinished = !1),
        (this.errorEmitted = !1),
        (this.emitClose = !e || !1 !== e.emitClose),
        (this.autoDestroy = !e || !1 !== e.autoDestroy),
        (this.errored = null),
        (this.closed = !1),
        (this.closeEmitted = !1),
        (this[N] = []);
    }
    function resetBuffer(e) {
      (e.buffered = []),
        (e.bufferedIndex = 0),
        (e.allBuffers = !0),
        (e.allNoop = !0);
    }
    function Writable(e) {
      const t = this instanceof w.Duplex;
      if (!t && !a(Writable, this)) return new Writable(e);
      (this._writableState = new WritableState(e, this, t)),
        e &&
          ("function" == typeof e.write && (this._write = e.write),
          "function" == typeof e.writev && (this._writev = e.writev),
          "function" == typeof e.destroy && (this._destroy = e.destroy),
          "function" == typeof e.final && (this._final = e.final),
          "function" == typeof e.construct && (this._construct = e.construct),
          e.signal && y(e.signal, this)),
        w.call(this, e),
        g.construct(this, () => {
          const e = this._writableState;
          e.writing || clearBuffer(this, e), finishMaybe(this, e);
        });
    }
    function _write(e, t, r, n) {
      const o = e._writableState;
      if ("function" == typeof r) (n = r), (r = o.defaultEncoding);
      else {
        if (r) {
          if ("buffer" !== r && !p.isEncoding(r)) throw new B(r);
        } else r = o.defaultEncoding;
        "function" != typeof n && (n = nop);
      }
      if (null === t) throw new D();
      if (!o.objectMode)
        if ("string" == typeof t)
          !1 !== o.decodeStrings && ((t = p.from(t, r)), (r = "buffer"));
        else if (t instanceof p) r = "buffer";
        else {
          if (!w._isUint8Array(t))
            throw new E("chunk", ["string", "Buffer", "Uint8Array"], t);
          (t = w._uint8ArrayToBuffer(t)), (r = "buffer");
        }
      let s;
      return (
        o.ending ? (s = new I()) : o.destroyed && (s = new M("write")),
        s
          ? (i.nextTick(n, s), A(e, s, !0), s)
          : (o.pendingcb++,
            (function writeOrBuffer(e, t, r, i, n) {
              const o = t.objectMode ? 1 : r.length;
              t.length += o;
              const s = t.length < t.highWaterMark;
              s || (t.needDrain = !0);
              t.writing || t.corked || t.errored || !t.constructed
                ? (t.buffered.push({ chunk: r, encoding: i, callback: n }),
                  t.allBuffers && "buffer" !== i && (t.allBuffers = !1),
                  t.allNoop && n !== nop && (t.allNoop = !1))
                : ((t.writelen = o),
                  (t.writecb = n),
                  (t.writing = !0),
                  (t.sync = !0),
                  e._write(r, i, t.onwrite),
                  (t.sync = !1));
              return s && !t.errored && !t.destroyed;
            })(e, o, t, r, n))
      );
    }
    function doWrite(e, t, r, i, n, o, s) {
      (t.writelen = i),
        (t.writecb = s),
        (t.writing = !0),
        (t.sync = !0),
        t.destroyed
          ? t.onwrite(new M("write"))
          : r
          ? e._writev(n, t.onwrite)
          : e._write(n, o, t.onwrite),
        (t.sync = !1);
    }
    function onwriteError(e, t, r, i) {
      --t.pendingcb, i(r), errorBuffer(t), A(e, r);
    }
    function onwrite(e, t) {
      const r = e._writableState,
        n = r.sync,
        o = r.writecb;
      "function" == typeof o
        ? ((r.writing = !1),
          (r.writecb = null),
          (r.length -= r.writelen),
          (r.writelen = 0),
          t
            ? (t.stack,
              r.errored || (r.errored = t),
              e._readableState &&
                !e._readableState.errored &&
                (e._readableState.errored = t),
              n
                ? i.nextTick(onwriteError, e, r, t, o)
                : onwriteError(e, r, t, o))
            : (r.buffered.length > r.bufferedIndex && clearBuffer(e, r),
              n
                ? null !== r.afterWriteTickInfo && r.afterWriteTickInfo.cb === o
                  ? r.afterWriteTickInfo.count++
                  : ((r.afterWriteTickInfo = {
                      count: 1,
                      cb: o,
                      stream: e,
                      state: r,
                    }),
                    i.nextTick(afterWriteTick, r.afterWriteTickInfo))
                : afterWrite(e, r, 1, o)))
        : A(e, new m());
    }
    function afterWriteTick({ stream: e, state: t, count: r, cb: i }) {
      return (t.afterWriteTickInfo = null), afterWrite(e, t, r, i);
    }
    function afterWrite(e, t, r, i) {
      for (
        !t.ending &&
        !e.destroyed &&
        0 === t.length &&
        t.needDrain &&
        ((t.needDrain = !1), e.emit("drain"));
        r-- > 0;

      )
        t.pendingcb--, i();
      t.destroyed && errorBuffer(t), finishMaybe(e, t);
    }
    function errorBuffer(e) {
      if (e.writing) return;
      for (let t = e.bufferedIndex; t < e.buffered.length; ++t) {
        const { chunk: r, callback: i } = e.buffered[t],
          n = e.objectMode ? 1 : r.length;
        (e.length -= n), i(e.errored ?? new M("write"));
      }
      const t = e[N].splice(0);
      for (let r = 0; r < t.length; r++) t[r](e.errored ?? new M("end"));
      resetBuffer(e);
    }
    function clearBuffer(e, t) {
      if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
        return;
      const { buffered: r, bufferedIndex: i, objectMode: n } = t,
        o = r.length - i;
      if (!o) return;
      let l = i;
      if (((t.bufferProcessing = !0), o > 1 && e._writev)) {
        t.pendingcb -= o - 1;
        const i = t.allNoop
            ? nop
            : (e) => {
                for (let t = l; t < r.length; ++t) r[t].callback(e);
              },
          n = t.allNoop && 0 === l ? r : s(r, l);
        (n.allBuffers = t.allBuffers),
          doWrite(e, t, !0, t.length, n, "", i),
          resetBuffer(t);
      } else {
        do {
          const { chunk: i, encoding: o, callback: s } = r[l];
          r[l++] = null;
          doWrite(e, t, !1, n ? 1 : i.length, i, o, s);
        } while (l < r.length && !t.writing);
        l === r.length
          ? resetBuffer(t)
          : l > 256
          ? (r.splice(0, l), (t.bufferedIndex = 0))
          : (t.bufferedIndex = l);
      }
      t.bufferProcessing = !1;
    }
    function needFinish(e) {
      return (
        e.ending &&
        !e.destroyed &&
        e.constructed &&
        0 === e.length &&
        !e.errored &&
        0 === e.buffered.length &&
        !e.finished &&
        !e.writing &&
        !e.errorEmitted &&
        !e.closeEmitted
      );
    }
    function prefinish(e, t) {
      t.prefinished ||
        t.finalCalled ||
        ("function" != typeof e._final || t.destroyed
          ? ((t.prefinished = !0), e.emit("prefinish"))
          : ((t.finalCalled = !0),
            (function callFinal(e, t) {
              let r = !1;
              function onFinish(n) {
                if (r) A(e, n ?? m());
                else if (((r = !0), t.pendingcb--, n)) {
                  const r = t[N].splice(0);
                  for (let e = 0; e < r.length; e++) r[e](n);
                  A(e, n, t.sync);
                } else
                  needFinish(t) &&
                    ((t.prefinished = !0),
                    e.emit("prefinish"),
                    t.pendingcb++,
                    i.nextTick(finish, e, t));
              }
              (t.sync = !0), t.pendingcb++;
              try {
                e._final(onFinish);
              } catch (e) {
                onFinish(e);
              }
              t.sync = !1;
            })(e, t)));
    }
    function finishMaybe(e, t, r) {
      needFinish(t) &&
        (prefinish(e, t),
        0 === t.pendingcb &&
          (r
            ? (t.pendingcb++,
              i.nextTick(
                (e, t) => {
                  needFinish(t) ? finish(e, t) : t.pendingcb--;
                },
                e,
                t
              ))
            : needFinish(t) && (t.pendingcb++, finish(e, t))));
    }
    function finish(e, t) {
      t.pendingcb--, (t.finished = !0);
      const r = t[N].splice(0);
      for (let e = 0; e < r.length; e++) r[e]();
      if ((e.emit("finish"), t.autoDestroy)) {
        const t = e._readableState;
        (!t || (t.autoDestroy && (t.endEmitted || !1 === t.readable))) &&
          e.destroy();
      }
    }
    (WritableState.prototype.getBuffer = function getBuffer() {
      return s(this.buffered, this.bufferedIndex);
    }),
      f(WritableState.prototype, "bufferedRequestCount", {
        __proto__: null,
        get() {
          return this.buffered.length - this.bufferedIndex;
        },
      }),
      f(Writable, b, {
        __proto__: null,
        value: function (e) {
          return (
            !!a(this, e) ||
            (this === Writable &&
              e &&
              e._writableState instanceof WritableState)
          );
        },
      }),
      (Writable.prototype.pipe = function () {
        A(this, new T());
      }),
      (Writable.prototype.write = function (e, t, r) {
        return !0 === _write(this, e, t, r);
      }),
      (Writable.prototype.cork = function () {
        this._writableState.corked++;
      }),
      (Writable.prototype.uncork = function () {
        const e = this._writableState;
        e.corked && (e.corked--, e.writing || clearBuffer(this, e));
      }),
      (Writable.prototype.setDefaultEncoding = function setDefaultEncoding(e) {
        if (("string" == typeof e && (e = u(e)), !p.isEncoding(e)))
          throw new B(e);
        return (this._writableState.defaultEncoding = e), this;
      }),
      (Writable.prototype._write = function (e, t, r) {
        if (!this._writev) throw new k("_write()");
        this._writev([{ chunk: e, encoding: t }], r);
      }),
      (Writable.prototype._writev = null),
      (Writable.prototype.end = function (e, t, r) {
        const n = this._writableState;
        let o;
        if (
          ("function" == typeof e
            ? ((r = e), (e = null), (t = null))
            : "function" == typeof t && ((r = t), (t = null)),
          null != e)
        ) {
          const r = _write(this, e, t);
          r instanceof l && (o = r);
        }
        return (
          n.corked && ((n.corked = 1), this.uncork()),
          o ||
            (n.errored || n.ending
              ? n.finished
                ? (o = new R("end"))
                : n.destroyed && (o = new M("end"))
              : ((n.ending = !0), finishMaybe(this, n, !0), (n.ended = !0))),
          "function" == typeof r &&
            (o || n.finished ? i.nextTick(r, o) : n[N].push(r)),
          this
        );
      }),
      c(Writable.prototype, {
        closed: {
          __proto__: null,
          get() {
            return !!this._writableState && this._writableState.closed;
          },
        },
        destroyed: {
          __proto__: null,
          get() {
            return !!this._writableState && this._writableState.destroyed;
          },
          set(e) {
            this._writableState && (this._writableState.destroyed = e);
          },
        },
        writable: {
          __proto__: null,
          get() {
            const e = this._writableState;
            return !(
              !e ||
              !1 === e.writable ||
              e.destroyed ||
              e.errored ||
              e.ending ||
              e.ended
            );
          },
          set(e) {
            this._writableState && (this._writableState.writable = !!e);
          },
        },
        writableFinished: {
          __proto__: null,
          get() {
            return !!this._writableState && this._writableState.finished;
          },
        },
        writableObjectMode: {
          __proto__: null,
          get() {
            return !!this._writableState && this._writableState.objectMode;
          },
        },
        writableBuffer: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.getBuffer();
          },
        },
        writableEnded: {
          __proto__: null,
          get() {
            return !!this._writableState && this._writableState.ending;
          },
        },
        writableNeedDrain: {
          __proto__: null,
          get() {
            const e = this._writableState;
            return !!e && !e.destroyed && !e.ending && e.needDrain;
          },
        },
        writableHighWaterMark: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.highWaterMark;
          },
        },
        writableCorked: {
          __proto__: null,
          get() {
            return this._writableState ? this._writableState.corked : 0;
          },
        },
        writableLength: {
          __proto__: null,
          get() {
            return this._writableState && this._writableState.length;
          },
        },
        errored: {
          __proto__: null,
          enumerable: !1,
          get() {
            return this._writableState ? this._writableState.errored : null;
          },
        },
        writableAborted: {
          __proto__: null,
          enumerable: !1,
          get: function () {
            return !(
              !1 === this._writableState.writable ||
              (!this._writableState.destroyed &&
                !this._writableState.errored) ||
              this._writableState.finished
            );
          },
        },
      });
    const x = g.destroy;
    let F;
    function lazyWebStreams() {
      return void 0 === F && (F = t("internal/webstreams/adapters")), F;
    }
    (Writable.prototype.destroy = function (e, t) {
      const r = this._writableState;
      return (
        !r.destroyed &&
          (r.bufferedIndex < r.buffered.length || r[N].length) &&
          i.nextTick(errorBuffer, r),
        x.call(this, e, t),
        this
      );
    }),
      (Writable.prototype._undestroy = g.undestroy),
      (Writable.prototype._destroy = function (e, t) {
        t(e);
      }),
      (Writable.prototype[_.captureRejectionSymbol] = function (e) {
        this.destroy(e);
      }),
      (Writable.fromWeb = function (e, t) {
        return lazyWebStreams().newStreamWritableFromWritableStream(e, t);
      }),
      (Writable.toWeb = function (e) {
        return lazyWebStreams().newWritableStreamFromStreamWritable(e);
      });
  },
  "internal/structured_clone": function (e, r, t, n, o, s) {
    "use strict";
    const {
        codes: { ERR_MISSING_ARGS: u },
      } = r("internal/errors"),
      { MessageChannel: a, receiveMessageOnPort: i } = r("internal/worker/io");
    let c;
    t.exports = {
      structuredClone: function structuredClone(e, r = void 0) {
        if (0 === arguments.length) throw new u("value");
        return (
          (c ??= new a()),
          c.port1.unref(),
          c.port2.unref(),
          c.port1.postMessage(e, r?.transfer),
          i(c.port2).message
        );
      },
    };
  },
  "internal/test/binding": function (n, i, t, e, r, s) {
    "use strict";
    const { globalThis: o } = s;
    e.emitWarning(
      "These APIs are for internal testing only. Do not use them.",
      "internal/test/binding"
    ),
      t.isPreloading && ((o.internalBinding = r), (o.primordials = s)),
      (t.exports = { internalBinding: r, primordials: s });
  },
  "internal/test/transfer": function (e, t, r, s, n, a) {
    "use strict";
    const {
      makeTransferable: i,
      kClone: o,
      kDeserialize: l,
    } = t("internal/worker/js_transferable");
    s.emitWarning(
      "These APIs are for internal testing only. Do not use them.",
      "internal/test/transfer"
    );
    class E {
      constructor(e) {
        this.b = e;
      }
    }
    r.exports = {
      E: E,
      F: class F extends E {
        constructor(e) {
          return super(e), i(this);
        }
        [o]() {
          return {
            data: { b: this.b },
            deserializeInfo: "internal/test/transfer:F",
          };
        }
        [l]({ b: e }) {
          this.b = e;
        }
      },
    };
  },
  "internal/test_runner/coverage": function (e, t, n, o, r, s) {
    "use strict";
    const {
        ArrayFrom: c,
        ArrayPrototypeMap: a,
        ArrayPrototypePush: i,
        JSONParse: l,
        MathFloor: g,
        NumberParseInt: u,
        RegExpPrototypeExec: f,
        RegExpPrototypeSymbolSplit: d,
        SafeMap: v,
        SafeSet: h,
        StringPrototypeIncludes: C,
        StringPrototypeLocaleCompare: y,
        StringPrototypeStartsWith: p,
      } = s,
      {
        copyFileSync: O,
        mkdirSync: _,
        mkdtempSync: m,
        opendirSync: P,
        readFileSync: L,
      } = t("fs"),
      { setupCoverageHooks: S } = t("internal/util"),
      { tmpdir: F } = t("os"),
      { join: D, resolve: R } = t("path"),
      { fileURLToPath: B } = t("url"),
      E = /^coverage-(\d+)-(\d{13})-(\d+)\.json$/,
      k = /\/\* node:coverage ignore next (?<count>\d+ )?\*\//,
      N = /\r?\n$/u,
      b = /(?<=\r?\n)/u,
      w = /\/\* node:coverage (?<status>enable|disable) \*\//;
    class CoverageLine {
      #e;
      constructor(e, t, n) {
        const o = f(N, t)?.[0].length ?? 0;
        (this.line = e),
          (this.src = t),
          (this.startOffset = n),
          (this.endOffset = n + t.length - o),
          (this.ignore = !1),
          (this.#e = !0);
      }
      get covered() {
        return this.#e;
      }
      set covered(e) {
        this.#e && (this.#e = e);
      }
    }
    class TestCoverage {
      constructor(e, t, n) {
        (this.coverageDirectory = e),
          (this.originalCoverageDirectory = t),
          (this.workingDirectory = n);
      }
      summary() {
        r("profiler").takeCoverage();
        const e = (function getCoverageFromDirectory(e) {
            const t = new v();
            let n;
            try {
              n = P(e);
              for (let o; null !== (o = n.readSync()); ) {
                if (null === f(E, o.name)) continue;
                const n = D(e, o.name);
                mergeCoverage(t, l(L(n, "utf8")).result);
              }
              return c(t.values());
            } finally {
              n && n.closeSync();
            }
          })(this.coverageDirectory),
          t = {
            __proto__: null,
            workingDirectory: this.workingDirectory,
            files: [],
            totals: {
              __proto__: null,
              totalLineCount: 0,
              totalBranchCount: 0,
              totalFunctionCount: 0,
              coveredLineCount: 0,
              coveredBranchCount: 0,
              coveredFunctionCount: 0,
              coveredLinePercent: 0,
              coveredBranchPercent: 0,
              coveredFunctionPercent: 0,
            },
          };
        if (!e) return t;
        for (let n = 0; n < e.length; ++n) {
          const { functions: o, url: r } = e[n],
            s = B(r);
          let c;
          try {
            c = L(s, "utf8");
          } catch {
            continue;
          }
          const l = d(b, c);
          let g = 0,
            v = !0,
            h = 0,
            C = 0,
            y = 0,
            p = 0,
            O = 0;
          const _ = a(l, (e, t) => {
            const n = new CoverageLine(t + 1, e, h);
            if (
              ((h += e.length),
              g > 0 ? (g--, (n.ignore = !0)) : v || (n.ignore = !0),
              !n.ignore)
            ) {
              const t = f(k, e);
              null !== t && (g = u(t.groups?.count ?? 1, 10));
            }
            const o = f(w, e),
              r = o?.groups?.status;
            return r && ((g = 0), (v = "enable" === r)), n;
          });
          for (let e = 0; e < o.length; ++e) {
            const { isBlockCoverage: t, ranges: n } = o[e];
            for (let e = 0; e < n.length; ++e) {
              const o = n[e];
              mapRangeToLines(o, _),
                t &&
                  ((0 === o.count && o.ignoredLines !== o.lines.length) || p++,
                  C++);
            }
            if (e > 0 && n.length > 0) {
              const e = n[0];
              (0 === e.count && e.ignoredLines !== e.lines.length) || O++, y++;
            }
          }
          let m = 0;
          const P = [];
          for (let e = 0; e < _.length; ++e) {
            const t = _[e];
            t.covered || t.ignore ? m++ : i(P, t.line);
          }
          i(t.files, {
            __proto__: null,
            path: s,
            totalLineCount: _.length,
            totalBranchCount: C,
            totalFunctionCount: y,
            coveredLineCount: m,
            coveredBranchCount: p,
            coveredFunctionCount: O,
            coveredLinePercent: toPercentage(m, _.length),
            coveredBranchPercent: toPercentage(p, C),
            coveredFunctionPercent: toPercentage(O, y),
            uncoveredLineNumbers: P,
          }),
            (t.totals.totalLineCount += _.length),
            (t.totals.totalBranchCount += C),
            (t.totals.totalFunctionCount += y),
            (t.totals.coveredLineCount += m),
            (t.totals.coveredBranchCount += p),
            (t.totals.coveredFunctionCount += O);
        }
        return (
          (t.totals.coveredLinePercent = toPercentage(
            t.totals.coveredLineCount,
            t.totals.totalLineCount
          )),
          (t.totals.coveredBranchPercent = toPercentage(
            t.totals.coveredBranchCount,
            t.totals.totalBranchCount
          )),
          (t.totals.coveredFunctionPercent = toPercentage(
            t.totals.coveredFunctionCount,
            t.totals.totalFunctionCount
          )),
          t.files.sort(sortCoverageFiles),
          t
        );
      }
      cleanup() {
        if (void 0 === this.originalCoverageDirectory)
          return void delete o.env.NODE_V8_COVERAGE;
        let e;
        o.env.NODE_V8_COVERAGE = this.originalCoverageDirectory;
        try {
          _(this.originalCoverageDirectory, { __proto__: null, recursive: !0 }),
            (e = P(this.coverageDirectory));
          for (let t; null !== (t = e.readSync()); ) {
            const e = D(this.coverageDirectory, t.name),
              n = D(this.originalCoverageDirectory, t.name);
            O(e, n);
          }
        } finally {
          e && e.closeSync();
        }
      }
    }
    function toPercentage(e, t) {
      return 0 === t ? 100 : (e / t) * 100;
    }
    function sortCoverageFiles(e, t) {
      return y(e.path, t.path);
    }
    function mapRangeToLines(e, t) {
      const { startOffset: n, endOffset: o, count: r } = e,
        s = [];
      let c,
        a = 0,
        l = 0,
        u = t.length;
      for (; l <= u; ) {
        c = g((l + u) / 2);
        let e = t[c];
        if (n >= e?.startOffset && n <= e?.endOffset) {
          for (; o > e?.startOffset; )
            0 === r &&
              n <= e.startOffset &&
              o >= e.endOffset &&
              (e.covered = !1),
              i(s, e),
              e.ignore && a++,
              c++,
              (e = t[c]);
          break;
        }
        n >= e?.endOffset ? (l = c + 1) : (u = c - 1);
      }
      (e.lines = s), (e.ignoredLines = a);
    }
    function mergeCoverage(e, t) {
      for (let n = 0; n < t.length; ++n) {
        const o = t[n],
          { url: r } = o;
        if (C(r, "/node_modules/") || !p(r, "file:")) continue;
        const s = e.get(r);
        void 0 === s ? e.set(r, o) : mergeCoverageScripts(s, o);
      }
    }
    function mergeCoverageScripts(e, t) {
      for (let n = 0; n < t.functions.length; ++n) {
        const o = t.functions[n];
        let r = !1;
        for (let t = 0; t < e.functions.length; ++t) {
          const n = e.functions[t];
          if (
            o.functionName === n.functionName &&
            o.ranges?.[0].startOffset === n.ranges?.[0].startOffset &&
            o.ranges?.[0].endOffset === n.ranges?.[0].endOffset
          ) {
            (r = !0),
              o.isBlockCoverage &&
                (n.isBlockCoverage
                  ? mergeCoverageRanges(n, o)
                  : ((n.isBlockCoverage = !0), (n.ranges = o.ranges)));
            break;
          }
        }
        r || i(e.functions, o);
      }
    }
    function mergeCoverageRanges(e, t) {
      const n = new h();
      for (let t = 0; t < e.ranges.length; ++t) {
        const o = e.ranges[t];
        o.count > 0 && n.add(o);
      }
      for (let s = 0; s < t.ranges.length; ++s) {
        const c = t.ranges[s];
        let a = !1;
        for (let t = 0; t < e.ranges.length; ++t) {
          const s = e.ranges[t];
          if (
            ((r = s),
            (o = c).startOffset === r.startOffset &&
              o.endOffset === r.endOffset)
          ) {
            (s.count += c.count), n.add(s), (a = !0);
            break;
          }
          0 === s.count &&
            0 === c.count &&
            (doesRangeContainOtherRange(s, c)
              ? n.add(c)
              : doesRangeContainOtherRange(c, s) && n.add(s));
        }
        c.count > 0 && !a && n.add(c);
      }
      var o, r;
      e.ranges = c(n);
    }
    function doesRangeContainOtherRange(e, t) {
      return e.startOffset <= t.startOffset && e.endOffset >= t.endOffset;
    }
    n.exports = {
      setupCoverage: function setupCoverage() {
        let e = o.env.NODE_V8_COVERAGE;
        const t = o.cwd();
        e && (e = R(t, e));
        const n = m(D(F(), "node-coverage-"));
        return S(n)
          ? ((o.env.NODE_V8_COVERAGE = n), new TestCoverage(n, e, t))
          : null;
      },
      TestCoverage: TestCoverage,
    };
  },
  "internal/test_runner/harness": function (e, t, n, o, r, a) {
    "use strict";
    const {
        ArrayPrototypeForEach: s,
        FunctionPrototypeBind: i,
        PromiseResolve: c,
        SafeMap: l,
      } = a,
      { getCallerLocation: u } = r("util"),
      { createHook: d, executionAsyncId: h } = t("async_hooks"),
      {
        codes: { ERR_TEST_FAILURE: p },
      } = t("internal/errors"),
      { kEmptyObject: f } = t("internal/util"),
      {
        kCancelledByParent: g,
        Test: _,
        Suite: v,
      } = t("internal/test_runner/test"),
      {
        parseCommandLine: b,
        reporterScope: y,
        setupTestReporters: T,
      } = t("internal/test_runner/utils"),
      { bigint: C } = o.hrtime,
      m = new l();
    function createTestTree(e = f) {
      return (function setup(e) {
        if (null !== e.startTime) return e;
        const n = b(),
          r = d({
            __proto__: null,
            init(e, t, n, o) {
              if (o instanceof _) return void m.set(e, o);
              const r = m.get(n);
              void 0 !== r && m.set(e, r);
            },
            destroy(e) {
              m.delete(e);
            },
          });
        r.enable();
        const a = createProcessEventHandler("uncaughtException", e),
          s = createProcessEventHandler("unhandledRejection", e),
          c = (function configureCoverage(e, n) {
            if (!n.coverage) return null;
            const { setupCoverage: r } = t("internal/test_runner/coverage");
            try {
              return r();
            } catch (t) {
              const n = `Warning: Code coverage could not be enabled. ${t}`;
              e.diagnostic(n), (o.exitCode = 1);
            }
          })(e, n),
          exitHandler = () => {
            e.postRun(
              new p(
                "Promise resolution is still pending but the event loop has already resolved",
                g
              )
            ),
              r.disable(),
              o.removeListener("unhandledRejection", s),
              o.removeListener("uncaughtException", a);
          },
          terminationHandler = () => {
            exitHandler(), o.exit();
          };
        o.on("uncaughtException", a),
          o.on("unhandledRejection", s),
          o.on("beforeExit", exitHandler),
          n.isTestRunner &&
            (o.on("SIGINT", terminationHandler),
            o.on("SIGTERM", terminationHandler));
        return (
          (e.harness = {
            __proto__: null,
            bootstrapComplete: !1,
            coverage: i(collectCoverage, null, e, c),
            counters: {
              __proto__: null,
              all: 0,
              failed: 0,
              passed: 0,
              cancelled: 0,
              skipped: 0,
              todo: 0,
              topLevel: 0,
              suites: 0,
            },
            shouldColorizeTestFiles: !1,
          }),
          (e.startTime = C()),
          e
        );
      })(new _({ __proto__: null, ...e, name: "<root>" }));
    }
    function createProcessEventHandler(e, t) {
      return (n) => {
        if (!t.harness.bootstrapComplete) throw n;
        const r = m.get(h());
        if (r === y) throw n;
        if (!r || r.finished) {
          let a;
          return (
            (a = r
              ? `Warning: Test "${r.name}" generated asynchronous activity after the test ended. This activity created the error "${n}" and would have caused the test to fail, but instead triggered an ${e} event.`
              : `Warning: A resource generated asynchronous activity after the test ended. This activity created the error "${n}" which triggered an ${e} event, caught by the test runner.`),
            t.diagnostic(a),
            void (o.exitCode = 1)
          );
        }
        r.fail(new p(n, e)), r.postRun();
      };
    }
    function collectCoverage(e, t) {
      if (!t) return null;
      let n = null;
      try {
        (n = t.summary()), t.cleanup();
      } catch (t) {
        const r = `Warning: Could not ${
          n ? "clean up" : "report"
        } code coverage. ${t}`;
        e.diagnostic(r), (o.exitCode = 1);
      }
      return n;
    }
    let E, R;
    function getGlobalRoot() {
      return (
        E ||
          ((E = createTestTree()),
          E.reporter.on("test:fail", (e) => {
            (void 0 !== e.todo && !1 !== e.todo) || (o.exitCode = 1);
          }),
          (R = T(E))),
        E
      );
    }
    function runInParentContext(e) {
      function run(t, n, o, r) {
        const a = m.get(h()) || getGlobalRoot(),
          s = a.createSubtest(e, t, n, o, r);
        return a instanceof v
          ? c()
          : (async function startSubtest(e) {
              await R,
                (getGlobalRoot().harness.bootstrapComplete = !0),
                await e.start();
            })(s);
      }
      const test = (e, t, n) => run(e, t, n, { __proto__: null, loc: u() });
      return (
        s(["skip", "todo", "only"], (e) => {
          test[e] = (t, n, o) =>
            run(t, n, o, { __proto__: null, [e]: !0, loc: u() });
        }),
        test
      );
    }
    function hook(e) {
      return (t, n) => {
        const o = m.get(h()) || getGlobalRoot();
        o.createHook(e, t, {
          __proto__: null,
          ...n,
          parent: o,
          hookType: e,
          loc: u(),
        });
      };
    }
    m.set(y.asyncId(), y),
      (n.exports = {
        createTestTree: createTestTree,
        test: runInParentContext(_),
        describe: runInParentContext(v),
        it: runInParentContext(_),
        before: hook("before"),
        after: hook("after"),
        beforeEach: hook("beforeEach"),
        afterEach: hook("afterEach"),
      });
  },
  "internal/test_runner/mock/mock": function (t, e, o, n, r, s) {
    "use strict";
    const {
        ArrayPrototypePush: i,
        ArrayPrototypeSlice: l,
        Error: c,
        FunctionPrototypeCall: a,
        ObjectDefineProperty: u,
        ObjectGetOwnPropertyDescriptor: m,
        ObjectGetPrototypeOf: p,
        Proxy: h,
        ReflectApply: f,
        ReflectConstruct: k,
        ReflectGet: _,
        SafeMap: g,
      } = s,
      {
        codes: { ERR_INVALID_ARG_TYPE: y, ERR_INVALID_ARG_VALUE: d },
      } = e("internal/errors"),
      { kEmptyObject: b } = e("internal/util"),
      {
        validateBoolean: w,
        validateFunction: F,
        validateInteger: C,
        validateObject: M,
      } = e("internal/validators"),
      { MockTimers: j } = e("internal/test_runner/mock/mock_timers");
    function kDefaultFunction() {}
    class MockFunctionContext {
      #t;
      #e;
      #o;
      #n;
      #r;
      constructor(t, e, o) {
        (this.#t = []),
          (this.#e = new g()),
          (this.#o = t),
          (this.#n = e),
          (this.#r = o);
      }
      get calls() {
        return l(this.#t, 0);
      }
      callCount() {
        return this.#t.length;
      }
      mockImplementation(t) {
        F(t, "implementation"), (this.#o = t);
      }
      mockImplementationOnce(t, e) {
        F(t, "implementation");
        const o = this.#t.length,
          n = e ?? o;
        C(n, "onCall", o), this.#e.set(n, t);
      }
      restore() {
        const {
          descriptor: t,
          object: e,
          original: o,
          methodName: n,
        } = this.#n;
        "string" == typeof n ? u(e, n, t) : (this.#o = o);
      }
      resetCalls() {
        this.#t = [];
      }
      trackCall(t) {
        i(this.#t, t);
      }
      nextImpl() {
        const t = this.#t.length,
          e = this.#e.get(t) ?? this.#o;
        return t + 1 === this.#r && this.restore(), this.#e.delete(t), e;
      }
    }
    const {
      nextImpl: D,
      restore: v,
      trackCall: x,
    } = MockFunctionContext.prototype;
    delete MockFunctionContext.prototype.trackCall,
      delete MockFunctionContext.prototype.nextImpl;
    function validateTimes(t, e) {
      t !== 1 / 0 && C(t, e, 1);
    }
    o.exports = {
      MockTracker: class MockTracker {
        #e = [];
        #s;
        get timers() {
          return (this.#s ??= new j()), this.#s;
        }
        fn(t = function () {}, e = t, o = b) {
          null !== t && "object" == typeof t
            ? ((o = t), (e = t = function () {}))
            : null !== e && "object" == typeof e && ((o = e), (e = t)),
            F(t, "original"),
            F(e, "implementation"),
            M(o, "options");
          const { times: n = 1 / 0 } = o;
          validateTimes(n, "options.times");
          const r = new MockFunctionContext(
            e,
            { __proto__: null, original: t },
            n
          );
          return this.#i(r, t);
        }
        method(t, e, o = kDefaultFunction, n = b) {
          !(function validateStringOrSymbol(t, e) {
            if ("string" != typeof t && "symbol" != typeof t)
              throw new y(e, ["string", "symbol"], t);
          })(e, "methodName"),
            "function" != typeof t && M(t, "object"),
            null !== o &&
              "object" == typeof o &&
              ((n = o), (o = kDefaultFunction)),
            F(o, "implementation"),
            M(n, "options");
          const { getter: r = !1, setter: s = !1, times: i = 1 / 0 } = n;
          if (
            (w(r, "options.getter"),
            w(s, "options.setter"),
            validateTimes(i, "options.times"),
            s && r)
          )
            throw new d(
              "options.setter",
              s,
              "cannot be used with 'options.getter'"
            );
          const l = (function findMethodOnPrototypeChain(t, e) {
            let o,
              n = t;
            for (; null !== n && ((o = m(n, e)), !o); ) n = p(n);
            return o;
          })(t, e);
          let c;
          if (
            ((c = r ? l?.get : s ? l?.set : l?.value), "function" != typeof c)
          )
            throw new d("methodName", c, "must be a method");
          const a = new MockFunctionContext(
              o === kDefaultFunction ? c : o,
              { __proto__: null, descriptor: l, object: t, methodName: e },
              i
            ),
            h = this.#i(a, c),
            f = {
              __proto__: null,
              configurable: l.configurable,
              enumerable: l.enumerable,
            };
          return (
            r
              ? ((f.get = h), (f.set = l.set))
              : s
              ? ((f.get = l.get), (f.set = h))
              : ((f.writable = l.writable), (f.value = h)),
            u(t, e, f),
            h
          );
        }
        getter(t, e, o = kDefaultFunction, n = b) {
          null !== o && "object" == typeof o
            ? ((n = o), (o = kDefaultFunction))
            : M(n, "options");
          const { getter: r = !0 } = n;
          if (!1 === r) throw new d("options.getter", r, "cannot be false");
          return this.method(t, e, o, { __proto__: null, ...n, getter: r });
        }
        setter(t, e, o = kDefaultFunction, n = b) {
          null !== o && "object" == typeof o
            ? ((n = o), (o = kDefaultFunction))
            : M(n, "options");
          const { setter: r = !0 } = n;
          if (!1 === r) throw new d("options.setter", r, "cannot be false");
          return this.method(t, e, o, { __proto__: null, ...n, setter: r });
        }
        reset() {
          this.restoreAll(), this.#s?.reset(), (this.#e = []);
        }
        restoreAll() {
          for (let t = 0; t < this.#e.length; t++) a(v, this.#e[t]);
        }
        #i(t, e) {
          const o = new h(e, {
            __proto__: null,
            apply(e, o, n) {
              const r = a(D, t);
              let s, i;
              try {
                s = f(r, o, n);
              } catch (t) {
                throw ((i = t), t);
              } finally {
                a(x, t, {
                  __proto__: null,
                  arguments: n,
                  error: i,
                  result: s,
                  stack: new c(),
                  target: void 0,
                  this: o,
                });
              }
              return s;
            },
            construct(e, o, n) {
              const r = a(D, t);
              let s, i;
              try {
                s = k(r, o, n);
              } catch (t) {
                throw ((i = t), t);
              } finally {
                a(x, t, {
                  __proto__: null,
                  arguments: o,
                  error: i,
                  result: s,
                  stack: new c(),
                  target: e,
                  this: s,
                });
              }
              return s;
            },
            get: (e, o, n) => ("mock" === o ? t : _(e, o, n)),
          });
          return i(this.#e, t), o;
        }
      },
    };
  },
  "internal/test_runner/mock/mock_timers": function (e, t, i, r, s, a) {
    "use strict";
    const { emitExperimentalWarning: l } = t("internal/util"),
      {
        ArrayPrototypeForEach: o,
        ArrayPrototypeIncludes: n,
        DateNow: m,
        FunctionPrototypeApply: u,
        FunctionPrototypeBind: h,
        ObjectDefineProperty: I,
        ObjectGetOwnPropertyDescriptor: c,
        Promise: d,
        SymbolAsyncIterator: T,
        SymbolDispose: v,
        globalThis: _,
      } = a,
      { validateAbortSignal: p, validateArray: S } = t("internal/validators"),
      {
        AbortError: f,
        codes: { ERR_INVALID_STATE: g, ERR_INVALID_ARG_VALUE: b },
      } = t("internal/errors"),
      P = t("internal/priority_queue"),
      y = t("timers"),
      w = t("timers/promises"),
      C = t("events");
    let A;
    function compareTimersLists(e, t) {
      return e.runAt - t.runAt || e.id - t.id;
    }
    function setPosition(e, t) {
      e.priorityQueuePosition = t;
    }
    function abortIt(e) {
      return new f(void 0, { __proto__: null, cause: e.reason });
    }
    const k = ["setTimeout", "setInterval", "setImmediate"],
      x = -1;
    i.exports = {
      MockTimers: class MockTimers {
        #e;
        #t;
        #i;
        #r;
        #s;
        #a;
        #l;
        #o;
        #n;
        #m;
        #u;
        #h;
        #I;
        #c;
        #d;
        #T = [];
        #v = !1;
        #_ = 1;
        #p = m();
        #S = new P(compareTimersLists, setPosition);
        #f = h(this.#g, this, !1);
        #b = h(this.#P, this);
        #y = h(this.#g, this, !0);
        #w = h(this.#P, this);
        #C = (e, ...t) => this.#g(!1, e, x, ...t);
        #A = h(this.#P, this);
        constructor() {
          l("The MockTimers API");
        }
        #g(e, t, i, ...r) {
          const s = this.#_++;
          return (
            this.#S.insert({
              __proto__: null,
              id: s,
              callback: t,
              runAt: this.#p + i,
              interval: e,
              args: r,
            }),
            s
          );
        }
        #P(e) {
          this.#S.removeAt(e);
        }
        async *#k(e, i, r) {
          const s = this,
            a = new C();
          if (r?.signal) {
            if ((p(r.signal, "options.signal"), r.signal.aborted))
              throw abortIt(r.signal);
            const onAbort = (e) => {
              a.emit("data", { __proto__: null, aborted: !0, reason: e });
            };
            (A ??= t("internal/event_target").kResistStopPropagation),
              r.signal.addEventListener("abort", onAbort, {
                __proto__: null,
                once: !0,
                [A]: !0,
              });
          }
          const l = C.on(a, "data"),
            o = this.#g(
              !0,
              () => {
                (i += e), a.emit("data", i);
              },
              e,
              r
            ),
            n = {
              __proto__: null,
              [T]() {
                return this;
              },
              async next() {
                const e = await l.next(),
                  t = e.value[0];
                if (t?.aborted) throw (n.return(), abortIt(r.signal));
                return { __proto__: null, done: e.done, value: t };
              },
              return: async () => (a.removeAllListeners(), s.#P(o), l.return()),
            };
          yield* n;
        }
        #x({ timerFn: e, clearFn: i, ms: r, result: s, options: a }) {
          return new d((l, o) => {
            if (a?.signal) {
              try {
                p(a.signal, "options.signal");
              } catch (e) {
                return o(e);
              }
              if (a.signal.aborted) return o(abortIt(a.signal));
            }
            const onabort = () => (i(n), o(abortIt(a.signal))),
              n = e(() => l(s), r);
            a?.signal &&
              ((A ??= t("internal/event_target").kResistStopPropagation),
              a.signal.addEventListener("abort", onabort, {
                __proto__: null,
                once: !0,
                [A]: !0,
              }));
          });
        }
        #E(e, t) {
          return this.#x({
            __proto__: null,
            timerFn: h(this.#C, this),
            clearFn: h(this.#A, this),
            ms: x,
            result: e,
            options: t,
          });
        }
        #O(e, t, i) {
          return this.#x({
            __proto__: null,
            timerFn: h(this.#f, this),
            clearFn: h(this.#b, this),
            ms: e,
            result: t,
            options: i,
          });
        }
        #F(e) {
          const t = {
              __proto__: null,
              toFake: {
                __proto__: null,
                setTimeout: () => {
                  this.#Q(),
                    (_.setTimeout = this.#f),
                    (_.clearTimeout = this.#b),
                    (y.setTimeout = this.#f),
                    (y.clearTimeout = this.#b),
                    (w.setTimeout = h(this.#O, this));
                },
                setInterval: () => {
                  this.#R(),
                    (_.setInterval = this.#y),
                    (_.clearInterval = this.#w),
                    (y.setInterval = this.#y),
                    (y.clearInterval = this.#w),
                    (w.setInterval = h(this.#k, this));
                },
                setImmediate: () => {
                  this.#L(),
                    (_.setImmediate = this.#C),
                    (_.clearImmediate = this.#A),
                    (y.setImmediate = this.#C),
                    (y.clearImmediate = this.#A),
                    (w.setImmediate = h(this.#E, this));
                },
              },
              toReal: {
                __proto__: null,
                setTimeout: () => {
                  this.#D();
                },
                setInterval: () => {
                  this.#M();
                },
                setImmediate: () => {
                  this.#N();
                },
              },
            },
            i = e ? t.toFake : t.toReal;
          o(this.#T, (e) => i[e]()), (this.#v = e);
        }
        #N() {
          I(_, "setImmediate", this.#s),
            I(_, "clearImmediate", this.#a),
            I(y, "setImmediate", this.#I),
            I(y, "clearImmediate", this.#c),
            I(w, "setImmediate", this.#d);
        }
        #M() {
          I(_, "setInterval", this.#i),
            I(_, "clearInterval", this.#r),
            I(y, "setInterval", this.#u),
            I(y, "clearInterval", this.#h),
            I(w, "setInterval", this.#o);
        }
        #D() {
          I(_, "setTimeout", this.#e),
            I(_, "clearTimeout", this.#t),
            I(y, "setTimeout", this.#n),
            I(y, "clearTimeout", this.#m),
            I(w, "setTimeout", this.#l);
        }
        #L() {
          (this.#s = c(_, "setImmediate")),
            (this.#a = c(_, "clearImmediate")),
            (this.#I = c(y, "setImmediate")),
            (this.#c = c(y, "clearImmediate")),
            (this.#d = c(w, "setImmediate"));
        }
        #R() {
          (this.#i = c(_, "setInterval")),
            (this.#r = c(_, "clearInterval")),
            (this.#u = c(y, "setInterval")),
            (this.#h = c(y, "clearInterval")),
            (this.#o = c(w, "setInterval"));
        }
        #Q() {
          (this.#e = c(_, "setTimeout")),
            (this.#t = c(_, "clearTimeout")),
            (this.#n = c(y, "setTimeout")),
            (this.#m = c(y, "clearTimeout")),
            (this.#l = c(w, "setTimeout"));
        }
        tick(e = 1) {
          if (!this.#v)
            throw new g(
              "You should enable MockTimers first by calling the .enable function"
            );
          if (e < 0) throw new b("time", "positive integer", e);
          this.#p += e;
          let t = this.#S.peek();
          for (; t && !(t.runAt > this.#p); ) {
            if ((u(t.callback, void 0, t.args), this.#S.shift(), t.interval))
              return (t.runAt += t.interval), void this.#S.insert(t);
            t = this.#S.peek();
          }
        }
        enable(e = k) {
          if (this.#v) throw new g("MockTimers is already enabled!");
          S(e, "timers"),
            o(e, (e) => {
              if (!n(k, e))
                throw new b("timers", e, `option ${e} is not supported`);
            }),
            (this.#T = e),
            (this.#p = m()),
            this.#F(!0);
        }
        [v]() {
          this.reset();
        }
        reset() {
          if (!this.#v) return;
          this.#F(!1), (this.#T = []);
          let e = this.#S.peek();
          for (; e; ) this.#S.shift(), (e = this.#S.peek());
        }
        runAll() {
          if (!this.#v)
            throw new g(
              "You should enable MockTimers first by calling the .enable function"
            );
          this.tick(1 / 0);
        }
      },
    };
  },
  "internal/test_runner/reporter/dot": function (t, e, n, s, i, o) {
    "use strict";
    const { MathMax: a } = o;
    function getLineLength() {
      return a(s.stdout.columns ?? 20, 20);
    }
    n.exports = async function* dot(t) {
      let e = 0,
        n = getLineLength();
      for await (const { type: s } of t)
        "test:pass" === s && (yield "."),
          "test:fail" === s && (yield "X"),
          ("test:fail" !== s && "test:pass" !== s) ||
            ++e !== n ||
            (yield "\n", (n = getLineLength()), (e = 0));
      yield "\n";
    };
  },
  "internal/test_runner/reporter/junit": function (t, e, n, s, r, a) {
    "use strict";
    const {
        ArrayPrototypeFilter: o,
        ArrayPrototypeMap: i,
        ArrayPrototypeJoin: l,
        ArrayPrototypePush: c,
        ArrayPrototypeSome: p,
        NumberPrototypeToFixed: d,
        ObjectEntries: u,
        RegExpPrototypeSymbolReplace: _,
        String: g,
        StringPrototypeRepeat: m,
      } = a,
      { inspectWithNoCustomRetry: f } = e("internal/errors"),
      { hostname: h } = e("os"),
      y = { __proto__: null, colors: !1, breakLength: 1 / 0 },
      $ = h();
    function escapeContent(t = "") {
      return _(/</g, _(/&/g, t, "&amp;"), "&lt;");
    }
    function treeToXML(t) {
      if ("string" == typeof t) return `${escapeContent(t)}\n`;
      const { tag: e, attrs: n, nesting: s, children: r, comment: a } = t,
        o = m("\t", s + 1);
      if (a)
        return `${o}\x3c!-- ${(function escapeComment(t = "") {
          return _(/--/g, t, "&#45;&#45;");
        })(a)} --\x3e\n`;
      const c = l(
        i(
          u(n),
          ({ 0: t, 1: e }) =>
            `${t}="${(function escapeAttribute(t = "") {
              return escapeContent(_(/"/g, _(/\n/g, t, ""), "&quot;"));
            })(g(e))}"`
        ),
        " "
      );
      if (!r?.length) return `${o}<${e} ${c}/>\n`;
      return `${o}<${e} ${c}>\n${l(i(r ?? [], treeToXML), "")}${o}</${e}>\n`;
    }
    function isFailure(t) {
      return (
        (t?.children && p(t.children, (t) => "failure" === t.tag)) ||
        t?.attrs?.failures
      );
    }
    function isSkipped(t) {
      return (
        (t?.children && p(t.children, (t) => "skipped" === t.tag)) ||
        t?.attrs?.failures
      );
    }
    n.exports = async function* junitReporter(t) {
      yield '<?xml version="1.0" encoding="utf-8"?>\n', yield "<testsuites>\n";
      let e = null;
      const n = [];
      function startTest(t) {
        const s = e;
        (e = {
          __proto__: null,
          attrs: { __proto__: null, name: t.data.name },
          nesting: t.data.nesting,
          parent: e,
          children: [],
        }),
          s?.children && c(s.children, e),
          e.parent || c(n, e);
      }
      for await (const s of t)
        switch (s.type) {
          case "test:start":
            startTest(s);
            break;
          case "test:pass":
          case "test:fail": {
            e ||
              startTest({
                __proto__: null,
                data: { __proto__: null, name: "root", nesting: 0 },
              }),
              (e.attrs.name === s.data.name && e.nesting === s.data.nesting) ||
                startTest(s);
            const t = e;
            e?.nesting === s.data.nesting && (e = e.parent),
              (t.attrs.time = d(s.data.details.duration_ms / 1e3, 6));
            const n = o(t.children, (t) => null == t.comment);
            if (n.length > 0)
              (t.tag = "testsuite"),
                (t.attrs.disabled = 0),
                (t.attrs.errors = 0),
                (t.attrs.tests = n.length),
                (t.attrs.failures = o(t.children, isFailure).length),
                (t.attrs.skipped = o(t.children, isSkipped).length),
                (t.attrs.hostname = $);
            else if (
              ((t.tag = "testcase"),
              (t.attrs.classname = s.data.classname ?? "test"),
              s.data.skip &&
                c(t.children, {
                  __proto__: null,
                  nesting: s.data.nesting + 1,
                  tag: "skipped",
                  attrs: {
                    __proto__: null,
                    type: "skipped",
                    message: s.data.skip,
                  },
                }),
              s.data.todo &&
                c(t.children, {
                  __proto__: null,
                  nesting: s.data.nesting + 1,
                  tag: "skipped",
                  attrs: {
                    __proto__: null,
                    type: "todo",
                    message: s.data.todo,
                  },
                }),
              "test:fail" === s.type)
            ) {
              const e = s.data.details?.error;
              t.children.push({
                __proto__: null,
                nesting: s.data.nesting + 1,
                tag: "failure",
                attrs: {
                  __proto__: null,
                  type: e?.failureType || e?.code,
                  message: e?.message ?? "",
                },
                children: [f(e, y)],
              }),
                (t.failures = 1),
                (t.attrs.failure = e?.message ?? "");
            }
            break;
          }
          case "test:diagnostic":
            c(e?.children ?? n, {
              __proto__: null,
              nesting: s.data.nesting,
              comment: s.data.message,
            });
            break;
        }
      for (const t of n) yield treeToXML(t);
      yield "</testsuites>\n";
    };
  },
  "internal/test_runner/reporter/spec": function (t, e, s, r, n, o) {
    "use strict";
    const {
        ArrayPrototypeJoin: a,
        ArrayPrototypePop: i,
        ArrayPrototypePush: l,
        ArrayPrototypeShift: d,
        ArrayPrototypeUnshift: h,
        hardenRegExp: p,
        RegExpPrototypeSymbolSplit: c,
        SafeMap: u,
        StringPrototypeRepeat: $,
      } = o,
      g = e("assert"),
      _ = e("internal/streams/transform"),
      { inspectWithNoCustomRetry: f } = e("internal/errors"),
      {
        green: m,
        blue: y,
        red: v,
        white: R,
        gray: T,
        shouldColorize: E,
      } = e("internal/util/colors"),
      { kSubtestsFailed: w } = e("internal/test_runner/test"),
      { getCoverageReport: P } = e("internal/test_runner/utils"),
      { relative: k } = e("path"),
      S = { __proto__: null, colors: E(r.stdout), breakLength: 1 / 0 },
      b = {
        __proto__: null,
        "test:fail": v,
        "test:pass": m,
        "test:diagnostic": y,
      },
      A = {
        __proto__: null,
        "test:fail": "✖ ",
        "test:pass": "✔ ",
        "test:diagnostic": "ℹ ",
        "test:coverage": "ℹ ",
        "arrow:right": "▶ ",
        "hyphen:minus": "﹣ ",
      };
    s.exports = class SpecReporter extends _ {
      #t = [];
      #e = [];
      #s = new u();
      #r = [];
      #n = r.cwd();
      constructor() {
        super({ __proto__: null, writableObjectMode: !0 });
      }
      #o(t) {
        let e = this.#s.get(t);
        return void 0 === e && ((e = $("  ", t)), this.#s.set(t, e)), e;
      }
      #a(t, e) {
        if (!t) return "";
        const s = "ERR_TEST_FAILURE" === t.code ? t.cause : t;
        return `\n${e}  ${a(c(p(/\r?\n/), f(s, S)), `\n${e}  `)}\n`;
      }
      #i(t, e, s = "", r = "", n = !1) {
        let o = b[t] ?? R,
          a = A[t] ?? " ";
        const { skip: i, todo: l } = e,
          d = e.details?.duration_ms
            ? ` ${T}(${e.details.duration_ms}ms)${R}`
            : "";
        let h = `${e.name}${d}`;
        if (
          (void 0 !== i
            ? (h += ` # ${"string" == typeof i && i.length ? i : "SKIP"}`)
            : void 0 !== l &&
              (h += ` # ${"string" == typeof l && l.length ? l : "TODO"}`),
          n)
        )
          return `${s}${r}${o}${A["arrow:right"]}${R}${h}\n`;
        const p = this.#a(e.details?.error, r);
        return (
          void 0 !== i && ((o = T), (a = A["hyphen:minus"])),
          `${s}${r}${o}${a}${h}${R}${p}`
        );
      }
      #l(t, e) {
        const s = d(this.#t);
        s &&
          (g("test:start" === s.type),
          g(s.data.nesting === e.nesting),
          g(s.data.name === e.name));
        let r = "";
        for (; this.#t.length; ) {
          const t = i(this.#t);
          g("test:start" === t.type);
          const e = t.data;
          h(this.#e, e),
            (r += `${this.#o(e.nesting)}${A["arrow:right"]}${e.name}\n`);
        }
        let n = !1;
        this.#e[0] &&
          this.#e[0].nesting === e.nesting &&
          this.#e[0].name === e.name &&
          (d(this.#e), (n = !0));
        const o = this.#o(e.nesting);
        return `${this.#i(t, e, r, o, n)}\n`;
      }
      #d({ type: t, data: e }) {
        switch (t) {
          case "test:fail":
            return (
              e.details?.error?.failureType !== w && l(this.#r, e),
              this.#l(t, e)
            );
          case "test:pass":
            return this.#l(t, e);
          case "test:start":
            h(this.#t, { __proto__: null, data: e, type: t });
            break;
          case "test:stderr":
          case "test:stdout":
            return e.message;
          case "test:diagnostic":
            return `${b[t]}${this.#o(e.nesting)}${A[t]}${e.message}${R}\n`;
          case "test:coverage":
            return P(this.#o(e.nesting), e.summary, A["test:coverage"], y, !0);
        }
      }
      _transform({ type: t, data: e }, s, r) {
        r(null, this.#d({ __proto__: null, type: t, data: e }));
      }
      _flush(t) {
        if (0 === this.#r.length) return void t(null, "");
        const e = [`\n${b["test:fail"]}${A["test:fail"]}failing tests:${R}\n`];
        for (let t = 0; t < this.#r.length; t++) {
          const s = this.#r[t],
            r = k(this.#n, s.file),
            n = this.#i("test:fail", s),
            o = `test at ${r}:${s.line}:${s.column}`;
          l(e, o, n);
        }
        t(null, a(e, "\n"));
      }
    };
  },
  "internal/test_runner/reporter/tap": function (e, t, n, r, s, o) {
    "use strict";
    const {
        ArrayPrototypeForEach: a,
        ArrayPrototypeJoin: i,
        ArrayPrototypePush: l,
        ObjectEntries: c,
        RegExpPrototypeSymbolReplace: p,
        RegExpPrototypeSymbolSplit: u,
        SafeMap: d,
        SafeSet: g,
        StringPrototypeReplaceAll: y,
        StringPrototypeRepeat: $,
      } = o,
      { inspectWithNoCustomRetry: f } = t("internal/errors"),
      { isError: m, kEmptyObject: T } = t("internal/util"),
      { getCoverageReport: k } = t("internal/test_runner/utils"),
      b = "    ",
      h = /^ {4}at /,
      E = /\n|\r\n/,
      j = { __proto__: null, colors: !1, breakLength: 1 / 0 };
    let _;
    function reportTest(e, t, n, r, s, o) {
      let a = `${indent(e)}${n} ${t}`;
      return (
        r && (a += ` ${tapEscape(`- ${r}`)}`),
        void 0 !== s
          ? (a +=
              " # SKIP" +
              ("string" == typeof s && s.length ? ` ${tapEscape(s)}` : ""))
          : void 0 !== o &&
            (a +=
              " # TODO" +
              ("string" == typeof o && o.length ? ` ${tapEscape(o)}` : "")),
        (a += "\n"),
        a
      );
    }
    function reportDetails(e, t = T, n) {
      const { error: r, duration_ms: s } = t,
        o = indent(e);
      let a = `${o}  ---\n`;
      return (
        (a += jsToYaml(o, "duration_ms", s)),
        (a += jsToYaml(o, "type", t.type)),
        n && (a += jsToYaml(o, "location", n)),
        (a += jsToYaml(o, null, r, new g())),
        (a += `${o}  ...\n`),
        a
      );
    }
    const Y = new d();
    function indent(e) {
      let t = Y.get(e);
      return void 0 === t && ((t = $(b, e)), Y.set(e, t)), t;
    }
    function tapEscape(e) {
      let t = y(e, "\b", "\\b");
      return (
        (t = y(t, "\f", "\\f")),
        (t = y(t, "\t", "\\t")),
        (t = y(t, "\n", "\\n")),
        (t = y(t, "\r", "\\r")),
        (t = y(t, "\v", "\\v")),
        (t = y(t, "\\", "\\\\")),
        (t = y(t, "#", "\\#")),
        t
      );
    }
    function jsToYaml(e, n, r, s) {
      if (null == r) return "";
      if ("object" != typeof r) {
        const t = `${e}  ${n}: `;
        if ("string" != typeof r) return `${t}${f(r, j)}\n`;
        const s = u(E, r);
        if (1 === s.length) return `${t}${f(r, j)}\n`;
        let o = `${t}|-\n`;
        for (let t = 0; t < s.length; t++) o += `${e}    ${s[t]}\n`;
        return o;
      }
      s.add(r);
      const o = c(r),
        d = m(r);
      let g = "",
        y = e;
      null != n && ((g += `${e}  ${n}:\n`), (y += "  "));
      for (let e = 0; e < o.length; e++) {
        const { 0: t, 1: n } = o[e];
        (!d || ("cause" !== t && "code" !== t)) &&
          (s.has(n)
            ? (g += `${y}  ${t}: <Circular>\n`)
            : (g += jsToYaml(y, t, n, s)));
      }
      if (d) {
        const { kUnwrapErrors: n } = (function lazyLoadTest() {
            return (_ ??= t("internal/test_runner/test")), _;
          })(),
          {
            cause: o,
            code: c,
            failureType: d,
            message: y,
            expected: $,
            actual: f,
            operator: m,
            stack: T,
            name: k,
          } = r;
        let b = y ?? "<unknown error>",
          j = k,
          Y = T,
          R = c,
          S = $,
          P = f,
          A = m,
          v = isAssertionLike(r);
        if (
          ("ERR_TEST_FAILURE" === c &&
            n.has(d) &&
            ((Y = o?.stack ?? Y),
            (R = o?.code ?? R),
            (j = o?.name ?? j),
            (b = o?.message ?? b),
            isAssertionLike(o) &&
              ((S = o.expected),
              (P = o.actual),
              (A = o.operator ?? A),
              (v = !0))),
          (g += jsToYaml(e, "error", b, s)),
          R && (g += jsToYaml(e, "code", R, s)),
          j && "Error" !== j && (g += jsToYaml(e, "name", j, s)),
          v &&
            ((g += jsToYaml(e, "expected", S, s)),
            (g += jsToYaml(e, "actual", P, s)),
            A && (g += jsToYaml(e, "operator", A, s))),
          "string" == typeof Y)
        ) {
          const t = [];
          if (
            (a(u(E, Y), (e) => {
              const n = p(h, e, "");
              n.length > 0 && n.length !== e.length && l(t, n);
            }),
            t.length > 0)
          ) {
            const n = `\n${e}    `;
            (g += `${e}  stack: |-${n}`), (g += `${i(t, n)}\n`);
          }
        }
      }
      return g;
    }
    function isAssertionLike(e) {
      return e && "object" == typeof e && "expected" in e && "actual" in e;
    }
    n.exports = async function* tapReporter(e) {
      yield "TAP version 13\n";
      for await (const { type: t, data: n } of e)
        switch (t) {
          case "test:fail": {
            yield reportTest(
              n.nesting,
              n.testNumber,
              "not ok",
              n.name,
              n.skip,
              n.todo
            );
            const e = `${n.file}:${n.line}:${n.column}`;
            yield reportDetails(n.nesting, n.details, e);
            break;
          }
          case "test:pass":
            yield reportTest(
              n.nesting,
              n.testNumber,
              "ok",
              n.name,
              n.skip,
              n.todo
            ),
              yield reportDetails(n.nesting, n.details, null);
            break;
          case "test:plan":
            yield `${indent(n.nesting)}1..${n.count}\n`;
            break;
          case "test:start":
            yield `${indent(n.nesting)}# Subtest: ${tapEscape(n.name)}\n`;
            break;
          case "test:stderr":
          case "test:stdout": {
            const e = u(E, n.message);
            for (let t = 0; t < e.length; t++)
              0 !== e[t].length && (yield `# ${tapEscape(e[t])}\n`);
            break;
          }
          case "test:diagnostic":
            yield `${indent(n.nesting)}# ${tapEscape(n.message)}\n`;
            break;
          case "test:coverage":
            yield k(indent(n.nesting), n.summary, "# ", "");
        }
    };
  },
  "internal/test_runner/reporter/v8-serializer": function (e, r, t, a, s, o) {
    "use strict";
    const { TypedArrayPrototypeGetLength: i } = o,
      { DefaultSerializer: n } = r("v8"),
      { Buffer: f } = r("buffer"),
      { serializeError: l } = r("internal/error_serdes");
    t.exports = async function* v8Reporter(e) {
      const r = new n();
      r.writeHeader();
      const t = i(r.releaseBuffer());
      for await (const a of e) {
        const e = a.data.details?.error;
        e && (a.data.details.error = l(e)),
          r.writeHeader(),
          r.writeRawBytes(f.allocUnsafe(4)),
          r.writeHeader(),
          r.writeValue(a),
          e && (a.data.details.error = e);
        const s = r.releaseBuffer(),
          o = s.length - (4 + t);
        s.set([(o >> 24) & 255, (o >> 16) & 255, (o >> 8) & 255, 255 & o], t),
          yield s;
      }
    };
  },
  "internal/test_runner/runner": function (e, t, r, s, n, o) {
    "use strict";
    const {
        ArrayFrom: i,
        ArrayIsArray: a,
        ArrayPrototypeFilter: l,
        ArrayPrototypeForEach: u,
        ArrayPrototypeIncludes: p,
        ArrayPrototypeMap: d,
        ArrayPrototypePush: f,
        ArrayPrototypeShift: c,
        ArrayPrototypeSlice: h,
        ArrayPrototypeSome: _,
        ArrayPrototypeSort: g,
        ObjectAssign: y,
        PromisePrototypeThen: w,
        SafePromiseAll: S,
        SafePromiseAllReturnVoid: m,
        SafePromiseAllSettledReturnVoid: R,
        PromiseResolve: T,
        SafeMap: P,
        SafeSet: B,
        StringPrototypeIndexOf: A,
        StringPrototypeSlice: E,
        StringPrototypeStartsWith: v,
        TypedArrayPrototypeGetLength: x,
        TypedArrayPrototypeSubarray: F,
      } = o,
      { spawn: b } = t("child_process"),
      { readdirSync: I, statSync: k } = t("fs"),
      { finished: C } = t("internal/streams/end-of-stream"),
      { DefaultDeserializer: N, DefaultSerializer: O } = t("v8"),
      { createInterface: z } = t("readline"),
      { deserializeError: D } = t("internal/error_serdes"),
      { Buffer: L } = t("buffer"),
      { FilesWatcher: M } = t("internal/watch_mode/files_watcher"),
      V = t("internal/console/global"),
      {
        codes: {
          ERR_INVALID_ARG_TYPE: $,
          ERR_INVALID_ARG_VALUE: j,
          ERR_TEST_FAILURE: U,
          ERR_OUT_OF_RANGE: G,
        },
      } = t("internal/errors"),
      {
        validateArray: H,
        validateBoolean: W,
        validateFunction: X,
        validateObject: Y,
        validateInteger: q,
      } = t("internal/validators"),
      {
        getInspectPort: J,
        isUsingInspector: K,
        isInspectorMessage: Q,
      } = t("internal/util/inspector"),
      { isRegExp: Z } = t("internal/util/types"),
      { kEmptyObject: ee } = t("internal/util"),
      { kEmitMessage: te } = t("internal/test_runner/tests_stream"),
      { createTestTree: re } = t("internal/test_runner/harness"),
      {
        kAborted: se,
        kCancelledByParent: ne,
        kSubtestsFailed: oe,
        kTestCodeFailure: ie,
        kTestTimeoutFailure: ae,
        Test: le,
      } = t("internal/test_runner/test"),
      {
        convertStringToRegExp: ue,
        countCompletedTest: pe,
        doesPathMatchFilter: de,
        isSupportedFileType: fe,
      } = t("internal/test_runner/utils"),
      { basename: ce, join: he, resolve: _e } = t("path"),
      { once: ge } = t("events"),
      { triggerUncaughtException: ye } = n("errors"),
      we = ["--test", "--experimental-test-coverage", "--watch"],
      Se = ["--test-reporter", "--test-reporter-destination"],
      me = [
        "tests",
        "suites",
        "pass",
        "fail",
        "cancelled",
        "skipped",
        "todo",
        "duration_ms",
      ],
      Re = new B().add(ne).add(se).add(ae);
    let Te;
    function processPath(e, t, r) {
      const s = k(e);
      if (s.isFile())
        (r.userSupplied || (r.underTestDir && fe(e)) || de(e)) && t.add(e);
      else if (s.isDirectory()) {
        const s = ce(e);
        if (!r.userSupplied && "node_modules" === s) return;
        const n = "test" === s,
          { underTestDir: o } = r,
          i = I(e);
        n && (r.underTestDir = !0), (r.userSupplied = !1);
        for (let s = 0; s < i.length; s++) processPath(he(e, i[s]), t, r);
        r.underTestDir = o;
      }
    }
    function filterExecArgv(e, t, r) {
      return (
        !p(we, e) &&
        !_(Se, (s) => e === s || (t > 0 && r[t - 1] === s) || v(e, `${s}=`))
      );
    }
    const Pe = new O();
    Pe.writeHeader();
    const Be = Pe.releaseBuffer(),
      Ae = x(Be),
      Ee = 4 + Ae;
    class FileTest extends le {
      #e = [];
      #t = [];
      #r = 0;
      #s = 0;
      failedSubtests = !1;
      constructor(e) {
        super(e),
          (this.loc ??= {
            __proto__: null,
            line: 1,
            column: 1,
            file: _e(this.name),
          });
      }
      #n() {
        return this.#s > 0 && (!this.error || this.error.failureType === oe);
      }
      #o(e) {
        const t = A(e, " ");
        if (-1 === t) return !1;
        return -1 === A(e, " ", t + 1) && p(me, E(e, 0, t));
      }
      #i(e) {
        const t = 0 === e.data.nesting;
        if (t) {
          if ("test:plan" === e.type && this.#n()) return;
          if ("test:diagnostic" === e.type && this.#o(e.data.message)) return;
        }
        e.data.details?.error &&
          (e.data.details.error = D(e.data.details.error)),
          ("test:pass" !== e.type && "test:fail" !== e.type) ||
            ((e.data.testNumber = t
              ? this.root.harness.counters.topLevel + 1
              : e.data.testNumber),
            pe(
              {
                __proto__: null,
                name: e.data.name,
                finished: !0,
                skipped: void 0 !== e.data.skip,
                isTodo: void 0 !== e.data.todo,
                passed: "test:pass" === e.type,
                cancelled: Re.has(e.data.details?.error?.failureType),
                nesting: e.data.nesting,
                reportedType: e.data.details?.type,
              },
              this.root.harness
            )),
          this.reporter[te](e.type, e.data);
      }
      #a(e) {
        ("test:pass" !== e.type && "test:fail" !== e.type) ||
          (this.#s++,
          0 === e.data.nesting &&
            "test:fail" === e.type &&
            (this.failedSubtests = !0));
      }
      #l() {
        this.#e.length > 0 && (u(this.#e, (e) => this.#i(e)), (this.#e = []));
      }
      addToReport(e) {
        this.#a(e),
          this.isClearToSend() ? (this.#l(), this.#i(e)) : f(this.#e, e);
      }
      reportStarted() {}
      drain() {
        this.#u(), this.#l();
      }
      report() {
        this.drain();
        this.#n() || (super.reportStarted(), super.report());
      }
      parseMessage(e) {
        let t = x(e);
        if (0 === t) return;
        const r = e[t - 1] === Be[0];
        r && ((e = F(e, 0, t - 1)), t--),
          this.#t[0] && x(this.#t[0]) < Ee
            ? (this.#t[0] = L.concat([this.#t[0], e]))
            : f(this.#t, e),
          (this.#r += t),
          this.#p(),
          r && (f(this.#t, F(Be, 0, 1)), this.#r++);
      }
      #u() {
        for (; this.#t.length > 0; ) this.#p();
      }
      #p() {
        let e = this.#t[0],
          t = e.indexOf(Be),
          r = L.alloc(0);
        for (; e && 0 !== t; ) {
          const s = -1 === t ? e : e.slice(0, t);
          (r = L.concat([r, s])),
            (this.#r -= x(s)),
            -1 === t ? c(this.#t) : (this.#t[0] = F(e, t)),
            (e = this.#t[0]),
            (t = e?.indexOf(Be));
        }
        for (
          x(r) > 0 &&
          this.addToReport({
            __proto__: null,
            type: "test:stdout",
            data: {
              __proto__: null,
              file: this.name,
              message: r.toString("utf-8"),
            },
          });
          e?.length >= Ee;

        ) {
          const t =
            ((e[Ae] << 24) | (e[Ae + 1] << 16) | (e[Ae + 2] << 8) | e[Ae + 3]) +
            Ee;
          if (this.#r < t) break;
          const r =
              1 === this.#t.length ? this.#t[0] : L.concat(this.#t, this.#r),
            s = new N(F(r, Ee, t));
          (e = F(r, t)),
            (this.#r = x(e)),
            (this.#t = 0 !== this.#r ? [e] : []),
            s.readHeader();
          const n = s.readValue();
          this.addToReport(n);
        }
      }
    }
    function runTestFile(e, t, r) {
      const n = null != t,
        o = r.root.createSubtest(FileTest, e, async (i) => {
          const a = (function getRunArgs(
              e,
              { inspectPort: t, testNamePatterns: r, only: n }
            ) {
              const o = l(s.execArgv, filterExecArgv);
              return (
                K() && f(o, `--inspect-port=${J(t)}`),
                null != r && u(r, (e) => f(o, `--test-name-pattern=${e}`)),
                !0 === n && f(o, "--test-only"),
                f(o, e),
                o
              );
            })(e, r),
            p = ["pipe", "pipe", "pipe"],
            d = { __proto__: null, ...s.env, NODE_TEST_CONTEXT: "child-v8" };
          n && (p.push("ipc"), (d.WATCH_REPORT_DEPENDENCIES = "1")),
            r.root.harness.shouldColorizeTestFiles && (d.FORCE_COLOR = "1");
          const c = b(s.execPath, a, {
            __proto__: null,
            signal: i.signal,
            encoding: "utf8",
            env: d,
            stdio: p,
          });
          let h;
          n &&
            (t.runningProcesses.set(e, c),
            t.watcher.watchChildProcessModules(c, e)),
            c.on("error", (e) => {
              h = e;
            }),
            c.stdout.on("data", (e) => {
              o.parseMessage(e);
            });
          z({ __proto__: null, input: c.stderr }).on("line", (t) => {
            Q(t)
              ? s.stderr.write(t + "\n")
              : o.addToReport({
                  __proto__: null,
                  type: "test:stderr",
                  data: { __proto__: null, file: e, message: t + "\n" },
                });
          });
          const {
            0: { 0: _, 1: g },
          } = await S([
            ge(c, "exit", { __proto__: null, signal: i.signal }),
            C(c.stdout, { __proto__: null, signal: i.signal }),
          ]);
          if (
            (n &&
              (t.runningProcesses.delete(e),
              t.runningSubtests.delete(e),
              0 === t.runningSubtests.size &&
                r.root.reporter[te]("test:watch:drained")),
            0 !== _ || null !== g)
          ) {
            if (!h) {
              const e = o.failedSubtests ? oe : ie;
              h = y(new U("test failed", e), {
                __proto__: null,
                exitCode: _,
                signal: g,
                stack: void 0,
              });
            }
            throw h;
          }
        });
      return o.start();
    }
    r.exports = {
      FileTest: FileTest,
      run: function run(e) {
        (null !== e && "object" == typeof e) || (e = ee);
        let { testNamePatterns: r, shard: n } = e;
        const {
          concurrency: o,
          timeout: u,
          signal: p,
          files: f,
          inspectPort: c,
          watch: _,
          setup: y,
          only: S,
        } = e;
        if (
          (null != f && H(f, "options.files"),
          null != _ && W(_, "options.watch"),
          null != S && W(S, "options.only"),
          null != n)
        ) {
          if (
            (Y(n, "options.shard"),
            (n = { __proto__: null, index: n.index, total: n.total }),
            q(n.total, "options.shard.total", 1),
            q(n.index, "options.shard.index"),
            n.index <= 0 || n.total < n.index)
          )
            throw new G(
              "options.shard.index",
              `>= 1 && <= ${n.total} ("options.shard.total")`,
              n.index
            );
          if (_)
            throw new j(
              "options.shard",
              _,
              "shards not supported with watch mode"
            );
        }
        null != y && X(y, "options.setup"),
          null != r &&
            (a(r) || (r = [r]),
            (r = d(r, (e, t) => {
              if (Z(e)) return e;
              const r = `options.testNamePatterns[${t}]`;
              if ("string" == typeof e) return ue(e, r);
              throw new $(r, ["string", "RegExp"], e);
            })));
        const A = re({
          __proto__: null,
          concurrency: o,
          timeout: u,
          signal: p,
        });
        let E =
          f ??
          (function createTestFileList() {
            const e = s.cwd(),
              t = s.argv.length > 1 ? h(s.argv, 1) : [e],
              r = new B();
            try {
              for (let e = 0; e < t.length; e++)
                processPath(_e(t[e]), r, { __proto__: null, userSupplied: !0 });
            } catch (e) {
              throw (
                ("ENOENT" === e?.code &&
                  (V.error(`Could not find '${e.path}'`), s.exit(1)),
                e)
              );
            }
            return g(i(r));
          })();
        n && (E = l(E, (e, t) => t % n.total == n.index - 1));
        let v,
          postRun = () => A.postRun();
        const x = {
          __proto__: null,
          root: A,
          signal: p,
          inspectPort: c,
          testNamePatterns: r,
          only: S,
        };
        return (
          _ &&
            ((v = (function watchFiles(e, r) {
              const s = new P(),
                n = new P(),
                o = new M({
                  __proto__: null,
                  debounce: 200,
                  mode: "filter",
                  signal: r.signal,
                }),
                i = {
                  __proto__: null,
                  watcher: o,
                  runningProcesses: s,
                  runningSubtests: n,
                };
              return (
                o.on("changed", ({ owners: t }) => {
                  o.unfilterFilesOwnedBy(t),
                    w(
                      m(
                        e,
                        async (e) => {
                          if (!t.has(e)) return;
                          const o = s.get(e);
                          o && (o.kill(), await ge(o, "exit")),
                            n.size || (r.root.harness.counters.topLevel = 0),
                            await n.get(e),
                            n.set(e, runTestFile(e, i, r));
                        },
                        void 0,
                        (e) => {
                          ye(e, !0);
                        }
                      )
                    );
                }),
                r.signal &&
                  ((Te ??= t("internal/event_target").kResistStopPropagation),
                  r.signal.addEventListener("abort", () => r.root.postRun(), {
                    __proto__: null,
                    once: !0,
                    [Te]: !0,
                  })),
                i
              );
            })(E, x)),
            (postRun = void 0)),
          w(
            w(
              T(y?.(A)),
              () => (
                (A.harness.bootstrapComplete = !0),
                R(E, (e) => {
                  const t = runTestFile(e, v, x);
                  return v?.runningSubtests.set(e, t), t;
                })
              )
            ),
            postRun
          ),
          A.reporter
        );
      },
    };
  },
  "internal/test_runner/test": function (t, e, s, i, r, n) {
    "use strict";
    const {
        ArrayPrototypePush: o,
        ArrayPrototypePushApply: a,
        ArrayPrototypeReduce: h,
        ArrayPrototypeShift: l,
        ArrayPrototypeSlice: u,
        ArrayPrototypeSome: c,
        ArrayPrototypeUnshift: p,
        FunctionPrototype: d,
        MathMax: g,
        Number: b,
        ObjectSeal: f,
        PromisePrototypeThen: m,
        PromiseResolve: y,
        SafePromisePrototypeFinally: _,
        ReflectApply: S,
        RegExpPrototypeExec: T,
        SafeMap: k,
        SafeSet: w,
        SafePromiseAll: P,
        SafePromiseRace: v,
        SymbolDispose: R,
        ObjectDefineProperty: A,
        Symbol: E,
      } = n,
      { getCallerLocation: C } = r("util"),
      { addAbortListener: O } = e("events"),
      { AsyncResource: x } = e("async_hooks"),
      { AbortController: H } = e("internal/abort_controller"),
      {
        codes: { ERR_INVALID_ARG_TYPE: F, ERR_TEST_FAILURE: N },
        AbortError: $,
      } = e("internal/errors"),
      { MockTracker: I } = e("internal/test_runner/mock/mock"),
      { TestsStream: L } = e("internal/test_runner/tests_stream"),
      {
        createDeferredCallback: j,
        countCompletedTest: D,
        isTestFailureError: M,
        parseCommandLine: U,
      } = e("internal/test_runner/utils"),
      {
        createDeferredPromise: q,
        kEmptyObject: z,
        once: B,
      } = e("internal/util"),
      { isPromise: G } = e("internal/util/types"),
      {
        validateAbortSignal: V,
        validateNumber: X,
        validateOneOf: Y,
        validateUint32: J,
      } = e("internal/validators"),
      { setTimeout: K } = e("timers"),
      { TIMEOUT_MAX: Q } = e("internal/timers"),
      { availableParallelism: W } = e("os"),
      { bigint: Z } = i.hrtime,
      tt = "cancelledByParent",
      et = "testAborted",
      st = "subtestsFailed",
      it = "testCodeFailure",
      rt = "testTimeoutFailure",
      nt = "hookFailed",
      ot = d,
      at = E("kShouldAbort"),
      ht = i.argv?.[1],
      lt = f(["before", "after", "beforeEach", "afterEach"]),
      ut = new w()
        .add(it)
        .add(nt)
        .add("uncaughtException")
        .add("unhandledRejection"),
      { testNamePatterns: ct, testOnlyFlag: pt } = U();
    let dt;
    function stopTest(t, e) {
      const s = q(),
        i = O(e, s.resolve);
      let r, n;
      return (
        null === t
          ? (n = i[R])
          : ((r = K(() => s.resolve(), t)),
            r.unref(),
            A(s, "promise", {
              __proto__: null,
              configurable: !0,
              writable: !0,
              value: m(s.promise, () => {
                throw new N(`test timed out after ${t}ms`, rt);
              }),
            }),
            (n = () => {
              i[R](), r[R]();
            })),
        A(s.promise, R, {
          __proto__: null,
          configurable: !0,
          writable: !0,
          value: n,
        }),
        s.promise
      );
    }
    class TestContext {
      #t;
      constructor(t) {
        this.#t = t;
      }
      get signal() {
        return this.#t.signal;
      }
      get name() {
        return this.#t.name;
      }
      diagnostic(t) {
        this.#t.diagnostic(t);
      }
      get mock() {
        return (this.#t.mock ??= new I()), this.#t.mock;
      }
      runOnly(t) {
        this.#t.runOnlySubtests = !!t;
      }
      skip(t) {
        this.#t.skip(t);
      }
      todo(t) {
        this.#t.todo(t);
      }
      test(t, e, s) {
        const i = { __proto__: null, loc: C() };
        return this.#t.createSubtest(Test, t, e, s, i).start();
      }
      before(t, e) {
        this.#t.createHook("before", t, e);
      }
      after(t, e) {
        this.#t.createHook("after", t, e);
      }
      beforeEach(t, e) {
        this.#t.createHook("beforeEach", t, e);
      }
      afterEach(t, e) {
        this.#t.createHook("afterEach", t, e);
      }
    }
    class SuiteContext {
      #e;
      constructor(t) {
        this.#e = t;
      }
      get signal() {
        return this.#e.signal;
      }
      get name() {
        return this.#e.name;
      }
    }
    class Test extends x {
      abortController;
      outerSignal;
      #s;
      constructor(t) {
        super("Test");
        let { fn: s, name: i, parent: r, skip: n } = t;
        const {
          concurrency: o,
          loc: a,
          only: h,
          timeout: l,
          todo: c,
          signal: p,
        } = t;
        if (
          ("function" != typeof s && (s = ot),
          ("string" == typeof i && "" !== i) || (i = s.name || "<anonymous>"),
          r instanceof Test || (r = null),
          null === r)
        )
          (this.concurrency = 1),
            (this.nesting = 0),
            (this.only = pt),
            (this.reporter = new L()),
            (this.runOnlySubtests = this.only),
            (this.testNumber = 0),
            (this.timeout = null),
            (this.root = this),
            (this.hooks = {
              __proto__: null,
              before: [],
              after: [],
              beforeEach: [],
              afterEach: [],
            });
        else {
          const t = null === r.parent ? r.nesting : r.nesting + 1;
          (this.concurrency = r.concurrency),
            (this.nesting = t),
            (this.only = h ?? !r.runOnlySubtests),
            (this.reporter = r.reporter),
            (this.runOnlySubtests = !this.only),
            (this.testNumber = r.subtests.length + 1),
            (this.timeout = r.timeout),
            (this.root = r.root),
            (this.hooks = {
              __proto__: null,
              before: [],
              after: [],
              beforeEach: u(r.hooks.beforeEach),
              afterEach: u(r.hooks.afterEach),
            });
        }
        switch (typeof o) {
          case "number":
            J(o, "options.concurrency", 1), (this.concurrency = o);
            break;
          case "boolean":
            this.concurrency = o ? (null === r ? g(W() - 1, 1) : 1 / 0) : 1;
            break;
          default:
            if (null != o)
              throw new F("options.concurrency", ["boolean", "number"], o);
        }
        if (
          (null != l &&
            l !== 1 / 0 &&
            (X(l, "options.timeout", 0, Q), (this.timeout = l)),
          (this.name = i),
          (this.parent = r),
          null === ct ||
            this.matchesTestNamePatterns() ||
            (n = "test name does not match pattern"),
          pt && !this.only && (n = "'only' option not set"),
          n && (s = ot),
          (this.abortController = new H()),
          (this.outerSignal = p),
          (this.signal = this.abortController.signal),
          V(p, "options.signal"),
          p && (dt ??= e("internal/event_target").kResistStopPropagation),
          this.outerSignal?.addEventListener("abort", this.#i, {
            __proto__: null,
            [dt]: !0,
          }),
          (this.fn = s),
          (this.harness = null),
          (this.mock = null),
          (this.cancelled = !1),
          (this.skipped = void 0 !== n && !1 !== n),
          (this.isTodo = void 0 !== c && !1 !== c),
          (this.startTime = null),
          (this.endTime = null),
          (this.passed = !1),
          (this.error = null),
          (this.diagnostics = []),
          (this.message =
            "string" == typeof n ? n : "string" == typeof c ? c : null),
          (this.activeSubtests = 0),
          (this.pendingSubtests = []),
          (this.readySubtests = new k()),
          (this.subtests = []),
          (this.waitingOn = 0),
          (this.finished = !1),
          !pt && (h || this.runOnlySubtests))
        ) {
          const t =
            "'only' and 'runOnly' require the --test-only command-line option.";
          this.diagnostic(t);
        }
        this.loc =
          void 0 === a || void 0 === ht
            ? void 0
            : { __proto__: null, line: a[0], column: a[1], file: a[2] };
      }
      matchesTestNamePatterns() {
        return (
          c(ct, (t) => null !== T(t, this.name)) ||
          this.parent?.matchesTestNamePatterns()
        );
      }
      hasConcurrency() {
        return this.concurrency > this.activeSubtests;
      }
      addPendingSubtest(t) {
        o(this.pendingSubtests, t);
      }
      async processPendingSubtests() {
        for (; this.pendingSubtests.length > 0 && this.hasConcurrency(); ) {
          const t = l(this.pendingSubtests),
            e = t.test;
          this.reporter.dequeue(e.nesting, e.loc, e.name),
            await e.run(),
            t.resolve();
        }
      }
      addReadySubtest(t) {
        this.readySubtests.set(t.testNumber, t);
      }
      processReadySubtestRange(t) {
        const e = this.waitingOn,
          s = e + this.readySubtests.size;
        for (let i = e; i < s; i++) {
          const e = this.readySubtests.get(i);
          if (void 0 === e) return;
          if (!(t = t || this.isClearToSend())) return;
          1 === i && null !== this.parent && this.reportStarted(),
            e.finalize(),
            this.readySubtests.delete(i);
        }
      }
      createSubtest(t, e, s, i, r) {
        "function" == typeof e
          ? (i = e)
          : null !== e && "object" == typeof e
          ? ((i = s), (s = e))
          : "function" == typeof s && (i = s),
          (null !== s && "object" == typeof s) || (s = z);
        let n = this;
        const a = this.finished || this.buildPhaseFinished;
        if (a) for (; null !== n.parent; ) n = n.parent;
        const h = new t({
          __proto__: null,
          fn: i,
          name: e,
          parent: n,
          ...s,
          ...r,
        });
        return (
          0 === n.waitingOn && (n.waitingOn = h.testNumber),
          a &&
            ((h.startTime = h.startTime || Z()),
            h.fail(
              new N(
                "test could not be started because its parent finished",
                "parentAlreadyFinished"
              )
            )),
          o(n.subtests, h),
          h
        );
      }
      #i = () => {
        const t = this.outerSignal?.reason || new $("The test was aborted");
        (t.failureType = et), this.#r(t);
      };
      #r(t) {
        null === this.endTime &&
          (this.fail(
            t ||
              new N(
                "test did not finish before its parent and was cancelled",
                tt
              )
          ),
          (this.startTime = this.startTime || this.endTime),
          (this.cancelled = !0),
          this.abortController.abort());
      }
      createHook(t, e, s) {
        Y(t, "hook name", lt);
        const i = new TestHook(e, s);
        return (
          ("before" !== t && "after" !== t) || (i.run = B(i.run)),
          o(this.hooks[t], i),
          i
        );
      }
      fail(t) {
        null === this.error &&
          ((this.endTime = Z()), (this.passed = !1), (this.error = t));
      }
      pass() {
        null === this.endTime && ((this.endTime = Z()), (this.passed = !0));
      }
      skip(t) {
        (this.skipped = !0), (this.message = t);
      }
      todo(t) {
        (this.isTodo = !0), (this.message = t);
      }
      diagnostic(t) {
        o(this.diagnostics, t);
      }
      start() {
        if (
          (this.reporter.enqueue(this.nesting, this.loc, this.name),
          !this.parent.hasConcurrency())
        ) {
          const t = q();
          return (t.test = this), this.parent.addPendingSubtest(t), t.promise;
        }
        return (
          this.reporter.dequeue(this.nesting, this.loc, this.name), this.run()
        );
      }
      [at]() {
        return (
          !!this.signal.aborted ||
          (this.outerSignal?.aborted ? (this.#i(), !0) : void 0)
        );
      }
      getRunArgs() {
        const t = new TestContext(this);
        return { __proto__: null, ctx: t, args: [t] };
      }
      async runHook(t, e) {
        Y(t, "hook name", lt);
        try {
          await h(
            this.hooks[t],
            async (t, s) => {
              if ((await t, await s.run(e), s.error)) throw s.error;
            },
            y()
          );
        } catch (e) {
          const s = new N(`failed running ${t} hook`, nt);
          throw ((s.cause = M(e) ? e.cause : e), s);
        }
      }
      async run() {
        if (
          (null !== this.parent && this.parent.activeSubtests++,
          (this.startTime = Z()),
          this[at]())
        )
          return void this.postRun();
        const { args: t, ctx: e } = this.getRunArgs(),
          after = async () => {
            this.hooks.after.length > 0 &&
              (await this.runHook("after", {
                __proto__: null,
                args: t,
                ctx: e,
              }));
          },
          s = B(async () => {
            this.parent?.hooks.afterEach.length > 0 &&
              (await this.parent.runHook("afterEach", {
                __proto__: null,
                args: t,
                ctx: e,
              }));
          });
        let i;
        try {
          this.parent?.hooks.before.length > 0 &&
            (await this.parent.runHook("before", this.parent.getRunArgs())),
            this.parent?.hooks.beforeEach.length > 0 &&
              (await this.parent.runHook("beforeEach", {
                __proto__: null,
                args: t,
                ctx: e,
              })),
            (i = stopTest(this.timeout, this.signal));
          const r = u(t);
          if ((p(r, this.fn, e), this.fn.length === r.length - 1)) {
            const { promise: t, cb: e } = j();
            o(r, e);
            const s = S(this.runInAsyncScope, this, r);
            G(s)
              ? (this.fail(
                  new N(
                    "passed a callback but also returned a Promise",
                    "callbackAndPromisePresent"
                  )
                ),
                await v([s, i]))
              : await v([y(t), i]);
          } else {
            const t = S(this.runInAsyncScope, this, r);
            await v([y(t), i]);
          }
          if (this[at]()) return void this.postRun();
          await s(), await after(), this.pass();
        } catch (t) {
          try {
            await s();
          } catch {}
          try {
            await after();
          } catch {}
          M(t)
            ? t.failureType === rt
              ? this.#r(t)
              : this.fail(t)
            : this.fail(new N(t, it));
        } finally {
          i?.[R](), null !== this.parent && this.abortController.abort();
        }
        (null === this.parent && "string" != typeof this.hookType) ||
          this.postRun();
      }
      postRun(t) {
        this.endTime < this.startTime && (this.endTime = Z()),
          (this.startTime ??= this.endTime),
          (this.pendingSubtests = []);
        let e = 0;
        for (let s = 0; s < this.subtests.length; s++) {
          const i = this.subtests[s];
          i.finished || (i.#r(t), i.postRun(t)), i.passed || i.isTodo || e++;
        }
        if ((this.passed || null === this.parent) && e > 0) {
          const t = `${e} ${"subtest" + (e > 1 ? "s" : "")} failed`;
          this.fail(new N(t, st));
        }
        if (
          (this.outerSignal?.removeEventListener("abort", this.#i),
          this.mock?.reset(),
          null !== this.parent)
        )
          this.parent.activeSubtests--,
            this.parent.addReadySubtest(this),
            this.parent.processReadySubtestRange(!1),
            this.parent.processPendingSubtests(),
            this.parent === this.root &&
              0 === this.root.activeSubtests &&
              0 === this.root.pendingSubtests.length &&
              0 === this.root.readySubtests.size &&
              this.root.hooks.after.length > 0 &&
              this.root.run();
        else if (!this.reported) {
          const {
            diagnostics: t,
            harness: e,
            loc: s,
            nesting: i,
            reporter: r,
          } = this;
          (this.reported = !0), r.plan(i, s, e.counters.topLevel);
          const n = e.coverage();
          for (let e = 0; e < t.length; e++) r.diagnostic(i, s, t[e]);
          r.diagnostic(i, s, `tests ${e.counters.all}`),
            r.diagnostic(i, s, `suites ${e.counters.suites}`),
            r.diagnostic(i, s, `pass ${e.counters.passed}`),
            r.diagnostic(i, s, `fail ${e.counters.failed}`),
            r.diagnostic(i, s, `cancelled ${e.counters.cancelled}`),
            r.diagnostic(i, s, `skipped ${e.counters.skipped}`),
            r.diagnostic(i, s, `todo ${e.counters.todo}`),
            r.diagnostic(i, s, `duration_ms ${this.duration()}`),
            n && r.coverage(i, s, n),
            r.end();
        }
      }
      isClearToSend() {
        return (
          null === this.parent ||
          (this.parent.waitingOn === this.testNumber &&
            this.parent.isClearToSend())
        );
      }
      finalize() {
        this.processReadySubtestRange(!0),
          this.report(),
          this.parent.waitingOn++,
          (this.finished = !0);
      }
      duration() {
        return b(this.endTime - this.startTime) / 1e6;
      }
      report() {
        let t;
        D(this),
          this.subtests.length > 0
            ? this.reporter.plan(
                this.subtests[0].nesting,
                this.loc,
                this.subtests.length
              )
            : this.reportStarted();
        const e = { __proto__: null, duration_ms: this.duration() };
        this.skipped
          ? (t = this.reporter.getSkip(this.message))
          : this.isTodo && (t = this.reporter.getTodo(this.message)),
          this.reportedType && (e.type = this.reportedType),
          this.passed
            ? this.reporter.ok(
                this.nesting,
                this.loc,
                this.testNumber,
                this.name,
                e,
                t
              )
            : ((e.error = this.error),
              this.reporter.fail(
                this.nesting,
                this.loc,
                this.testNumber,
                this.name,
                e,
                t
              ));
        for (let t = 0; t < this.diagnostics.length; t++)
          this.reporter.diagnostic(this.nesting, this.loc, this.diagnostics[t]);
      }
      reportStarted() {
        this.#s ||
          null === this.parent ||
          ((this.#s = !0),
          this.parent.reportStarted(),
          this.reporter.start(this.nesting, this.loc, this.name));
      }
    }
    class TestHook extends Test {
      #n;
      constructor(t, e) {
        (null !== e && "object" == typeof e) || (e = z);
        const { loc: s, timeout: i, signal: r } = e;
        super({ __proto__: null, fn: t, loc: s, timeout: i, signal: r }),
          (this.parentTest = e.parent ?? null),
          (this.hookType = e.hookType);
      }
      run(t) {
        return (
          this.error &&
            !this.outerSignal?.aborted &&
            ((this.passed = !1),
            (this.error = null),
            this.abortController.abort(),
            (this.abortController = new H()),
            (this.signal = this.abortController.signal)),
          (this.#n = t),
          super.run()
        );
      }
      getRunArgs() {
        return this.#n;
      }
      matchesTestNamePatterns() {
        return !0;
      }
      postRun() {
        const { error: t, loc: e, parentTest: s } = this;
        t &&
          null !== s &&
          s === s.root &&
          "after" === this.hookType &&
          (M(t) && (t.failureType = nt),
          s.reporter.fail(
            0,
            e,
            s.subtests.length + 1,
            e.file,
            { __proto__: null, duration_ms: this.duration(), error: t },
            void 0
          ));
      }
    }
    s.exports = {
      kCancelledByParent: tt,
      kSubtestsFailed: st,
      kTestCodeFailure: it,
      kTestTimeoutFailure: rt,
      kAborted: et,
      kUnwrapErrors: ut,
      Suite: class Suite extends Test {
        reportedType = "suite";
        constructor(t) {
          super(t),
            null === ct ||
              t.skip ||
              t.todo ||
              ((this.fn = t.fn || this.fn), (this.skipped = !1)),
            (this.runOnlySubtests = pt);
          try {
            const { ctx: t, args: e } = this.getRunArgs(),
              s = [this.fn, t];
            a(s, e),
              (this.buildSuite = _(
                m(y(S(this.runInAsyncScope, this, s)), void 0, (t) => {
                  this.fail(new N(t, it));
                }),
                () => {
                  this.buildPhaseFinished = !0;
                }
              ));
          } catch (t) {
            this.fail(new N(t, it)), (this.buildPhaseFinished = !0);
          }
          this.fn = () => {};
        }
        getRunArgs() {
          const t = new SuiteContext(this);
          return { __proto__: null, ctx: t, args: [t] };
        }
        async run() {
          const t = this.getRunArgs();
          let e;
          try {
            if (
              (this.parent.activeSubtests++,
              await this.buildSuite,
              (this.startTime = Z()),
              this[at]())
            )
              return (this.subtests = []), void this.postRun();
            this.parent.hooks.before.length > 0 &&
              (await this.parent.runHook("before", this.parent.getRunArgs())),
              await this.runHook("before", t),
              (e = stopTest(this.timeout, this.signal));
            const s = this.skipped || this.error ? [] : this.subtests,
              i = P(s, (t) => t.start());
            await v([i, e]), await this.runHook("after", t), this.pass();
          } catch (t) {
            M(t) ? this.fail(t) : this.fail(new N(t, it));
          } finally {
            e?.[R]();
          }
          this.postRun();
        }
      },
      Test: Test,
    };
  },
  "internal/test_runner/tests_stream": function (t, s, e, n, r, _) {
    "use strict";
    const { ArrayPrototypePush: o, ArrayPrototypeShift: u, Symbol: i } = _,
      a = s("internal/streams/readable"),
      l = i("kEmitMessage");
    e.exports = {
      TestsStream: class TestsStream extends a {
        #t;
        #s;
        constructor() {
          super({ __proto__: null, objectMode: !0 }),
            (this.#t = []),
            (this.#s = !0);
        }
        _read() {
          for (this.#s = !0; this.#t.length > 0; ) {
            const t = u(this.#t);
            if (!this.#e(t)) return;
          }
        }
        fail(t, s, e, n, r, _) {
          this[l]("test:fail", {
            __proto__: null,
            name: n,
            nesting: t,
            testNumber: e,
            details: r,
            ...s,
            ..._,
          });
        }
        ok(t, s, e, n, r, _) {
          this[l]("test:pass", {
            __proto__: null,
            name: n,
            nesting: t,
            testNumber: e,
            details: r,
            ...s,
            ..._,
          });
        }
        plan(t, s, e) {
          this[l]("test:plan", { __proto__: null, nesting: t, count: e, ...s });
        }
        getSkip(t = void 0) {
          return { __proto__: null, skip: t ?? !0 };
        }
        getTodo(t = void 0) {
          return { __proto__: null, todo: t ?? !0 };
        }
        enqueue(t, s, e) {
          this[l]("test:enqueue", {
            __proto__: null,
            nesting: t,
            name: e,
            ...s,
          });
        }
        dequeue(t, s, e) {
          this[l]("test:dequeue", {
            __proto__: null,
            nesting: t,
            name: e,
            ...s,
          });
        }
        start(t, s, e) {
          this[l]("test:start", { __proto__: null, nesting: t, name: e, ...s });
        }
        diagnostic(t, s, e) {
          this[l]("test:diagnostic", {
            __proto__: null,
            nesting: t,
            message: e,
            ...s,
          });
        }
        stderr(t, s) {
          this[l]("test:stderr", { __proto__: null, message: s, ...t });
        }
        stdout(t, s) {
          this[l]("test:stdout", { __proto__: null, message: s, ...t });
        }
        coverage(t, s, e) {
          this[l]("test:coverage", {
            __proto__: null,
            nesting: t,
            summary: e,
            ...s,
          });
        }
        end() {
          this.#e(null);
        }
        [l](t, s) {
          this.emit(t, s), this.#e({ type: t, data: s });
        }
        #e(t) {
          return this.#s ? (this.#s = this.push(t)) : o(this.#t, t), this.#s;
        }
      },
      kEmitMessage: l,
    };
  },
  "internal/test_runner/utils": function (e, t, r, n, o, s) {
    "use strict";
    const {
        ArrayPrototypeJoin: i,
        ArrayPrototypeMap: l,
        ArrayPrototypePush: a,
        ArrayPrototypeReduce: c,
        ObjectCreate: u,
        ObjectGetOwnPropertyDescriptor: p,
        MathFloor: d,
        MathMax: g,
        MathMin: f,
        NumberPrototypeToFixed: h,
        SafePromiseAllReturnArrayLike: m,
        RegExp: $,
        RegExpPrototypeExec: T,
        SafeMap: v,
        StringPrototypePadStart: y,
        StringPrototypePadEnd: _,
        StringPrototypeRepeat: E,
        StringPrototypeSlice: R,
      } = s,
      { AsyncResource: C } = t("async_hooks"),
      { basename: L, relative: S } = t("path"),
      { createWriteStream: w } = t("fs"),
      { pathToFileURL: P } = t("internal/url"),
      { createDeferredPromise: b } = t("internal/util"),
      { getOptionValue: F } = t("internal/options"),
      {
        green: k,
        yellow: x,
        red: A,
        white: M,
        shouldColorize: N,
      } = t("internal/util/colors"),
      {
        codes: { ERR_INVALID_ARG_VALUE: D, ERR_TEST_FAILURE: O },
        kIsNodeError: j,
      } = t("internal/errors"),
      { compose: I } = t("stream"),
      U = k,
      z = x,
      V = A,
      B = /^\/(.*)\/([a-z]*)$/,
      G = /\.[cm]?js$/,
      X = /((^test(-.+)?)|(.+[.\-_]test))\.[cm]?js$/;
    function convertStringToRegExp(e, t) {
      const r = T(B, e),
        n = r?.[1] ?? e,
        o = r?.[2] || "";
      try {
        return new $(n, o);
      } catch (r) {
        const n = r?.message;
        throw new D(
          t,
          e,
          "is an invalid regular expression." + (n ? ` ${n}` : "")
        );
      }
    }
    const J = new v([
        ["stdout", n.stdout],
        ["stderr", n.stderr],
      ]),
      W = new v([
        ["spec", "internal/test_runner/reporter/spec"],
        ["dot", "internal/test_runner/reporter/dot"],
        ["tap", "internal/test_runner/reporter/tap"],
        ["junit", "internal/test_runner/reporter/junit"],
      ]),
      Y = n.stdout.isTTY ? "spec" : "tap",
      q = "stdout";
    async function getReportersMap(e, r, o) {
      return m(e, async (e, s) => {
        const i = J.get(r[s]) ?? w(r[s]);
        o.harness.shouldColorizeTestFiles ||= N(i);
        let l = (function tryBuiltinReporter(e) {
          const r = W.get(e);
          if (void 0 !== r) return t(r);
        })(e);
        if (void 0 === l) {
          let r;
          try {
            r = P(n.cwd() + "/").href;
          } catch {
            r = "file:///";
          }
          const { esmLoader: o } = t("internal/process/esm_loader");
          l = await o.import(e, r, u(null));
        }
        if (
          (l?.default && (l = l.default),
          l?.prototype && p(l.prototype, "constructor") && (l = new l()),
          !l)
        )
          throw new D("Reporter", e, "is not a valid reporter");
        return { __proto__: null, reporter: l, destination: i };
      });
    }
    const H = new C("TestReporterScope"),
      K = H.bind(async (e) => {
        const { reporters: t, destinations: r } = parseCommandLine(),
          n = await getReportersMap(t, r, e);
        for (let t = 0; t < n.length; t++) {
          const { reporter: r, destination: o } = n[t];
          I(e.reporter, r).pipe(o);
        }
      });
    let Q;
    function parseCommandLine() {
      if (Q) return Q;
      const e = F("--test"),
        t = F("--experimental-test-coverage"),
        r = "child" === n.env.NODE_TEST_CONTEXT;
      let o, s, i, c;
      if ("child-v8" === n.env.NODE_TEST_CONTEXT)
        W.set("v8-serializer", "internal/test_runner/reporter/v8-serializer"),
          (s = ["v8-serializer"]),
          (o = [q]);
      else if (r) (s = ["tap"]), (o = [q]);
      else if (
        ((o = F("--test-reporter-destination")),
        (s = F("--test-reporter")),
        0 === s.length && 0 === o.length && a(s, Y),
        1 === s.length && 0 === o.length && a(o, q),
        o.length !== s.length)
      )
        throw new D(
          "--test-reporter",
          s,
          "must match the number of specified '--test-reporter-destination'"
        );
      if (e) (c = !1), (i = null);
      else {
        const e = F("--test-name-pattern");
        (c = F("--test-only")),
          (i =
            e?.length > 0
              ? l(e, (e) => convertStringToRegExp(e, "--test-name-pattern"))
              : null);
      }
      return (
        (Q = {
          __proto__: null,
          isTestRunner: e,
          coverage: t,
          testOnlyFlag: c,
          testNamePatterns: i,
          reporters: s,
          destinations: o,
        }),
        Q
      );
    }
    const Z = new v();
    function addTableLine(e, t) {
      const r = `${e}-${t}`;
      let n = Z.get(r);
      return void 0 === n && ((n = `${e}${E("-", t)}\n`), Z.set(r, n)), n;
    }
    const ee = "…";
    function truncateStart(e, t) {
      return e.length > t ? `${ee}${R(e, e.length - t + 1)}` : e;
    }
    function truncateEnd(e, t) {
      return e.length > t ? `${R(e, 0, t - 1)}${ee}` : e;
    }
    function formatUncoveredLines(e, t) {
      return t
        ? i(
            (function formatLinesToRanges(e) {
              return l(
                c(
                  e,
                  (e, t, r, n) => (
                    r > 0 && t - n[r - 1] == 1
                      ? (e[e.length - 1][1] = t)
                      : e.push([t]),
                    e
                  ),
                  []
                ),
                (e) => i(e, "-")
              );
            })(e),
            " "
          )
        : i(e, ", ");
    }
    const te = ["line %", "branch %", "funcs %"],
      re = [
        "coveredLinePercent",
        "coveredBranchPercent",
        "coveredFunctionPercent",
      ],
      ne = " | ";
    r.exports = {
      convertStringToRegExp: convertStringToRegExp,
      countCompletedTest: function countCompletedTest(e, t = e.root.harness) {
        0 === e.nesting && t.counters.topLevel++,
          "suite" !== e.reportedType
            ? (e.skipped
                ? t.counters.skipped++
                : e.isTodo
                ? t.counters.todo++
                : e.cancelled
                ? t.counters.cancelled++
                : e.passed
                ? t.counters.passed++
                : t.counters.failed++,
              t.counters.all++)
            : t.counters.suites++;
      },
      createDeferredCallback: function createDeferredCallback() {
        let e = 0;
        const { promise: t, resolve: r, reject: n } = b();
        return {
          __proto__: null,
          promise: t,
          cb: (t) => {
            if ((e++, e > 1)) {
              if (2 === e)
                throw new O(
                  "callback invoked multiple times",
                  "multipleCallbackInvocations"
                );
            } else {
              if (t) return n(t);
              r();
            }
          },
        };
      },
      doesPathMatchFilter: function doesPathMatchFilter(e) {
        return null !== T(X, L(e));
      },
      isSupportedFileType: function isSupportedFileType(e) {
        return null !== T(G, e);
      },
      isTestFailureError: function isTestFailureError(e) {
        return "ERR_TEST_FAILURE" === e?.code && j in e;
      },
      parseCommandLine: parseCommandLine,
      reporterScope: H,
      setupTestReporters: K,
      getCoverageReport: function getCoverageReport(e, t, r, o, s) {
        const a = `${e}${r}`;
        let u,
          p,
          m,
          $ = `${o}${a}start of coverage report\n`,
          T = [];
        if (s) {
          (u =
            s &&
            c(
              t.files,
              (e, r) => g(e, S(t.workingDirectory, r.path).length),
              0
            )),
            (u = g(u, 4));
          const e = u + 2;
          T = l(te, (e) => (s ? g(e.length, 6) : 0));
          const r = c(T, (e, t) => e + t + 3, 0);
          (p =
            s &&
            c(
              t.files,
              (e, t) =>
                g(e, formatUncoveredLines(t.uncoveredLineNumbers, s).length),
              0
            )),
            (p = g(p, 15));
          m = e + r + (p + 2);
          const o = (n.stdout.columns || 1 / 0) - a.length,
            i = m - o;
          if (s && i > 0) {
            const e = f(8, u);
            (u -= d(0.2 * i)),
              (u = g(u, e)),
              (p = g(o - r - (u + 2) - 2, 1)),
              (m = o);
          } else p = 1 / 0;
        }
        function getCell(e, t, r, n, i) {
          if (!s) return e;
          let l = e;
          return (
            r && (l = r(l, t)),
            n && (l = n(l, t)),
            o && void 0 !== i
              ? i > 90
                ? `${U}${l}${o}`
                : i > 50
                ? `${z}${l}${o}`
                : `${V}${l}${o}`
              : l
          );
        }
        s && ($ += addTableLine(a, m)),
          ($ += `${a}${getCell("file", u, _, truncateEnd)}${ne}${i(
            l(te, (e, t) => getCell(e, T[t], y)),
            ne
          )}${ne}${getCell("uncovered lines", p, !1, truncateEnd)}\n`),
          s && ($ += addTableLine(a, m));
        for (let e = 0; e < t.files.length; ++e) {
          const r = t.files[e],
            n = S(t.workingDirectory, r.path);
          let o = 0;
          const c = l(re, (e) => {
            const t = r[e];
            return (o += t), t;
          });
          (o /= re.length),
            ($ += `${a}${getCell(n, u, _, truncateStart, o)}${ne}${i(
              l(c, (e, t) => getCell(h(e, 2), T[t], y, !1, e)),
              ne
            )}${ne}${getCell(
              formatUncoveredLines(r.uncoveredLineNumbers, s),
              p,
              !1,
              truncateEnd
            )}\n`);
        }
        return (
          s && ($ += addTableLine(a, m)),
          ($ += `${a}${getCell("all files", u, _, truncateEnd)}${ne}${i(
            l(re, (e, r) =>
              getCell(h(t.totals[e], 2), T[r], y, !1, t.totals[e])
            ),
            ne
          )} |\n`),
          s && ($ += addTableLine(a, m)),
          ($ += `${a}end of coverage report\n`),
          o && ($ += M),
          $
        );
      },
    };
  },
  "internal/timers": function (e, t, i, n, s, r) {
    "use strict";
    const {
        MathMax: o,
        MathTrunc: u,
        NumberIsFinite: d,
        NumberMIN_SAFE_INTEGER: l,
        ObjectCreate: a,
        ReflectApply: c,
        Symbol: m,
        setTimeout: h,
      } = r,
      {
        scheduleTimer: _,
        toggleTimerRef: f,
        getLibuvNow: y,
        immediateInfo: T,
        timeoutInfo: p,
        toggleImmediateRef: v,
      } = s("timers"),
      {
        getDefaultTriggerAsyncId: g,
        newAsyncId: R,
        initHooksExist: I,
        destroyHooksExist: x,
        emitInit: N,
        emitBefore: b,
        emitAfter: A,
        emitDestroy: k,
      } = t("internal/async_hooks"),
      w = m("asyncId"),
      C = m("triggerId"),
      P = m("kHasPrimitive"),
      { ERR_OUT_OF_RANGE: L } = t("internal/errors").codes,
      { validateFunction: O, validateNumber: E } = t("internal/validators"),
      M = t("internal/linkedlist"),
      D = t("internal/priority_queue"),
      { inspect: F } = t("internal/util/inspect");
    let S = t("internal/util/debuglog").debuglog("timer", (e) => {
      S = e;
    });
    const G = 2 ** 31 - 1;
    let H = l;
    const Q = m("refed");
    let U = 1 / 0;
    p[0] = 0;
    const W = new D(
        function compareTimersLists(e, t) {
          const i = e.expiry - t.expiry;
          if (0 === i) {
            if (e.id < t.id) return -1;
            if (e.id > t.id) return 1;
          }
          return i;
        },
        function setPosition(e, t) {
          e.priorityQueuePosition = t;
        }
      ),
      $ = a(null);
    function initAsyncResource(e, t) {
      const i = (e[w] = R()),
        n = (e[C] = g());
      I() && N(i, t, n, e);
    }
    class Timeout {
      constructor(e, t, i, s, r) {
        ((t *= 1) >= 1 && t <= G) ||
          (t > G &&
            n.emitWarning(
              `${t} does not fit into a 32-bit signed integer.\nTimeout duration was set to 1.`,
              "TimeoutOverflowWarning"
            ),
          (t = 1)),
          (this._idleTimeout = t),
          (this._idlePrev = this),
          (this._idleNext = this),
          (this._idleStart = null),
          (this._onTimeout = null),
          (this._onTimeout = e),
          (this._timerArgs = i),
          (this._repeat = s ? t : null),
          (this._destroyed = !1),
          r && incRefCount(),
          (this[Q] = r),
          (this[P] = !1),
          initAsyncResource(this, "Timeout");
      }
      [F.custom](e, t) {
        return F(this, { ...t, depth: 0, customInspect: !1 });
      }
      refresh() {
        return this[Q] ? active(this) : unrefActive(this), this;
      }
      unref() {
        return (
          this[Q] && ((this[Q] = !1), this._destroyed || decRefCount()), this
        );
      }
      ref() {
        return (
          this[Q] || ((this[Q] = !0), this._destroyed || incRefCount()), this
        );
      }
      hasRef() {
        return this[Q];
      }
    }
    class TimersList {
      constructor(e, t) {
        (this._idleNext = this),
          (this._idlePrev = this),
          (this.expiry = e),
          (this.id = H++),
          (this.msecs = t),
          (this.priorityQueuePosition = null);
      }
      [F.custom](e, t) {
        return F(this, { ...t, depth: 0, customInspect: !1 });
      }
    }
    class ImmediateList {
      constructor() {
        (this.head = null), (this.tail = null);
      }
      append(e) {
        null !== this.tail
          ? ((this.tail._idleNext = e), (e._idlePrev = this.tail))
          : (this.head = e),
          (this.tail = e);
      }
      remove(e) {
        e._idleNext && (e._idleNext._idlePrev = e._idlePrev),
          e._idlePrev && (e._idlePrev._idleNext = e._idleNext),
          e === this.head && (this.head = e._idleNext),
          e === this.tail && (this.tail = e._idlePrev),
          (e._idleNext = null),
          (e._idlePrev = null);
      }
    }
    const j = new ImmediateList();
    function incRefCount() {
      0 == p[0]++ && f(!0);
    }
    function decRefCount() {
      0 == --p[0] && f(!1);
    }
    function active(e) {
      insertGuarded(e, !0);
    }
    function unrefActive(e) {
      insertGuarded(e, !1);
    }
    function insertGuarded(e, t, i) {
      const n = e._idleTimeout;
      if (n < 0 || void 0 === n) return;
      insert(e, n, i);
      const s = e._destroyed;
      (!s && e[w]) || ((e._destroyed = !1), initAsyncResource(e, "Timeout")),
        s
          ? t && incRefCount()
          : t === !e[Q] && (t ? incRefCount() : decRefCount()),
        (e[Q] = t);
    }
    function insert(e, t, i = y()) {
      (t = u(t)), (e._idleStart = i);
      let n = $[t];
      if (void 0 === n) {
        S("no %d list was found in insert, creating a new one", t);
        const e = i + t;
        ($[t] = n = new TimersList(e, t)),
          W.insert(n),
          U > e && (_(t), (U = e));
      }
      M.append(n, e);
    }
    i.exports = {
      TIMEOUT_MAX: G,
      kTimeout: m("timeout"),
      async_id_symbol: w,
      trigger_async_id_symbol: C,
      Timeout: Timeout,
      Immediate: class Immediate {
        constructor(e, t) {
          (this._idleNext = null),
            (this._idlePrev = null),
            (this._onImmediate = e),
            (this._argv = t),
            (this._destroyed = !1),
            (this[Q] = !1),
            initAsyncResource(this, "Immediate"),
            this.ref(),
            T[0]++,
            j.append(this);
        }
        ref() {
          return !1 === this[Q] && ((this[Q] = !0), 0 == T[1]++ && v(!0)), this;
        }
        unref() {
          return !0 === this[Q] && ((this[Q] = !1), 0 == --T[1] && v(!1)), this;
        }
        hasRef() {
          return !!this[Q];
        }
      },
      kRefed: Q,
      kHasPrimitive: P,
      initAsyncResource: initAsyncResource,
      setUnrefTimeout: function setUnrefTimeout(e, t) {
        O(e, "callback");
        const i = new Timeout(e, t, void 0, !1, !1);
        return insert(i, i._idleTimeout), i;
      },
      getTimerDuration: function getTimerDuration(e, t) {
        if ((E(e, t), e < 0 || !d(e)))
          throw new L(t, "a non-negative finite number", e);
        return e > G
          ? (n.emitWarning(
              `${e} does not fit into a 32-bit signed integer.\nTimer duration was truncated to 2147483647.`,
              "TimeoutOverflowWarning"
            ),
            G)
          : e;
      },
      immediateQueue: j,
      getTimerCallbacks: function getTimerCallbacks(e) {
        const t = new ImmediateList();
        function listOnTimeout(t, i) {
          const n = t.msecs;
          S("timeout callback %d", n);
          let s;
          for (; null != (s = M.peek(t)); ) {
            const r = i - s._idleStart;
            if (r < n)
              return (
                (t.expiry = o(s._idleStart + n, i + 1)),
                (t.id = H++),
                W.percolateDown(1),
                void S("%d list wait because diff is %d", n, r)
              );
            M.remove(s);
            const u = s[w];
            if (!s._onTimeout) {
              s._destroyed || ((s._destroyed = !0), s[Q] && p[0]--);
              continue;
            }
            let d;
            s._repeat && (d = y());
            try {
              const t = s._timerArgs;
              h(
                (t, i, n) => {
                  b(u, n[C], n);
                  try {
                    e(), void 0 === i ? t() : c(t, void 0, i);
                  } finally {
                    e(),
                      (n._repeat && -1 !== n._idleTimeout) ||
                        n._idleNext ||
                        n._idlePrev ||
                        n._destroyed ||
                        ((n._destroyed = !0), x() && k(u)),
                      A(u);
                  }
                },
                0,
                s._onTimeout.bind(s),
                t,
                s
              );
            } finally {
              s._repeat && -1 !== s._idleTimeout
                ? ((s._idleTimeout = s._repeat), insert(s, s._idleTimeout, d))
                : s._idleNext ||
                  s._idlePrev ||
                  s._destroyed ||
                  (s[Q] && p[0]--);
            }
          }
          S("%d list empty", n), t === $[n] && (delete $[n], W.shift());
        }
        return {
          processImmediate: function processImmediate() {
            const i = null !== t.head ? t : j;
            let n,
              s = i.head;
            for (
              i !== t && ((i.head = i.tail = null), (T[2] = 1));
              null !== s;

            ) {
              if (s._destroyed) {
                t.head = s = n._idleNext;
                continue;
              }
              (s._destroyed = !0),
                T[0]--,
                s[Q] && T[1]--,
                (s[Q] = null),
                (n = s);
              const i = s[w];
              try {
                const t = s._argv;
                h(
                  (t, n, s) => {
                    b(i, s[C], s);
                    try {
                      e(), n ? t(...n) : t();
                    } finally {
                      e(), x() && k(i), A(i);
                    }
                  },
                  0,
                  s._onImmediate.bind(s),
                  t,
                  s
                );
              } finally {
                (s._onImmediate = null), (t.head = s = s._idleNext);
              }
            }
            i === t && (t.head = null), (T[2] = 0);
          },
          processTimers: function processTimers(e) {
            let t;
            for (
              S("process timer lists %d", e), U = 1 / 0;
              null != (t = W.peek());

            ) {
              if (t.expiry > e) return (U = t.expiry), p[0] > 0 ? U : -U;
              listOnTimeout(t, e);
            }
            return 0;
          },
        };
      },
      immediateInfoFields: { kCount: 0, kRefCount: 1, kHasOutstanding: 2 },
      active: active,
      unrefActive: unrefActive,
      insert: insert,
      timerListMap: $,
      timerListQueue: W,
      decRefCount: decRefCount,
      incRefCount: incRefCount,
    };
  },
  "internal/tls/secure-context": function (e, t, i, n, r, s) {
    "use strict";
    const {
        ArrayIsArray: o,
        ArrayPrototypeFilter: a,
        ArrayPrototypeForEach: l,
        ArrayPrototypeJoin: u,
        StringPrototypeSplit: p,
        StringPrototypeStartsWith: f,
      } = s,
      {
        codes: {
          ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED: c,
          ERR_INVALID_ARG_TYPE: y,
          ERR_INVALID_ARG_VALUE: d,
        },
      } = t("internal/errors"),
      { kEmptyObject: C } = t("internal/util"),
      { isArrayBufferView: g } = t("internal/util/types"),
      {
        validateBuffer: h,
        validateInt32: E,
        validateObject: K,
        validateString: S,
      } = t("internal/validators"),
      { toBuf: v } = t("internal/crypto/util"),
      {
        crypto: { TLS1_2_VERSION: w, TLS1_3_VERSION: _ },
      } = r("constants");
    function getDefaultEcdhCurve() {
      return t("tls").DEFAULT_ECDH_CURVE || "auto";
    }
    function getDefaultCiphers() {
      return t("tls").DEFAULT_CIPHERS;
    }
    function validateKeyOrCertOption(e, t) {
      if ("string" != typeof t && !g(t))
        throw new y(e, ["string", "Buffer", "TypedArray", "DataView"], t);
    }
    function setKey(e, t, i, n) {
      validateKeyOrCertOption(`${n}.key`, t),
        null != i && S(i, `${n}.passphrase`),
        e.setKey(t, i);
    }
    i.exports = {
      configSecureContext: function configSecureContext(
        e,
        t = C,
        i = "options"
      ) {
        K(t, i);
        const {
          ca: r,
          cert: s,
          ciphers: g = getDefaultCiphers(),
          clientCertEngine: O,
          crl: $,
          dhparam: P,
          ecdhCurve: I = getDefaultEcdhCurve(),
          key: R,
          passphrase: A,
          pfx: T,
          privateKeyIdentifier: D,
          privateKeyEngine: L,
          sessionIdContext: m,
          sessionTimeout: x,
          sigalgs: N,
          ticketKeys: V,
        } = t;
        null != g && S(g, `${i}.ciphers`);
        const { cipherList: b, cipherSuites: k } = (function processCiphers(
          e,
          t
        ) {
          e = p(e || getDefaultCiphers(), ":");
          const i = u(
              a(e, (e) => e.length > 0 && !f(e, "TLS_")),
              ":"
            ),
            n = u(
              a(e, (e) => e.length > 0 && f(e, "TLS_")),
              ":"
            );
          if ("" === n && "" === i) throw new d(t, e);
          return { cipherList: i, cipherSuites: n };
        })(g, `${i}.ciphers`);
        if (
          ("" !== k && e.setCipherSuites(k),
          e.setCiphers(b),
          "" === b &&
            e.getMinProto() < _ &&
            e.getMaxProto() > w &&
            e.setMinProto(_),
          r
            ? (function addCACerts(e, t, i) {
                l(t, (t) => {
                  validateKeyOrCertOption(i, t), e.addCACert(t);
                });
              })(e, o(r) ? r : [r], `${i}.ca`)
            : e.addRootCerts(),
          s &&
            (function setCerts(e, t, i) {
              l(t, (t) => {
                validateKeyOrCertOption(i, t), e.setCert(t);
              });
            })(e, o(s) ? s : [s], `${i}.cert`),
          R)
        )
          if (o(R))
            for (let t = 0; t < R.length; ++t) {
              const n = R[t],
                r = void 0 !== n?.pem ? n.pem : n,
                s = void 0 !== n?.passphrase ? n.passphrase : A;
              setKey(e, r, s, i);
            }
          else setKey(e, R, A, i);
        if (null != N) {
          if ((S(N, `${i}.sigalgs`), "" === N)) throw new d(`${i}.sigalgs`, N);
          e.setSigalgs(N);
        }
        if (null != D) {
          if (null == L) throw new d(`${i}.privateKeyEngine`, L);
          if (R) throw new d(`${i}.privateKeyIdentifier`, D);
          if ("string" != typeof D || "string" != typeof L)
            throw "string" != typeof D
              ? new y(
                  `${i}.privateKeyIdentifier`,
                  ["string", "null", "undefined"],
                  D
                )
              : new y(
                  `${i}.privateKeyEngine`,
                  ["string", "null", "undefined"],
                  L
                );
          if (!e.setEngineKey) throw new c();
          e.setEngineKey(D, L);
        }
        if ((S(I, `${i}.ecdhCurve`), e.setECDHCurve(I), null != P)) {
          validateKeyOrCertOption(`${i}.dhparam`, P);
          const t = e.setDHParam("auto" === P || P);
          t && n.emitWarning(t, "SecurityWarning");
        }
        if (null != $)
          if (o($))
            for (const t of $)
              validateKeyOrCertOption(`${i}.crl`, t), e.addCRL(t);
          else validateKeyOrCertOption(`${i}.crl`, $), e.addCRL($);
        if (
          (null != m &&
            (S(m, `${i}.sessionIdContext`), e.setSessionIdContext(m)),
          null != T &&
            (o(T)
              ? l(T, (t) => {
                  const i = t.buf || t,
                    n = t.passphrase || A;
                  null != n ? e.loadPKCS12(v(i), v(n)) : e.loadPKCS12(v(i));
                })
              : A
              ? e.loadPKCS12(v(T), v(A))
              : e.loadPKCS12(v(T))),
          "string" == typeof O)
        ) {
          if ("function" != typeof e.setClientCertEngine) throw new c();
          e.setClientCertEngine(O);
        } else if (null != O)
          throw new y(
            `${i}.clientCertEngine`,
            ["string", "null", "undefined"],
            O
          );
        if (null != V) {
          if ((h(V, `${i}.ticketKeys`), 48 !== V.byteLength))
            throw new d(
              `${i}.ticketKeys`,
              V.byteLength,
              "must be exactly 48 bytes"
            );
          e.setTicketKeys(V);
        }
        null != x && (E(x, `${i}.sessionTimeout`), e.setSessionTimeout(x));
      },
    };
  },
  "internal/tls/secure-pair": function (e, t, s, r, c, i) {
    "use strict";
    const n = t("events"),
      { kEmptyObject: o } = t("internal/util"),
      { Duplex: u } = t("stream"),
      l = t("_tls_wrap"),
      h = t("_tls_common"),
      { Symbol: a, ReflectConstruct: k } = i,
      p = a("Callback"),
      x = a("Other");
    class DuplexSocket extends u {
      constructor() {
        super(), (this[p] = null), (this[x] = null);
      }
      _read() {
        const e = this[p];
        e && ((this[p] = null), e());
      }
      _write(e, t, s) {
        0 === e.length ? r.nextTick(s) : (this[x].push(e), (this[x][p] = s));
      }
      _final(e) {
        this[x].on("end", e), this[x].push(null);
      }
    }
    class DuplexPair {
      constructor() {
        (this.socket1 = new DuplexSocket()),
          (this.socket2 = new DuplexSocket()),
          (this.socket1[x] = this.socket2),
          (this.socket2[x] = this.socket1);
      }
    }
    class SecurePair extends n {
      constructor(e = h.createSecureContext(), t = !1, s = !t, r = !1, c = o) {
        super();
        const { socket1: i, socket2: n } = new DuplexPair();
        (this.server = c.server),
          (this.credentials = e),
          (this.encrypted = i),
          (this.cleartext = new l.TLSSocket(n, {
            secureContext: e,
            isServer: t,
            requestCert: s,
            rejectUnauthorized: r,
            ...c,
          })),
          this.cleartext.once("secure", () => this.emit("secure"));
      }
      destroy() {
        this.cleartext.destroy(), this.encrypted.destroy();
      }
    }
    e.createSecurePair = function createSecurePair(...e) {
      return k(SecurePair, e);
    };
  },
  "internal/trace_events_async_hooks": function (e, t, n, o, s, c) {
    "use strict";
    const { ObjectKeys: a, SafeMap: i, SafeSet: r, Symbol: d } = c,
      { trace: _ } = s("trace_events"),
      A = s("async_wrap"),
      l = t("async_hooks"),
      { CHAR_LOWERCASE_B: y, CHAR_LOWERCASE_E: b } = t("internal/constants"),
      C = y,
      h = b,
      S = "node,node.async_hooks",
      f = d("enabled"),
      u = new r(a(A.Providers)),
      E = new i();
    u.delete("PROMISE"),
      (e.createHook = function createHook() {
        const e = l.createHook({
          init(e, t, n, o) {
            u.has(t) ||
              (E.set(e, t),
              _(C, S, t, e, {
                triggerAsyncId: n,
                executionAsyncId: l.executionAsyncId(),
              }));
          },
          before(e) {
            const t = E.get(e);
            void 0 !== t && _(C, S, `${t}_CALLBACK`, e);
          },
          after(e) {
            const t = E.get(e);
            void 0 !== t && _(h, S, `${t}_CALLBACK`, e);
          },
          destroy(e) {
            const t = E.get(e);
            void 0 !== t && (_(h, S, t, e), E.delete(e));
          },
        });
        return {
          enable() {
            this[f] || ((this[f] = !0), e.enable());
          },
          disable() {
            this[f] && ((this[f] = !1), e.disable(), E.clear());
          },
        };
      });
  },
  "internal/tty": function (e, t, r, n, o, i) {
    "use strict";
    const {
        ArrayPrototypeSome: O,
        RegExpPrototypeExec: s,
        StringPrototypeSplit: a,
        StringPrototypeToLowerCase: u,
      } = i,
      { validateInteger: R } = t("internal/validators");
    let c;
    const l = 1,
      C = 4,
      E = 8,
      T = 24,
      _ = {
        eterm: C,
        cons25: C,
        console: C,
        cygwin: C,
        dtterm: C,
        gnome: C,
        hurd: C,
        jfbterm: C,
        konsole: C,
        kterm: C,
        mlterm: C,
        mosh: T,
        putty: C,
        st: C,
        "rxvt-unicode-24bit": T,
        terminator: T,
      },
      d = [
        /ansi/,
        /color/,
        /linux/,
        /^con[0-9]*x[0-9]/,
        /^rxvt/,
        /^screen/,
        /^xterm/,
        /^vt100/,
      ];
    let f = !1;
    function warnOnDeactivatedColors(e) {
      if (f) return;
      let t = "";
      void 0 !== e.NODE_DISABLE_COLORS && (t = "NODE_DISABLE_COLORS"),
        void 0 !== e.NO_COLOR &&
          ("" !== t && (t += "' and '"), (t += "NO_COLOR")),
        "" !== t &&
          (n.emitWarning(
            `The '${t}' env is ignored due to the 'FORCE_COLOR' env being set.`,
            "Warning"
          ),
          (f = !0));
    }
    function getColorDepth(e = n.env) {
      if (void 0 !== e.FORCE_COLOR)
        switch (e.FORCE_COLOR) {
          case "":
          case "1":
          case "true":
            return warnOnDeactivatedColors(e), C;
          case "2":
            return warnOnDeactivatedColors(e), E;
          case "3":
            return warnOnDeactivatedColors(e), T;
          default:
            return l;
        }
      if (
        void 0 !== e.NODE_DISABLE_COLORS ||
        void 0 !== e.NO_COLOR ||
        "dumb" === e.TERM
      )
        return l;
      if ("win32" === n.platform) {
        if (void 0 === c) {
          const { release: e } = t("os");
          c = a(e(), ".");
        }
        if (+c[0] >= 10) {
          const e = +c[2];
          if (e >= 14931) return T;
          if (e >= 10586) return E;
        }
        return C;
      }
      if (e.TMUX) return E;
      if (e.CI)
        return [
          "APPVEYOR",
          "BUILDKITE",
          "CIRCLECI",
          "DRONE",
          "GITHUB_ACTIONS",
          "GITLAB_CI",
          "TRAVIS",
        ].some((t) => t in e) || "codeship" === e.CI_NAME
          ? E
          : l;
      if ("TEAMCITY_VERSION" in e)
        return null !== s(/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/, e.TEAMCITY_VERSION)
          ? C
          : l;
      switch (e.TERM_PROGRAM) {
        case "iTerm.app":
          return e.TERM_PROGRAM_VERSION &&
            null === s(/^[0-2]\./, e.TERM_PROGRAM_VERSION)
            ? T
            : E;
        case "HyperTerm":
        case "MacTerm":
          return T;
        case "Apple_Terminal":
          return E;
      }
      if ("truecolor" === e.COLORTERM || "24bit" === e.COLORTERM) return T;
      if (e.TERM) {
        if (null !== s(/^xterm-256/, e.TERM)) return E;
        const t = u(e.TERM);
        if (_[t]) return _[t];
        if (O(d, (e) => null !== s(e, t))) return C;
      }
      return e.COLORTERM ? C : l;
    }
    r.exports = {
      getColorDepth: getColorDepth,
      hasColors: function hasColors(e, t) {
        return (
          void 0 === t && (void 0 === e || ("object" == typeof e && null !== e))
            ? ((t = e), (e = 16))
            : R(e, "count", 2),
          e <= 2 ** getColorDepth(t)
        );
      },
    };
  },
  "internal/url": function (t, e, r, s, o, n) {
    "use strict";
    const {
        Array: a,
        ArrayIsArray: h,
        ArrayPrototypeJoin: i,
        ArrayPrototypeMap: c,
        ArrayPrototypePush: l,
        ArrayPrototypeReduce: f,
        ArrayPrototypeSlice: u,
        Int8Array: p,
        IteratorPrototype: R,
        Number: w,
        ObjectCreate: m,
        ObjectDefineProperties: L,
        ObjectDefineProperty: U,
        ObjectGetOwnPropertySymbols: d,
        ObjectGetPrototypeOf: _,
        ObjectKeys: g,
        ObjectPrototypeHasOwnProperty: P,
        ReflectGetOwnPropertyDescriptor: S,
        ReflectOwnKeys: y,
        RegExpPrototypeSymbolReplace: b,
        SafeMap: A,
        SafeSet: C,
        SafeWeakMap: I,
        StringPrototypeCharAt: v,
        StringPrototypeCharCodeAt: $,
        StringPrototypeCodePointAt: E,
        StringPrototypeIncludes: k,
        StringPrototypeIndexOf: O,
        StringPrototypeSlice: H,
        StringPrototypeSplit: x,
        StringPrototypeStartsWith: T,
        Symbol: j,
        SymbolIterator: D,
        SymbolToStringTag: N,
        decodeURIComponent: F,
      } = n,
      { inspect: V } = e("internal/util/inspect"),
      { encodeStr: z, hexTable: G, isHexTable: q } = e("internal/querystring"),
      {
        getConstructorOf: M,
        removeColors: W,
        toUSVString: B,
        kEnumerableProperty: J,
        SideEffectFreeRegExpPrototypeSymbolReplace: K,
      } = e("internal/util"),
      {
        codes: {
          ERR_ARG_NOT_ITERABLE: Q,
          ERR_INVALID_ARG_TYPE: Y,
          ERR_INVALID_ARG_VALUE: Z,
          ERR_INVALID_FILE_URL_HOST: X,
          ERR_INVALID_FILE_URL_PATH: tt,
          ERR_INVALID_THIS: et,
          ERR_INVALID_TUPLE: rt,
          ERR_INVALID_URL: st,
          ERR_INVALID_URL_SCHEME: ot,
          ERR_MISSING_ARGS: nt,
          ERR_NO_CRYPTO: at,
        },
      } = e("internal/errors"),
      {
        CHAR_AMPERSAND: ht,
        CHAR_BACKWARD_SLASH: it,
        CHAR_EQUAL: ct,
        CHAR_FORWARD_SLASH: lt,
        CHAR_LOWERCASE_A: ft,
        CHAR_LOWERCASE_Z: ut,
        CHAR_PERCENT: pt,
        CHAR_PLUS: Rt,
      } = e("internal/constants"),
      wt = e("path"),
      { validateFunction: mt } = e("internal/validators"),
      Lt = e("querystring"),
      { platform: Ut } = s,
      dt = "win32" === Ut,
      _t = o("url"),
      { storeDataObject: gt, revokeDataObject: Pt } = o("blob"),
      St = /\//g,
      yt = j("context"),
      bt = j("query"),
      At = new I(),
      Ct = new C(["javascript", "javascript:"]),
      It = new C(["javascript", "javascript:"]),
      vt = new C([
        "http",
        "http:",
        "https",
        "https:",
        "ftp",
        "ftp:",
        "gopher",
        "gopher:",
        "file",
        "file:",
        "ws",
        "ws:",
        "wss",
        "wss:",
      ]),
      $t = {
        kProtocol: 0,
        kHost: 1,
        kHostname: 2,
        kPort: 3,
        kUsername: 4,
        kPassword: 5,
        kPathname: 6,
        kSearch: 7,
        kHash: 8,
        kHref: 9,
      };
    let Et, kt;
    class URLContext {
      static #t = 4294967295;
      href = "";
      protocol_end = 0;
      username_end = 0;
      host_start = 0;
      host_end = 0;
      pathname_start = 0;
      search_start = 0;
      hash_start = 0;
      port = 0;
      scheme_type = 1;
      get hasPort() {
        return this.port !== URLContext.#t;
      }
      get hasSearch() {
        return this.search_start !== URLContext.#t;
      }
      get hasHash() {
        return this.hash_start !== URLContext.#t;
      }
    }
    function isURLSearchParams(t) {
      return t?.[bt];
    }
    class URLSearchParams {
      [bt] = [];
      [yt] = null;
      constructor(t = void 0) {
        if (null == t);
        else if ("object" == typeof t || "function" == typeof t) {
          const e = t[D];
          if (e === this[D]) {
            const e = t[bt];
            this[bt] = e.slice();
          } else if (null != e) {
            if ("function" != typeof e) throw new Q("Query pairs");
            for (const e of t) {
              if (null == e) throw new rt("Each query pair", "[name, value]");
              if (h(e)) {
                if (2 !== e.length)
                  throw new rt("Each query pair", "[name, value]");
                l(this[bt], B(e[0]), B(e[1]));
              } else {
                if (
                  ("object" != typeof e && "function" != typeof e) ||
                  "function" != typeof e[D]
                )
                  throw new rt("Each query pair", "[name, value]");
                let t = 0;
                for (const r of e) t++, l(this[bt], B(r));
                if (2 !== t) throw new rt("Each query pair", "[name, value]");
              }
            }
          } else {
            const e = new A(),
              r = y(t);
            for (let s = 0; s < r.length; s++) {
              const o = r[s],
                n = S(t, o);
              if (void 0 !== n && n.enumerable) {
                const r = B(o),
                  s = B(t[o]),
                  n = e.get(r);
                void 0 !== n
                  ? (this[bt][n] = s)
                  : e.set(r, l(this[bt], r, s) - 1);
              }
            }
          }
        } else (t = B(t)), (this[bt] = t ? parseParams(t) : []);
      }
      [V.custom](t, e) {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        if ("number" == typeof t && t < 0)
          return e.stylize("[Object]", "special");
        const r = ", ",
          s = { ...e };
        null !== t && (s.depth = t - 1);
        const innerInspect = (t) => V(t, s),
          o = this[bt],
          n = [];
        for (let t = 0; t < o.length; t += 2)
          l(n, `${innerInspect(o[t])} => ${innerInspect(o[t + 1])}`);
        return f(n, (t, e) => t + W(e).length + 2, -2) > e.breakLength
          ? `${this.constructor.name} {\n  ${i(n, ",\n  ")} }`
          : n.length
          ? `${this.constructor.name} { ${i(n, r)} }`
          : `${this.constructor.name} {}`;
      }
      get size() {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        return this[bt].length / 2;
      }
      append(t, e) {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        if (arguments.length < 2) throw new nt("name", "value");
        (t = B(t)),
          (e = B(e)),
          l(this[bt], t, e),
          this[yt] && (this[yt].search = this.toString());
      }
      delete(t, e = void 0) {
        if (
          "object" != typeof this ||
          null === this ||
          !isURLSearchParams(this)
        )
          throw new et("URLSearchParams");
        if (arguments.length < 1) throw new nt("name");
        const r = this[bt];
        if (((t = B(t)), void 0 !== e)) {
          e = B(e);
          for (let s = 0; s < r.length; )
            r[s] === t && r[s + 1] === e ? r.splice(s, 2) : (s += 2);
        } else
          for (let e = 0; e < r.length; )
            r[e] === t ? r.splice(e, 2) : (e += 2);
        this[yt] && (this[yt].search = this.toString());
      }
      get(t) {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        if (arguments.length < 1) throw new nt("name");
        const e = this[bt];
        t = B(t);
        for (let r = 0; r < e.length; r += 2) if (e[r] === t) return e[r + 1];
        return null;
      }
      getAll(t) {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        if (arguments.length < 1) throw new nt("name");
        const e = this[bt],
          r = [];
        t = B(t);
        for (let s = 0; s < e.length; s += 2) e[s] === t && r.push(e[s + 1]);
        return r;
      }
      has(t, e = void 0) {
        if (
          "object" != typeof this ||
          null === this ||
          !isURLSearchParams(this)
        )
          throw new et("URLSearchParams");
        if (arguments.length < 1) throw new nt("name");
        const r = this[bt];
        (t = B(t)), void 0 !== e && (e = B(e));
        for (let s = 0; s < r.length; s += 2)
          if (r[s] === t && (void 0 === e || r[s + 1] === e)) return !0;
        return !1;
      }
      set(t, e) {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        if (arguments.length < 2) throw new nt("name", "value");
        const r = this[bt];
        (t = B(t)), (e = B(e));
        let s = !1;
        for (let o = 0; o < r.length; ) {
          r[o] === t
            ? s
              ? r.splice(o, 2)
              : ((r[o + 1] = e), (s = !0), (o += 2))
            : (o += 2);
        }
        s || l(r, t, e), this[yt] && (this[yt].search = this.toString());
      }
      sort() {
        const t = this[bt],
          e = t.length;
        if (e <= 2);
        else if (e < 100)
          for (let r = 2; r < e; r += 2) {
            const e = t[r],
              s = t[r + 1];
            let o;
            for (o = r - 2; o >= 0 && t[o] > e; o -= 2)
              (t[o + 2] = t[o]), (t[o + 3] = t[o + 1]);
            (t[o + 2] = e), (t[o + 3] = s);
          }
        else {
          const r = new a(e),
            s = new a(e);
          for (let o = 2; o < e; o *= 2)
            for (let n = 0; n < e - 2; n += 2 * o) {
              const a = n + o;
              let h = a + o;
              (h = h < e ? h : e), a > h || merge(t, n, a, h, r, s);
            }
        }
        this[yt] && (this[yt].search = this.toString());
      }
      entries() {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        return createSearchParamsIterator(this, "key+value");
      }
      forEach(t, e = void 0) {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        mt(t, "callback");
        let r = this[bt],
          s = 0;
        for (; s < r.length; ) {
          const o = r[s],
            n = r[s + 1];
          t.call(e, n, o, this), (r = this[bt]), (s += 2);
        }
      }
      keys() {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        return createSearchParamsIterator(this, "key");
      }
      values() {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        return createSearchParamsIterator(this, "value");
      }
      toString() {
        if (!isURLSearchParams(this)) throw new et("URLSearchParams");
        return (function serializeParams(t) {
          const e = t.length;
          if (0 === e) return "";
          const r = z(t[0], Ot, Ht),
            s = z(t[1], Ot, Ht);
          let o = `${r}=${s}`;
          for (let r = 2; r < e; r += 2) {
            o += `&${z(t[r], Ot, Ht)}=${z(t[r + 1], Ot, Ht)}`;
          }
          return o;
        })(this[bt]);
      }
    }
    function isURL(t) {
      return null != t && P(t, yt);
    }
    L(URLSearchParams.prototype, {
      append: J,
      delete: J,
      get: J,
      getAll: J,
      has: J,
      set: J,
      size: J,
      sort: J,
      entries: J,
      forEach: J,
      keys: J,
      values: J,
      toString: J,
      [N]: { __proto__: null, configurable: !0, value: "URLSearchParams" },
      [D]: {
        __proto__: null,
        configurable: !0,
        writable: !0,
        value: URLSearchParams.prototype.entries,
      },
    });
    class URL {
      constructor(t, e = void 0) {
        if (0 === arguments.length) throw new nt("url");
        (t = `${t}`),
          (this[yt] = new URLContext()),
          void 0 !== e && (e = `${e}`);
        const r = _t.parse(t, e);
        if (!r) throw new st(t);
        this.#e(r);
      }
      [V.custom](t, e) {
        if (null == this || _(this[yt]) !== URLContext.prototype)
          throw new et("URL");
        if ("number" == typeof t && t < 0) return this;
        const r = M(this) || URL,
          s = m({ constructor: r });
        return (
          (s.href = this.href),
          (s.origin = this.origin),
          (s.protocol = this.protocol),
          (s.username = this.username),
          (s.password = this.password),
          (s.host = this.host),
          (s.hostname = this.hostname),
          (s.port = this.port),
          (s.pathname = this.pathname),
          (s.search = this.search),
          (s.searchParams = this.searchParams),
          (s.hash = this.hash),
          e.showHidden && (s[yt] = this[yt]),
          `${r.name} ${V(s, e)}`
        );
      }
      #e(t) {
        const e = this[yt];
        e.href = t;
        const {
          0: r,
          1: s,
          2: o,
          3: n,
          4: a,
          5: h,
          6: i,
          7: c,
          8: l,
        } = _t.urlComponents;
        (e.protocol_end = r),
          (e.username_end = s),
          (e.host_start = o),
          (e.host_end = n),
          (e.port = a),
          (e.pathname_start = h),
          (e.search_start = i),
          (e.hash_start = c),
          (e.scheme_type = l);
        const f = At.get(this);
        f && (e.hasSearch ? (f[bt] = parseParams(this.search)) : (f[bt] = []));
      }
      toString() {
        if (!isURL(this)) throw new et("URL");
        return this[yt].href;
      }
      get href() {
        if (!isURL(this)) throw new et("URL");
        return this[yt].href;
      }
      set href(t) {
        if (!isURL(this)) throw new et("URL");
        t = `${t}`;
        const e = _t.update(this[yt].href, $t.kHref, t);
        if (!e) throw st(t);
        this.#e(e);
      }
      get origin() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt],
          e = H(t.href, 0, t.protocol_end);
        if (1 !== t.scheme_type)
          return 6 === t.scheme_type ? "null" : `${e}//${this.host}`;
        if ("blob:" === e) {
          const t = this.pathname;
          if (t.length > 0)
            try {
              const e = new URL(t);
              if (0 === e[yt].scheme_type || 2 === e[yt].scheme_type)
                return `${e.protocol}//${e.host}`;
            } catch {}
        }
        return "null";
      }
      get protocol() {
        if (!isURL(this)) throw new et("URL");
        return H(this[yt].href, 0, this[yt].protocol_end);
      }
      set protocol(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kProtocol, `${t}`);
        e && this.#e(e);
      }
      get username() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        return t.protocol_end + 2 < t.username_end
          ? H(t.href, t.protocol_end + 2, t.username_end)
          : "";
      }
      set username(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kUsername, `${t}`);
        e && this.#e(e);
      }
      get password() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        return t.host_start - t.username_end > 0
          ? H(t.href, t.username_end + 1, t.host_start)
          : "";
      }
      set password(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kPassword, `${t}`);
        e && this.#e(e);
      }
      get host() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        let e = t.host_start;
        return (
          "@" === t.href[e] && e++,
          e === t.host_end ? "" : H(t.href, e, t.pathname_start)
        );
      }
      set host(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kHost, `${t}`);
        e && this.#e(e);
      }
      get hostname() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        let e = t.host_start;
        return "@" === t.href[e] && e++, H(t.href, e, t.host_end);
      }
      set hostname(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kHostname, `${t}`);
        e && this.#e(e);
      }
      get port() {
        if (!isURL(this)) throw new et("URL");
        return this[yt].hasPort ? `${this[yt].port}` : "";
      }
      set port(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kPort, `${t}`);
        e && this.#e(e);
      }
      get pathname() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        let e;
        return (
          t.hasSearch ? (e = t.search_start) : t.hasHash && (e = t.hash_start),
          H(t.href, t.pathname_start, e)
        );
      }
      set pathname(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kPathname, `${t}`);
        e && this.#e(e);
      }
      get search() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        if (!t.hasSearch) return "";
        let e = t.href.length;
        return (
          t.hasHash && (e = t.hash_start),
          e - t.search_start <= 1 ? "" : H(t.href, t.search_start, e)
        );
      }
      set search(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kSearch, B(t));
        e && this.#e(e);
      }
      get searchParams() {
        if (!isURL(this)) throw new et("URL");
        const t = At.get(this);
        if (null != t) return t;
        const e = new URLSearchParams(this.search);
        return (e[yt] = this), At.set(this, e), e;
      }
      get hash() {
        if (!isURL(this)) throw new et("URL");
        const t = this[yt];
        return !t.hasHash || t.href.length - t.hash_start <= 1
          ? ""
          : H(t.href, t.hash_start);
      }
      set hash(t) {
        if (!isURL(this)) throw new et("URL");
        const e = _t.update(this[yt].href, $t.kHash, `${t}`);
        e && this.#e(e);
      }
      toJSON() {
        if (!isURL(this)) throw new et("URL");
        return this[yt].href;
      }
      static canParse(t, e = void 0) {
        if (0 === arguments.length) throw new nt("url");
        return (t = `${t}`), void 0 !== e && (e = `${e}`), _t.canParse(t, e);
      }
      static createObjectURL(t) {
        const r = (function lazyCryptoRandom() {
          try {
            kt ??= e("internal/crypto/random");
          } catch {}
          return kt;
        })();
        if (void 0 === r) throw new at();
        const s = (function lazyBlob() {
          return (Et ??= e("internal/blob")), Et;
        })();
        if (!s.isBlob(t)) throw new Y("obj", "Blob", t);
        const o = r.randomUUID();
        return gt(o, t[s.kHandle], t.size, t.type), `blob:nodedata:${o}`;
      }
      static revokeObjectURL(t) {
        t = `${t}`;
        try {
          const e = new URL(t),
            r = x(e.pathname, ":");
          2 === r.length && Pt(r[1]);
        } catch {}
      }
    }
    function parseParams(t) {
      const e = [];
      let r = !1,
        s = "",
        o = !1,
        n = 0,
        a = "?" === t[0] ? 1 : 0,
        h = a,
        i = a;
      for (; a < t.length; ++a) {
        const c = $(t, a);
        if (c !== ht)
          r || c !== ct
            ? c === Rt
              ? (i < a && (s += H(t, i, a)), (s += " "), (i = a + 1))
              : o ||
                (c === pt
                  ? (n = 1)
                  : n > 0 && (1 === q[c] ? 3 == ++n && (o = !0) : (n = 0)))
            : (i < a && (s += t.slice(i, a)),
              o && (s = Lt.unescape(s)),
              e.push(s),
              (r = !0),
              (s = ""),
              (o = !1),
              (n = 0),
              (i = a + 1));
        else {
          if (h === a) {
            i = h = a + 1;
            continue;
          }
          i < a && (s += t.slice(i, a)),
            o && (s = Lt.unescape(s)),
            e.push(s),
            r || e.push(""),
            (r = !1),
            (s = ""),
            (o = !1),
            (n = 0),
            (i = h = a + 1);
        }
      }
      return (
        h === a ||
          (i < a && (s += H(t, i, a)),
          o && (s = Lt.unescape(s)),
          l(e, s),
          r || l(e, "")),
        e
      );
    }
    L(URL.prototype, {
      [N]: { __proto__: null, configurable: !0, value: "URL" },
      toString: J,
      href: J,
      origin: J,
      protocol: J,
      username: J,
      password: J,
      host: J,
      hostname: J,
      port: J,
      pathname: J,
      search: J,
      searchParams: J,
      hash: J,
      toJSON: J,
    }),
      L(URL, {
        canParse: {
          __proto__: null,
          configurable: !0,
          writable: !0,
          enumerable: !0,
        },
        createObjectURL: J,
        revokeObjectURL: J,
      });
    const Ot = new p([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0,
      ]),
      Ht = G.slice();
    function merge(t, e, r, s, o, n) {
      const a = r - e,
        h = s - r;
      let i, c, l;
      for (i = 0; i < a; i++) o[i] = t[e + i];
      for (c = 0; c < h; c++) n[c] = t[r + c];
      for (i = 0, c = 0, l = e; i < a && c < h; )
        o[i] <= n[c]
          ? ((t[l++] = o[i++]), (t[l++] = o[i++]))
          : ((t[l++] = n[c++]), (t[l++] = n[c++]));
      for (; i < a; ) t[l++] = o[i++];
      for (; c < h; ) t[l++] = n[c++];
    }
    function createSearchParamsIterator(t, e) {
      const r = m(xt);
      return (r[yt] = { target: t, kind: e, index: 0 }), r;
    }
    Ht[32] = "+";
    const xt = m(R);
    function domainToASCII(t) {
      if (arguments.length < 1) throw new nt("domain");
      return _t.domainToASCII(`${t}`);
    }
    function domainToUnicode(t) {
      if (arguments.length < 1) throw new nt("domain");
      return _t.domainToUnicode(`${t}`);
    }
    function fileURLToPath(t) {
      if ("string" == typeof t) t = new URL(t);
      else if (!isURL(t)) throw new Y("path", ["string", "URL"], t);
      if ("file:" !== t.protocol) throw new ot("file");
      return dt
        ? (function getPathFromURLWin32(t) {
            const e = t.hostname;
            let r = t.pathname;
            for (let t = 0; t < r.length; t++)
              if ("%" === r[t]) {
                const e = 32 | E(r, t + 2);
                if (
                  ("2" === r[t + 1] && 102 === e) ||
                  ("5" === r[t + 1] && 99 === e)
                )
                  throw new tt("must not include encoded \\ or / characters");
              }
            if (((r = K(St, r, "\\")), (r = F(r)), "" !== e))
              return `\\\\${domainToUnicode(e)}${r}`;
            const s = 32 | E(r, 1),
              o = v(r, 2);
            if (s < ft || s > ut || ":" !== o) throw new tt("must be absolute");
            return H(r, 1);
          })(t)
        : (function getPathFromURLPosix(t) {
            if ("" !== t.hostname) throw new X(Ut);
            const e = t.pathname;
            for (let t = 0; t < e.length; t++)
              if ("%" === e[t]) {
                const r = 32 | E(e, t + 2);
                if ("2" === e[t + 1] && 102 === r)
                  throw new tt("must not include encoded / characters");
              }
            return F(e);
          })(t);
    }
    !(function defineIDLClass(t, e, r) {
      U(t, N, {
        __proto__: null,
        writable: !1,
        enumerable: !1,
        configurable: !0,
        value: e,
      });
      for (const e of g(r))
        U(t, e, {
          __proto__: null,
          writable: !0,
          enumerable: !0,
          configurable: !0,
          value: r[e],
        });
      for (const e of d(r))
        U(t, e, {
          __proto__: null,
          writable: !0,
          enumerable: !1,
          configurable: !0,
          value: r[e],
        });
    })(xt, "URLSearchParams Iterator", {
      next() {
        if (!this || _(this) !== xt) throw new et("URLSearchParamsIterator");
        const { target: t, kind: e, index: r } = this[yt],
          s = t[bt];
        if (r >= s.length) return { value: void 0, done: !0 };
        const o = s[r],
          n = s[r + 1];
        let a;
        return (
          (this[yt].index = r + 2),
          (a = "key" === e ? o : "value" === e ? n : [o, n]),
          { value: a, done: !1 }
        );
      },
      [V.custom](t, e) {
        if (null == this || null == this[yt] || null == this[yt].target)
          throw new et("URLSearchParamsIterator");
        if ("number" == typeof t && t < 0)
          return e.stylize("[Object]", "special");
        const r = { ...e };
        null !== t && (r.depth = t - 1);
        const { target: s, kind: o, index: n } = this[yt],
          a = f(
            u(s[bt], n),
            (t, e, r) => {
              const a = r % 2 == 0;
              return (
                "key" === o && a
                  ? l(t, e)
                  : "value" !== o || a
                  ? "key+value" !== o || a || l(t, [s[bt][n + r - 1], e])
                  : l(t, e),
                t
              );
            },
            []
          ),
          h = k(V(a, r), "\n"),
          p = c(a, (t) => V(t, r));
        let R;
        return (
          (R = h ? `\n  ${i(p, ",\n  ")}` : ` ${i(p, ", ")}`),
          `${this[N]} {${R} }`
        );
      },
    });
    const Tt = /%/g,
      jt = /\\/g,
      Dt = /\n/g,
      Nt = /\r/g,
      Ft = /\t/g,
      Vt = /\?/g,
      zt = /#/g;
    function encodePathChars(t) {
      return (
        -1 !== O(t, "%") && (t = b(Tt, t, "%25")),
        dt || -1 === O(t, "\\") || (t = b(jt, t, "%5C")),
        -1 !== O(t, "\n") && (t = b(Dt, t, "%0A")),
        -1 !== O(t, "\r") && (t = b(Nt, t, "%0D")),
        -1 !== O(t, "\t") && (t = b(Ft, t, "%09")),
        t
      );
    }
    r.exports = {
      toUSVString: B,
      fileURLToPath: fileURLToPath,
      pathToFileURL: function pathToFileURL(t) {
        if (dt && T(t, "\\\\")) {
          const e = new URL("file://"),
            r = O(t, "\\", 2);
          if (-1 === r) throw new Z("path", t, "Missing UNC resource path");
          if (2 === r) throw new Z("path", t, "Empty UNC servername");
          const s = H(t, 2, r);
          return (
            (e.hostname = domainToASCII(s)),
            (e.pathname = encodePathChars(b(jt, H(t, r), "/"))),
            e
          );
        }
        let e = wt.resolve(t);
        const r = $(t, t.length - 1);
        return (
          (r === lt || (dt && r === it)) &&
            e[e.length - 1] !== wt.sep &&
            (e += "/"),
          (e = encodePathChars(e)),
          -1 !== O(e, "?") && (e = b(Vt, e, "%3F")),
          -1 !== O(e, "#") && (e = b(zt, e, "%23")),
          new URL(`file://${e}`)
        );
      },
      toPathIfFileURL: function toPathIfFileURL(t) {
        return isURL(t) ? fileURLToPath(t) : t;
      },
      URL: URL,
      URLSearchParams: URLSearchParams,
      domainToASCII: domainToASCII,
      domainToUnicode: domainToUnicode,
      urlToHttpOptions: function urlToHttpOptions(t) {
        const {
            hostname: e,
            pathname: r,
            port: s,
            username: o,
            password: n,
            search: a,
          } = t,
          h = {
            __proto__: null,
            ...t,
            protocol: t.protocol,
            hostname: e && T(e, "[") ? H(e, 1, -1) : e,
            hash: t.hash,
            search: a,
            pathname: r,
            path: `${r || ""}${a || ""}`,
            href: t.href,
          };
        return (
          "" !== s && (h.port = w(s)),
          (o || n) && (h.auth = `${F(o)}:${F(n)}`),
          h
        );
      },
      encodeStr: z,
      isURL: isURL,
      urlUpdateActions: $t,
      unsafeProtocol: Ct,
      hostlessProtocol: It,
      slashedProtocol: vt,
    };
  },
  "internal/util": function (e, t, r, n, o, i) {
    "use strict";
    const {
        ArrayBufferPrototypeGetByteLength: a,
        ArrayFrom: u,
        ArrayIsArray: c,
        ArrayPrototypePush: l,
        ArrayPrototypeSlice: s,
        ArrayPrototypeSort: f,
        Error: p,
        FunctionPrototypeCall: g,
        ObjectCreate: d,
        ObjectDefineProperties: y,
        ObjectDefineProperty: m,
        ObjectGetOwnPropertyDescriptor: b,
        ObjectGetOwnPropertyDescriptors: _,
        ObjectGetPrototypeOf: S,
        ObjectFreeze: E,
        ObjectPrototypeHasOwnProperty: v,
        ObjectSetPrototypeOf: P,
        ObjectValues: w,
        Promise: h,
        ReflectApply: x,
        ReflectConstruct: R,
        RegExpPrototypeExec: C,
        RegExpPrototypeGetDotAll: D,
        RegExpPrototypeGetGlobal: O,
        RegExpPrototypeGetHasIndices: k,
        RegExpPrototypeGetIgnoreCase: F,
        RegExpPrototypeGetMultiline: L,
        RegExpPrototypeGetSticky: I,
        RegExpPrototypeGetUnicode: A,
        RegExpPrototypeGetSource: G,
        SafeMap: W,
        SafeSet: U,
        SafeWeakMap: N,
        StringPrototypeReplace: T,
        StringPrototypeToLowerCase: j,
        StringPrototypeToUpperCase: z,
        Symbol: M,
        SymbolFor: $,
        SymbolReplace: B,
        SymbolSplit: V,
      } = i,
      {
        hideStackFrames: H,
        codes: { ERR_NO_CRYPTO: Y, ERR_UNKNOWN_SIGNAL: K },
        uvErrmapGet: X,
        overrideStackTrace: q,
      } = t("internal/errors"),
      { signals: J } = o("constants").os,
      {
        isArrayBufferDetached: Q,
        privateSymbols: {
          arrow_message_private_symbol: Z,
          decorated_private_symbol: ee,
        },
        sleep: te,
        toUSVString: re,
      } = o("util"),
      { isNativeError: ne } = o("types"),
      { getOptionValue: oe } = t("internal/options"),
      ie = !n.versions.openssl,
      ae = new U(),
      ue = /\u001b\[\d\d?m/g,
      ce =
        /(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/;
    let le;
    function isError(e) {
      return ne(e) || e instanceof p;
    }
    const se = new U();
    let fe, pe, ge, de;
    function getDeprecationWarningEmitter(e, r, o, i, a = () => !0) {
      let u = !1;
      return function () {
        if (!u && a())
          if (((u = !0), void 0 !== e)) {
            if (!se.has(e)) {
              (i
                ? t("internal/process/warning").emitWarningSync
                : n.emitWarning)(r, "DeprecationWarning", e, o),
                se.add(e);
            }
          } else n.emitWarning(r, "DeprecationWarning", o);
      };
    }
    function isPendingDeprecation() {
      return oe("--pending-deprecation") && !oe("--no-deprecation");
    }
    const ye = $("nodejs.util.promisify.custom"),
      me = M("customPromisifyArgs");
    let be;
    function promisify(e) {
      if (
        (void 0 === be && ({ validateFunction: be } = t("internal/validators")),
        be(e, "original"),
        e[ye])
      ) {
        const t = e[ye];
        return (
          be(t, "util.promisify.custom"),
          m(t, ye, {
            __proto__: null,
            value: t,
            enumerable: !1,
            writable: !1,
            configurable: !0,
          })
        );
      }
      const r = e[me];
      function fn(...t) {
        return new h((n, o) => {
          l(t, (e, ...t) => {
            if (e) return o(e);
            if (void 0 !== r && t.length > 1) {
              const e = {};
              for (let n = 0; n < r.length; n++) e[r[n]] = t[n];
              n(e);
            } else n(t[0]);
          }),
            x(e, this, t);
        });
      }
      P(fn, S(e)),
        m(fn, ye, {
          __proto__: null,
          value: fn,
          enumerable: !1,
          writable: !1,
          configurable: !0,
        });
      const n = _(e),
        o = w(n);
      for (let e = 0; e < o.length; e++) P(o[e], null);
      return y(fn, n);
    }
    promisify.custom = ye;
    const _e = /^(.*)[\\/]node_modules[\\/]/;
    let Se, Ee, ve;
    function defineLazyProperties(e, r, n, o = !0) {
      const i = { __proto__: null };
      let a;
      for (let u = 0; u < n.length; u++) {
        let set = function (t) {
            m(e, c, { __proto__: null, writable: !0, value: t });
          },
          get = function () {
            return (a ??= t(r)), void 0 === l && ((l = a[c]), set(l)), l;
          };
        const c = n[u];
        let l;
        m(set, "name", { __proto__: null, value: `set ${c}` }),
          m(get, "name", { __proto__: null, value: `get ${c}` }),
          (i[c] = {
            __proto__: null,
            configurable: !0,
            enumerable: o,
            get: get,
            set: set,
          });
      }
      y(e, i);
    }
    const Pe = H(
        (e, t) => ((ve ??= o("messaging").DOMException), new ve(e, t))
      ),
      we = d(null);
    (we.enumerable = !0), E(we);
    const he = E(d(null));
    let xe;
    function getInternalGlobal() {
      if (null == xe) {
        const { runInNewContext: e } = t("vm");
        xe = e("this", void 0, { contextName: "internal" });
      }
      return xe;
    }
    const Re = new N();
    function getCrossRelmRegex(e) {
      const t = Re.get(e);
      if (t) return t;
      let r = "";
      k(e) && (r += "d"),
        O(e) && (r += "g"),
        F(e) && (r += "i"),
        L(e) && (r += "m"),
        D(e) && (r += "s"),
        A(e) && (r += "u"),
        I(e) && (r += "y");
      const { RegExp: n } = getInternalGlobal(),
        o = new n(G(e), r);
      return Re.set(e, o), o;
    }
    r.exports = {
      getLazy: function getLazy(e) {
        let t,
          r = !1;
        return function () {
          return !1 === r && ((t = e()), (r = !0)), t;
        };
      },
      assertCrypto: function assertCrypto() {
        if (ie) throw new Y();
      },
      cachedResult: function cachedResult(e) {
        let t;
        return () => (void 0 === t && (t = e()), s(t));
      },
      convertToValidSignal: function convertToValidSignal(e) {
        if (
          "number" == typeof e &&
          (function getSignalsToNamesMapping() {
            if (void 0 !== pe) return pe;
            pe = d(null);
            for (const e in J) pe[J[e]] = e;
            return pe;
          })()[e]
        )
          return e;
        if ("string" == typeof e) {
          const t = J[z(e)];
          if (t) return t;
        }
        throw new K(e);
      },
      createClassWrapper: function createClassWrapper(e) {
        function fn(...t) {
          return R(e, t, new.target || e);
        }
        return (
          y(fn, {
            name: { __proto__: null, value: e.name },
            length: { __proto__: null, value: e.length },
          }),
          P(fn, e),
          (fn.prototype = e.prototype),
          fn
        );
      },
      createDeferredPromise: function createDeferredPromise() {
        let e, t;
        return {
          promise: new h((r, n) => {
            (e = r), (t = n);
          }),
          resolve: e,
          reject: t,
        };
      },
      decorateErrorStack: function decorateErrorStack(e) {
        if (!isError(e) || !e.stack || e[ee]) return;
        const t = e[Z];
        t && ((e.stack = t + e.stack), (e[ee] = !0));
      },
      defineOperation: function defineOperation(e, t, r) {
        m(e, t, {
          __proto__: null,
          writable: !0,
          enumerable: !0,
          configurable: !0,
          value: r,
        });
      },
      defineLazyProperties: defineLazyProperties,
      defineReplaceableLazyAttribute: function defineReplaceableLazyAttribute(
        e,
        r,
        n,
        o = !0
      ) {
        let i;
        for (let a = 0; a < n.length; a++) {
          let get = function () {
              return l || ((i ??= t(r)), (c ??= i[u])), c;
            },
            set = function (e) {
              (l = !0), (c = e);
            };
          const u = n[a];
          let c,
            l = !1;
          m(get, "name", { __proto__: null, value: `get ${u}` }),
            m(set, "name", { __proto__: null, value: `set ${u}` }),
            m(e, u, {
              __proto__: null,
              enumerable: !0,
              configurable: !0,
              get: get,
              set: o ? set : void 0,
            });
        }
      },
      deprecate: function deprecate(e, r, o, i) {
        if (!0 === n.noDeprecation) return e;
        void 0 === fe && ({ validateString: fe } = t("internal/validators")),
          void 0 !== o && fe(o, "code");
        const a = getDeprecationWarningEmitter(o, r, deprecated, i);
        function deprecated(...t) {
          return a(), new.target ? R(e, t, new.target) : x(e, this, t);
        }
        return (
          P(deprecated, e),
          e.prototype && (deprecated.prototype = e.prototype),
          deprecated
        );
      },
      emitExperimentalWarning: function emitExperimentalWarning(e) {
        if (ae.has(e)) return;
        const t = `${e} is an experimental feature and might change at any time`;
        ae.add(e), n.emitWarning(t, "ExperimentalWarning");
      },
      exposeInterface: function exposeInterface(e, t, r) {
        m(e, t, {
          __proto__: null,
          writable: !0,
          enumerable: !1,
          configurable: !0,
          value: r,
        });
      },
      exposeLazyInterfaces: function exposeLazyInterfaces(e, t, r) {
        defineLazyProperties(e, t, r, !1);
      },
      filterDuplicateStrings: function filterDuplicateStrings(e, t) {
        const r = new W();
        for (let n = 0; n < e.length; n++) {
          const o = e[n],
            i = j(o);
          t ? r.set(i, i) : r.set(i, o);
        }
        return f(u(r.values()));
      },
      filterOwnProperties: function filterOwnProperties(e, t) {
        const r = d(null);
        for (let n = 0; n < t.length; n++) {
          const o = t[n];
          v(e, o) && (r[o] = e[o]);
        }
        return r;
      },
      getConstructorOf: function getConstructorOf(e) {
        for (; e; ) {
          const t = b(e, "constructor");
          if (
            void 0 !== t &&
            "function" == typeof t.value &&
            "" !== t.value.name
          )
            return t.value;
          e = S(e);
        }
        return null;
      },
      getCWDURL: function getCWDURL() {
        const { sep: e } = t("path"),
          { pathToFileURL: r } = t("internal/url");
        let o;
        try {
          o = n.cwd();
        } catch {
          ge ??= r(e);
        }
        return null != o && o !== de && ((ge = r(o + e)), (de = o)), ge;
      },
      getInternalGlobal: getInternalGlobal,
      getSystemErrorMap: function getSystemErrorMap() {
        return (function lazyUv() {
          return (le ??= o("uv")), le;
        })().getErrorMap();
      },
      getSystemErrorName: function getSystemErrorName(e) {
        const t = X(e);
        return t ? t[0] : `Unknown system error ${e}`;
      },
      isArrayBufferDetached: function isArrayBufferDetached(e) {
        return 0 === a(e) && Q(e);
      },
      isError: isError,
      isInsideNodeModules: function isInsideNodeModules() {
        if (void 0 === Se) {
          const { runInNewContext: e } = t("vm");
          Se = e(
            "(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e, (err, trace) => trace);\n        return e.stack;\n      };\n    })()",
            { overrideStackTrace: q },
            { filename: "structured-stack" }
          );
        }
        const e = Se();
        if (c(e))
          for (const t of e) {
            const e = t.getFileName();
            if (null !== C(/^\/|\\/, e)) return null !== C(_e, e);
          }
        return !1;
      },
      join: function join(e, t) {
        let r = "";
        if (0 !== e.length) {
          const n = e.length - 1;
          for (let o = 0; o < n; o++) (r += e[o]), (r += t);
          r += e[n];
        }
        return r;
      },
      lazyDOMException: Pe,
      lazyDOMExceptionClass: () => ((ve ??= o("messaging").DOMException), ve),
      normalizeEncoding: function normalizeEncoding(e) {
        return null == e || "utf8" === e || "utf-8" === e
          ? "utf8"
          : (function slowCases(e) {
              switch (e.length) {
                case 4:
                  if ("UTF8" === e) return "utf8";
                  if ("ucs2" === e || "UCS2" === e) return "utf16le";
                  if ("utf8" === (e = `${e}`.toLowerCase())) return "utf8";
                  if ("ucs2" === e) return "utf16le";
                  break;
                case 3:
                  if (
                    "hex" === e ||
                    "HEX" === e ||
                    "hex" === `${e}`.toLowerCase()
                  )
                    return "hex";
                  break;
                case 5:
                  if ("ascii" === e) return "ascii";
                  if ("ucs-2" === e) return "utf16le";
                  if ("UTF-8" === e) return "utf8";
                  if ("ASCII" === e) return "ascii";
                  if ("UCS-2" === e) return "utf16le";
                  if ("utf-8" === (e = `${e}`.toLowerCase())) return "utf8";
                  if ("ascii" === e) return "ascii";
                  if ("ucs-2" === e) return "utf16le";
                  break;
                case 6:
                  if ("base64" === e) return "base64";
                  if ("latin1" === e || "binary" === e) return "latin1";
                  if ("BASE64" === e) return "base64";
                  if ("LATIN1" === e || "BINARY" === e) return "latin1";
                  if ("base64" === (e = `${e}`.toLowerCase())) return "base64";
                  if ("latin1" === e || "binary" === e) return "latin1";
                  break;
                case 7:
                  if (
                    "utf16le" === e ||
                    "UTF16LE" === e ||
                    "utf16le" === `${e}`.toLowerCase()
                  )
                    return "utf16le";
                  break;
                case 8:
                  if (
                    "utf-16le" === e ||
                    "UTF-16LE" === e ||
                    "utf-16le" === `${e}`.toLowerCase()
                  )
                    return "utf16le";
                  break;
                case 9:
                  if (
                    "base64url" === e ||
                    "BASE64URL" === e ||
                    "base64url" === `${e}`.toLowerCase()
                  )
                    return "base64url";
                  break;
                default:
                  if ("" === e) return "utf8";
              }
            })(e);
      },
      once: function once(e) {
        let t = !1;
        return function (...r) {
          if (!t) return (t = !0), x(e, this, r);
        };
      },
      promisify: promisify,
      SideEffectFreeRegExpPrototypeExec:
        function SideEffectFreeRegExpPrototypeExec(e, t) {
          const { RegExp: r } = getInternalGlobal();
          return g(r.prototype.exec, e, t);
        },
      SideEffectFreeRegExpPrototypeSymbolReplace:
        function SideEffectFreeRegExpPrototypeSymbolReplace(e, t, r) {
          return getCrossRelmRegex(e)[B](t, r);
        },
      SideEffectFreeRegExpPrototypeSymbolSplit:
        function SideEffectFreeRegExpPrototypeSymbolSplit(e, t, r = void 0) {
          return getCrossRelmRegex(e)[V](t, r);
        },
      sleep: function sleep(e) {
        void 0 === Ee && ({ validateUint32: Ee } = t("internal/validators")),
          Ee(e, "msec"),
          te(e);
      },
      spliceOne: function spliceOne(e, t) {
        for (; t + 1 < e.length; t++) e[t] = e[t + 1];
        e.pop();
      },
      setupCoverageHooks: function setupCoverageHooks(e) {
        const r = t("internal/process/execution").tryGetCwd(),
          { resolve: i } = t("path"),
          a = i(r, e),
          { sourceMapCacheToObject: u } = t(
            "internal/source_map/source_map_cache"
          );
        return n.features.inspector
          ? (o("profiler").setCoverageDirectory(a),
            o("profiler").setSourceMapCacheGetter(u),
            a)
          : (n.emitWarning(
              "The inspector is disabled, coverage could not be collected",
              "Warning"
            ),
            "");
      },
      toUSVString: function toUSVString(e) {
        const t = `${e}`,
          r = C(ce, t);
        return r ? re(t, r.index) : t;
      },
      removeColors: function removeColors(e) {
        return T(e, ue, "");
      },
      customPromisifyArgs: me,
      customInspectSymbol: $("nodejs.util.inspect.custom"),
      kIsEncodingSymbol: M("kIsEncodingSymbol"),
      kVmBreakFirstLineSymbol: M("kVmBreakFirstLineSymbol"),
      kEmptyObject: he,
      kEnumerableProperty: we,
      setOwnProperty: function setOwnProperty(e, t, r) {
        return m(e, t, {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          value: r,
          writable: !0,
        });
      },
      pendingDeprecate: function pendingDeprecate(e, t, r) {
        const n = getDeprecationWarningEmitter(
          r,
          t,
          deprecated,
          !1,
          isPendingDeprecation
        );
        function deprecated(...t) {
          return n(), x(e, this, t);
        }
        return deprecated;
      },
    };
  },
  "internal/util/colors": function (e, r, o, t, s, l) {
    "use strict";
    let n;
    (o.exports = {
      blue: "",
      green: "",
      white: "",
      red: "",
      gray: "",
      clear: "",
      hasColors: !1,
      shouldColorize: (e) =>
        void 0 !== t.env.FORCE_COLOR
          ? (function lazyInternalTTY() {
              return (n ??= r("internal/tty")), n;
            })().getColorDepth() > 2
          : e?.isTTY &&
            ("function" != typeof e.getColorDepth || e.getColorDepth() > 2),
      refresh() {
        if (t.stderr.isTTY) {
          const e = o.exports.shouldColorize(t.stderr);
          (o.exports.blue = e ? "[34m" : ""),
            (o.exports.green = e ? "[32m" : ""),
            (o.exports.white = e ? "[39m" : ""),
            (o.exports.yellow = e ? "[33m" : ""),
            (o.exports.red = e ? "[31m" : ""),
            (o.exports.gray = e ? "[90m" : ""),
            (o.exports.clear = e ? "c" : ""),
            (o.exports.hasColors = e);
        }
      },
    }),
      o.exports.refresh();
  },
  "internal/util/comparisons": function (e, t, n, r, i, o) {
    "use strict";
    const {
        ArrayIsArray: u,
        ArrayPrototypeFilter: l,
        ArrayPrototypePush: f,
        BigIntPrototypeValueOf: s,
        BooleanPrototypeValueOf: a,
        DatePrototypeGetTime: c,
        Error: y,
        NumberIsNaN: g,
        NumberPrototypeValueOf: p,
        ObjectGetOwnPropertySymbols: h,
        ObjectGetPrototypeOf: b,
        ObjectIs: E,
        ObjectKeys: m,
        ObjectPrototypeHasOwnProperty: d,
        ObjectPrototypePropertyIsEnumerable: q,
        ObjectPrototypeToString: P,
        SafeMap: v,
        SafeSet: O,
        StringPrototypeValueOf: j,
        SymbolPrototypeValueOf: D,
        TypedArrayPrototypeGetSymbolToStringTag: S,
        Uint8Array: L,
      } = o,
      { compare: w } = i("buffer"),
      k = t("internal/assert"),
      A = t("internal/util/types"),
      {
        isAnyArrayBuffer: B,
        isArrayBufferView: H,
        isDate: I,
        isMap: M,
        isRegExp: N,
        isSet: x,
        isNativeError: z,
        isBoxedPrimitive: C,
        isNumberObject: T,
        isStringObject: V,
        isBooleanObject: F,
        isBigIntObject: _,
        isSymbolObject: G,
        isFloat32Array: R,
        isFloat64Array: U,
      } = A,
      {
        constants: { ONLY_ENUMERABLE: K, SKIP_SYMBOLS: Y },
        getOwnNonIndexProperties: $,
      } = i("util"),
      J = 0,
      Q = 1,
      W = 2,
      X = 3;
    function innerDeepEqual(e, t, n, r) {
      if (e === t) return 0 !== e || !n || E(e, t);
      if (n) {
        if ("object" != typeof e) return "number" == typeof e && g(e) && g(t);
        if ("object" != typeof t || null === e || null === t) return !1;
        if (b(e) !== b(t)) return !1;
      } else {
        if (null === e || "object" != typeof e)
          return (
            (null === t || "object" != typeof t) && (e == t || (g(e) && g(t)))
          );
        if (null === t || "object" != typeof t) return !1;
      }
      const i = P(e);
      if (i !== P(t)) return !1;
      if (u(e)) {
        if (!u(t) || e.length !== t.length) return !1;
        const i = n ? K : K | Y,
          o = $(e, i),
          l = $(t, i);
        return o.length === l.length && keyCheck(e, t, n, r, Q, o);
      }
      if ("[object Object]" === i) return keyCheck(e, t, n, r, J);
      if (I(e)) {
        if (!I(t) || c(e) !== c(t)) return !1;
      } else if (N(e)) {
        if (
          !N(t) ||
          !(function areSimilarRegExps(e, t) {
            return (
              e.source === t.source &&
              e.flags === t.flags &&
              e.lastIndex === t.lastIndex
            );
          })(e, t)
        )
          return !1;
      } else if (z(e) || e instanceof y) {
        if (
          (!z(t) && !(t instanceof y)) ||
          e.message !== t.message ||
          e.name !== t.name
        )
          return !1;
      } else {
        if (H(e)) {
          if (S(e) !== S(t)) return !1;
          if (n || (!R(e) && !U(e))) {
            if (
              !(function areSimilarTypedArrays(e, t) {
                return (
                  e.byteLength === t.byteLength &&
                  0 ===
                    w(
                      new L(e.buffer, e.byteOffset, e.byteLength),
                      new L(t.buffer, t.byteOffset, t.byteLength)
                    )
                );
              })(e, t)
            )
              return !1;
          } else if (
            !(function areSimilarFloatArrays(e, t) {
              if (e.byteLength !== t.byteLength) return !1;
              for (let n = 0; n < e.byteLength; n++)
                if (e[n] !== t[n]) return !1;
              return !0;
            })(e, t)
          )
            return !1;
          const i = n ? K : K | Y,
            o = $(e, i),
            u = $(t, i);
          return o.length === u.length && keyCheck(e, t, n, r, J, o);
        }
        if (x(e))
          return !(!x(t) || e.size !== t.size) && keyCheck(e, t, n, r, W);
        if (M(e))
          return !(!M(t) || e.size !== t.size) && keyCheck(e, t, n, r, X);
        if (B(e)) {
          if (
            !B(t) ||
            !(function areEqualArrayBuffers(e, t) {
              return (
                e.byteLength === t.byteLength && 0 === w(new L(e), new L(t))
              );
            })(e, t)
          )
            return !1;
        } else if (C(e)) {
          if (
            !(function isEqualBoxedPrimitive(e, t) {
              return T(e)
                ? T(t) && E(p(e), p(t))
                : V(e)
                ? V(t) && j(e) === j(t)
                : F(e)
                ? F(t) && a(e) === a(t)
                : _(e)
                ? _(t) && s(e) === s(t)
                : G(e)
                ? G(t) && D(e) === D(t)
                : void k.fail(`Unknown boxed type ${e}`);
            })(e, t)
          )
            return !1;
        } else if (
          u(t) ||
          H(t) ||
          x(t) ||
          M(t) ||
          I(t) ||
          N(t) ||
          B(t) ||
          C(t) ||
          z(t) ||
          t instanceof y
        )
          return !1;
      }
      return keyCheck(e, t, n, r, J);
    }
    function getEnumerables(e, t) {
      return l(t, (t) => q(e, t));
    }
    function keyCheck(e, t, n, r, i, o) {
      if (5 === arguments.length) {
        o = m(e);
        const n = m(t);
        if (o.length !== n.length) return !1;
      }
      let u = 0;
      for (; u < o.length; u++) if (!q(t, o[u])) return !1;
      if (n && 5 === arguments.length) {
        const n = h(e);
        if (0 !== n.length) {
          let r = 0;
          for (u = 0; u < n.length; u++) {
            const i = n[u];
            if (q(e, i)) {
              if (!q(t, i)) return !1;
              f(o, i), r++;
            } else if (q(t, i)) return !1;
          }
          const i = h(t);
          if (n.length !== i.length && getEnumerables(t, i).length !== r)
            return !1;
        } else {
          const e = h(t);
          if (0 !== e.length && 0 !== getEnumerables(t, e).length) return !1;
        }
      }
      if (
        0 === o.length &&
        (i === J || (i === Q && 0 === e.length) || 0 === e.size)
      )
        return !0;
      if (void 0 === r) r = { val1: new v(), val2: new v(), position: 0 };
      else {
        const n = r.val1.get(e);
        if (void 0 !== n) {
          const e = r.val2.get(t);
          if (void 0 !== e) return n === e;
        }
        r.position++;
      }
      r.val1.set(e, r.position), r.val2.set(t, r.position);
      const l = (function objEquiv(e, t, n, r, i, o) {
        let u = 0;
        if (o === W) {
          if (
            !(function setEquiv(e, t, n, r) {
              let i = null;
              for (const r of e)
                if ("object" == typeof r && null !== r)
                  null === i && (i = new O()), i.add(r);
                else if (!t.has(r)) {
                  if (n) return !1;
                  if (!setMightHaveLoosePrim(e, t, r)) return !1;
                  null === i && (i = new O()), i.add(r);
                }
              if (null !== i) {
                for (const o of t)
                  if ("object" == typeof o && null !== o) {
                    if (!setHasEqualElement(i, o, n, r)) return !1;
                  } else if (!n && !e.has(o) && !setHasEqualElement(i, o, n, r))
                    return !1;
                return 0 === i.size;
              }
              return !0;
            })(e, t, n, i)
          )
            return !1;
        } else if (o === X) {
          if (
            !(function mapEquiv(e, t, n, r) {
              let i = null;
              for (const { 0: o, 1: u } of e)
                if ("object" == typeof o && null !== o)
                  null === i && (i = new O()), i.add(o);
                else {
                  const l = t.get(o);
                  if (
                    (void 0 === l && !t.has(o)) ||
                    !innerDeepEqual(u, l, n, r)
                  ) {
                    if (n) return !1;
                    if (!mapMightHaveLoosePrim(e, t, o, u, r)) return !1;
                    null === i && (i = new O()), i.add(o);
                  }
                }
              if (null !== i) {
                for (const { 0: o, 1: u } of t)
                  if ("object" == typeof o && null !== o) {
                    if (!mapHasEqualEntry(i, e, o, u, n, r)) return !1;
                  } else if (
                    !(
                      n ||
                      (e.has(o) && innerDeepEqual(e.get(o), u, !1, r)) ||
                      mapHasEqualEntry(i, e, o, u, !1, r)
                    )
                  )
                    return !1;
                return 0 === i.size;
              }
              return !0;
            })(e, t, n, i)
          )
            return !1;
        } else if (o === Q)
          for (; u < e.length; u++) {
            if (!d(e, u)) {
              if (d(t, u)) return !1;
              {
                const r = m(e);
                for (; u < r.length; u++) {
                  const o = r[u];
                  if (!d(t, o) || !innerDeepEqual(e[o], t[o], n, i)) return !1;
                }
                return r.length === m(t).length;
              }
            }
            if (!d(t, u) || !innerDeepEqual(e[u], t[u], n, i)) return !1;
          }
        for (u = 0; u < r.length; u++) {
          const o = r[u];
          if (!innerDeepEqual(e[o], t[o], n, i)) return !1;
        }
        return !0;
      })(e, t, n, o, r, i);
      return r.val1.delete(e), r.val2.delete(t), l;
    }
    function setHasEqualElement(e, t, n, r) {
      for (const i of e) if (innerDeepEqual(t, i, n, r)) return e.delete(i), !0;
      return !1;
    }
    function findLooseMatchingPrimitives(e) {
      switch (typeof e) {
        case "undefined":
          return null;
        case "object":
          return;
        case "symbol":
          return !1;
        case "string":
          e = +e;
        case "number":
          if (g(e)) return !1;
      }
      return !0;
    }
    function setMightHaveLoosePrim(e, t, n) {
      const r = findLooseMatchingPrimitives(n);
      return null != r ? r : t.has(r) && !e.has(r);
    }
    function mapMightHaveLoosePrim(e, t, n, r, i) {
      const o = findLooseMatchingPrimitives(n);
      if (null != o) return o;
      const u = t.get(o);
      return (
        !((void 0 === u && !t.has(o)) || !innerDeepEqual(r, u, !1, i)) &&
        !e.has(o) &&
        innerDeepEqual(r, u, !1, i)
      );
    }
    function mapHasEqualEntry(e, t, n, r, i, o) {
      for (const u of e)
        if (innerDeepEqual(n, u, i, o) && innerDeepEqual(r, t.get(u), i, o))
          return e.delete(u), !0;
      return !1;
    }
    n.exports = {
      isDeepEqual: function isDeepEqual(e, t) {
        return innerDeepEqual(e, t, false);
      },
      isDeepStrictEqual: function isDeepStrictEqual(e, t) {
        return innerDeepEqual(e, t, true);
      },
    };
  },
  "internal/util/debuglog": function (e, t, n, r, i, o) {
    "use strict";
    const {
        ObjectCreate: l,
        ObjectDefineProperty: s,
        RegExp: u,
        RegExpPrototypeExec: a,
        SafeArrayIterator: c,
        StringPrototypeToLowerCase: g,
        StringPrototypeToUpperCase: p,
      } = o,
      {
        inspect: f,
        format: d,
        formatWithOptions: b,
      } = t("internal/util/inspect");
    let h, m;
    const noop = () => {};
    let w;
    function debuglogImpl(e, n) {
      if (void 0 === h[n])
        if (e) {
          const e = r.pid;
          !(function emitWarningIfNeeded(e) {
            ("HTTP" !== e && "HTTP2" !== e) ||
              r.emitWarning(
                "Setting the NODE_DEBUG environment variable to '" +
                  g(e) +
                  "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log."
              );
          })(n),
            (h[n] = function debug(...i) {
              const o = (function lazyUtilColors() {
                  return (w ??= t("internal/util/colors")), w;
                })().shouldColorize(r.stderr),
                l = b({ colors: o }, ...i),
                s = f(e, { colors: o });
              r.stderr.write(d("%s %s: %s\n", n, s, l));
            });
        } else h[n] = noop;
      return h[n];
    }
    n.exports = {
      debuglog: function debuglog(e, t) {
        function init() {
          (e = p(e)), (n = m(e));
        }
        let n,
          debug = (...r) => {
            switch (
              (init(),
              (debug = debuglogImpl(n, e)),
              "function" == typeof t && t(debug),
              r.length)
            ) {
              case 1:
                return debug(r[0]);
              case 2:
                return debug(r[0], r[1]);
              default:
                return debug(...new c(r));
            }
          },
          test = () => (init(), (test = () => n), n);
        const logger = (...e) => {
          switch (e.length) {
            case 1:
              return debug(e[0]);
            case 2:
              return debug(e[0], e[1]);
            default:
              return debug(...new c(e));
          }
        };
        return (
          s(logger, "enabled", {
            __proto__: null,
            get: () => test(),
            configurable: !0,
            enumerable: !0,
          }),
          logger
        );
      },
      initializeDebugEnv: function initializeDebugEnv(e) {
        if (((h = l(null)), e)) {
          e = e
            .replace(/[|\\{}()[\]^$+?.]/g, "\\$&")
            .replaceAll("*", ".*")
            .replaceAll(",", "$|^");
          const t = new u(`^${e}$`, "i");
          m = (e) => null !== a(t, e);
        } else m = () => !1;
      },
    };
  },
  "internal/util/inspect": function (t, e, n, r, o, i) {
    "use strict";
    const {
        Array: l,
        ArrayIsArray: a,
        ArrayPrototypeFilter: s,
        ArrayPrototypeForEach: c,
        ArrayPrototypeIncludes: f,
        ArrayPrototypeIndexOf: u,
        ArrayPrototypeJoin: g,
        ArrayPrototypeMap: d,
        ArrayPrototypePop: p,
        ArrayPrototypePush: y,
        ArrayPrototypePushApply: m,
        ArrayPrototypeSlice: h,
        ArrayPrototypeSplice: $,
        ArrayPrototypeSort: x,
        ArrayPrototypeUnshift: b,
        BigIntPrototypeValueOf: S,
        BooleanPrototypeValueOf: P,
        DatePrototypeGetTime: v,
        DatePrototypeToISOString: A,
        DatePrototypeToString: L,
        ErrorPrototypeToString: C,
        FunctionPrototypeBind: w,
        FunctionPrototypeCall: k,
        FunctionPrototypeToString: I,
        JSONStringify: B,
        MapPrototypeGetSize: N,
        MapPrototypeEntries: z,
        MathFloor: O,
        MathMax: E,
        MathMin: T,
        MathRound: M,
        MathSqrt: _,
        MathTrunc: j,
        Number: F,
        NumberIsFinite: R,
        NumberIsNaN: V,
        NumberParseFloat: W,
        NumberParseInt: H,
        NumberPrototypeToString: D,
        NumberPrototypeValueOf: G,
        Object: Z,
        ObjectAssign: K,
        ObjectCreate: U,
        ObjectDefineProperty: q,
        ObjectGetOwnPropertyDescriptor: Q,
        ObjectGetOwnPropertyNames: Y,
        ObjectGetOwnPropertySymbols: J,
        ObjectGetPrototypeOf: X,
        ObjectIs: tt,
        ObjectKeys: et,
        ObjectPrototypeHasOwnProperty: nt,
        ObjectPrototypePropertyIsEnumerable: rt,
        ObjectSeal: ot,
        ObjectSetPrototypeOf: it,
        ReflectApply: lt,
        ReflectOwnKeys: at,
        RegExp: st,
        RegExpPrototypeExec: ct,
        RegExpPrototypeSymbolReplace: ft,
        RegExpPrototypeSymbolSplit: ut,
        RegExpPrototypeToString: gt,
        SafeStringIterator: dt,
        SafeMap: pt,
        SafeSet: yt,
        SetPrototypeGetSize: mt,
        SetPrototypeValues: ht,
        String: $t,
        StringPrototypeCharCodeAt: xt,
        StringPrototypeCodePointAt: bt,
        StringPrototypeIncludes: St,
        StringPrototypeIndexOf: Pt,
        StringPrototypeLastIndexOf: vt,
        StringPrototypeNormalize: At,
        StringPrototypePadEnd: Lt,
        StringPrototypePadStart: Ct,
        StringPrototypeRepeat: wt,
        StringPrototypeReplaceAll: kt,
        StringPrototypeSlice: It,
        StringPrototypeSplit: Bt,
        StringPrototypeEndsWith: Nt,
        StringPrototypeStartsWith: zt,
        StringPrototypeToLowerCase: Ot,
        StringPrototypeTrim: Et,
        StringPrototypeValueOf: Tt,
        SymbolPrototypeToString: Mt,
        SymbolPrototypeValueOf: _t,
        SymbolIterator: jt,
        SymbolToStringTag: Ft,
        TypedArrayPrototypeGetLength: Rt,
        TypedArrayPrototypeGetSymbolToStringTag: Vt,
        Uint8Array: Wt,
        globalThis: Ht,
        uncurryThis: Dt,
      } = i,
      {
        constants: {
          ALL_PROPERTIES: Gt,
          ONLY_ENUMERABLE: Zt,
          kPending: Kt,
          kRejected: Ut,
        },
        getOwnNonIndexProperties: qt,
        getPromiseDetails: Qt,
        getProxyDetails: Yt,
        previewEntries: Jt,
        getConstructorName: Xt,
        getExternalValue: te,
      } = o("util"),
      {
        customInspectSymbol: ee,
        isError: ne,
        join: re,
        removeColors: oe,
      } = e("internal/util"),
      { isStackOverflowError: ie } = e("internal/errors"),
      {
        isAsyncFunction: le,
        isGeneratorFunction: ae,
        isAnyArrayBuffer: se,
        isArrayBuffer: ce,
        isArgumentsObject: fe,
        isBoxedPrimitive: ue,
        isDataView: ge,
        isExternal: de,
        isMap: pe,
        isMapIterator: ye,
        isModuleNamespaceObject: me,
        isNativeError: he,
        isPromise: $e,
        isSet: xe,
        isSetIterator: be,
        isWeakMap: Se,
        isWeakSet: Pe,
        isRegExp: ve,
        isDate: Ae,
        isTypedArray: Le,
        isStringObject: Ce,
        isNumberObject: we,
        isBooleanObject: ke,
        isBigIntObject: Ie,
      } = e("internal/util/types"),
      Be = e("internal/assert"),
      { BuiltinModule: Ne } = e("internal/bootstrap/realm"),
      { validateObject: ze, validateString: Oe } = e("internal/validators");
    let Ee, Te;
    function pathToFileUrlHref(t) {
      return (Te ??= e("internal/url")), Te.pathToFileURL(t).href;
    }
    const Me = new yt(s(Y(Ht), (t) => null !== ct(/^[A-Z][a-zA-Z0-9]+$/, t))),
      isUndetectableObject = (t) => void 0 === t && void 0 !== t,
      _e = ot({
        showHidden: !1,
        depth: 2,
        colors: !1,
        customInspect: !0,
        showProxy: !1,
        maxArrayLength: 100,
        maxStringLength: 1e4,
        breakLength: 80,
        compact: 3,
        sorted: !1,
        getters: !1,
        numericSeparator: !1,
      }),
      je = 0,
      Fe = 1,
      Re = 2,
      Ve =
        /[\x00-\x1f\x27\x5c\x7f-\x9f]|[\ud800-\udbff](?![\udc00-\udfff])|(?<![\ud800-\udbff])[\udc00-\udfff]/,
      We =
        /[\x00-\x1f\x27\x5c\x7f-\x9f]|[\ud800-\udbff](?![\udc00-\udfff])|(?<![\ud800-\udbff])[\udc00-\udfff]/g,
      He =
        /[\x00-\x1f\x5c\x7f-\x9f]|[\ud800-\udbff](?![\udc00-\udfff])|(?<![\ud800-\udbff])[\udc00-\udfff]/,
      De =
        /[\x00-\x1f\x5c\x7f-\x9f]|[\ud800-\udbff](?![\udc00-\udfff])|(?<![\ud800-\udbff])[\udc00-\udfff]/g,
      Ge = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
      Ze = /^(0|[1-9][0-9]*)$/,
      Ke = /^ {4}at (?:[^/\\(]+ \(|)node:(.+):\d+:\d+\)?$/,
      Ue = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g,
      qe = /^(\s+[^(]*?)\s*{/,
      Qe = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g,
      Ye = 16,
      Je = 0,
      Xe = 1,
      tn = 2,
      en = [
        "\\x00",
        "\\x01",
        "\\x02",
        "\\x03",
        "\\x04",
        "\\x05",
        "\\x06",
        "\\x07",
        "\\b",
        "\\t",
        "\\n",
        "\\x0B",
        "\\f",
        "\\r",
        "\\x0E",
        "\\x0F",
        "\\x10",
        "\\x11",
        "\\x12",
        "\\x13",
        "\\x14",
        "\\x15",
        "\\x16",
        "\\x17",
        "\\x18",
        "\\x19",
        "\\x1A",
        "\\x1B",
        "\\x1C",
        "\\x1D",
        "\\x1E",
        "\\x1F",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\'",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\x7F",
        "\\x80",
        "\\x81",
        "\\x82",
        "\\x83",
        "\\x84",
        "\\x85",
        "\\x86",
        "\\x87",
        "\\x88",
        "\\x89",
        "\\x8A",
        "\\x8B",
        "\\x8C",
        "\\x8D",
        "\\x8E",
        "\\x8F",
        "\\x90",
        "\\x91",
        "\\x92",
        "\\x93",
        "\\x94",
        "\\x95",
        "\\x96",
        "\\x97",
        "\\x98",
        "\\x99",
        "\\x9A",
        "\\x9B",
        "\\x9C",
        "\\x9D",
        "\\x9E",
        "\\x9F",
      ],
      nn = new st(
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
        "g"
      );
    let rn;
    function inspect(t, e) {
      const n = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: _e.showHidden,
        depth: _e.depth,
        colors: _e.colors,
        customInspect: _e.customInspect,
        showProxy: _e.showProxy,
        maxArrayLength: _e.maxArrayLength,
        maxStringLength: _e.maxStringLength,
        breakLength: _e.breakLength,
        compact: _e.compact,
        sorted: _e.sorted,
        getters: _e.getters,
        numericSeparator: _e.numericSeparator,
      };
      if (arguments.length > 1)
        if (
          (arguments.length > 2 &&
            (void 0 !== arguments[2] && (n.depth = arguments[2]),
            arguments.length > 3 &&
              void 0 !== arguments[3] &&
              (n.colors = arguments[3])),
          "boolean" == typeof e)
        )
          n.showHidden = e;
        else if (e) {
          const t = et(e);
          for (let r = 0; r < t.length; ++r) {
            const o = t[r];
            nt(_e, o) || "stylize" === o
              ? (n[o] = e[o])
              : void 0 === n.userOptions && (n.userOptions = e);
          }
        }
      return (
        n.colors && (n.stylize = stylizeWithColor),
        null === n.maxArrayLength && (n.maxArrayLength = 1 / 0),
        null === n.maxStringLength && (n.maxStringLength = 1 / 0),
        formatValue(n, t, 0)
      );
    }
    (inspect.custom = ee),
      q(inspect, "defaultOptions", {
        __proto__: null,
        get: () => _e,
        set: (t) => (ze(t, "options"), K(_e, t)),
      });
    const on = 39,
      ln = 49;
    function defineColorAlias(t, e) {
      q(inspect.colors, e, {
        __proto__: null,
        get() {
          return this[t];
        },
        set(e) {
          this[t] = e;
        },
        configurable: !0,
        enumerable: !1,
      });
    }
    function addQuotes(t, e) {
      return -1 === e ? `"${t}"` : -2 === e ? `\`${t}\`` : `'${t}'`;
    }
    function escapeFn(t) {
      const e = xt(t);
      return en.length > e ? en[e] : `\\u${D(e, 16)}`;
    }
    function strEscape(t) {
      let e = Ve,
        n = We,
        r = 39;
      if (
        (St(t, "'") &&
          (St(t, '"') ? St(t, "`") || St(t, "${") || (r = -2) : (r = -1),
          39 !== r && ((e = He), (n = De))),
        t.length < 5e3 && null === ct(e, t))
      )
        return addQuotes(t, r);
      if (t.length > 100) return addQuotes((t = ft(n, t, escapeFn)), r);
      let o = "",
        i = 0;
      for (let e = 0; e < t.length; e++) {
        const n = xt(t, e);
        if (n === r || 92 === n || n < 32 || (n > 126 && n < 160))
          (o += i === e ? en[n] : `${It(t, i, e)}${en[n]}`), (i = e + 1);
        else if (n >= 55296 && n <= 57343) {
          if (n <= 56319 && e + 1 < t.length) {
            const n = xt(t, e + 1);
            if (n >= 56320 && n <= 57343) {
              e++;
              continue;
            }
          }
          (o += `${It(t, i, e)}\\u${D(n, 16)}`), (i = e + 1);
        }
      }
      return i !== t.length && (o += It(t, i)), addQuotes(o, r);
    }
    function stylizeWithColor(t, e) {
      const n = inspect.styles[e];
      if (void 0 !== n) {
        const e = inspect.colors[n];
        if (void 0 !== e) return `[${e[0]}m${t}[${e[1]}m`;
      }
      return t;
    }
    function stylizeNoColor(t) {
      return t;
    }
    function getEmptyFormatArray() {
      return [];
    }
    function isInstanceof(t, e) {
      try {
        return t instanceof e;
      } catch {
        return !1;
      }
    }
    function getConstructorName(t, e, n, r) {
      let o;
      const i = t;
      for (; t || isUndetectableObject(t); ) {
        const l = Q(t, "constructor");
        if (
          void 0 !== l &&
          "function" == typeof l.value &&
          "" !== l.value.name &&
          isInstanceof(i, l.value)
        )
          return (
            void 0 === r ||
              (o === t && Me.has(l.value.name)) ||
              addPrototypeProperties(e, i, o || i, n, r),
            $t(l.value.name)
          );
        (t = X(t)), void 0 === o && (o = t);
      }
      if (null === o) return null;
      const l = Xt(i);
      if (n > e.depth && null !== e.depth) return `${l} <Complex prototype>`;
      const a = getConstructorName(o, e, n + 1, r);
      return null === a
        ? `${l} <${inspect(o, { ...e, customInspect: !1, depth: -1 })}>`
        : `${l} <${a}>`;
    }
    function addPrototypeProperties(t, e, n, r, o) {
      let i,
        l,
        a = 0;
      do {
        if (0 !== a || e === n) {
          if (null === (n = X(n))) return;
          const t = Q(n, "constructor");
          if (
            void 0 !== t &&
            "function" == typeof t.value &&
            Me.has(t.value.name)
          )
            return;
        }
        0 === a ? (l = new yt()) : c(i, (t) => l.add(t)),
          (i = at(n)),
          y(t.seen, e);
        for (const s of i) {
          if ("constructor" === s || nt(e, s) || (0 !== a && l.has(s)))
            continue;
          const i = Q(n, s);
          if ("function" == typeof i.value) continue;
          const c = formatProperty(t, n, r, s, je, i, e);
          t.colors ? y(o, `[2m${c}[22m`) : y(o, c);
        }
        p(t.seen);
      } while (3 != ++a);
    }
    function getPrefix(t, e, n, r = "") {
      return null === t
        ? "" !== e && n !== e
          ? `[${n}${r}: null prototype] [${e}] `
          : `[${n}${r}: null prototype] `
        : "" !== e && t !== e
        ? `${t}${r} [${e}] `
        : `${t}${r} `;
    }
    function getKeys(t, e) {
      let n;
      const r = J(t);
      if (e) (n = Y(t)), 0 !== r.length && m(n, r);
      else {
        try {
          n = et(t);
        } catch (e) {
          Be(he(e) && "ReferenceError" === e.name && me(t)), (n = Y(t));
        }
        if (0 !== r.length) {
          m(
            n,
            s(r, (e) => rt(t, e))
          );
        }
      }
      return n;
    }
    function getCtxStyle(t, e, n) {
      let r = "";
      return (
        null === e && ((r = Xt(t)), r === n && (r = "Object")),
        getPrefix(e, n, r)
      );
    }
    function formatValue(t, e, n, o) {
      if (
        "object" != typeof e &&
        "function" != typeof e &&
        !isUndetectableObject(e)
      )
        return formatPrimitive(t.stylize, e, t);
      if (null === e) return t.stylize("null", "null");
      const l = e,
        s = Yt(e, !!t.showProxy);
      if (void 0 !== s) {
        if (null === s || null === s[0])
          return t.stylize("<Revoked Proxy>", "special");
        if (t.showProxy)
          return (function formatProxy(t, e, n) {
            if (n > t.depth && null !== t.depth)
              return t.stylize("Proxy [Array]", "special");
            (n += 1), (t.indentationLvl += 2);
            const r = [formatValue(t, e[0], n), formatValue(t, e[1], n)];
            return (
              (t.indentationLvl -= 2),
              reduceToSingleString(t, r, "", ["Proxy [", "]"], Re, n)
            );
          })(t, s, n);
        e = s;
      }
      if (t.customInspect) {
        const r = e[ee];
        if (
          "function" == typeof r &&
          r !== inspect &&
          (!e.constructor || e.constructor.prototype !== e)
        ) {
          const e = null === t.depth ? null : t.depth - n,
            o = k(
              r,
              l,
              e,
              (function getUserOptions(t, e) {
                const n = {
                  stylize: t.stylize,
                  showHidden: t.showHidden,
                  depth: t.depth,
                  colors: t.colors,
                  customInspect: t.customInspect,
                  showProxy: t.showProxy,
                  maxArrayLength: t.maxArrayLength,
                  maxStringLength: t.maxStringLength,
                  breakLength: t.breakLength,
                  compact: t.compact,
                  sorted: t.sorted,
                  getters: t.getters,
                  numericSeparator: t.numericSeparator,
                  ...t.userOptions,
                };
                if (e) {
                  it(n, null);
                  for (const t of et(n))
                    ("object" != typeof n[t] && "function" != typeof n[t]) ||
                      null === n[t] ||
                      delete n[t];
                  n.stylize = it((e, n) => {
                    let r;
                    try {
                      r = `${t.stylize(e, n)}`;
                    } catch {}
                    return "string" != typeof r ? e : r;
                  }, null);
                }
                return n;
              })(t, void 0 !== s || !(l instanceof Z)),
              inspect
            );
          if (o !== l)
            return "string" != typeof o
              ? formatValue(t, o, n)
              : kt(o, "\n", `\n${wt(" ", t.indentationLvl)}`);
        }
      }
      if (t.seen.includes(e)) {
        let n = 1;
        return (
          void 0 === t.circular
            ? ((t.circular = new pt()), t.circular.set(e, n))
            : ((n = t.circular.get(e)),
              void 0 === n &&
                ((n = t.circular.size + 1), t.circular.set(e, n))),
          t.stylize(`[Circular *${n}]`, "special")
        );
      }
      return (function formatRaw(t, e, n, o) {
        let l, s;
        t.showHidden && (n <= t.depth || null === t.depth) && (s = []);
        const c = getConstructorName(e, t, n, s);
        void 0 !== s && 0 === s.length && (s = void 0);
        let d = e[Ft];
        ("string" != typeof d ||
          ("" !== d && (t.showHidden ? nt : rt)(e, Ft))) &&
          (d = "");
        let C,
          k = "",
          B = getEmptyFormatArray,
          O = !0,
          E = 0;
        const T = t.showHidden ? Gt : Zt;
        let M,
          _ = je;
        if (jt in e || null === c)
          if (((O = !1), a(e))) {
            const t =
              "Array" !== c || "" !== d
                ? getPrefix(c, d, "Array", `(${e.length})`)
                : "";
            if (
              ((l = qt(e, T)),
              (C = [`${t}[`, "]"]),
              0 === e.length && 0 === l.length && void 0 === s)
            )
              return `${C[0]}]`;
            (_ = Re), (B = formatArray);
          } else if (xe(e)) {
            const n = mt(e),
              r = getPrefix(c, d, "Set", `(${n})`);
            if (
              ((l = getKeys(e, t.showHidden)),
              (B = w(formatSet, null, null !== c ? e : ht(e))),
              0 === n && 0 === l.length && void 0 === s)
            )
              return `${r}{}`;
            C = [`${r}{`, "}"];
          } else if (pe(e)) {
            const n = N(e),
              r = getPrefix(c, d, "Map", `(${n})`);
            if (
              ((l = getKeys(e, t.showHidden)),
              (B = w(formatMap, null, null !== c ? e : z(e))),
              0 === n && 0 === l.length && void 0 === s)
            )
              return `${r}{}`;
            C = [`${r}{`, "}"];
          } else if (Le(e)) {
            l = qt(e, T);
            let n = e,
              r = "";
            null === c && ((r = Vt(e)), (n = new i[r](e)));
            const o = Rt(e);
            if (
              ((C = [`${getPrefix(c, d, r, `(${o})`)}[`, "]"]),
              0 === e.length && 0 === l.length && !t.showHidden)
            )
              return `${C[0]}]`;
            (B = w(formatTypedArray, null, n, o)), (_ = Re);
          } else
            ye(e)
              ? ((l = getKeys(e, t.showHidden)),
                (C = getIteratorBraces("Map", d)),
                (B = w(formatIterator, null, C)))
              : be(e)
              ? ((l = getKeys(e, t.showHidden)),
                (C = getIteratorBraces("Set", d)),
                (B = w(formatIterator, null, C)))
              : (O = !0);
        if (O)
          if (
            ((l = getKeys(e, t.showHidden)), (C = ["{", "}"]), "Object" === c)
          ) {
            if (
              (fe(e)
                ? (C[0] = "[Arguments] {")
                : "" !== d && (C[0] = `${getPrefix(c, d, "Object")}{`),
              0 === l.length && void 0 === s)
            )
              return `${C[0]}}`;
          } else if ("function" == typeof e) {
            if (
              ((k = (function getFunctionBase(t, e, n) {
                const r = I(t);
                if (zt(r, "class") && Nt(r, "}")) {
                  const o = It(r, 5, -1),
                    i = Pt(o, "{");
                  if (
                    -1 !== i &&
                    (!St(It(o, 0, i), "(") || null !== ct(qe, ft(Qe, o)))
                  )
                    return (function getClassBase(t, e, n) {
                      const r = nt(t, "name"),
                        o = (r && t.name) || "(anonymous)";
                      let i = `class ${o}`;
                      "Function" !== e && null !== e && (i += ` [${e}]`);
                      "" !== n && e !== n && (i += ` [${n}]`);
                      if (null !== e) {
                        const e = X(t).name;
                        e && (i += ` extends ${e}`);
                      } else i += " extends [null prototype]";
                      return `[${i}]`;
                    })(t, e, n);
                }
                let o = "Function";
                ae(t) && (o = `Generator${o}`);
                le(t) && (o = `Async${o}`);
                let i = `[${o}`;
                null === e && (i += " (null prototype)");
                "" === t.name ? (i += " (anonymous)") : (i += `: ${t.name}`);
                (i += "]"), e !== o && null !== e && (i += ` ${e}`);
                "" !== n && e !== n && (i += ` [${n}]`);
                return i;
              })(e, c, d)),
              0 === l.length && void 0 === s)
            )
              return t.stylize(k, "special");
          } else if (ve(e)) {
            k = gt(null !== c ? e : new st(e));
            const r = getPrefix(c, d, "RegExp");
            if (
              ("RegExp " !== r && (k = `${r}${k}`),
              (0 === l.length && void 0 === s) ||
                (n > t.depth && null !== t.depth))
            )
              return t.stylize(k, "regexp");
          } else if (Ae(e)) {
            k = V(v(e)) ? L(e) : A(e);
            const n = getPrefix(c, d, "Date");
            if (
              ("Date " !== n && (k = `${n}${k}`),
              0 === l.length && void 0 === s)
            )
              return t.stylize(k, "date");
          } else if (ne(e)) {
            if (
              ((k = (function formatError(t, e, n, o, i) {
                const l = null != t.name ? $t(t.name) : "Error";
                let s = getStackString(t);
                (function removeDuplicateErrorKeys(t, e, n, r) {
                  if (!t.showHidden && 0 !== e.length)
                    for (const t of ["name", "message", "stack"]) {
                      const o = u(e, t);
                      -1 !== o && St(r, n[t]) && $(e, o, 1);
                    }
                })(o, i, t, s),
                  !("cause" in t) ||
                    (0 !== i.length && f(i, "cause")) ||
                    y(i, "cause");
                !a(t.errors) ||
                  (0 !== i.length && f(i, "errors")) ||
                  y(i, "errors");
                s = (function improveStack(t, e, n, r) {
                  let o = n.length;
                  if (
                    null === e ||
                    (Nt(n, "Error") &&
                      zt(t, n) &&
                      (t.length === o || ":" === t[o] || "\n" === t[o]))
                  ) {
                    let i = "Error";
                    if (null === e) {
                      const e =
                        ct(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/, t) ||
                        ct(/^([a-z_A-Z0-9-]*Error)$/, t);
                      (i = (e && e[1]) || ""),
                        (o = i.length),
                        (i = i || "Error");
                    }
                    const l = It(getPrefix(e, r, i), 0, -1);
                    n !== l &&
                      (t = St(l, n)
                        ? 0 === o
                          ? `${l}: ${t}`
                          : `${l}${It(t, o)}`
                        : `${l} [${n}]${It(t, o)}`);
                  }
                  return t;
                })(s, e, l, n);
                let c = (t.message && Pt(s, t.message)) || -1;
                -1 !== c && (c += t.message.length);
                const d = Pt(s, "\n    at", c);
                if (-1 === d) s = `[${s}]`;
                else {
                  let e = It(s, 0, d);
                  const n = (function getStackFrames(t, e, n) {
                    const r = Bt(n, "\n");
                    let o;
                    try {
                      ({ cause: o } = e);
                    } catch {}
                    if (null != o && ne(o)) {
                      const e = getStackString(o),
                        n = Pt(e, "\n    at");
                      if (-1 !== n) {
                        const o = Bt(It(e, n + 1), "\n"),
                          { len: i, offset: l } = identicalSequenceRange(r, o);
                        if (i > 0) {
                          const e = i - 2,
                            n = `    ... ${e} lines matching cause stack trace ...`;
                          r.splice(l + 1, e, t.stylize(n, "undefined"));
                        }
                      }
                    }
                    return r;
                  })(o, t, It(s, d + 1));
                  if (o.colors) {
                    const t = (function safeGetCWD() {
                      let t;
                      try {
                        t = r.cwd();
                      } catch {
                        return;
                      }
                      return t;
                    })();
                    let i;
                    for (let r of n) {
                      const n = ct(Ke, r);
                      if (null !== n && Ne.exists(n[1]))
                        e += `\n${o.stylize(r, "undefined")}`;
                      else {
                        if (
                          ((e += "\n"),
                          (r = markNodeModules(o, r)),
                          void 0 !== t)
                        ) {
                          let e = markCwd(o, r, t);
                          e === r &&
                            ((i ??= pathToFileUrlHref(t)),
                            (e = markCwd(o, r, i))),
                            (r = e);
                        }
                        e += r;
                      }
                    }
                  } else e += `\n${g(n, "\n")}`;
                  s = e;
                }
                if (0 !== o.indentationLvl) {
                  const t = wt(" ", o.indentationLvl);
                  s = kt(s, "\n", `\n${t}`);
                }
                return s;
              })(e, c, d, t, l)),
              0 === l.length && void 0 === s)
            )
              return k;
          } else if (se(e)) {
            const n = getPrefix(
              c,
              d,
              ce(e) ? "ArrayBuffer" : "SharedArrayBuffer"
            );
            if (void 0 === o) B = formatArrayBuffer;
            else if (0 === l.length && void 0 === s)
              return (
                n +
                `{ byteLength: ${formatNumber(t.stylize, e.byteLength, !1)} }`
              );
            (C[0] = `${n}{`), b(l, "byteLength");
          } else if (ge(e))
            (C[0] = `${getPrefix(c, d, "DataView")}{`),
              b(l, "byteLength", "byteOffset", "buffer");
          else if ($e(e))
            (C[0] = `${getPrefix(c, d, "Promise")}{`), (B = formatPromise);
          else if (Pe(e))
            (C[0] = `${getPrefix(c, d, "WeakSet")}{`),
              (B = t.showHidden ? formatWeakSet : formatWeakCollection);
          else if (Se(e))
            (C[0] = `${getPrefix(c, d, "WeakMap")}{`),
              (B = t.showHidden ? formatWeakMap : formatWeakCollection);
          else if (me(e))
            (C[0] = `${getPrefix(c, d, "Module")}{`),
              (B = w(formatNamespaceObject, null, l));
          else if (ue(e)) {
            if (
              ((k = (function getBoxedBase(t, e, n, r, o) {
                let i, l;
                we(t)
                  ? ((i = G), (l = "Number"))
                  : Ce(t)
                  ? ((i = Tt), (l = "String"), n.splice(0, t.length))
                  : ke(t)
                  ? ((i = P), (l = "Boolean"))
                  : Ie(t)
                  ? ((i = S), (l = "BigInt"))
                  : ((i = _t), (l = "Symbol"));
                let a = `[${l}`;
                l !== r && (a += null === r ? " (null prototype)" : ` (${r})`);
                (a += `: ${formatPrimitive(stylizeNoColor, i(t), e)}]`),
                  "" !== o && o !== r && (a += ` [${o}]`);
                return 0 !== n.length || e.stylize === stylizeNoColor
                  ? a
                  : e.stylize(a, Ot(l));
              })(e, t, l, c, d)),
              0 === l.length && void 0 === s)
            )
              return k;
          } else {
            if (0 === l.length && void 0 === s) {
              if (de(e)) {
                const n = te(e).toString(16);
                return t.stylize(`[External: ${n}]`, "special");
              }
              return `${getCtxStyle(e, c, d)}{}`;
            }
            C[0] = `${getCtxStyle(e, c, d)}{`;
          }
        if (n > t.depth && null !== t.depth) {
          let n = It(getCtxStyle(e, c, d), 0, -1);
          return null !== c && (n = `[${n}]`), t.stylize(n, "special");
        }
        (n += 1), y(t.seen, e), (t.currentDepth = n);
        const j = t.indentationLvl;
        try {
          for (M = B(t, e, n), E = 0; E < l.length; E++)
            y(M, formatProperty(t, e, n, l[E], _));
          void 0 !== s && m(M, s);
        } catch (n) {
          return (function handleMaxCallStackSize(t, e, n, r) {
            if (ie(e))
              return (
                p(t.seen),
                (t.indentationLvl = r),
                t.stylize(
                  `[${n}: Inspection interrupted prematurely. Maximum call stack size exceeded.]`,
                  "special"
                )
              );
            Be.fail(e.stack);
          })(t, n, It(getCtxStyle(e, c, d), 0, -1), j);
        }
        if (void 0 !== t.circular) {
          const n = t.circular.get(e);
          if (void 0 !== n) {
            const e = t.stylize(`<ref *${n}>`, "special");
            !0 !== t.compact
              ? (k = "" === k ? e : `${e} ${k}`)
              : (C[0] = `${e} ${C[0]}`);
          }
        }
        if ((p(t.seen), t.sorted)) {
          const e = !0 === t.sorted ? void 0 : t.sorted;
          if (_ === je) x(M, e);
          else if (l.length > 1) {
            const t = x(h(M, M.length - l.length), e);
            b(t, M, M.length - l.length, l.length), lt($, null, t);
          }
        }
        const F = reduceToSingleString(t, M, k, C, _, n, e),
          R = t.budget[t.indentationLvl] || 0,
          W = R + F.length;
        (t.budget[t.indentationLvl] = W), W > 2 ** 27 && (t.depth = -1);
        return F;
      })(t, e, n, o);
    }
    function getIteratorBraces(t, e) {
      return (
        e !== `${t} Iterator` &&
          ("" !== e && (e += "] ["), (e += `${t} Iterator`)),
        [`[${e}] {`, "}"]
      );
    }
    function identicalSequenceRange(t, e) {
      for (let n = 0; n < t.length - 3; n++) {
        const r = u(e, t[n]);
        if (-1 !== r) {
          const o = e.length - r;
          if (o > 3) {
            let i = 1;
            const l = T(t.length - n, o);
            for (; l > i && t[n + i] === e[r + i]; ) i++;
            if (i > 3) return { len: i, offset: n };
          }
        }
      }
      return { len: 0, offset: 0 };
    }
    function getStackString(t) {
      return t.stack ? $t(t.stack) : C(t);
    }
    function markNodeModules(t, e) {
      let n,
        r = "",
        o = 0;
      for (; null !== (n = Ue.exec(e)); )
        (r += It(e, o, n.index + 14)),
          (r += t.stylize(n[1], "module")),
          (o = n.index + n[0].length);
      return 0 !== o && (e = r + It(e, o)), e;
    }
    function markCwd(t, e, n) {
      let r = Pt(e, n),
        o = "",
        i = n.length;
      if (-1 !== r) {
        "file://" === It(e, r - 7, r) && ((i += 7), (r -= 7));
        const n = "(" === e[r - 1] ? r - 1 : r,
          l = n !== r && Nt(e, ")") ? -1 : e.length,
          a = r + i + 1,
          s = It(e, n, a);
        (o += It(e, 0, n)),
          (o += t.stylize(s, "undefined")),
          (o += It(e, a, l)),
          -1 === l && (o += t.stylize(")", "undefined"));
      } else o += e;
      return o;
    }
    function addNumericSeparator(t) {
      let e = "",
        n = t.length;
      const r = zt(t, "-") ? 1 : 0;
      for (; n >= r + 4; n -= 3) e = `_${It(t, n - 3, n)}${e}`;
      return n === t.length ? t : `${It(t, 0, n)}${e}`;
    }
    function formatNumber(t, e, n) {
      if (!n) return tt(e, -0) ? t("-0", "number") : t(`${e}`, "number");
      const r = j(e),
        o = $t(r);
      return r === e
        ? !R(e) || St(o, "e")
          ? t(o, "number")
          : t(`${addNumericSeparator(o)}`, "number")
        : V(e)
        ? t(o, "number")
        : t(
            `${addNumericSeparator(o)}.${(function addNumericSeparatorEnd(t) {
              let e = "",
                n = 0;
              for (; n < t.length - 3; n += 3) e += `${It(t, n, n + 3)}_`;
              return 0 === n ? t : `${e}${It(t, n)}`;
            })(It($t(e), o.length + 1))}`,
            "number"
          );
    }
    function formatBigInt(t, e, n) {
      const r = $t(e);
      return t(n ? `${addNumericSeparator(r)}n` : `${r}n`, "bigint");
    }
    function formatPrimitive(t, e, n) {
      if ("string" == typeof e) {
        let r = "";
        if (e.length > n.maxStringLength) {
          const t = e.length - n.maxStringLength;
          (e = It(e, 0, n.maxStringLength)),
            (r = `... ${t} more character${t > 1 ? "s" : ""}`);
        }
        return !0 !== n.compact &&
          e.length > Ye &&
          e.length > n.breakLength - n.indentationLvl - 4
          ? g(
              d(ut(/(?<=\n)/, e), (e) => t(strEscape(e), "string")),
              ` +\n${wt(" ", n.indentationLvl + 2)}`
            ) + r
          : t(strEscape(e), "string") + r;
      }
      return "number" == typeof e
        ? formatNumber(t, e, n.numericSeparator)
        : "bigint" == typeof e
        ? formatBigInt(t, e, n.numericSeparator)
        : "boolean" == typeof e
        ? t(`${e}`, "boolean")
        : void 0 === e
        ? t("undefined", "undefined")
        : t(Mt(e), "symbol");
    }
    function formatNamespaceObject(t, e, n, r) {
      const o = new l(t.length);
      for (let i = 0; i < t.length; i++)
        try {
          o[i] = formatProperty(e, n, r, t[i], je);
        } catch (n) {
          Be(he(n) && "ReferenceError" === n.name);
          const l = { [t[i]]: "" };
          o[i] = formatProperty(e, l, r, t[i], je);
          const a = vt(o[i], " ");
          o[i] = It(o[i], 0, a + 1) + e.stylize("<uninitialized>", "special");
        }
      return (t.length = 0), o;
    }
    function formatSpecialArray(t, e, n, r, o, i) {
      const l = et(e);
      let a = i;
      for (; i < l.length && o.length < r; i++) {
        const s = l[i],
          c = +s;
        if (c > 2 ** 32 - 2) break;
        if (`${a}` !== s) {
          if (null === ct(Ze, s)) break;
          const e = c - a,
            n = `<${e} empty item${e > 1 ? "s" : ""}>`;
          if ((y(o, t.stylize(n, "undefined")), (a = c), o.length === r)) break;
        }
        y(o, formatProperty(t, e, n, s, Fe)), a++;
      }
      const s = e.length - a;
      if (o.length !== r) {
        if (s > 0) {
          const e = `<${s} empty item${s > 1 ? "s" : ""}>`;
          y(o, t.stylize(e, "undefined"));
        }
      } else s > 0 && y(o, `... ${s} more item${s > 1 ? "s" : ""}`);
      return o;
    }
    function formatArrayBuffer(t, n) {
      let r;
      try {
        r = new Wt(n);
      } catch {
        return [t.stylize("(detached)", "special")];
      }
      void 0 === Ee && (Ee = Dt(e("buffer").Buffer.prototype.hexSlice));
      let o = Et(ft(/(.{2})/g, Ee(r, 0, T(t.maxArrayLength, r.length)), "$1 "));
      const i = r.length - t.maxArrayLength;
      return (
        i > 0 && (o += ` ... ${i} more byte${i > 1 ? "s" : ""}`),
        [`${t.stylize("[Uint8Contents]", "special")}: <${o}>`]
      );
    }
    function formatArray(t, e, n) {
      const r = e.length,
        o = T(E(0, t.maxArrayLength), r),
        i = r - o,
        l = [];
      for (let r = 0; r < o; r++) {
        if (!nt(e, r)) return formatSpecialArray(t, e, n, o, l, r);
        y(l, formatProperty(t, e, n, r, Fe));
      }
      return i > 0 && y(l, `... ${i} more item${i > 1 ? "s" : ""}`), l;
    }
    function formatTypedArray(t, e, n, r, o) {
      const i = T(E(0, n.maxArrayLength), e),
        a = t.length - i,
        s = new l(i),
        c =
          t.length > 0 && "number" == typeof t[0] ? formatNumber : formatBigInt;
      for (let e = 0; e < i; ++e) s[e] = c(n.stylize, t[e], n.numericSeparator);
      if (
        (a > 0 && (s[i] = `... ${a} more item${a > 1 ? "s" : ""}`),
        n.showHidden)
      ) {
        n.indentationLvl += 2;
        for (const e of [
          "BYTES_PER_ELEMENT",
          "length",
          "byteLength",
          "byteOffset",
          "buffer",
        ]) {
          const r = formatValue(n, t[e], o, !0);
          y(s, `[${e}]: ${r}`);
        }
        n.indentationLvl -= 2;
      }
      return s;
    }
    function formatSet(t, e, n, r) {
      const o = [];
      e.indentationLvl += 2;
      for (const n of t) y(o, formatValue(e, n, r));
      return (e.indentationLvl -= 2), o;
    }
    function formatMap(t, e, n, r) {
      const o = [];
      e.indentationLvl += 2;
      for (const { 0: n, 1: i } of t)
        y(o, `${formatValue(e, n, r)} => ${formatValue(e, i, r)}`);
      return (e.indentationLvl -= 2), o;
    }
    function formatSetIterInner(t, e, n, r) {
      const o = E(t.maxArrayLength, 0),
        i = T(o, n.length),
        a = new l(i);
      t.indentationLvl += 2;
      for (let r = 0; r < i; r++) a[r] = formatValue(t, n[r], e);
      (t.indentationLvl -= 2), r !== Je || t.sorted || x(a);
      const s = n.length - i;
      return s > 0 && y(a, `... ${s} more item${s > 1 ? "s" : ""}`), a;
    }
    function formatMapIterInner(t, e, n, r) {
      const o = E(t.maxArrayLength, 0),
        i = n.length / 2,
        a = i - o,
        s = T(o, i),
        c = new l(s);
      let f = 0;
      if (((t.indentationLvl += 2), r === Je)) {
        for (; f < s; f++) {
          const r = 2 * f;
          c[f] = `${formatValue(t, n[r], e)} => ${formatValue(t, n[r + 1], e)}`;
        }
        t.sorted || x(c);
      } else
        for (; f < s; f++) {
          const r = 2 * f,
            o = [formatValue(t, n[r], e), formatValue(t, n[r + 1], e)];
          c[f] = reduceToSingleString(t, o, "", ["[", "]"], Re, e);
        }
      return (
        (t.indentationLvl -= 2),
        a > 0 && y(c, `... ${a} more item${a > 1 ? "s" : ""}`),
        c
      );
    }
    function formatWeakCollection(t) {
      return [t.stylize("<items unknown>", "special")];
    }
    function formatWeakSet(t, e, n) {
      return formatSetIterInner(t, n, Jt(e), Je);
    }
    function formatWeakMap(t, e, n) {
      return formatMapIterInner(t, n, Jt(e), Je);
    }
    function formatIterator(t, e, n, r) {
      const { 0: o, 1: i } = Jt(n, !0);
      return i
        ? ((t[0] = ft(/ Iterator] {$/, t[0], " Entries] {")),
          formatMapIterInner(e, r, o, tn))
        : formatSetIterInner(e, r, o, Xe);
    }
    function formatPromise(t, e, n) {
      let r;
      const { 0: o, 1: i } = Qt(e);
      if (o === Kt) r = [t.stylize("<pending>", "special")];
      else {
        t.indentationLvl += 2;
        const e = formatValue(t, i, n);
        (t.indentationLvl -= 2),
          (r = [o === Ut ? `${t.stylize("<rejected>", "special")} ${e}` : e]);
      }
      return r;
    }
    function formatProperty(t, e, n, r, o, i, l = e) {
      let a,
        s,
        c = " ";
      if (
        void 0 !== (i = i || Q(e, r) || { value: e[r], enumerable: !0 }).value
      ) {
        const e = !0 !== t.compact || o !== je ? 2 : 3;
        (t.indentationLvl += e),
          (s = formatValue(t, i.value, n)),
          3 === e &&
            t.breakLength < rn(s, t.colors) &&
            (c = `\n${wt(" ", t.indentationLvl)}`),
          (t.indentationLvl -= e);
      } else if (void 0 !== i.get) {
        const e = void 0 !== i.set ? "Getter/Setter" : "Getter",
          r = t.stylize,
          o = "special";
        if (
          t.getters &&
          (!0 === t.getters ||
            ("get" === t.getters && void 0 === i.set) ||
            ("set" === t.getters && void 0 !== i.set))
        )
          try {
            const a = k(i.get, l);
            if (((t.indentationLvl += 2), null === a))
              s = `${r(`[${e}:`, o)} ${r("null", "null")}${r("]", o)}`;
            else if ("object" == typeof a)
              s = `${r(`[${e}]`, o)} ${formatValue(t, a, n)}`;
            else {
              const n = formatPrimitive(r, a, t);
              s = `${r(`[${e}:`, o)} ${n}${r("]", o)}`;
            }
            t.indentationLvl -= 2;
          } catch (t) {
            const n = `<Inspection threw (${t.message})>`;
            s = `${r(`[${e}:`, o)} ${n}${r("]", o)}`;
          }
        else s = t.stylize(`[${e}]`, o);
      } else
        s =
          void 0 !== i.set
            ? t.stylize("[Setter]", "special")
            : t.stylize("undefined", "undefined");
      if (o === Fe) return s;
      if ("symbol" == typeof r) {
        const e = ft(We, Mt(r), escapeFn);
        a = `[${t.stylize(e, "symbol")}]`;
      } else if ("__proto__" === r) a = "['__proto__']";
      else if (!1 === i.enumerable) {
        a = `[${ft(We, r, escapeFn)}]`;
      } else
        a =
          null !== ct(Ge, r)
            ? t.stylize(r, "name")
            : t.stylize(strEscape(r), "string");
      return `${a}:${c}${s}`;
    }
    function isBelowBreakLength(t, e, n, r) {
      let o = e.length + n;
      if (o + e.length > t.breakLength) return !1;
      for (let n = 0; n < e.length; n++)
        if (
          (t.colors ? (o += oe(e[n]).length) : (o += e[n].length),
          o > t.breakLength)
        )
          return !1;
      return "" === r || !St(r, "\n");
    }
    function reduceToSingleString(t, e, n, r, o, i, a) {
      if (!0 !== t.compact) {
        if ("number" == typeof t.compact && t.compact >= 1) {
          const s = e.length;
          if (
            (o === Re &&
              s > 6 &&
              (e = (function groupArrayElements(t, e, n) {
                let r = 0,
                  o = 0,
                  i = 0,
                  a = e.length;
                t.maxArrayLength < e.length && a--;
                const s = new l(a);
                for (; i < a; i++) {
                  const n = rn(e[i], t.colors);
                  (s[i] = n), (r += n + 2), o < n && (o = n);
                }
                const c = o + 2;
                if (
                  3 * c + t.indentationLvl < t.breakLength &&
                  (r / c > 5 || o <= 6)
                ) {
                  const o = 2.5,
                    i = _(c - r / e.length),
                    l = E(c - 3 - i, 1),
                    f = T(
                      M(_(o * l * a) / l),
                      O((t.breakLength - t.indentationLvl) / c),
                      4 * t.compact,
                      15
                    );
                  if (f <= 1) return e;
                  const u = [],
                    g = [];
                  for (let t = 0; t < f; t++) {
                    let n = 0;
                    for (let r = t; r < e.length; r += f)
                      s[r] > n && (n = s[r]);
                    (n += 2), (g[t] = n);
                  }
                  let d = Ct;
                  if (void 0 !== n)
                    for (let t = 0; t < e.length; t++)
                      if ("number" != typeof n[t] && "bigint" != typeof n[t]) {
                        d = Lt;
                        break;
                      }
                  for (let t = 0; t < a; t += f) {
                    const n = T(t + f, a);
                    let r = "",
                      o = t;
                    for (; o < n - 1; o++) {
                      const n = g[o - t] + e[o].length - s[o];
                      r += d(`${e[o]}, `, n, " ");
                    }
                    if (d === Ct) {
                      const n = g[o - t] + e[o].length - s[o] - 2;
                      r += Ct(e[o], n, " ");
                    } else r += e[o];
                    y(u, r);
                  }
                  t.maxArrayLength < e.length && y(u, e[a]), (e = u);
                }
                return e;
              })(t, e, a)),
            t.currentDepth - i < t.compact && s === e.length)
          ) {
            if (
              isBelowBreakLength(
                t,
                e,
                e.length + t.indentationLvl + r[0].length + n.length + 10,
                n
              )
            ) {
              const t = re(e, ", ");
              if (!St(t, "\n"))
                return `${n ? `${n} ` : ""}${r[0]} ${t} ${r[1]}`;
            }
          }
        }
        const s = `\n${wt(" ", t.indentationLvl)}`;
        return `${n ? `${n} ` : ""}${r[0]}${s}  ${re(e, `,${s}  `)}${s}${r[1]}`;
      }
      if (isBelowBreakLength(t, e, 0, n))
        return `${r[0]}${n ? ` ${n}` : ""} ${re(e, ", ")} ` + r[1];
      const s = wt(" ", t.indentationLvl),
        c = "" === n && 1 === r[0].length ? " " : `${n ? ` ${n}` : ""}\n${s}  `;
      return `${r[0]}${c}${re(e, `,\n${s}  `)} ${r[1]}`;
    }
    function hasBuiltInToString(t) {
      const e = Yt(t, !1);
      if (void 0 !== e) {
        if (null === e) return !0;
        t = e;
      }
      if ("function" != typeof t.toString) return !0;
      if (nt(t, "toString")) return !1;
      let n = t;
      do {
        n = X(n);
      } while (!nt(n, "toString"));
      const r = Q(n, "constructor");
      return (
        void 0 !== r && "function" == typeof r.value && Me.has(r.value.name)
      );
    }
    (inspect.colors = {
      __proto__: null,
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      blink: [5, 25],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      doubleunderline: [21, 24],
      black: [30, on],
      red: [31, on],
      green: [32, on],
      yellow: [33, on],
      blue: [34, on],
      magenta: [35, on],
      cyan: [36, on],
      white: [37, on],
      bgBlack: [40, ln],
      bgRed: [41, ln],
      bgGreen: [42, ln],
      bgYellow: [43, ln],
      bgBlue: [44, ln],
      bgMagenta: [45, ln],
      bgCyan: [46, ln],
      bgWhite: [47, ln],
      framed: [51, 54],
      overlined: [53, 55],
      gray: [90, on],
      redBright: [91, on],
      greenBright: [92, on],
      yellowBright: [93, on],
      blueBright: [94, on],
      magentaBright: [95, on],
      cyanBright: [96, on],
      whiteBright: [97, on],
      bgGray: [100, ln],
      bgRedBright: [101, ln],
      bgGreenBright: [102, ln],
      bgYellowBright: [103, ln],
      bgBlueBright: [104, ln],
      bgMagentaBright: [105, ln],
      bgCyanBright: [106, ln],
      bgWhiteBright: [107, ln],
    }),
      defineColorAlias("gray", "grey"),
      defineColorAlias("gray", "blackBright"),
      defineColorAlias("bgGray", "bgGrey"),
      defineColorAlias("bgGray", "bgBlackBright"),
      defineColorAlias("dim", "faint"),
      defineColorAlias("strikethrough", "crossedout"),
      defineColorAlias("strikethrough", "strikeThrough"),
      defineColorAlias("strikethrough", "crossedOut"),
      defineColorAlias("hidden", "conceal"),
      defineColorAlias("inverse", "swapColors"),
      defineColorAlias("inverse", "swapcolors"),
      defineColorAlias("doubleunderline", "doubleUnderline"),
      (inspect.styles = K(U(null), {
        special: "cyan",
        number: "yellow",
        bigint: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        symbol: "green",
        date: "magenta",
        regexp: "red",
        module: "underline",
      }));
    const firstErrorLine = (t) => Bt(t.message, "\n", 1)[0];
    let an;
    function tryStringify(t) {
      try {
        return B(t);
      } catch (t) {
        if (!an)
          try {
            const t = {};
            (t.a = t), B(t);
          } catch (t) {
            an = firstErrorLine(t);
          }
        if ("TypeError" === t.name && firstErrorLine(t) === an)
          return "[Circular]";
        throw t;
      }
    }
    function formatNumberNoColor(t, e) {
      return formatNumber(
        stylizeNoColor,
        t,
        e?.numericSeparator ?? _e.numericSeparator
      );
    }
    function formatBigIntNoColor(t, e) {
      return formatBigInt(
        stylizeNoColor,
        t,
        e?.numericSeparator ?? _e.numericSeparator
      );
    }
    function formatWithOptionsInternal(t, e) {
      const n = e[0];
      let r = 0,
        o = "",
        i = "";
      if ("string" == typeof n) {
        if (1 === e.length) return n;
        let l,
          a = 0;
        for (let i = 0; i < n.length - 1; i++)
          if (37 === xt(n, i)) {
            const s = xt(n, ++i);
            if (r + 1 !== e.length) {
              switch (s) {
                case 115: {
                  const n = e[++r];
                  l =
                    "number" == typeof n
                      ? formatNumberNoColor(n, t)
                      : "bigint" == typeof n
                      ? formatBigIntNoColor(n, t)
                      : "object" == typeof n &&
                        null !== n &&
                        hasBuiltInToString(n)
                      ? inspect(n, { ...t, compact: 3, colors: !1, depth: 0 })
                      : $t(n);
                  break;
                }
                case 106:
                  l = tryStringify(e[++r]);
                  break;
                case 100: {
                  const n = e[++r];
                  l =
                    "bigint" == typeof n
                      ? formatBigIntNoColor(n, t)
                      : "symbol" == typeof n
                      ? "NaN"
                      : formatNumberNoColor(F(n), t);
                  break;
                }
                case 79:
                  l = inspect(e[++r], t);
                  break;
                case 111:
                  l = inspect(e[++r], {
                    ...t,
                    showHidden: !0,
                    showProxy: !0,
                    depth: 4,
                  });
                  break;
                case 105: {
                  const n = e[++r];
                  l =
                    "bigint" == typeof n
                      ? formatBigIntNoColor(n, t)
                      : "symbol" == typeof n
                      ? "NaN"
                      : formatNumberNoColor(H(n), t);
                  break;
                }
                case 102: {
                  const n = e[++r];
                  l =
                    "symbol" == typeof n ? "NaN" : formatNumberNoColor(W(n), t);
                  break;
                }
                case 99:
                  (r += 1), (l = "");
                  break;
                case 37:
                  (o += It(n, a, i)), (a = i + 1);
                  continue;
                default:
                  continue;
              }
              a !== i - 1 && (o += It(n, a, i - 1)), (o += l), (a = i + 1);
            } else 37 === s && ((o += It(n, a, i)), (a = i + 1));
          }
        0 !== a && (r++, (i = " "), a < n.length && (o += It(n, a)));
      }
      for (; r < e.length; ) {
        const n = e[r];
        (o += i),
          (o += "string" != typeof n ? inspect(n, t) : n),
          (i = " "),
          r++;
      }
      return o;
    }
    function isZeroWidthCodePoint(t) {
      return (
        t <= 31 ||
        (t >= 127 && t <= 159) ||
        (t >= 768 && t <= 879) ||
        (t >= 8203 && t <= 8207) ||
        (t >= 8400 && t <= 8447) ||
        (t >= 65024 && t <= 65039) ||
        (t >= 65056 && t <= 65071) ||
        (t >= 917760 && t <= 917999)
      );
    }
    if (o("config").hasIntl) {
      const t = o("icu");
      rn = function getStringWidth2(e, n = !0) {
        let r = 0;
        n && (e = stripVTControlCharacters(e));
        for (let n = 0; n < e.length; n++) {
          const o = xt(e, n);
          if (o >= 127) {
            r += t.getStringWidth(At(It(e, n), "NFC"));
            break;
          }
          r += o >= 32 ? 1 : 0;
        }
        return r;
      };
    } else {
      rn = function getStringWidth2(t, e = !0) {
        let n = 0;
        e && (t = stripVTControlCharacters(t)), (t = At(t, "NFC"));
        for (const e of new dt(t)) {
          const t = bt(e, 0);
          isFullWidthCodePoint(t) ? (n += 2) : isZeroWidthCodePoint(t) || n++;
        }
        return n;
      };
      const isFullWidthCodePoint = (t) =>
        t >= 4352 &&
        (t <= 4447 ||
          9001 === t ||
          9002 === t ||
          (t >= 11904 && t <= 12871 && 12351 !== t) ||
          (t >= 12880 && t <= 19903) ||
          (t >= 19968 && t <= 42182) ||
          (t >= 43360 && t <= 43388) ||
          (t >= 44032 && t <= 55203) ||
          (t >= 63744 && t <= 64255) ||
          (t >= 65040 && t <= 65049) ||
          (t >= 65072 && t <= 65131) ||
          (t >= 65281 && t <= 65376) ||
          (t >= 65504 && t <= 65510) ||
          (t >= 110592 && t <= 110593) ||
          (t >= 127488 && t <= 127569) ||
          (t >= 127744 && t <= 128591) ||
          (t >= 131072 && t <= 262141));
    }
    function stripVTControlCharacters(t) {
      return Oe(t, "str"), ft(nn, t, "");
    }
    n.exports = {
      identicalSequenceRange: identicalSequenceRange,
      inspect: inspect,
      inspectDefaultOptions: _e,
      format: function format(...t) {
        return formatWithOptionsInternal(void 0, t);
      },
      formatWithOptions: function formatWithOptions(t, ...e) {
        return (
          ze(t, "inspectOptions", { allowArray: !0 }),
          formatWithOptionsInternal(t, e)
        );
      },
      getStringWidth: rn,
      stripVTControlCharacters: stripVTControlCharacters,
      isZeroWidthCodePoint: isZeroWidthCodePoint,
    };
  },
  "internal/util/inspector": function (e, n, t, o, s, r) {
    "use strict";
    const {
        ArrayPrototypeSome: i,
        ArrayPrototypePushApply: c,
        FunctionPrototypeBind: l,
        ObjectDefineProperty: p,
        ObjectKeys: a,
        ObjectPrototypeHasOwnProperty: u,
        RegExpPrototypeExec: d,
        SafeWeakMap: g,
      } = r,
      { validatePort: f } = n("internal/validators"),
      y = /--inspect(?:-brk|-port)?|--debug-port/,
      P =
        /Debugger listening on ws:\/\/\[?(.+?)\]?:(\d+)\/|For help, see: https:\/\/nodejs\.org\/en\/docs\/inspector|Debugger attached|Waiting for the debugger to disconnect\.\.\./,
      h = new g();
    function isUsingInspector(e = o.execArgv) {
      return (
        h.has(e) ||
          h.set(
            e,
            i(e, (e) => null !== d(y, e)) || null !== d(y, o.env.NODE_OPTIONS)
          ),
        h.get(e)
      );
    }
    let I,
      b = 1;
    t.exports = {
      getInspectPort: function getInspectPort(e) {
        return (
          "function" == typeof e
            ? (e = e())
            : null == e &&
              ((e = o.debugPort + b) > 65535 && (e = e - 65535 + 1024 - 1),
              b++),
          f(e),
          e
        );
      },
      installConsoleExtensions: function installConsoleExtensions(e) {
        if (e.require) return;
        const { tryGetCwd: t } = n("internal/process/execution"),
          o = n("internal/modules/cjs/loader").Module,
          { makeRequireFunction: s } = n("internal/modules/helpers"),
          r = new o("<inspector console>"),
          i = t();
        (r.paths = []),
          c(r.paths, o._nodeModulePaths(i)),
          c(r.paths, o.globalPaths),
          (e.require = s(r));
      },
      isInspectorMessage: function isInspectorMessage(e) {
        return isUsingInspector() && null !== d(P, e);
      },
      isUsingInspector: isUsingInspector,
      sendInspectorCommand: function sendInspectorCommand(e, t) {
        const { hasInspector: o } = s("config");
        if (!o) return t();
        const r = n("inspector");
        void 0 === I && (I = new r.Session()), I.connect();
        try {
          return e(I);
        } finally {
          I.disconnect();
        }
      },
      wrapConsole: function wrapConsole(e) {
        const { consoleCall: n, console: t } = s("inspector");
        for (const o of a(t))
          u(e, o)
            ? ((e[o] = l(n, e, t[o], e[o])),
              p(e[o], "name", { __proto__: null, value: o }))
            : (e[o] = t[o]);
      },
    };
  },
  "internal/util/iterable_weak_map": function (e, t, a, r, n, s) {
    "use strict";
    const {
      ObjectFreeze: i,
      SafeFinalizationRegistry: f,
      SafeSet: l,
      SafeWeakMap: o,
      SafeWeakRef: u,
      SymbolIterator: p,
    } = s;
    class IterableWeakMap {
      #e = new o();
      #t = new l();
      #a = new f(cleanup);
      set(e, t) {
        const a = this.#e.get(e);
        if (a) this.#e.set(e, { value: t, ref: a.ref });
        else {
          const a = new u(e);
          this.#e.set(e, { value: t, ref: a }),
            this.#t.add(a),
            this.#a.register(e, { set: this.#t, ref: a }, a);
        }
      }
      get(e) {
        return this.#e.get(e)?.value;
      }
      has(e) {
        return this.#e.has(e);
      }
      delete(e) {
        const t = this.#e.get(e);
        return (
          !!t &&
          (this.#e.delete(e),
          this.#t.delete(t.ref),
          this.#a.unregister(t.ref),
          !0)
        );
      }
      [p]() {
        const e = this.#t[p](),
          next = () => {
            const t = e.next();
            if (t.done) return t;
            const a = t.value.deref();
            if (null == a) return next();
            const { value: r } = this.#e.get(a);
            return { done: !1, value: r };
          };
        return {
          [p]() {
            return this;
          },
          next: next,
        };
      }
    }
    function cleanup({ set: e, ref: t }) {
      e.delete(t);
    }
    i(IterableWeakMap.prototype),
      (a.exports = { IterableWeakMap: IterableWeakMap });
  },
  "internal/util/parse_args/parse_args": function (t, o, n, e, i, a) {
    "use strict";
    const {
        ArrayPrototypeForEach: r,
        ArrayPrototypeIncludes: s,
        ArrayPrototypeMap: l,
        ArrayPrototypePush: p,
        ArrayPrototypePushApply: u,
        ArrayPrototypeShift: c,
        ArrayPrototypeSlice: g,
        ArrayPrototypeUnshiftApply: f,
        ObjectEntries: y,
        ObjectPrototypeHasOwnProperty: d,
        StringPrototypeCharAt: _,
        StringPrototypeIndexOf: h,
        StringPrototypeSlice: m,
        StringPrototypeStartsWith: w,
      } = a,
      {
        validateArray: A,
        validateBoolean: O,
        validateBooleanArray: v,
        validateObject: P,
        validateString: k,
        validateStringArray: S,
        validateUnion: $,
      } = o("internal/validators"),
      {
        findLongOptionForShort: N,
        isLoneLongOption: E,
        isLoneShortOption: R,
        isLongOptionAndValue: V,
        isOptionValue: b,
        isOptionLikeValue: L,
        isShortOptionAndValue: I,
        isShortOptionGroup: x,
        useDefaultValueOption: D,
        objectGetOwn: G,
        optionsGetOwn: T,
      } = o("internal/util/parse_args/utils"),
      {
        codes: {
          ERR_INVALID_ARG_VALUE: U,
          ERR_PARSE_ARGS_INVALID_OPTION_VALUE: j,
          ERR_PARSE_ARGS_UNKNOWN_OPTION: X,
          ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL: F,
        },
      } = o("internal/errors"),
      { kEmptyObject: Y } = o("internal/util");
    n.exports = {
      parseArgs: (t = Y) => {
        const o =
            G(t, "args") ??
            (function getMainArgs() {
              const t = e.execArgv;
              return s(t, "-e") ||
                s(t, "--eval") ||
                s(t, "-p") ||
                s(t, "--print")
                ? g(e.argv, 1)
                : g(e.argv, 2);
            })(),
          n = G(t, "strict") ?? !0,
          i = G(t, "allowPositionals") ?? !n,
          a = G(t, "tokens") ?? !1,
          Z = G(t, "options") ?? { __proto__: null },
          B = { args: o, strict: n, options: Z, allowPositionals: i };
        A(o, "args"),
          O(n, "strict"),
          O(i, "allowPositionals"),
          O(a, "tokens"),
          P(Z, "options"),
          r(y(Z), ({ 0: t, 1: o }) => {
            P(o, `options.${t}`);
            const n = G(o, "type");
            if (
              ($(n, `options.${t}.type`, ["string", "boolean"]), d(o, "short"))
            ) {
              const n = o.short;
              if ((k(n, `options.${t}.short`), 1 !== n.length))
                throw new U(
                  `options.${t}.short`,
                  n,
                  "must be a single character"
                );
            }
            const e = G(o, "multiple");
            d(o, "multiple") && O(e, `options.${t}.multiple`);
            const i = G(o, "default");
            if (void 0 !== i) {
              let o;
              switch (n) {
                case "string":
                  o = e ? S : k;
                  break;
                case "boolean":
                  o = e ? v : O;
              }
              o(i, `options.${t}.default`);
            }
          });
        const C = (function argsToTokens(t, o) {
            const n = [];
            let e = -1,
              i = 0;
            const a = g(t);
            for (; a.length > 0; ) {
              const t = c(a),
                r = a[0];
              if ((i > 0 ? i-- : e++, "--" === t)) {
                p(n, { kind: "option-terminator", index: e }),
                  u(
                    n,
                    l(a, (t) => ({ kind: "positional", index: ++e, value: t }))
                  );
                break;
              }
              if (R(t)) {
                const i = _(t, 1),
                  s = N(i, o);
                let l, u;
                "string" === T(o, s, "type") && b(r) && ((l = c(a)), (u = !1)),
                  p(n, {
                    kind: "option",
                    name: s,
                    rawName: t,
                    index: e,
                    value: l,
                    inlineValue: u,
                  }),
                  null != l && ++e;
              } else if (x(t, o)) {
                const n = [];
                for (let e = 1; e < t.length; e++) {
                  const i = _(t, e),
                    a = N(i, o);
                  if ("string" === T(o, a, "type") && e !== t.length - 1) {
                    p(n, `-${m(t, e)}`);
                    break;
                  }
                  p(n, `-${i}`);
                }
                f(a, n), (i = n.length);
              } else if (I(t, o)) {
                const i = _(t, 1),
                  a = N(i, o),
                  r = m(t, 2);
                p(n, {
                  kind: "option",
                  name: a,
                  rawName: `-${i}`,
                  index: e,
                  value: r,
                  inlineValue: !0,
                });
              } else if (E(t)) {
                const i = m(t, 2);
                let s, l;
                "string" === T(o, i, "type") && b(r) && ((s = c(a)), (l = !1)),
                  p(n, {
                    kind: "option",
                    name: i,
                    rawName: t,
                    index: e,
                    value: s,
                    inlineValue: l,
                  }),
                  null != s && ++e;
              } else if (V(t)) {
                const o = h(t, "="),
                  i = m(t, 2, o),
                  a = m(t, o + 1);
                p(n, {
                  kind: "option",
                  name: i,
                  rawName: `--${i}`,
                  index: e,
                  value: a,
                  inlineValue: !0,
                });
              } else p(n, { kind: "positional", index: e, value: t });
            }
            return n;
          })(o, Z),
          M = { values: { __proto__: null }, positionals: [] };
        return (
          a && (M.tokens = C),
          r(C, (t) => {
            if ("option" === t.kind)
              n &&
                (!(function checkOptionUsage(t, o) {
                  if (!d(t.options, o.name))
                    throw new X(o.rawName, t.allowPositionals);
                  const n = T(t.options, o.name, "short"),
                    e = `${n ? `-${n}, ` : ""}--${o.name}`,
                    i = T(t.options, o.name, "type");
                  if ("string" === i && "string" != typeof o.value)
                    throw new j(`Option '${e} <value>' argument missing`);
                  if ("boolean" === i && null != o.value)
                    throw new j(`Option '${e}' does not take an argument`);
                })(B, t),
                (function checkOptionLikeValue(t) {
                  if (!t.inlineValue && L(t.value)) {
                    const o = w(t.rawName, "--")
                        ? `'${t.rawName}=-XYZ'`
                        : `'--${t.name}=-XYZ' or '${t.rawName}-XYZ'`,
                      n = `Option '${t.rawName}' argument is ambiguous.\nDid you forget to specify the option argument for '${t.rawName}'?\nTo specify an option argument starting with a dash use ${o}.`;
                    throw new j(n);
                  }
                })(t)),
                (function storeOption(t, o, n, e) {
                  if ("__proto__" === t) return;
                  const i = o ?? !0;
                  T(n, t, "multiple")
                    ? e[t]
                      ? p(e[t], i)
                      : (e[t] = [i])
                    : (e[t] = i);
                })(t.name, t.value, Z, M.values);
            else if ("positional" === t.kind) {
              if (!i) throw new F(t.value);
              p(M.positionals, t.value);
            }
          }),
          r(y(Z), ({ 0: t, 1: o }) => {
            D(t, o, M.values) &&
              (function storeDefaultOption(t, o, n) {
                "__proto__" !== t && (n[t] = o);
              })(t, G(o, "default"), M.values);
          }),
          M
        );
      },
    };
  },
  "internal/util/parse_args/utils": function (t, n, o, i, e, r) {
    "use strict";
    const {
        ArrayPrototypeFind: u,
        ObjectEntries: p,
        ObjectPrototypeHasOwnProperty: s,
        StringPrototypeCharAt: O,
        StringPrototypeIncludes: l,
        StringPrototypeStartsWith: c,
      } = r,
      { validateObject: a } = n("internal/validators");
    function objectGetOwn(t, n) {
      if (s(t, n)) return t[n];
    }
    function optionsGetOwn(t, n, o) {
      if (s(t, n)) return objectGetOwn(t[n], o);
    }
    function findLongOptionForShort(t, n) {
      a(n, "options");
      const o = u(p(n), ({ 1: n }) => objectGetOwn(n, "short") === t);
      return o?.[0] ?? t;
    }
    o.exports = {
      findLongOptionForShort: findLongOptionForShort,
      isLoneLongOption: function isLoneLongOption(t) {
        return t.length > 2 && c(t, "--") && !l(t, "=", 3);
      },
      isLoneShortOption: function isLoneShortOption(t) {
        return 2 === t.length && "-" === O(t, 0) && "-" !== O(t, 1);
      },
      isLongOptionAndValue: function isLongOptionAndValue(t) {
        return t.length > 2 && c(t, "--") && l(t, "=", 3);
      },
      isOptionValue: function isOptionValue(t) {
        return null != t;
      },
      isOptionLikeValue: function isOptionLikeValue(t) {
        return null != t && t.length > 1 && "-" === O(t, 0);
      },
      isShortOptionAndValue: function isShortOptionAndValue(t, n) {
        return (
          a(n, "options"),
          !(t.length <= 2) &&
            "-" === O(t, 0) &&
            "-" !== O(t, 1) &&
            "string" ===
              optionsGetOwn(n, findLongOptionForShort(O(t, 1), n), "type")
        );
      },
      isShortOptionGroup: function isShortOptionGroup(t, n) {
        return (
          !(t.length <= 2) &&
          "-" === O(t, 0) &&
          "-" !== O(t, 1) &&
          "string" !==
            optionsGetOwn(n, findLongOptionForShort(O(t, 1), n), "type")
        );
      },
      useDefaultValueOption: function useDefaultValueOption(t, n, o) {
        return void 0 !== objectGetOwn(n, "default") && void 0 === o[t];
      },
      objectGetOwn: objectGetOwn,
      optionsGetOwn: optionsGetOwn,
    };
  },
  "internal/util/types": function (r, n, t, i, e, a) {
    "use strict";
    const {
      ArrayBufferIsView: y,
      ObjectDefineProperties: s,
      TypedArrayPrototypeGetSymbolToStringTag: o,
    } = a;
    let A, u;
    (t.exports = {
      ...e("types"),
      isArrayBufferView: y,
      isTypedArray: function isTypedArray(r) {
        return void 0 !== o(r);
      },
      isUint8Array: function isUint8Array(r) {
        return "Uint8Array" === o(r);
      },
      isUint8ClampedArray: function isUint8ClampedArray(r) {
        return "Uint8ClampedArray" === o(r);
      },
      isUint16Array: function isUint16Array(r) {
        return "Uint16Array" === o(r);
      },
      isUint32Array: function isUint32Array(r) {
        return "Uint32Array" === o(r);
      },
      isInt8Array: function isInt8Array(r) {
        return "Int8Array" === o(r);
      },
      isInt16Array: function isInt16Array(r) {
        return "Int16Array" === o(r);
      },
      isInt32Array: function isInt32Array(r) {
        return "Int32Array" === o(r);
      },
      isFloat32Array: function isFloat32Array(r) {
        return "Float32Array" === o(r);
      },
      isFloat64Array: function isFloat64Array(r) {
        return "Float64Array" === o(r);
      },
      isBigInt64Array: function isBigInt64Array(r) {
        return "BigInt64Array" === o(r);
      },
      isBigUint64Array: function isBigUint64Array(r) {
        return "BigUint64Array" === o(r);
      },
    }),
      s(t.exports, {
        isKeyObject: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: (r) =>
            !!i.versions.openssl &&
            (u || ({ isKeyObject: u } = n("internal/crypto/keys")), u(r)),
        },
        isCryptoKey: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: (r) =>
            !!i.versions.openssl &&
            (A || ({ isCryptoKey: A } = n("internal/crypto/keys")), A(r)),
        },
      });
  },
  "internal/v8/startup_snapshot": function (i, a, n, e, l, t) {
    "use strict";
    const { validateFunction: s } = a("internal/validators"),
      {
        codes: {
          ERR_NOT_BUILDING_SNAPSHOT: o,
          ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION: r,
        },
      } = a("internal/errors"),
      {
        setSerializeCallback: c,
        setDeserializeCallback: u,
        setDeserializeMainFunction: h,
      } = l("mksnapshot");
    function isBuildingSnapshot() {
      return a("internal/options").getOptionValue("--build-snapshot");
    }
    function throwIfNotBuildingSnapshot() {
      if (!isBuildingSnapshot()) throw new o();
    }
    const d = [];
    let p = !1;
    function runDeserializeCallbacks() {
      for (; d.length > 0; ) {
        const { 0: i, 1: a } = d.shift();
        i(a);
      }
    }
    const f = [];
    function runSerializeCallbacks() {
      for (; f.length > 0; ) {
        const { 0: i, 1: a } = f.shift();
        i(a);
      }
    }
    let k = !1;
    n.exports = {
      initializeCallbacks: function initializeCallbacks() {
        isBuildingSnapshot() && c(runSerializeCallbacks);
      },
      runDeserializeCallbacks: runDeserializeCallbacks,
      namespace: {
        addDeserializeCallback: function addDeserializeCallback(i, a) {
          throwIfNotBuildingSnapshot(),
            s(i, "callback"),
            p || (u(runDeserializeCallbacks), (p = !0)),
            d.push([i, a]);
        },
        addSerializeCallback: function addSerializeCallback(i, a) {
          throwIfNotBuildingSnapshot(), s(i, "callback"), f.push([i, a]);
        },
        setDeserializeMainFunction: function setDeserializeMainFunction(i, n) {
          if ((throwIfNotBuildingSnapshot(), s(i, "callback"), k))
            throw new r();
          (k = !0),
            h(function deserializeMain() {
              const {
                prepareMainThreadExecution: e,
                markBootstrapComplete: l,
              } = a("internal/process/pre_execution");
              e(!1), l(), i(n);
            });
        },
        isBuildingSnapshot: isBuildingSnapshot,
      },
    };
  },
  "internal/v8_prof_polyfill": function (e, n, t, r, i, o) {
    "use strict";
    if (
      ((t.exports = { versionCheck: versionCheck }),
      "internal/v8_prof_polyfill" === t.id)
    )
      return;
    const l = n("fs"),
      s = n("child_process"),
      { Buffer: c } = n("buffer"),
      f = {
        system: function (e, n) {
          if ("linux" === r.platform && "nm" === e) {
            const e = n[n.length - 1];
            if (
              "[vdso]" === e ||
              "[vsyscall]" === e ||
              /^[0-9a-f]+-[0-9a-f]+$/.test(e)
            )
              return "";
          }
          let t = s.spawnSync(e, n).stdout.toString();
          if ("darwin" === r.platform && "nm" === e) {
            const e = t.match(/(?:^|\n)([^\n]*xcodebuild[^\n]*)(?:\n|$)/);
            if (e) throw new Error(e[1]);
            t = (function macCppfiltNm(e) {
              const n = /^([0-9a-fA-F]{8,16} [iItT] )(.*)$/gm,
                t = /^[0-9a-fA-F]{8,16} [iItT] /;
              let r,
                i = e.match(n);
              if (null === i) return e;
              i = i.map((e) => e.replace(t, ""));
              try {
                r = s
                  .spawnSync("c++filt", ["-p", "-i"], { input: i.join("\n") })
                  .stdout.toString();
              } catch {
                return e;
              }
              let o = 0;
              return (
                (r = r.split("\n")),
                e.replace(n, (e, n, t) => n + (r[o++] || t))
              );
            })(t);
          }
          return t;
        },
      },
      a = console.log;
    const u = r.exit,
      d = globalThis.arguments[globalThis.arguments.length - 1];
    try {
      l.accessSync(d);
    } catch {
      console.error(
        "Please provide a valid isolate file as the final argument."
      ),
        r.exit(1);
    }
    const g = l.openSync(d, "r"),
      p = c.allocUnsafe(4096),
      h = new (n("string_decoder").StringDecoder)("utf-8");
    let v = "";
    {
      const e = versionCheck(
        (function peekline() {
          const e = readline();
          return (v = `${e}\n${v}`), e;
        })(),
        r.versions.v8
      );
      e && console.log(e);
    }
    function readline() {
      for (;;) {
        const e = v.indexOf("\n");
        if (-1 !== e) {
          const n = v.slice(0, e);
          return (v = v.slice(e + 1)), n;
        }
        const n = l.readSync(g, p, 0, p.length);
        if (((v += h.write(p.slice(0, n))), 0 === v.length)) return "";
        if (0 === n)
          return (
            r.emitWarning(`Profile file ${d} is broken`, {
              code: "BROKEN_PROFILE_FILE",
              detail: `${JSON.stringify(v)} at the file end is broken`,
            }),
            ""
          );
      }
    }
    function versionCheck(e, n) {
      e = e.split(",");
      const t = n.split(/[.-]/);
      if ((6 !== e.length && 7 !== e.length) || "v8-version" !== e[0])
        return "Unable to read v8-version from log file.";
      for (let n = 0; n < 3; n++)
        if (t[n] !== e[n + 1])
          return "Testing v8 version different from logging version";
    }
    Object.assign(globalThis, {
      os: f,
      print: a,
      read: function read(e) {
        return l.readFileSync(e, "utf8");
      },
      quit: u,
      readline: readline,
    });
  },
  "internal/v8_prof_processor": function (t, e, r, n, o, i) {
    "use strict";
    const {
        ArrayPrototypePush: l,
        ArrayPrototypePushApply: a,
        ArrayPrototypeSlice: s,
        StringPrototypeSlice: c,
      } = i,
      u = e("buffer").Buffer,
      p = e("internal/console/global"),
      f = e("vm"),
      { SourceTextModule: y } = e("internal/vm/module"),
      w = o("natives");
    async function linker(t, e) {
      const r = c(t, 2, -4),
        n = w[`internal/deps/v8/tools/${r}`];
      return new y(n, { context: e.context });
    }
    (async () => {
      const t = [];
      "darwin" === n.platform
        ? l(t, "--mac")
        : "win32" === n.platform && l(t, "--windows"),
        a(t, s(n.argv, 1));
      const o = f.createContext({
          arguments: t,
          write(t) {
            n.stdout.write(t);
          },
          printErr(t) {
            p.error(t);
          },
          console: p,
          process: n,
          Buffer: u,
        }),
        i = `(function(module, require) {\n    ${w["internal/v8_prof_polyfill"]}\n  })`;
      f.runInContext(i, o)(r, e);
      const c = w["internal/deps/v8/tools/tickprocessor-driver"],
        d = new y(c, { context: o });
      await d.link(linker), await d.evaluate();
    })();
  },
  "internal/validators": function (t, e, n, r, i, o) {
    "use strict";
    const {
        ArrayIsArray: a,
        ArrayPrototypeIncludes: l,
        ArrayPrototypeJoin: f,
        ArrayPrototypeMap: u,
        NumberIsInteger: s,
        NumberIsNaN: d,
        NumberMAX_SAFE_INTEGER: w,
        NumberMIN_SAFE_INTEGER: c,
        NumberParseInt: y,
        ObjectPrototypeHasOwnProperty: g,
        RegExpPrototypeExec: v,
        String: h,
        StringPrototypeToUpperCase: p,
        StringPrototypeTrim: b,
      } = o,
      {
        hideStackFrames: A,
        codes: {
          ERR_SOCKET_BAD_PORT: m,
          ERR_INVALID_ARG_TYPE: $,
          ERR_INVALID_ARG_VALUE: N,
          ERR_OUT_OF_RANGE: S,
          ERR_UNKNOWN_SIGNAL: _,
        },
      } = e("internal/errors"),
      { normalizeEncoding: E } = e("internal/util"),
      { isAsyncFunction: I, isArrayBufferView: O } = e("internal/util/types"),
      { signals: P } = i("constants").os;
    const R = /^[0-7]+$/;
    const F = A((t, e, n = c, r = w) => {
        if ("number" != typeof t) throw new $(e, "number", t);
        if (!s(t)) throw new S(e, "an integer", t);
        if (t < n || t > r) throw new S(e, `>= ${n} && <= ${r}`, t);
      }),
      V = A((t, e, n = -2147483648, r = 2147483647) => {
        if ("number" != typeof t) throw new $(e, "number", t);
        if (!s(t)) throw new S(e, "an integer", t);
        if (t < n || t > r) throw new S(e, `>= ${n} && <= ${r}`, t);
      }),
      B = A((t, e, n = !1) => {
        if ("number" != typeof t) throw new $(e, "number", t);
        if (!s(t)) throw new S(e, "an integer", t);
        const r = n ? 1 : 0,
          i = 4294967295;
        if (t < r || t > i) throw new S(e, `>= ${r} && <= ${i}`, t);
      });
    function validateString(t, e) {
      if ("string" != typeof t) throw new $(e, "string", t);
    }
    const D = A((t, e, n) => {
      if (!l(n, t)) {
        const r = f(
          u(n, (t) => ("string" == typeof t ? `'${t}'` : h(t))),
          ", "
        );
        throw new N(e, t, "must be one of: " + r);
      }
    });
    function validateBoolean(t, e) {
      if ("boolean" != typeof t) throw new $(e, "boolean", t);
    }
    function getOwnPropertyValueOrDefault(t, e, n) {
      return null != t && g(t, e) ? t[e] : n;
    }
    const U = A((t, e, n = null) => {
        const r = getOwnPropertyValueOrDefault(n, "allowArray", !1),
          i = getOwnPropertyValueOrDefault(n, "allowFunction", !1);
        if (
          (!getOwnPropertyValueOrDefault(n, "nullable", !1) && null === t) ||
          (!r && a(t)) ||
          ("object" != typeof t && (!i || "function" != typeof t))
        )
          throw new $(e, "Object", t);
      }),
      L = A((t, e) => {
        if (null != t && "object" != typeof t && "function" != typeof t)
          throw new $(e, "a dictionary", t);
      }),
      T = A((t, e, n = 0) => {
        if (!a(t)) throw new $(e, "Array", t);
        if (t.length < n) {
          throw new N(e, t, `must be longer than ${n}`);
        }
      });
    const j = A((t, e = "buffer") => {
      if (!O(t)) throw new $(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    const k = A((t, e) => {
        if (
          void 0 !== t &&
          (null === t || "object" != typeof t || !("aborted" in t))
        )
          throw new $(e, "AbortSignal", t);
      }),
      G = A((t, e) => {
        if ("function" != typeof t) throw new $(e, "Function", t);
      }),
      H = A((t, e) => {
        if ("function" != typeof t || I(t)) throw new $(e, "Function", t);
      }),
      M = A((t, e) => {
        if (void 0 !== t) throw new $(e, "undefined", t);
      });
    const x = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(t, e) {
      if (void 0 === t || !v(x, t))
        throw new N(
          e,
          t,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
    }
    n.exports = {
      isInt32: function isInt32(t) {
        return t === (0 | t);
      },
      isUint32: function isUint32(t) {
        return t === t >>> 0;
      },
      parseFileMode: function parseFileMode(t, e, n) {
        if (((t ??= n), "string" == typeof t)) {
          if (null === v(R, t))
            throw new N(
              e,
              t,
              "must be a 32-bit unsigned integer or an octal string"
            );
          t = y(t, 8);
        }
        return B(t, e), t;
      },
      validateArray: T,
      validateStringArray: function validateStringArray(t, e) {
        T(t, e);
        for (let n = 0; n < t.length; n++) validateString(t[n], `${e}[${n}]`);
      },
      validateBooleanArray: function validateBooleanArray(t, e) {
        T(t, e);
        for (let n = 0; n < t.length; n++) validateBoolean(t[n], `${e}[${n}]`);
      },
      validateAbortSignalArray: function validateAbortSignalArray(t, e) {
        T(t, e);
        for (let n = 0; n < t.length; n++) {
          const r = t[n],
            i = `${e}[${n}]`;
          if (null == r) throw new $(i, "AbortSignal", r);
          k(r, i);
        }
      },
      validateBoolean: validateBoolean,
      validateBuffer: j,
      validateDictionary: L,
      validateEncoding: function validateEncoding(t, e) {
        const n = E(e),
          r = t.length;
        if ("hex" === n && r % 2 != 0)
          throw new N("encoding", e, `is invalid for data of length ${r}`);
      },
      validateFunction: G,
      validateInt32: V,
      validateInteger: F,
      validateNumber: function validateNumber(t, e, n = void 0, r) {
        if ("number" != typeof t) throw new $(e, "number", t);
        if (
          (null != n && t < n) ||
          (null != r && t > r) ||
          ((null != n || null != r) && d(t))
        )
          throw new S(
            e,
            `${null != n ? `>= ${n}` : ""}${
              null != n && null != r ? " && " : ""
            }${null != r ? `<= ${r}` : ""}`,
            t
          );
      },
      validateObject: U,
      validateOneOf: D,
      validatePlainFunction: H,
      validatePort: function validatePort(t, e = "Port", n = !0) {
        if (
          ("number" != typeof t && "string" != typeof t) ||
          ("string" == typeof t && 0 === b(t).length) ||
          +t != +t >>> 0 ||
          t > 65535 ||
          (0 === t && !n)
        )
          throw new m(e, t, n);
        return 0 | t;
      },
      validateSignalName: function validateSignalName(t, e = "signal") {
        if ((validateString(t, e), void 0 === P[t])) {
          if (void 0 !== P[p(t)])
            throw new _(t + " (signals must use all capital letters)");
          throw new _(t);
        }
      },
      validateString: validateString,
      validateUint32: B,
      validateUndefined: M,
      validateUnion: function validateUnion(t, e, n) {
        if (!l(n, t)) throw new $(e, `('${f(n, "|")}')`, t);
      },
      validateAbortSignal: k,
      validateLinkHeaderValue: function validateLinkHeaderValue(t) {
        if ("string" == typeof t)
          return validateLinkHeaderFormat(t, "hints"), t;
        if (a(t)) {
          const e = t.length;
          let n = "";
          if (0 === e) return n;
          for (let r = 0; r < e; r++) {
            const i = t[r];
            validateLinkHeaderFormat(i, "hints"),
              (n += i),
              r !== e - 1 && (n += ", ");
          }
          return n;
        }
        throw new N(
          "hints",
          t,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      },
    };
  },
  "internal/vm": function (t, e, n, o, i, a) {
    "use strict";
    const { ReflectApply: c, Symbol: l } = a,
      {
        ContextifyScript: r,
        compileFunction: u,
        isContext: d,
      } = i("contextify"),
      { runInContext: m } = r.prototype,
      { default_host_defined_options: p, vm_dynamic_import_missing_flag: s } =
        i("symbols"),
      { validateFunction: y, validateObject: f } = e("internal/validators"),
      { getOptionValue: D } = e("internal/options");
    function registerImportModuleDynamically(t, n) {
      const { importModuleDynamicallyWrap: o } = e("internal/vm/module"),
        { registerModule: i } = e("internal/modules/esm/utils");
      i(t, { __proto__: null, importModuleDynamically: o(n) });
    }
    n.exports = {
      getHostDefinedOptionId: function getHostDefinedOptionId(t, e) {
        return (
          void 0 !== t && y(t, "options.importModuleDynamically"),
          void 0 === t ? p : D("--experimental-vm-modules") ? l(e) : s
        );
      },
      internalCompileFunction: function internalCompileFunction(
        t,
        e,
        n,
        o,
        i,
        a,
        c,
        l,
        r,
        d,
        m
      ) {
        const p = u(t, e, n, o, i, a, c, l, r, d);
        return (
          a && (p.function.cachedDataProduced = p.cachedDataProduced),
          p.cachedData && (p.function.cachedData = p.cachedData),
          "boolean" == typeof p.cachedDataRejected &&
            (p.function.cachedDataRejected = p.cachedDataRejected),
          void 0 !== m && registerImportModuleDynamically(p.function, m),
          p
        );
      },
      isContext: function isContext(t) {
        return f(t, "object", { __proto__: null, allowArray: !0 }), d(t);
      },
      makeContextifyScript: function makeContextifyScript(
        t,
        e,
        n,
        o,
        i,
        a,
        c,
        l,
        u
      ) {
        let d;
        try {
          d = new r(t, e, n, o, i, a, c, l);
        } catch (t) {
          throw t;
        }
        return void 0 !== u && registerImportModuleDynamically(d, u), d;
      },
      registerImportModuleDynamically: registerImportModuleDynamically,
      runScriptInThisContext: function runScriptInThisContext(t, e, n) {
        return c(m, t, [null, -1, e, !1, n]);
      },
    };
  },
  "internal/vm/module": function (t, e, i, r, o, n) {
    "use strict";
    const s = e("internal/assert"),
      {
        ArrayIsArray: a,
        ArrayPrototypeForEach: l,
        ArrayPrototypeIndexOf: u,
        ArrayPrototypeSome: c,
        ObjectCreate: d,
        ObjectDefineProperty: h,
        ObjectGetPrototypeOf: f,
        ObjectSetPrototypeOf: p,
        ReflectApply: w,
        SafePromiseAllReturnVoid: m,
        Symbol: v,
        SymbolToStringTag: y,
        TypeError: _,
      } = n,
      { isContext: M } = o("contextify"),
      { isModuleNamespaceObject: E } = e("internal/util/types"),
      {
        customInspectSymbol: g,
        emitExperimentalWarning: k,
        getConstructorOf: O,
        kEmptyObject: D,
      } = e("internal/util"),
      {
        ERR_INVALID_ARG_TYPE: x,
        ERR_INVALID_ARG_VALUE: b,
        ERR_VM_MODULE_ALREADY_LINKED: S,
        ERR_VM_MODULE_DIFFERENT_CONTEXT: R,
        ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA: A,
        ERR_VM_MODULE_LINK_FAILURE: I,
        ERR_VM_MODULE_NOT_MODULE: T,
        ERR_VM_MODULE_STATUS: N,
      } = e("internal/errors").codes,
      {
        validateBoolean: L,
        validateBuffer: C,
        validateFunction: U,
        validateInt32: V,
        validateObject: P,
        validateUint32: j,
        validateString: W,
      } = e("internal/validators"),
      $ = o("module_wrap"),
      {
        ModuleWrap: F,
        kUninstantiated: z,
        kInstantiating: G,
        kInstantiated: q,
        kEvaluating: B,
        kEvaluated: K,
        kErrored: Y,
      } = $,
      H = {
        [z]: "unlinked",
        [G]: "linking",
        [q]: "linked",
        [B]: "evaluating",
        [K]: "evaluated",
        [Y]: "errored",
      };
    let X = 0;
    const J = "vm:module",
      Q = v("kWrap"),
      Z = v("kContext"),
      tt = v("kPerContextModuleId"),
      et = v("kLink");
    class Module {
      constructor(t) {
        if ((k("VM Modules"), new.target === Module))
          throw new _("Module is not a constructor");
        const {
          context: i,
          sourceText: r,
          syntheticExportNames: o,
          syntheticEvaluationSteps: n,
        } = t;
        if (void 0 !== i && (P(i, "context"), !M(i)))
          throw new x("options.context", "vm.Context", i);
        let { identifier: a } = t;
        if (void 0 !== a) W(a, "options.identifier");
        else if (void 0 === i) a = `${J}(${X++})`;
        else if (void 0 !== i[tt]) {
          const t = i[tt];
          (a = `${J}(${t})`), (i[tt] += 1);
        } else
          (a = `${J}(0)`),
            h(i, tt, {
              __proto__: null,
              value: 1,
              writable: !0,
              enumerable: !1,
              configurable: !0,
            });
        let l = { __proto__: null };
        void 0 !== r
          ? ((this[Q] = new F(
              a,
              i,
              r,
              t.lineOffset,
              t.columnOffset,
              t.cachedData
            )),
            (l = {
              __proto__: null,
              initializeImportMeta: t.initializeImportMeta,
              importModuleDynamically: t.importModuleDynamically
                ? importModuleDynamicallyWrap(t.importModuleDynamically)
                : void 0,
            }))
          : (s(n), (this[Q] = new F(a, i, o, n))),
          (l.callbackReferrer = this);
        const { registerModule: u } = e("internal/modules/esm/utils");
        u(this[Q], l), (this[Z] = i);
      }
      get identifier() {
        if (void 0 === this[Q]) throw new T();
        return this[Q].url;
      }
      get context() {
        if (void 0 === this[Q]) throw new T();
        return this[Z];
      }
      get namespace() {
        if (void 0 === this[Q]) throw new T();
        if (this[Q].getStatus() < q)
          throw new N("must not be unlinked or linking");
        return this[Q].getNamespace();
      }
      get status() {
        if (void 0 === this[Q]) throw new T();
        return H[this[Q].getStatus()];
      }
      get error() {
        if (void 0 === this[Q]) throw new T();
        if (this[Q].getStatus() !== Y) throw new N("must be errored");
        return this[Q].getError();
      }
      async link(t) {
        if (void 0 === this[Q]) throw new T();
        if ((U(t, "linker"), "linked" === this.status)) throw new S();
        if ("unlinked" !== this.status) throw new N("must be unlinked");
        await this[et](t), this[Q].instantiate();
      }
      async evaluate(t = D) {
        if (void 0 === this[Q]) throw new T();
        P(t, "options");
        let e = t.timeout;
        void 0 === e ? (e = -1) : j(e, "options.timeout", !0);
        const { breakOnSigint: i = !1 } = t;
        L(i, "options.breakOnSigint");
        const r = this[Q].getStatus();
        if (r !== q && r !== K && r !== Y)
          throw new N("must be one of linked, evaluated, or errored");
        await this[Q].evaluate(e, i);
      }
      [g](t, i) {
        if (void 0 === this[Q]) throw new T();
        if ("number" == typeof t && t < 0) return this;
        const r = O(this) || Module,
          o = d({ constructor: r });
        (o.status = this.status),
          (o.identifier = this.identifier),
          (o.context = this.context),
          p(o, f(this)),
          h(o, y, { __proto__: null, value: r.name, configurable: !0 });
        const { inspect: n } = e("internal/util/inspect");
        return n(o, { ...i, customInspect: !1 });
      }
    }
    const it = v("kDependencySpecifiers"),
      rt = v("kNoError");
    function importModuleDynamicallyWrap(t) {
      return async (...e) => {
        const i = await w(t, this, e);
        if (E(i)) return i;
        if (!i || void 0 === i[Q]) throw new T();
        if ("errored" === i.status) throw i.error;
        return i.namespace;
      };
    }
    i.exports = {
      Module: Module,
      SourceTextModule: class SourceTextModule extends Module {
        #t = rt;
        #e;
        constructor(t, e = D) {
          W(t, "sourceText"), P(e, "options");
          const {
            lineOffset: i = 0,
            columnOffset: r = 0,
            initializeImportMeta: o,
            importModuleDynamically: n,
            context: s,
            identifier: a,
            cachedData: l,
          } = e;
          V(i, "options.lineOffset"),
            V(r, "options.columnOffset"),
            void 0 !== o && U(o, "options.initializeImportMeta"),
            void 0 !== n && U(n, "options.importModuleDynamically"),
            void 0 !== l && C(l, "options.cachedData"),
            super({
              sourceText: t,
              context: s,
              identifier: a,
              lineOffset: i,
              columnOffset: r,
              cachedData: l,
              initializeImportMeta: o,
              importModuleDynamically: n,
            }),
            (this[et] = async (t) => {
              this.#e = "linking";
              const e = this[Q].link(async (e, i) => {
                const r = await t(e, this, { attributes: i, assert: i });
                if (void 0 === r[Q]) throw new T();
                if (r.context !== this.context) throw new R();
                if ("errored" === r.status)
                  throw new I(
                    `request for '${e}' resolved to an errored module`,
                    r.error
                  );
                return "unlinked" === r.status && (await r[et](t)), r[Q];
              });
              try {
                void 0 !== e && (await m(e));
              } catch (t) {
                throw ((this.#t = t), t);
              } finally {
                this.#e = void 0;
              }
            }),
            (this[it] = void 0);
        }
        get dependencySpecifiers() {
          if (void 0 === this[Q]) throw new T();
          return (
            void 0 === this[it] &&
              (this[it] = this[Q].getStaticDependencySpecifiers()),
            this[it]
          );
        }
        get status() {
          if (void 0 === this[Q]) throw new T();
          return this.#t !== rt ? "errored" : this.#e ? this.#e : super.status;
        }
        get error() {
          if (void 0 === this[Q]) throw new T();
          return this.#t !== rt ? this.#t : super.error;
        }
        createCachedData() {
          const { status: t } = this;
          if ("evaluating" === t || "evaluated" === t || "errored" === t)
            throw new A();
          return this[Q].createCachedData();
        }
      },
      SyntheticModule: class SyntheticModule extends Module {
        constructor(t, e, i = D) {
          if (!a(t) || c(t, (t) => "string" != typeof t))
            throw new x("exportNames", "Array of unique strings", t);
          l(t, (e, i) => {
            if (-1 !== u(t, e, i + 1))
              throw new b(`exportNames.${e}`, e, "is duplicated");
          }),
            U(e, "evaluateCallback"),
            P(i, "options");
          const { context: r, identifier: o } = i;
          super({
            syntheticExportNames: t,
            syntheticEvaluationSteps: e,
            context: r,
            identifier: o,
          }),
            (this[et] = () =>
              this[Q].link(() => {
                s.fail("link callback should not be called");
              }));
        }
        setExport(t, e) {
          if (void 0 === this[Q]) throw new T();
          if ((W(t, "name"), this[Q].getStatus() < q))
            throw new N("must be linked");
          this[Q].setExport(t, e);
        }
      },
      importModuleDynamicallyWrap: importModuleDynamicallyWrap,
    };
  },
  "internal/wasm_web_api": function (e, s, n, t, o, a) {
    "use strict";
    const { PromiseResolve: i } = a,
      { ERR_INVALID_ARG_TYPE: r, ERR_WEBASSEMBLY_RESPONSE: c } =
        s("internal/errors").codes;
    let u;
    n.exports = {
      wasmStreamingCallback: function wasmStreamingCallback(e, n) {
        (async () => {
          const t = await i(n);
          if (
            !(
              t instanceof
              (function lazyUndici() {
                return (u ??= s("internal/deps/undici/undici"));
              })().Response
            )
          )
            throw new r(
              "source",
              ["Response", "Promise resolving to Response"],
              t
            );
          const o = t.headers.get("Content-Type");
          if ("application/wasm" !== o)
            throw new c(`has unsupported MIME type '${o}'`);
          if (!t.ok) throw new c(`has status code ${t.status}`);
          if (!1 !== t.bodyUsed) throw new c("body has already been used");
          t.url && e.setURL(t.url);
          const { body: a } = t;
          if (null != a) for await (const s of a) e.push(s);
        })().then(
          () => {
            e.finish();
          },
          (s) => {
            e.abort(s);
          }
        );
      },
    };
  },
  "internal/watch_mode/files_watcher": function (e, t, i, s, r, n) {
    "use strict";
    const {
        ArrayIsArray: h,
        ArrayPrototypeForEach: a,
        SafeMap: c,
        SafeSet: l,
        StringPrototypeStartsWith: d,
      } = n,
      { validateNumber: o, validateOneOf: w } = t("internal/validators"),
      { kEmptyObject: f } = t("internal/util"),
      { TIMEOUT_MAX: u } = t("internal/timers"),
      p = t("events"),
      { watch: m } = t("fs"),
      { fileURLToPath: g } = t("url"),
      { resolve: F, dirname: y } = t("path"),
      { setTimeout: b } = t("timers"),
      O = "win32" === s.platform || "darwin" === s.platform;
    i.exports = {
      FilesWatcher: class FilesWatcher extends p {
        #e = new c();
        #t = new l();
        #i = new l();
        #s = new c();
        #r = new c();
        #n;
        #h;
        #a;
        constructor({ debounce: e = 200, mode: t = "filter", signal: i } = f) {
          super(),
            o(e, "options.debounce", 0, u),
            w(t, "options.mode", ["filter", "all"]),
            (this.#n = e),
            (this.#h = t),
            (this.#a = i),
            i && p.addAbortListener(i, () => this.clear());
        }
        #c(e) {
          if (this.#e.has(e)) return !0;
          for (const { 0: t, 1: i } of this.#e.entries())
            if (i.recursive && d(e, t)) return !0;
          return !1;
        }
        #l(e) {
          for (const { 0: t, 1: i } of this.#e.entries())
            e !== t && d(t, e) && (this.#d(i), this.#e.delete(t));
        }
        #d(e) {
          e.handle.removeAllListeners(), e.handle.close();
        }
        #o(e) {
          if (this.#i.has(e)) return;
          if ("filter" === this.#h && !this.#t.has(e)) return;
          this.#i.add(e);
          const t = this.#s.get(e);
          b(() => {
            this.#i.delete(e), this.emit("changed", { owners: t });
          }, this.#n).unref();
        }
        get watchedPaths() {
          return [...this.#e.keys()];
        }
        watchPath(e, t = !0) {
          if (this.#c(e)) return;
          const i = m(e, { recursive: t, signal: this.#a });
          i.on("change", (i, s) => this.#o(t ? F(e, s) : e)),
            this.#e.set(e, { handle: i, recursive: t }),
            t && this.#l(e);
        }
        filterFile(e, t) {
          if (
            e &&
            (O ? this.watchPath(y(e)) : this.watchPath(e, !1),
            this.#t.add(e),
            t)
          ) {
            const i = this.#s.get(e) ?? new l(),
              s = this.#r.get(e) ?? new l();
            i.add(t), s.add(e), this.#s.set(e, i), this.#r.set(t, s);
          }
        }
        watchChildProcessModules(e, t = null) {
          "filter" === this.#h &&
            e.on("message", (e) => {
              try {
                h(e["watch:require"]) &&
                  a(e["watch:require"], (e) => this.filterFile(e, t)),
                  h(e["watch:import"]) &&
                    a(e["watch:import"], (e) => this.filterFile(g(e), t));
              } catch {}
            });
        }
        unfilterFilesOwnedBy(e) {
          e.forEach((e) => {
            this.#r.get(e)?.forEach((e) => {
              this.#t.delete(e), this.#s.delete(e);
            }),
              this.#t.delete(e),
              this.#s.delete(e),
              this.#r.delete(e);
          });
        }
        clearFileFilters() {
          this.#t.clear();
        }
        clear() {
          this.#e.forEach(this.#d),
            this.#e.clear(),
            this.#t.clear(),
            this.#s.clear(),
            this.#r.clear();
        }
      },
    };
  },
  "internal/watchdog": function (e, t, s, i, r, n) {
    "use strict";
    const { TraceSigintWatchdog: o } = r("watchdog");
    s.exports = {
      SigintWatchdog: class SigintWatchdog extends o {
        _started = !1;
        _effective = !1;
        _onNewListener = (e) => {
          "SIGINT" === e &&
            this._effective &&
            (super.stop(), (this._effective = !1));
        };
        _onRemoveListener = (e) => {
          "SIGINT" !== e ||
            0 !== i.listenerCount("SIGINT") ||
            this._effective ||
            (super.start(), (this._effective = !0));
        };
        start() {
          this._started ||
            ((this._started = !0),
            i.prependListener("newListener", this._onNewListener),
            i.addListener("removeListener", this._onRemoveListener),
            0 === i.listenerCount("SIGINT") &&
              (super.start(), (this._effective = !0)));
        }
        stop() {
          this._started &&
            ((this._started = !1),
            i.removeListener("newListener", this._onNewListener),
            i.removeListener("removeListener", this._onRemoveListener),
            this._effective && (super.stop(), (this._effective = !1)));
        }
      },
    };
  },
  "internal/webidl": function (n, t, o, e, r, u) {
    "use strict";
    const {
        MathAbs: i,
        MathMax: c,
        MathMin: s,
        MathPow: w,
        MathSign: _,
        MathTrunc: a,
        NumberIsNaN: f,
        NumberMAX_SAFE_INTEGER: p,
        NumberMIN_SAFE_INTEGER: M,
        String: l,
      } = u,
      {
        codes: { ERR_INVALID_ARG_VALUE: N },
      } = t("internal/errors"),
      { kEmptyObject: R } = t("internal/util"),
      h = { __proto__: null },
      E = a;
    function evenRound(n) {
      const t = E(n) + 0,
        o = i(n % 1),
        e = _(t);
      if (0.5 === o) return t % 2 == 0 ? t : t + e;
      const r = o < 0.5 ? t : t + e;
      return 0 === r ? 0 : r;
    }
    function pow2(n) {
      return n < 31
        ? 1 << n
        : 31 === n
        ? 2147483648
        : 32 === n
        ? 4294967296
        : w(2, n);
    }
    (h.DOMString = function DOMString(n) {
      if ("symbol" == typeof n) throw new N("value", n);
      return l(n);
    }),
      (o.exports = {
        convertToInt: function convertToInt(n, t, o, e = R) {
          const { signed: r = !1, enforceRange: u = !1, clamp: i = !1 } = e;
          let w, _;
          64 === o
            ? ((w = p), (_ = r ? M : 0))
            : r
            ? ((_ = -pow2(o - 1)), (w = pow2(o - 1) - 1))
            : ((_ = 0), (w = pow2(o) - 1));
          let a = +t;
          if ((0 === a && (a = 0), u)) {
            if (f(a) || a === 1 / 0 || a === -1 / 0) throw new N(n, a);
            if (((a = E(a)), a < _ || a > w)) throw new N(n, a);
            return a;
          }
          return i && !f(a)
            ? ((a = s(c(a, _), w)), (a = evenRound(a)), a)
            : f(a) || 0 === a || a === 1 / 0 || a === -1 / 0
            ? 0
            : ((a = E(a)),
              (a = (function modulo(n, t) {
                const o = n % t;
                return 0 === o ? 0 : o;
              })(a, pow2(o))),
              r && a >= pow2(o - 1) ? a - pow2(o) : a);
        },
        evenRound: evenRound,
        converters: h,
      });
  },
  "internal/webstreams/adapters": function (e, r, t, n, o, a) {
    "use strict";
    const {
        PromisePrototypeThen: i,
        PromiseResolve: d,
        SafePromiseAll: l,
        SafePromisePrototypeFinally: c,
        TypedArrayPrototypeGetBuffer: s,
        TypedArrayPrototypeGetByteOffset: m,
        TypedArrayPrototypeGetByteLength: w,
        Uint8Array: u,
      } = a,
      { TextEncoder: b } = r("internal/encoding"),
      { ReadableStream: f, isReadableStream: p } = r(
        "internal/webstreams/readablestream"
      ),
      { WritableStream: S, isWritableStream: h } = r(
        "internal/webstreams/writablestream"
      ),
      { CountQueuingStrategy: y } = r("internal/webstreams/queuingstrategies"),
      { Writable: R, Readable: W, Duplex: g, destroy: v } = r("stream"),
      {
        isDestroyed: E,
        isReadable: M,
        isWritable: _,
        isWritableEnded: k,
      } = r("internal/streams/utils"),
      { Buffer: F } = r("buffer"),
      {
        errnoException: j,
        codes: {
          ERR_INVALID_ARG_TYPE: T,
          ERR_INVALID_ARG_VALUE: A,
          ERR_INVALID_STATE: P,
          ERR_STREAM_PREMATURE_CLOSE: x,
        },
        AbortError: B,
      } = r("internal/errors"),
      {
        createDeferredPromise: D,
        kEmptyObject: O,
        normalizeEncoding: L,
      } = r("internal/util"),
      {
        validateBoolean: I,
        validateFunction: C,
        validateObject: U,
      } = r("internal/validators"),
      {
        WriteWrap: G,
        ShutdownWrap: N,
        kReadBytesOrError: V,
        kLastWriteWasAsync: H,
        streamBaseState: q,
      } = o("stream_wrap"),
      z = r("internal/streams/end-of-stream"),
      { UV_EOF: Q } = o("uv"),
      Y = new b();
    function newWritableStreamFromStreamWritable(e) {
      if (!(e && "function" == typeof e?.write && "function" == typeof e?.on))
        throw new T("streamWritable", "stream.Writable", e);
      if (E(e) || !_(e)) {
        const e = new S();
        return e.close(), e;
      }
      const r = e.writableHighWaterMark,
        t = e.writableObjectMode
          ? new y({ highWaterMark: r })
          : { highWaterMark: r };
      let n, o, a;
      const i = z(e, (r) => {
        if ("ERR_STREAM_PREMATURE_CLOSE" === r?.code) {
          r = new B(void 0, { cause: r });
        }
        return (
          i(),
          e.on("error", () => {}),
          null != r
            ? (void 0 !== o && o.reject(r),
              void 0 !== a && (a.reject(r), (a = void 0)),
              n.error(r),
              void (n = void 0))
            : void 0 !== a
            ? (a.resolve(), void (a = void 0))
            : (n.error(new B()), void (n = void 0))
        );
      });
      return (
        e.on("drain", function onDrain() {
          void 0 !== o && o.resolve();
        }),
        new S(
          {
            start(e) {
              n = e;
            },
            async write(r) {
              if (e.writableNeedDrain || !e.write(r))
                return (
                  (o = D()),
                  c(o.promise, () => {
                    o = void 0;
                  })
                );
            },
            abort(r) {
              v(e, r);
            },
            close: () =>
              void 0 !== a || k(e)
                ? ((n = void 0), d())
                : ((a = D()), e.end(), a.promise),
          },
          t
        )
      );
    }
    function newReadableStreamFromStreamReadable(e, r = O) {
      if ("object" != typeof e?._readableState)
        throw new T("streamReadable", "stream.Readable", e);
      if (E(e) || !M(e)) {
        const e = new f();
        return e.cancel(), e;
      }
      const t = e.readableObjectMode,
        n = e.readableHighWaterMark,
        o =
          ((a = r?.strategy),
          a || (t ? new y({ highWaterMark: n }) : { highWaterMark: n }));
      var a;
      let i;
      e.pause();
      const d = z(e, (r) => {
        if ("ERR_STREAM_PREMATURE_CLOSE" === r?.code) {
          r = new B(void 0, { cause: r });
        }
        if ((d(), e.on("error", () => {}), r)) return i.error(r);
        i.close();
      });
      return (
        e.on("data", function onData(r) {
          F.isBuffer(r) && !t && (r = new u(r)),
            i.enqueue(r),
            i.desiredSize <= 0 && e.pause();
        }),
        new f(
          {
            start(e) {
              i = e;
            },
            pull() {
              e.resume();
            },
            cancel(r) {
              v(e, r);
            },
          },
          o
        )
      );
    }
    t.exports = {
      newWritableStreamFromStreamWritable: newWritableStreamFromStreamWritable,
      newReadableStreamFromStreamReadable: newReadableStreamFromStreamReadable,
      newStreamWritableFromWritableStream:
        function newStreamWritableFromWritableStream(e, r = O) {
          if (!h(e)) throw new T("writableStream", "WritableStream", e);
          U(r, "options");
          const {
            highWaterMark: t,
            decodeStrings: o = !0,
            objectMode: a = !1,
            signal: d,
          } = r;
          I(a, "options.objectMode"), I(o, "options.decodeStrings");
          const c = e.getWriter();
          let b = !1;
          const f = new R({
            highWaterMark: t,
            objectMode: a,
            decodeStrings: o,
            signal: d,
            writev(e, r) {
              function done(e) {
                e = e.filter((e) => e);
                try {
                  r(0 === e.length ? void 0 : e);
                } catch (e) {
                  n.nextTick(() => v(f, e));
                }
              }
              i(
                c.ready,
                () =>
                  i(
                    l(e, (e) => c.write(e.chunk)),
                    done,
                    done
                  ),
                done
              );
            },
            write(e, r, t) {
              if ("string" == typeof e && o && !a) {
                "utf8" === L(r)
                  ? (e = Y.encode(e))
                  : ((e = F.from(e, r)), (e = new u(s(e), m(e), w(e))));
              }
              function done(e) {
                try {
                  t(e);
                } catch (e) {
                  v(f, e);
                }
              }
              i(c.ready, () => i(c.write(e), done, done), done);
            },
            destroy(e, r) {
              function done() {
                try {
                  r(e);
                } catch (e) {
                  n.nextTick(() => {
                    throw e;
                  });
                }
              }
              b ? done() : i(null != e ? c.abort(e) : c.close(), done, done);
            },
            final(e) {
              function done(r) {
                try {
                  e(r);
                } catch (e) {
                  n.nextTick(() => v(f, e));
                }
              }
              b || i(c.close(), done, done);
            },
          });
          return (
            i(
              c.closed,
              () => {
                (b = !0), k(f) || v(f, new x());
              },
              (e) => {
                (b = !0), v(f, e);
              }
            ),
            f
          );
        },
      newStreamReadableFromReadableStream:
        function newStreamReadableFromReadableStream(e, r = O) {
          if (!p(e)) throw new T("readableStream", "ReadableStream", e);
          U(r, "options");
          const {
            highWaterMark: t,
            encoding: o,
            objectMode: a = !1,
            signal: d,
          } = r;
          if (void 0 !== o && !F.isEncoding(o))
            throw new A(o, "options.encoding");
          I(a, "options.objectMode");
          const l = e.getReader();
          let c = !1;
          const s = new W({
            objectMode: a,
            highWaterMark: t,
            encoding: o,
            signal: d,
            read() {
              i(
                l.read(),
                (e) => {
                  e.done ? s.push(null) : s.push(e.value);
                },
                (e) => v(s, e)
              );
            },
            destroy(e, r) {
              function done() {
                try {
                  r(e);
                } catch (e) {
                  n.nextTick(() => {
                    throw e;
                  });
                }
              }
              c ? done() : i(l.cancel(e), done, done);
            },
          });
          return (
            i(
              l.closed,
              () => {
                c = !0;
              },
              (e) => {
                (c = !0), v(s, e);
              }
            ),
            s
          );
        },
      newReadableWritablePairFromDuplex:
        function newReadableWritablePairFromDuplex(e) {
          if (
            "object" != typeof e?._writableState ||
            "object" != typeof e?._readableState
          )
            throw new T("duplex", "stream.Duplex", e);
          if (E(e)) {
            const e = new S(),
              r = new f();
            return e.close(), r.cancel(), { readable: r, writable: e };
          }
          const r = _(e) ? newWritableStreamFromStreamWritable(e) : new S();
          _(e) || r.close();
          const t = M(e) ? newReadableStreamFromStreamReadable(e) : new f();
          return M(e) || t.cancel(), { writable: r, readable: t };
        },
      newStreamDuplexFromReadableWritablePair:
        function newStreamDuplexFromReadableWritablePair(e = O, r = O) {
          U(e, "pair");
          const { readable: t, writable: o } = e;
          if (!p(t)) throw new T("pair.readable", "ReadableStream", t);
          if (!h(o)) throw new T("pair.writable", "WritableStream", o);
          U(r, "options");
          const {
            allowHalfOpen: a = !1,
            objectMode: d = !1,
            encoding: c,
            decodeStrings: b = !0,
            highWaterMark: f,
            signal: S,
          } = r;
          if ((I(d, "options.objectMode"), void 0 !== c && !F.isEncoding(c)))
            throw new A(c, "options.encoding");
          const y = o.getWriter(),
            R = t.getReader();
          let W = !1,
            E = !1;
          const M = new g({
            allowHalfOpen: a,
            highWaterMark: f,
            objectMode: d,
            encoding: c,
            decodeStrings: b,
            signal: S,
            writev(e, r) {
              function done(e) {
                e = e.filter((e) => e);
                try {
                  r(0 === e.length ? void 0 : e);
                } catch (e) {
                  n.nextTick(() => v(M, e));
                }
              }
              i(
                y.ready,
                () =>
                  i(
                    l(e, (e) => y.write(e.chunk)),
                    done,
                    done
                  ),
                done
              );
            },
            write(e, r, t) {
              if ("string" == typeof e && b && !d) {
                "utf8" === L(r)
                  ? (e = Y.encode(e))
                  : ((e = F.from(e, r)), (e = new u(s(e), m(e), w(e))));
              }
              function done(e) {
                try {
                  t(e);
                } catch (e) {
                  v(M, e);
                }
              }
              i(y.ready, () => i(y.write(e), done, done), done);
            },
            final(e) {
              function done(r) {
                try {
                  e(r);
                } catch (e) {
                  n.nextTick(() => v(M, e));
                }
              }
              W || i(y.close(), done, done);
            },
            read() {
              i(
                R.read(),
                (e) => {
                  e.done ? M.push(null) : M.push(e.value);
                },
                (e) => v(M, e)
              );
            },
            destroy(e, r) {
              function done() {
                try {
                  r(e);
                } catch (e) {
                  n.nextTick(() => {
                    throw e;
                  });
                }
              }
              W && E
                ? done()
                : i(
                    l([
                      (async function closeWriter() {
                        W || (await y.abort(e));
                      })(),
                      (async function closeReader() {
                        E || (await R.cancel(e));
                      })(),
                    ]),
                    done,
                    done
                  );
            },
          });
          return (
            i(
              y.closed,
              () => {
                (W = !0), k(M) || v(M, new x());
              },
              (e) => {
                (W = !0), (E = !0), v(M, e);
              }
            ),
            i(
              R.closed,
              () => {
                E = !0;
              },
              (e) => {
                (W = !0), (E = !0), v(M, e);
              }
            ),
            M
          );
        },
      newWritableStreamFromStreamBase: function newWritableStreamFromStreamBase(
        e,
        r
      ) {
        let t;
        function onWriteComplete(e) {
          if (e < 0) {
            const r = j(e, "write", this.error);
            return this.promise.reject(r), void this.controller.error(r);
          }
          this.promise.resolve();
        }
        function doWrite(r, t) {
          const n = D();
          let o, a;
          try {
            (a = (function createWriteWrap(r, t) {
              const n = new G();
              return (
                (n.handle = e),
                (n.oncomplete = onWriteComplete),
                (n.async = !1),
                (n.bytes = 0),
                (n.buffer = null),
                (n.controller = r),
                (n.promise = t),
                n
              );
            })(t, n)),
              (o = e.writeBuffer(a, r)),
              q[H] && (a.buffer = r),
              (a.async = !!q[H]);
          } catch (e) {
            n.reject(e);
          }
          return (
            0 !== o ? n.reject(j(o, "write", a)) : a.async || n.resolve(),
            n.promise
          );
        }
        return (
          U(e, "streamBase"),
          new S(
            {
              write: (e, r) => (
                (t =
                  void 0 !== t
                    ? i(
                        t,
                        () => doWrite(e, r),
                        (e) => r.error(e)
                      )
                    : doWrite(e, r)),
                t
              ),
              close() {
                const r = D(),
                  t = new N();
                t.oncomplete = () => r.resolve();
                return 1 === e.shutdown(t) && r.resolve(), r.promise;
              },
            },
            r
          )
        );
      },
      newReadableStreamFromStreamBase: function newReadableStreamFromStreamBase(
        e,
        r,
        t = O
      ) {
        U(e, "streamBase"), U(t, "options");
        const { ondone: n = () => {} } = t;
        if ("function" == typeof e.onread)
          throw new P("StreamBase already has a consumer");
        let o;
        return (
          C(n, "options.ondone"),
          (e.onread = (r) => {
            const t = q[V];
            if (0 !== t)
              try {
                if (t === Q) {
                  o.close(), e.readStop();
                  try {
                    n();
                  } catch (e) {
                    o.error(e);
                  }
                  return;
                }
                o.enqueue(r), o.desiredSize <= 0 && e.readStop();
              } catch (r) {
                o.error(r), e.readStop();
              }
          }),
          new f(
            {
              start(e) {
                o = e;
              },
              pull() {
                e.readStart();
              },
              cancel() {
                const r = D();
                try {
                  n();
                } catch (e) {
                  return r.reject(e), r.promise;
                }
                const t = new N();
                t.oncomplete = () => r.resolve();
                return 1 === e.shutdown(t) && r.resolve(), r.promise;
              },
            },
            r
          )
        );
      },
    };
  },
  "internal/webstreams/compression": function (e, r, t, s, i, a) {
    "use strict";
    const { ObjectDefineProperties: o, Symbol: n } = a,
      {
        codes: { ERR_INVALID_ARG_VALUE: m, ERR_INVALID_THIS: l },
      } = r("internal/errors"),
      { newReadableWritablePairFromDuplex: p } = r(
        "internal/webstreams/adapters"
      ),
      { customInspect: c } = r("internal/webstreams/util"),
      { customInspectSymbol: b, kEnumerableProperty: h } = r("internal/util");
    let w;
    function lazyZlib() {
      return (w ??= r("zlib")), w;
    }
    const S = n("kHandle"),
      u = n("kTransform"),
      f = n("kType");
    function isCompressionStream(e) {
      return "object" == typeof e?.[S] && "CompressionStream" === e?.[f];
    }
    function isDecompressionStream(e) {
      return "object" == typeof e?.[S] && "DecompressionStream" === e?.[f];
    }
    class CompressionStream {
      constructor(e) {
        switch (((this[f] = "CompressionStream"), e)) {
          case "deflate":
            this[S] = lazyZlib().createDeflate();
            break;
          case "gzip":
            this[S] = lazyZlib().createGzip();
            break;
          default:
            throw new m("format", e);
        }
        this[u] = p(this[S]);
      }
      get readable() {
        if (!isCompressionStream(this)) throw new l("CompressionStream");
        return this[u].readable;
      }
      get writable() {
        if (!isCompressionStream(this)) throw new l("CompressionStream");
        return this[u].writable;
      }
      [b](e, r) {
        if (!isCompressionStream(this)) throw new l("CompressionStream");
        c(e, r, "CompressionStream", {
          readable: this[u].readable,
          writable: this[u].writable,
        });
      }
    }
    class DecompressionStream {
      constructor(e) {
        switch (((this[f] = "DecompressionStream"), e)) {
          case "deflate":
            this[S] = lazyZlib().createInflate();
            break;
          case "gzip":
            this[S] = lazyZlib().createGunzip();
            break;
          default:
            throw new m("format", e);
        }
        this[u] = p(this[S]);
      }
      get readable() {
        if (!isDecompressionStream(this)) throw new l("DecompressionStream");
        return this[u].readable;
      }
      get writable() {
        if (!isDecompressionStream(this)) throw new l("DecompressionStream");
        return this[u].writable;
      }
      [b](e, r) {
        if (!isDecompressionStream(this)) throw new l("DecompressionStream");
        c(e, r, "DecompressionStream", {
          readable: this[u].readable,
          writable: this[u].writable,
        });
      }
    }
    o(CompressionStream.prototype, { readable: h, writable: h }),
      o(DecompressionStream.prototype, { readable: h, writable: h }),
      (t.exports = {
        CompressionStream: CompressionStream,
        DecompressionStream: DecompressionStream,
      });
  },
  "internal/webstreams/encoding": function (e, t, r, n, i, o) {
    "use strict";
    const {
        ObjectDefineProperties: a,
        String: s,
        StringPrototypeCharCodeAt: c,
        Symbol: d,
        Uint8Array: h,
      } = o,
      { TextDecoder: m, TextEncoder: l } = t("internal/encoding"),
      { TransformStream: S } = t("internal/webstreams/transformstream"),
      { customInspect: T } = t("internal/webstreams/util"),
      {
        codes: { ERR_INVALID_THIS: u },
      } = t("internal/errors"),
      {
        customInspectSymbol: x,
        kEmptyObject: w,
        kEnumerableProperty: f,
      } = t("internal/util"),
      g = d("kHandle"),
      b = d("kTransform"),
      D = d("kType"),
      E = d("kPendingHighSurrogate");
    function isTextEncoderStream(e) {
      return "object" == typeof e?.[g] && "TextEncoderStream" === e?.[D];
    }
    function isTextDecoderStream(e) {
      return "object" == typeof e?.[g] && "TextDecoderStream" === e?.[D];
    }
    class TextEncoderStream {
      constructor() {
        (this[E] = null),
          (this[D] = "TextEncoderStream"),
          (this[g] = new l()),
          (this[b] = new S({
            transform: (e, t) => {
              e = s(e);
              let r = "";
              for (let t = 0; t < e.length; t++) {
                const n = e[t],
                  i = c(n, 0);
                if (null !== this[E]) {
                  const e = this[E];
                  if (((this[E] = null), 56320 <= i && i <= 57343)) {
                    r += e + n;
                    continue;
                  }
                  r += "�";
                }
                55296 <= i && i <= 56319
                  ? (this[E] = n)
                  : (r += 56320 <= i && i <= 57343 ? "�" : n);
              }
              if (r) {
                const e = this[g].encode(r);
                t.enqueue(e);
              }
            },
            flush: (e) => {
              null !== this[E] && e.enqueue(new h([239, 191, 189]));
            },
          }));
      }
      get encoding() {
        if (!isTextEncoderStream(this)) throw new u("TextEncoderStream");
        return this[g].encoding;
      }
      get readable() {
        if (!isTextEncoderStream(this)) throw new u("TextEncoderStream");
        return this[b].readable;
      }
      get writable() {
        if (!isTextEncoderStream(this)) throw new u("TextEncoderStream");
        return this[b].writable;
      }
      [x](e, t) {
        if (!isTextEncoderStream(this)) throw new u("TextEncoderStream");
        return T(e, t, "TextEncoderStream", {
          encoding: this[g].encoding,
          readable: this[b].readable,
          writable: this[b].writable,
        });
      }
    }
    class TextDecoderStream {
      constructor(e = "utf-8", t = w) {
        (this[D] = "TextDecoderStream"),
          (this[g] = new m(e, t)),
          (this[b] = new S({
            transform: (e, t) => {
              const r = this[g].decode(e, { stream: !0 });
              r && t.enqueue(r);
            },
            flush: (e) => {
              const t = this[g].decode();
              t && e.enqueue(t), e.terminate();
            },
          }));
      }
      get encoding() {
        if (!isTextDecoderStream(this)) throw new u("TextDecoderStream");
        return this[g].encoding;
      }
      get fatal() {
        if (!isTextDecoderStream(this)) throw new u("TextDecoderStream");
        return this[g].fatal;
      }
      get ignoreBOM() {
        if (!isTextDecoderStream(this)) throw new u("TextDecoderStream");
        return this[g].ignoreBOM;
      }
      get readable() {
        if (!isTextDecoderStream(this)) throw new u("TextDecoderStream");
        return this[b].readable;
      }
      get writable() {
        if (!isTextDecoderStream(this)) throw new u("TextDecoderStream");
        return this[b].writable;
      }
      [x](e, t) {
        if (!isTextDecoderStream(this)) throw new u("TextDecoderStream");
        return T(e, t, "TextDecoderStream", {
          encoding: this[g].encoding,
          fatal: this[g].fatal,
          ignoreBOM: this[g].ignoreBOM,
          readable: this[b].readable,
          writable: this[b].writable,
        });
      }
    }
    a(TextEncoderStream.prototype, { encoding: f, readable: f, writable: f }),
      a(TextDecoderStream.prototype, {
        encoding: f,
        fatal: f,
        ignoreBOM: f,
        readable: f,
        writable: f,
      }),
      (r.exports = {
        TextEncoderStream: TextEncoderStream,
        TextDecoderStream: TextDecoderStream,
      });
  },
  "internal/webstreams/queuingstrategies": function (t, e, r, i, n, a) {
    "use strict";
    const {
        ObjectDefineProperties: g,
        ObjectDefineProperty: h,
        SymbolToStringTag: u,
      } = a,
      {
        codes: { ERR_INVALID_THIS: o, ERR_MISSING_OPTION: s },
      } = e("internal/errors"),
      { customInspectSymbol: y, kEnumerableProperty: S } = e("internal/util"),
      {
        customInspect: k,
        isBrandCheck: l,
        kType: c,
        kState: M,
      } = e("internal/webstreams/util"),
      { validateObject: Q } = e("internal/validators"),
      W = l("ByteLengthQueuingStrategy"),
      _ = l("CountQueuingStrategy"),
      p = { __proto__: null, value: "size" },
      w = h((t) => t.byteLength, "name", p),
      L = h(() => 1, "name", p),
      getNonWritablePropertyDescriptor = (t) => ({
        __proto__: null,
        configurable: !0,
        value: t,
      });
    class ByteLengthQueuingStrategy {
      [c] = "ByteLengthQueuingStrategy";
      constructor(t) {
        if ((Q(t, "init"), void 0 === t.highWaterMark))
          throw new s("init.highWaterMark");
        this[M] = { highWaterMark: +t.highWaterMark };
      }
      get highWaterMark() {
        if (!W(this)) throw new o("ByteLengthQueuingStrategy");
        return this[M].highWaterMark;
      }
      get size() {
        if (!W(this)) throw new o("ByteLengthQueuingStrategy");
        return w;
      }
      [y](t, e) {
        return k(t, e, this[c], { highWaterMark: this.highWaterMark });
      }
    }
    g(ByteLengthQueuingStrategy.prototype, {
      highWaterMark: S,
      size: S,
      [u]: getNonWritablePropertyDescriptor(ByteLengthQueuingStrategy.name),
    });
    class CountQueuingStrategy {
      [c] = "CountQueuingStrategy";
      constructor(t) {
        if ((Q(t, "init"), void 0 === t.highWaterMark))
          throw new s("init.highWaterMark");
        this[M] = { highWaterMark: +t.highWaterMark };
      }
      get highWaterMark() {
        if (!_(this)) throw new o("CountQueuingStrategy");
        return this[M].highWaterMark;
      }
      get size() {
        if (!_(this)) throw new o("CountQueuingStrategy");
        return L;
      }
      [y](t, e) {
        return k(t, e, this[c], { highWaterMark: this.highWaterMark });
      }
    }
    g(CountQueuingStrategy.prototype, {
      highWaterMark: S,
      size: S,
      [u]: getNonWritablePropertyDescriptor(CountQueuingStrategy.name),
    }),
      (r.exports = {
        ByteLengthQueuingStrategy: ByteLengthQueuingStrategy,
        CountQueuingStrategy: CountQueuingStrategy,
      });
  },
  "internal/webstreams/readablestream": function (e, r, t, a, l, o) {
    "use strict";
    const {
        ArrayBuffer: n,
        ArrayBufferPrototypeGetByteLength: d,
        ArrayBufferPrototypeSlice: s,
        ArrayPrototypePush: i,
        ArrayPrototypeShift: u,
        DataView: m,
        FunctionPrototypeBind: b,
        FunctionPrototypeCall: c,
        MathMin: S,
        NumberIsInteger: f,
        ObjectCreate: R,
        ObjectDefineProperties: h,
        ObjectSetPrototypeOf: C,
        Promise: y,
        PromisePrototypeThen: p,
        PromiseResolve: B,
        PromiseReject: w,
        ReflectConstruct: g,
        SafePromiseAll: D,
        Symbol: q,
        SymbolAsyncIterator: v,
        SymbolDispose: I,
        SymbolToStringTag: P,
        Uint8Array: E,
      } = o,
      {
        AbortError: A,
        codes: {
          ERR_ILLEGAL_CONSTRUCTOR: T,
          ERR_INVALID_ARG_VALUE: O,
          ERR_INVALID_ARG_TYPE: k,
          ERR_INVALID_STATE: z,
          ERR_INVALID_THIS: F,
        },
      } = r("internal/errors"),
      { DOMException: Y } = l("messaging"),
      { isArrayBufferView: W, isDataView: G } = r("internal/util/types"),
      {
        createDeferredPromise: N,
        customInspectSymbol: L,
        isArrayBufferDetached: _,
        kEmptyObject: H,
        kEnumerableProperty: Q,
        SideEffectFreeRegExpPrototypeSymbolReplace: V,
      } = r("internal/util"),
      {
        validateAbortSignal: j,
        validateBuffer: M,
        validateObject: x,
      } = r("internal/validators"),
      { MessageChannel: U } = r("internal/worker/io"),
      {
        kDeserialize: $,
        kTransfer: J,
        kTransferList: K,
        makeTransferable: X,
      } = r("internal/worker/js_transferable"),
      { queueMicrotask: Z } = r("internal/process/task_queues"),
      {
        kIsDisturbed: ee,
        kIsErrored: re,
        kIsReadable: te,
        kIsClosedPromise: ae,
        kControllerErrorFunction: le,
      } = r("internal/streams/utils"),
      { structuredClone: oe } = r("internal/structured_clone"),
      {
        ArrayBufferViewGetBuffer: ne,
        ArrayBufferViewGetByteLength: de,
        ArrayBufferViewGetByteOffset: se,
        AsyncIterator: ie,
        cloneAsUint8Array: ue,
        copyArrayBuffer: me,
        customInspect: be,
        dequeueValue: ce,
        ensureIsPromise: Se,
        enqueueValueWithSize: fe,
        extractHighWaterMark: Re,
        extractSizeAlgorithm: he,
        lazyTransfer: Ce,
        isViewedArrayBufferDetached: ye,
        isBrandCheck: pe,
        resetQueue: Be,
        setPromiseHandled: we,
        transferArrayBuffer: ge,
        nonOpCancel: De,
        nonOpPull: qe,
        nonOpStart: ve,
        kType: Ie,
        kState: Pe,
      } = r("internal/webstreams/util"),
      {
        WritableStreamDefaultWriter: Ee,
        isWritableStream: Ae,
        isWritableStreamLocked: Te,
        isWritableStreamDefaultController: Oe,
        isWritableStreamDefaultWriter: ke,
        writableStreamAbort: ze,
        writableStreamCloseQueuedOrInFlight: Fe,
        writableStreamDefaultWriterCloseWithErrorPropagation: Ye,
        writableStreamDefaultWriterRelease: We,
        writableStreamDefaultWriterWrite: Ge,
      } = r("internal/webstreams/writablestream"),
      { Buffer: Ne } = r("buffer"),
      Le = r("internal/assert"),
      _e = q("kCancel"),
      He = q("kClose"),
      Qe = q("kChunk"),
      Ve = q("kError"),
      je = q("kPull"),
      Me = q("kRelease"),
      xe = q("kSkipThrow");
    let Ue, $e, Je;
    const Ke = /^ {4}at (?:[^/\\(]+ \()(?!node:(.+):\d+:\d+\)$).*/gm;
    function lazyReadableReleasingError() {
      return (
        $e ||
        (($e = new z.TypeError("Releasing reader")),
        ($e.stack = V(Ke, $e.stack, "")),
        $e)
      );
    }
    const getNonWritablePropertyDescriptor = (e) => ({
      __proto__: null,
      configurable: !0,
      value: e,
    });
    class ReadableStream {
      [Ie] = "ReadableStream";
      constructor(e = {}, r = H) {
        if (null === e) throw new O("source", "Object", e);
        (this[Pe] = {
          disturbed: !1,
          reader: void 0,
          state: "readable",
          storedError: void 0,
          stream: void 0,
          transfer: {
            writable: void 0,
            port1: void 0,
            port2: void 0,
            promise: void 0,
          },
        }),
          (this[ae] = N()),
          (this[le] = () => {});
        const t = r?.size,
          a = r?.highWaterMark,
          l = e.type;
        if ("bytes" == `${l}`) {
          if (void 0 !== t) throw new O.RangeError("strategy.size", t);
          setupReadableByteStreamControllerFromSource(this, e, Re(a, 0));
        } else {
          if (void 0 !== l) throw new O("source.type", l);
          setupReadableStreamDefaultControllerFromSource(
            this,
            e,
            Re(a, 1),
            he(t)
          );
        }
        return X(this);
      }
      get [ee]() {
        return this[Pe].disturbed;
      }
      get [re]() {
        return "errored" === this[Pe].state;
      }
      get [te]() {
        return "readable" === this[Pe].state;
      }
      get locked() {
        if (!Xe(this)) throw new F("ReadableStream");
        return isReadableStreamLocked(this);
      }
      cancel(e = void 0) {
        return Xe(this)
          ? isReadableStreamLocked(this)
            ? w(new z.TypeError("ReadableStream is locked"))
            : readableStreamCancel(this, e)
          : w(new F("ReadableStream"));
      }
      getReader(e = H) {
        if (!Xe(this)) throw new F("ReadableStream");
        x(e, "options", { nullable: !0, allowFunction: !0 });
        const r = e?.mode;
        if (void 0 === r) return new ReadableStreamDefaultReader(this);
        if ("byob" != `${r}`) throw new O("options.mode", r);
        return new ReadableStreamBYOBReader(this);
      }
      pipeThrough(e, r = H) {
        if (!Xe(this)) throw new F("ReadableStream");
        const t = e?.readable;
        if (!Xe(t)) throw new k("transform.readable", "ReadableStream", t);
        const a = e?.writable;
        if (!Ae(a)) throw new k("transform.writable", "WritableStream", a);
        const l = r?.preventAbort,
          o = r?.preventCancel,
          n = r?.preventClose,
          d = r?.signal;
        if (
          (void 0 !== d && j(d, "options.signal"), isReadableStreamLocked(this))
        )
          throw new z.TypeError("The ReadableStream is locked");
        if (Te(a)) throw new z.TypeError("The WritableStream is locked");
        const s = readableStreamPipeTo(this, a, !!n, !!l, !!o, d);
        return we(s), t;
      }
      pipeTo(e, r = H) {
        try {
          if (!Xe(this)) throw new F("ReadableStream");
          if (!Ae(e)) throw new k("transform.writable", "WritableStream", e);
          const t = r?.preventAbort,
            a = r?.preventCancel,
            l = r?.preventClose,
            o = r?.signal;
          if (
            (void 0 !== o && j(o, "options.signal"),
            isReadableStreamLocked(this))
          )
            throw new z.TypeError("The ReadableStream is locked");
          if (Te(e)) throw new z.TypeError("The WritableStream is locked");
          return readableStreamPipeTo(this, e, !!l, !!t, !!a, o);
        } catch (e) {
          return w(e);
        }
      }
      tee() {
        if (!Xe(this)) throw new F("ReadableStream");
        return readableStreamTee(this, !1);
      }
      values(e = H) {
        if (!Xe(this)) throw new F("ReadableStream");
        x(e, "options");
        const { preventCancel: r = !1 } = e,
          t = new ReadableStreamDefaultReader(this);
        let a,
          l = !1,
          o = !1;
        function nextSteps() {
          if (l) return B({ done: !0, value: void 0 });
          if (void 0 === t[Pe].stream)
            return w(
              new z.TypeError("The reader is not bound to a ReadableStream")
            );
          const e = N();
          return (
            readableStreamDefaultReaderRead(t, {
              [Qe](r) {
                (a = void 0), e.resolve({ value: r, done: !1 });
              },
              [He]() {
                (a = void 0),
                  (l = !0),
                  readableStreamReaderGenericRelease(t),
                  e.resolve({ done: !0, value: void 0 });
              },
              [Ve](r) {
                (a = void 0),
                  (l = !0),
                  readableStreamReaderGenericRelease(t),
                  e.reject(r);
              },
            }),
            e.promise
          );
        }
        async function returnSteps(e) {
          if (l) return { done: !0, value: e };
          if (((l = !0), void 0 === t[Pe].stream))
            throw new z.TypeError(
              "The reader is not bound to a ReadableStream"
            );
          if ((Le(!t[Pe].readRequests.length), !r)) {
            const r = readableStreamReaderGenericCancel(t, e);
            return (
              readableStreamReaderGenericRelease(t),
              await r,
              { done: !0, value: e }
            );
          }
          return readableStreamReaderGenericRelease(t), { done: !0, value: e };
        }
        return C(
          {
            next: () => (
              o || ((a = B()), (o = !0)),
              (a = void 0 !== a ? p(a, nextSteps, nextSteps) : nextSteps()),
              a
            ),
            return: (e) =>
              a
                ? p(
                    a,
                    () => returnSteps(e),
                    () => returnSteps(e)
                  )
                : returnSteps(e),
            [v]() {
              return this;
            },
          },
          ie
        );
      }
      [L](e, r) {
        return be(e, r, this[Ie], {
          locked: this.locked,
          state: this[Pe].state,
          supportsBYOB:
            this[Pe].controller instanceof ReadableByteStreamController,
        });
      }
      [J]() {
        if (!Xe(this)) throw new F("ReadableStream");
        if (this.locked)
          throw (
            (this[Pe].transfer.port1?.close(),
            (this[Pe].transfer.port1 = void 0),
            (this[Pe].transfer.port2 = void 0),
            new Y("Cannot transfer a locked ReadableStream", "DataCloneError"))
          );
        const { writable: e, promise: r } = Ce().newCrossRealmWritableSink(
          this,
          this[Pe].transfer.port1
        );
        return (
          (this[Pe].transfer.writable = e),
          (this[Pe].transfer.promise = r),
          {
            data: { port: this[Pe].transfer.port2 },
            deserializeInfo:
              "internal/webstreams/readablestream:TransferredReadableStream",
          }
        );
      }
      [K]() {
        const { port1: e, port2: r } = new U();
        return (
          (this[Pe].transfer.port1 = e), (this[Pe].transfer.port2 = r), [r]
        );
      }
      [$]({ port: e }) {
        setupReadableStreamDefaultControllerFromSource(
          this,
          new (Ce().CrossRealmTransformReadableSource)(e),
          0,
          () => 1
        );
      }
    }
    function TransferredReadableStream() {
      return X(
        g(
          function () {
            (this[Ie] = "ReadableStream"),
              (this[Pe] = {
                disturbed: !1,
                state: "readable",
                storedError: void 0,
                stream: void 0,
                transfer: { writable: void 0, port: void 0, promise: void 0 },
              }),
              (this[ae] = N());
          },
          [],
          ReadableStream
        )
      );
    }
    h(ReadableStream.prototype, {
      [v]: {
        __proto__: null,
        configurable: !0,
        enumerable: !1,
        writable: !0,
        value: ReadableStream.prototype.values,
      },
      locked: Q,
      cancel: Q,
      getReader: Q,
      pipeThrough: Q,
      pipeTo: Q,
      tee: Q,
      [P]: getNonWritablePropertyDescriptor(ReadableStream.name),
    }),
      (TransferredReadableStream.prototype[$] = () => {});
    class ReadableStreamBYOBRequest {
      [Ie] = "ReadableStreamBYOBRequest";
      constructor(e = void 0) {
        if (e !== xe) throw new T();
      }
      get view() {
        if (!er(this)) throw new F("ReadableStreamBYOBRequest");
        return this[Pe].view;
      }
      respond(e) {
        if (!er(this)) throw new F("ReadableStreamBYOBRequest");
        const { view: r, controller: t } = this[Pe];
        if (void 0 === t)
          throw new z.TypeError("This BYOB request has been invalidated");
        const a = de(r),
          l = ne(r),
          o = d(l);
        if (_(l)) throw new z.TypeError("Viewed ArrayBuffer is detached");
        Le(a > 0), Le(o > 0), readableByteStreamControllerRespond(t, e);
      }
      respondWithNewView(e) {
        if (!er(this)) throw new F("ReadableStreamBYOBRequest");
        const { controller: r } = this[Pe];
        if (void 0 === r)
          throw new z.TypeError("This BYOB request has been invalidated");
        if ((M(e, "view"), ye(e)))
          throw new z.TypeError("Viewed ArrayBuffer is detached");
        readableByteStreamControllerRespondWithNewView(r, e);
      }
      [L](e, r) {
        return be(e, r, this[Ie], {
          view: this.view,
          controller: this[Pe].controller,
        });
      }
    }
    h(ReadableStreamBYOBRequest.prototype, {
      view: Q,
      respond: Q,
      respondWithNewView: Q,
      [P]: getNonWritablePropertyDescriptor(ReadableStreamBYOBRequest.name),
    });
    class DefaultReadRequest {
      constructor() {
        this[Pe] = N();
      }
      [Qe](e) {
        this[Pe].resolve?.({ value: e, done: !1 });
      }
      [He]() {
        this[Pe].resolve?.({ value: void 0, done: !0 });
      }
      [Ve](e) {
        this[Pe].reject?.(e);
      }
      get promise() {
        return this[Pe].promise;
      }
    }
    class ReadIntoRequest {
      constructor() {
        this[Pe] = N();
      }
      [Qe](e) {
        this[Pe].resolve?.({ value: e, done: !1 });
      }
      [He](e) {
        this[Pe].resolve?.({ value: e, done: !0 });
      }
      [Ve](e) {
        this[Pe].reject?.(e);
      }
      get promise() {
        return this[Pe].promise;
      }
    }
    class ReadableStreamDefaultReader {
      [Ie] = "ReadableStreamDefaultReader";
      constructor(e) {
        if (!Xe(e)) throw new k("stream", "ReadableStream", e);
        (this[Pe] = {
          readRequests: [],
          stream: void 0,
          close: { promise: void 0, resolve: void 0, reject: void 0 },
        }),
          setupReadableStreamDefaultReader(this, e);
      }
      read() {
        if (!rr(this)) return w(new F("ReadableStreamDefaultReader"));
        if (void 0 === this[Pe].stream)
          return w(new z.TypeError("The reader is not attached to a stream"));
        const e = new DefaultReadRequest();
        return readableStreamDefaultReaderRead(this, e), e.promise;
      }
      releaseLock() {
        if (!rr(this)) throw new F("ReadableStreamDefaultReader");
        void 0 !== this[Pe].stream && readableStreamDefaultReaderRelease(this);
      }
      get closed() {
        return rr(this)
          ? this[Pe].close.promise
          : w(new F("ReadableStreamDefaultReader"));
      }
      cancel(e = void 0) {
        return rr(this)
          ? void 0 === this[Pe].stream
            ? w(new z.TypeError("The reader is not attached to a stream"))
            : readableStreamReaderGenericCancel(this, e)
          : w(new F("ReadableStreamDefaultReader"));
      }
      [L](e, r) {
        return be(e, r, this[Ie], {
          stream: this[Pe].stream,
          readRequests: this[Pe].readRequests.length,
          close: this[Pe].close.promise,
        });
      }
    }
    h(ReadableStreamDefaultReader.prototype, {
      closed: Q,
      read: Q,
      releaseLock: Q,
      cancel: Q,
      [P]: getNonWritablePropertyDescriptor(ReadableStreamDefaultReader.name),
    });
    class ReadableStreamBYOBReader {
      [Ie] = "ReadableStreamBYOBReader";
      constructor(e) {
        if (!Xe(e)) throw new k("stream", "ReadableStream", e);
        (this[Pe] = {
          stream: void 0,
          requestIntoRequests: [],
          close: { promise: void 0, resolve: void 0, reject: void 0 },
        }),
          setupReadableStreamBYOBReader(this, e);
      }
      read(e) {
        if (!tr(this)) return w(new F("ReadableStreamBYOBReader"));
        if (!W(e))
          return w(new k("view", ["Buffer", "TypedArray", "DataView"], e));
        const r = de(e),
          t = ne(e),
          a = d(t);
        if (0 === r || 0 === a)
          return w(
            new z.TypeError(
              "View or Viewed ArrayBuffer is zero-length or detached"
            )
          );
        if (void 0 === this[Pe].stream)
          return w(new z.TypeError("The reader is not attached to a stream"));
        const l = new ReadIntoRequest();
        return readableStreamBYOBReaderRead(this, e, l), l.promise;
      }
      releaseLock() {
        if (!tr(this)) throw new F("ReadableStreamBYOBReader");
        void 0 !== this[Pe].stream && readableStreamBYOBReaderRelease(this);
      }
      get closed() {
        return tr(this)
          ? this[Pe].close.promise
          : w(new F("ReadableStreamBYOBReader"));
      }
      cancel(e = void 0) {
        return tr(this)
          ? void 0 === this[Pe].stream
            ? w(new z.TypeError("The reader is not attached to a stream"))
            : readableStreamReaderGenericCancel(this, e)
          : w(new F("ReadableStreamBYOBReader"));
      }
      [L](e, r) {
        return be(e, r, this[Ie], {
          stream: this[Pe].stream,
          requestIntoRequests: this[Pe].requestIntoRequests.length,
          close: this[Pe].close.promise,
        });
      }
    }
    h(ReadableStreamBYOBReader.prototype, {
      closed: Q,
      read: Q,
      releaseLock: Q,
      cancel: Q,
      [P]: getNonWritablePropertyDescriptor(ReadableStreamBYOBReader.name),
    });
    class ReadableStreamDefaultController {
      [Ie] = "ReadableStreamDefaultController";
      [Pe] = {};
      constructor(e = void 0) {
        if (e !== xe) throw new T();
      }
      get desiredSize() {
        return readableStreamDefaultControllerGetDesiredSize(this);
      }
      close() {
        if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))
          throw new z.TypeError("Controller is already closed");
        readableStreamDefaultControllerClose(this);
      }
      enqueue(e = void 0) {
        if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))
          throw new z.TypeError("Controller is already closed");
        readableStreamDefaultControllerEnqueue(this, e);
      }
      error(e = void 0) {
        readableStreamDefaultControllerError(this, e);
      }
      [_e](e) {
        return readableStreamDefaultControllerCancelSteps(this, e);
      }
      [je](e) {
        readableStreamDefaultControllerPullSteps(this, e);
      }
      [Me]() {}
      [L](e, r) {
        return be(e, r, this[Ie], {});
      }
    }
    h(ReadableStreamDefaultController.prototype, {
      desiredSize: Q,
      close: Q,
      enqueue: Q,
      error: Q,
      [P]: getNonWritablePropertyDescriptor(
        ReadableStreamDefaultController.name
      ),
    });
    class ReadableByteStreamController {
      [Ie] = "ReadableByteStreamController";
      [Pe] = {};
      constructor(e = void 0) {
        if (e !== xe) throw new T();
      }
      get byobRequest() {
        if (!Ze(this)) throw new F("ReadableByteStreamController");
        if (null === this[Pe].byobRequest && this[Pe].pendingPullIntos.length) {
          const {
              buffer: e,
              byteOffset: r,
              bytesFilled: t,
              byteLength: a,
            } = this[Pe].pendingPullIntos[0],
            l = new E(e, r + t, a - t);
          this[Pe].byobRequest = (function createReadableStreamBYOBRequest(
            e,
            r
          ) {
            const t = new ReadableStreamBYOBRequest(xe);
            return (t[Pe] = { controller: e, view: r }), t;
          })(this, l);
        }
        return this[Pe].byobRequest;
      }
      get desiredSize() {
        if (!Ze(this)) throw new F("ReadableByteStreamController");
        return readableByteStreamControllerGetDesiredSize(this);
      }
      close() {
        if (!Ze(this)) throw new F("ReadableByteStreamController");
        if (this[Pe].closeRequested)
          throw new z.TypeError("Controller is already closed");
        if ("readable" !== this[Pe].stream[Pe].state)
          throw new z.TypeError("ReadableStream is already closed");
        readableByteStreamControllerClose(this);
      }
      enqueue(e) {
        if (!Ze(this)) throw new F("ReadableByteStreamController");
        M(e);
        const r = de(e),
          t = ne(e),
          a = d(t);
        if (0 === r || 0 === a)
          throw new z.TypeError("chunk ArrayBuffer is zero-length or detached");
        if (this[Pe].closeRequested)
          throw new z.TypeError("Controller is already closed");
        if ("readable" !== this[Pe].stream[Pe].state)
          throw new z.TypeError("ReadableStream is already closed");
        readableByteStreamControllerEnqueue(this, e);
      }
      error(e = void 0) {
        if (!Ze(this)) throw new F("ReadableByteStreamController");
        readableByteStreamControllerError(this, e);
      }
      [_e](e) {
        return readableByteStreamControllerCancelSteps(this, e);
      }
      [je](e) {
        readableByteStreamControllerPullSteps(this, e);
      }
      [Me]() {
        const { pendingPullIntos: e } = this[Pe];
        if (e.length > 0) {
          const r = e[0];
          (r.type = "none"), (this[Pe].pendingPullIntos = [r]);
        }
      }
      [L](e, r) {
        return be(e, r, this[Ie], {});
      }
    }
    function createTeeReadableStream(e, r, t) {
      return g(
        function () {
          return (
            (this[Ie] = "ReadableStream"),
            (this[Pe] = {
              disturbed: !1,
              state: "readable",
              storedError: void 0,
              stream: void 0,
              transfer: { writable: void 0, port: void 0, promise: void 0 },
            }),
            (this[ae] = N()),
            setupReadableStreamDefaultControllerFromSource(
              this,
              R(null, {
                start: { __proto__: null, value: e },
                pull: { __proto__: null, value: r },
                cancel: { __proto__: null, value: t },
              }),
              1,
              () => 1
            ),
            X(this)
          );
        },
        [],
        ReadableStream
      );
    }
    h(ReadableByteStreamController.prototype, {
      byobRequest: Q,
      desiredSize: Q,
      close: Q,
      enqueue: Q,
      error: Q,
      [P]: getNonWritablePropertyDescriptor(ReadableByteStreamController.name),
    });
    const Xe = pe("ReadableStream"),
      Ze = pe("ReadableByteStreamController"),
      er = pe("ReadableStreamBYOBRequest"),
      rr = pe("ReadableStreamDefaultReader"),
      tr = pe("ReadableStreamBYOBReader");
    function readableStreamPipeTo(e, t, a, l, o, n) {
      let d, s, u;
      try {
        (d = new ReadableStreamDefaultReader(e)), (s = new Ee(t));
      } catch (e) {
        return w(e);
      }
      e[Pe].disturbed = !0;
      let m = !1;
      if (void 0 !== n)
        try {
          j(n, "options.signal");
        } catch (e) {
          return w(e);
        }
      const b = N();
      let c = B();
      function finalize(e, r) {
        We(s),
          readableStreamReaderGenericRelease(d),
          void 0 !== n && u?.[I](),
          e ? b.reject(r) : b.resolve();
      }
      async function waitForCurrentWrite() {
        const e = c;
        await e, e !== c && (await waitForCurrentWrite());
      }
      function shutdownWithAnAction(e, r, a) {
        function complete() {
          p(
            e(),
            () => finalize(r, a),
            (e) => finalize(!0, e)
          );
        }
        m ||
          ((m = !0),
          "writable" !== t[Pe].state || Fe(t)
            ? complete()
            : p(waitForCurrentWrite(), complete, (e) => finalize(!0, e)));
      }
      function shutdown(e, r) {
        m ||
          ((m = !0),
          "writable" !== t[Pe].state || Fe(t)
            ? finalize(e, r)
            : p(
                waitForCurrentWrite(),
                () => finalize(e, r),
                (e) => finalize(!0, e)
              ));
      }
      function abortAlgorithm() {
        let r;
        r =
          n.reason instanceof A
            ? new Y(n.reason.message, "AbortError")
            : n.reason;
        const a = [];
        l || i(a, () => ("writable" === t[Pe].state ? ze(t, r) : B())),
          o ||
            i(a, () =>
              "readable" === e[Pe].state ? readableStreamCancel(e, r) : B()
            ),
          shutdownWithAnAction(() => D(a, (e) => e()), !0, r);
      }
      function watchErrored(e, r, t) {
        "errored" === e[Pe].state ? t(e[Pe].storedError) : p(r, void 0, t);
      }
      async function step() {
        return (
          !!m ||
          (await s[Pe].ready.promise,
          new y((e, r) => {
            readableStreamDefaultReaderRead(d, {
              [Qe](r) {
                (c = Ge(s, r)), we(c), e(!1);
              },
              [He]: () => e(!0),
              [Ve]: r,
            });
          }))
        );
      }
      if (void 0 !== n) {
        if (n.aborted) return abortAlgorithm(), b.promise;
        (Je ??= r("events").addAbortListener), (u = Je(n, abortAlgorithm));
      }
      if (
        (we(
          (async function run() {
            for (; !(await step()); );
          })()
        ),
        watchErrored(e, d[Pe].close.promise, (e) => {
          if (!l) return shutdownWithAnAction(() => ze(t, e), !0, e);
          shutdown(!0, e);
        }),
        watchErrored(t, s[Pe].close.promise, (r) => {
          if (!o)
            return shutdownWithAnAction(
              () => readableStreamCancel(e, r),
              !0,
              r
            );
          shutdown(!0, r);
        }),
        (function watchClosed(e, r, t) {
          "closed" === e[Pe].state ? t() : p(r, t, () => {});
        })(e, d[Pe].close.promise, () => {
          if (!a) return shutdownWithAnAction(() => Ye(s));
          shutdown();
        }),
        Fe(t) || "closed" === t[Pe].state)
      ) {
        const r = new z.TypeError("Destination WritableStream is closed");
        o
          ? shutdown(!0, r)
          : shutdownWithAnAction(() => readableStreamCancel(e, r), !0, r);
      }
      return b.promise;
    }
    function readableStreamTee(e, r) {
      return Ze(e[Pe].controller)
        ? (function readableByteStreamTee(e) {
            Le(Xe(e)), Le(Ze(e[Pe].controller));
            let r,
              t,
              a,
              l,
              o = new ReadableStreamDefaultReader(e),
              n = !1,
              d = !1,
              s = !1,
              i = !1,
              u = !1;
            const m = N();
            function forwardReaderError(e) {
              p(e[Pe].close.promise, void 0, (r) => {
                e === o &&
                  (readableStreamDefaultControllerError(a[Pe].controller, r),
                  readableStreamDefaultControllerError(l[Pe].controller, r),
                  (i && u) || m.resolve());
              });
            }
            function pullWithDefaultReader() {
              tr(o) &&
                (readableStreamBYOBReaderRelease(o),
                (o = new ReadableStreamDefaultReader(e)),
                forwardReaderError(o));
              readableStreamDefaultReaderRead(o, {
                [Qe](r) {
                  Z(() => {
                    (d = !1), (s = !1);
                    const t = r;
                    let o = r;
                    if (!i && !u)
                      try {
                        o = ue(r);
                      } catch (r) {
                        return (
                          readableByteStreamControllerError(
                            a[Pe].controller,
                            r
                          ),
                          readableByteStreamControllerError(
                            l[Pe].controller,
                            r
                          ),
                          void m.resolve(readableStreamCancel(e, r))
                        );
                      }
                    i ||
                      readableByteStreamControllerEnqueue(a[Pe].controller, t),
                      u ||
                        readableByteStreamControllerEnqueue(
                          l[Pe].controller,
                          o
                        ),
                      (n = !1),
                      d ? pull1Algorithm() : s && pull2Algorithm();
                  });
                },
                [He]() {
                  (n = !1),
                    i || readableByteStreamControllerClose(a[Pe].controller),
                    u || readableByteStreamControllerClose(l[Pe].controller),
                    a[Pe].controller[Pe].pendingPullIntos.length > 0 &&
                      readableByteStreamControllerRespond(a[Pe].controller, 0),
                    l[Pe].controller[Pe].pendingPullIntos.length > 0 &&
                      readableByteStreamControllerRespond(l[Pe].controller, 0),
                    (i && u) || m.resolve();
                },
                [Ve]() {
                  n = !1;
                },
              });
            }
            function pullWithBYOBReader(r, t) {
              rr(o) &&
                (readableStreamDefaultReaderRelease(o),
                (o = new ReadableStreamBYOBReader(e)),
                forwardReaderError(o));
              const b = !0 === t ? l : a,
                c = !1 === t ? l : a;
              readableStreamBYOBReaderRead(o, r, {
                [Qe](r) {
                  Z(() => {
                    (d = !1), (s = !1);
                    const a = !0 === t ? u : i;
                    if (!1 === t ? u : i)
                      a ||
                        readableByteStreamControllerRespondWithNewView(
                          b[Pe].controller,
                          r
                        );
                    else {
                      let t;
                      try {
                        t = ue(r);
                      } catch (r) {
                        return (
                          readableByteStreamControllerError(
                            b[Pe].controller,
                            r
                          ),
                          readableByteStreamControllerError(
                            c[Pe].controller,
                            r
                          ),
                          void m.resolve(readableStreamCancel(e, r))
                        );
                      }
                      a ||
                        readableByteStreamControllerRespondWithNewView(
                          b[Pe].controller,
                          r
                        ),
                        readableByteStreamControllerEnqueue(
                          c[Pe].controller,
                          t
                        );
                    }
                    (n = !1), d ? pull1Algorithm() : s && pull2Algorithm();
                  });
                },
                [He](e) {
                  n = !1;
                  const r = !0 === t ? u : i,
                    a = !1 === t ? u : i;
                  r || readableByteStreamControllerClose(b[Pe].controller),
                    a || readableByteStreamControllerClose(c[Pe].controller),
                    void 0 !== e &&
                      (r ||
                        readableByteStreamControllerRespondWithNewView(
                          b[Pe].controller,
                          e
                        ),
                      !a &&
                        c[Pe].controller[Pe].pendingPullIntos.length > 0 &&
                        readableByteStreamControllerRespond(
                          c[Pe].controller,
                          0
                        )),
                    (r && a) || m.resolve();
                },
                [Ve]() {
                  n = !1;
                },
              });
            }
            function pull1Algorithm() {
              if (n) return (d = !0), B();
              n = !0;
              const e = a[Pe].controller.byobRequest;
              return (
                null === e
                  ? pullWithDefaultReader()
                  : pullWithBYOBReader(e[Pe].view, !1),
                B()
              );
            }
            function pull2Algorithm() {
              if (n) return (s = !0), B();
              n = !0;
              const e = l[Pe].controller.byobRequest;
              return (
                null === e
                  ? pullWithDefaultReader()
                  : pullWithBYOBReader(e[Pe].view, !0),
                B()
              );
            }
            function cancel1Algorithm(a) {
              return (
                (i = !0),
                (r = a),
                u && m.resolve(readableStreamCancel(e, [r, t])),
                m.promise
              );
            }
            function cancel2Algorithm(a) {
              return (
                (u = !0),
                (t = a),
                i && m.resolve(readableStreamCancel(e, [r, t])),
                m.promise
              );
            }
            return (
              (a = new ReadableStream({
                type: "bytes",
                pull: pull1Algorithm,
                cancel: cancel1Algorithm,
              })),
              (l = new ReadableStream({
                type: "bytes",
                pull: pull2Algorithm,
                cancel: cancel2Algorithm,
              })),
              forwardReaderError(o),
              [a, l]
            );
          })(e)
        : (function readableStreamDefaultTee(e, r) {
            const t = new ReadableStreamDefaultReader(e);
            let l,
              o,
              n,
              d,
              s = !1,
              i = !1,
              u = !1;
            const m = N();
            async function pullAlgorithm() {
              if (s) return;
              s = !0;
              readableStreamDefaultReaderRead(t, {
                [Qe](e) {
                  Z(() => {
                    s = !1;
                    const t = e;
                    let a = e;
                    !u && r && (a = oe(a)),
                      i ||
                        readableStreamDefaultControllerEnqueue(
                          n[Pe].controller,
                          t
                        ),
                      u ||
                        readableStreamDefaultControllerEnqueue(
                          d[Pe].controller,
                          a
                        );
                  });
                },
                [He]() {
                  a.nextTick(() => {
                    (s = !1),
                      i ||
                        readableStreamDefaultControllerClose(n[Pe].controller),
                      u ||
                        readableStreamDefaultControllerClose(d[Pe].controller),
                      (i && u) || m.resolve();
                  });
                },
                [Ve]() {
                  s = !1;
                },
              });
            }
            function cancel1Algorithm(r) {
              if (((i = !0), (l = r), u)) {
                const r = [l, o];
                m.resolve(readableStreamCancel(e, r));
              }
              return m.promise;
            }
            function cancel2Algorithm(r) {
              if (((u = !0), (o = r), i)) {
                const r = [l, o];
                m.resolve(readableStreamCancel(e, r));
              }
              return m.promise;
            }
            return (
              (n = createTeeReadableStream(
                ve,
                pullAlgorithm,
                cancel1Algorithm
              )),
              (d = createTeeReadableStream(
                ve,
                pullAlgorithm,
                cancel2Algorithm
              )),
              p(t[Pe].close.promise, void 0, (e) => {
                readableStreamDefaultControllerError(n[Pe].controller, e),
                  readableStreamDefaultControllerError(d[Pe].controller, e),
                  (i && u) || m.resolve();
              }),
              [n, d]
            );
          })(e, r);
    }
    function readableByteStreamControllerConvertPullIntoDescriptor(e) {
      const {
        buffer: r,
        bytesFilled: t,
        byteLength: a,
        byteOffset: l,
        ctor: o,
        elementSize: n,
      } = e;
      if (t > a) throw new z.RangeError("The buffer size is invalid");
      Le(!(t % n));
      const d = ge(r);
      return o === Ne ? Ne.from(d, l, t / n) : new o(d, l, t / n);
    }
    function isReadableStreamLocked(e) {
      return void 0 !== e[Pe].reader;
    }
    function readableStreamCancel(e, r) {
      switch (((e[Pe].disturbed = !0), e[Pe].state)) {
        case "closed":
          return B();
        case "errored":
          return w(e[Pe].storedError);
      }
      readableStreamClose(e);
      const { reader: t } = e[Pe];
      if (void 0 !== t && readableStreamHasBYOBReader(e)) {
        for (let e = 0; e < t[Pe].readIntoRequests.length; e++)
          t[Pe].readIntoRequests[e][He]();
        t[Pe].readIntoRequests = [];
      }
      return p(Se(e[Pe].controller[_e], e[Pe].controller, r), () => {});
    }
    function readableStreamClose(e) {
      Le("readable" === e[Pe].state), (e[Pe].state = "closed"), e[ae].resolve();
      const { reader: r } = e[Pe];
      if (
        void 0 !== r &&
        (r[Pe].close.resolve(), readableStreamHasDefaultReader(e))
      ) {
        for (let e = 0; e < r[Pe].readRequests.length; e++)
          r[Pe].readRequests[e][He]();
        r[Pe].readRequests = [];
      }
    }
    function readableStreamError(e, r) {
      Le("readable" === e[Pe].state),
        (e[Pe].state = "errored"),
        (e[Pe].storedError = r),
        e[ae].reject(r),
        we(e[ae].promise);
      const { reader: t } = e[Pe];
      if (void 0 !== t)
        if (
          (t[Pe].close.reject(r),
          we(t[Pe].close.promise),
          readableStreamHasDefaultReader(e))
        ) {
          for (let e = 0; e < t[Pe].readRequests.length; e++)
            t[Pe].readRequests[e][Ve](r);
          t[Pe].readRequests = [];
        } else {
          Le(readableStreamHasBYOBReader(e));
          for (let e = 0; e < t[Pe].readIntoRequests.length; e++)
            t[Pe].readIntoRequests[e][Ve](r);
          t[Pe].readIntoRequests = [];
        }
    }
    function readableStreamHasDefaultReader(e) {
      const { reader: r } = e[Pe];
      return (
        void 0 !== r &&
        void 0 !== r[Pe] &&
        "ReadableStreamDefaultReader" === r[Ie]
      );
    }
    function readableStreamGetNumReadRequests(e) {
      return (
        Le(readableStreamHasDefaultReader(e)),
        e[Pe].reader[Pe].readRequests.length
      );
    }
    function readableStreamHasBYOBReader(e) {
      const { reader: r } = e[Pe];
      return (
        void 0 !== r && void 0 !== r[Pe] && "ReadableStreamBYOBReader" === r[Ie]
      );
    }
    function readableStreamGetNumReadIntoRequests(e) {
      return (
        Le(readableStreamHasBYOBReader(e)),
        e[Pe].reader[Pe].readIntoRequests.length
      );
    }
    function readableStreamFulfillReadRequest(e, r, t) {
      Le(readableStreamHasDefaultReader(e));
      const { reader: a } = e[Pe];
      Le(a[Pe].readRequests.length);
      const l = u(a[Pe].readRequests);
      t ? l[He]() : l[Qe](r);
    }
    function readableStreamFulfillReadIntoRequest(e, r, t) {
      Le(readableStreamHasBYOBReader(e));
      const { reader: a } = e[Pe];
      Le(a[Pe].readIntoRequests.length);
      const l = u(a[Pe].readIntoRequests);
      t ? l[He](r) : l[Qe](r);
    }
    function readableStreamAddReadRequest(e, r) {
      Le(readableStreamHasDefaultReader(e)),
        Le("readable" === e[Pe].state),
        i(e[Pe].reader[Pe].readRequests, r);
    }
    function readableStreamAddReadIntoRequest(e, r) {
      Le(readableStreamHasBYOBReader(e)),
        Le("errored" !== e[Pe].state),
        i(e[Pe].reader[Pe].readIntoRequests, r);
    }
    function readableStreamReaderGenericCancel(e, r) {
      const { stream: t } = e[Pe];
      return Le(void 0 !== t), readableStreamCancel(t, r);
    }
    function readableStreamReaderGenericInitialize(e, r) {
      switch (((e[Pe].stream = r), (r[Pe].reader = e), r[Pe].state)) {
        case "readable":
          e[Pe].close = N();
          break;
        case "closed":
          e[Pe].close = { promise: B(), resolve: void 0, reject: void 0 };
          break;
        case "errored":
          (e[Pe].close = {
            promise: w(r[Pe].storedError),
            resolve: void 0,
            reject: void 0,
          }),
            we(e[Pe].close.promise);
      }
    }
    function readableStreamDefaultReaderRelease(e) {
      readableStreamReaderGenericRelease(e),
        (function readableStreamDefaultReaderErrorReadRequests(e, r) {
          for (let t = 0; t < e[Pe].readRequests.length; ++t)
            e[Pe].readRequests[t][Ve](r);
          e[Pe].readRequests = [];
        })(e, lazyReadableReleasingError());
    }
    function readableStreamBYOBReaderRelease(e) {
      readableStreamReaderGenericRelease(e),
        (function readableStreamBYOBReaderErrorReadIntoRequests(e, r) {
          for (let t = 0; t < e[Pe].readIntoRequests.length; ++t)
            e[Pe].readIntoRequests[t][Ve](r);
          e[Pe].readIntoRequests = [];
        })(e, lazyReadableReleasingError());
    }
    function readableStreamReaderGenericRelease(e) {
      const { stream: r } = e[Pe];
      Le(void 0 !== r), Le(r[Pe].reader === e);
      const t = (function lazyReadableReleasedError() {
        return (
          Ue ||
          ((Ue = new z.TypeError("Reader released")),
          (Ue.stack = V(Ke, Ue.stack, "")),
          Ue)
        );
      })();
      "readable" === r[Pe].state
        ? e[Pe].close.reject?.(t)
        : (e[Pe].close = { promise: w(t), resolve: void 0, reject: void 0 }),
        we(e[Pe].close.promise),
        r[Pe].controller[Me](),
        (r[Pe].reader = void 0),
        (e[Pe].stream = void 0);
    }
    function readableStreamBYOBReaderRead(e, r, t) {
      const { stream: a } = e[Pe];
      Le(void 0 !== a),
        (a[Pe].disturbed = !0),
        "errored" !== a[Pe].state
          ? readableByteStreamControllerPullInto(a[Pe].controller, r, t)
          : t[Ve](a[Pe].storedError);
    }
    function readableStreamDefaultReaderRead(e, r) {
      const { stream: t } = e[Pe];
      switch ((Le(void 0 !== t), (t[Pe].disturbed = !0), t[Pe].state)) {
        case "closed":
          r[He]();
          break;
        case "errored":
          r[Ve](t[Pe].storedError);
          break;
        case "readable":
          t[Pe].controller[je](r);
      }
    }
    function setupReadableStreamBYOBReader(e, r) {
      if (isReadableStreamLocked(r))
        throw new z.TypeError("ReadableStream is locked");
      const { controller: t } = r[Pe];
      if (!Ze(t)) throw new O("stream", r, "must be a byte stream");
      readableStreamReaderGenericInitialize(e, r),
        (e[Pe].readIntoRequests = []);
    }
    function setupReadableStreamDefaultReader(e, r) {
      if (isReadableStreamLocked(r))
        throw new z.TypeError("ReadableStream is locked");
      readableStreamReaderGenericInitialize(e, r), (e[Pe].readRequests = []);
    }
    function readableStreamDefaultControllerClose(e) {
      readableStreamDefaultControllerCanCloseOrEnqueue(e) &&
        ((e[Pe].closeRequested = !0),
        e[Pe].queue.length ||
          (readableStreamDefaultControllerClearAlgorithms(e),
          readableStreamClose(e[Pe].stream)));
    }
    function readableStreamDefaultControllerEnqueue(e, r) {
      if (!readableStreamDefaultControllerCanCloseOrEnqueue(e)) return;
      const { stream: t } = e[Pe];
      if (isReadableStreamLocked(t) && readableStreamGetNumReadRequests(t))
        readableStreamFulfillReadRequest(t, r, !1);
      else
        try {
          const t = c(e[Pe].sizeAlgorithm, void 0, r);
          fe(e, r, t);
        } catch (r) {
          throw (readableStreamDefaultControllerError(e, r), r);
        }
      readableStreamDefaultControllerCallPullIfNeeded(e);
    }
    function readableStreamDefaultControllerCanCloseOrEnqueue(e) {
      const { stream: r } = e[Pe];
      return !e[Pe].closeRequested && "readable" === r[Pe].state;
    }
    function readableStreamDefaultControllerGetDesiredSize(e) {
      const { stream: r, highWaterMark: t, queueTotalSize: a } = e[Pe];
      switch (r[Pe].state) {
        case "errored":
          return null;
        case "closed":
          return 0;
        default:
          return t - a;
      }
    }
    function readableStreamDefaultControllerShouldCallPull(e) {
      const { stream: r } = e[Pe];
      if (
        !readableStreamDefaultControllerCanCloseOrEnqueue(e) ||
        !e[Pe].started
      )
        return !1;
      if (isReadableStreamLocked(r) && readableStreamGetNumReadRequests(r))
        return !0;
      const t = readableStreamDefaultControllerGetDesiredSize(e);
      return Le(null !== t), t > 0;
    }
    function readableStreamDefaultControllerCallPullIfNeeded(e) {
      readableStreamDefaultControllerShouldCallPull(e) &&
        (e[Pe].pulling
          ? (e[Pe].pullAgain = !0)
          : (Le(!e[Pe].pullAgain),
            (e[Pe].pulling = !0),
            p(
              Se(e[Pe].pullAlgorithm, e),
              () => {
                (e[Pe].pulling = !1),
                  e[Pe].pullAgain &&
                    ((e[Pe].pullAgain = !1),
                    readableStreamDefaultControllerCallPullIfNeeded(e));
              },
              (r) => readableStreamDefaultControllerError(e, r)
            )));
    }
    function readableStreamDefaultControllerClearAlgorithms(e) {
      (e[Pe].pullAlgorithm = void 0),
        (e[Pe].cancelAlgorithm = void 0),
        (e[Pe].sizeAlgorithm = void 0);
    }
    function readableStreamDefaultControllerError(e, r) {
      const { stream: t } = e[Pe];
      "readable" === t[Pe].state &&
        (Be(e),
        readableStreamDefaultControllerClearAlgorithms(e),
        readableStreamError(t, r));
    }
    function readableStreamDefaultControllerCancelSteps(e, r) {
      Be(e);
      try {
        return e[Pe].cancelAlgorithm(r);
      } finally {
        readableStreamDefaultControllerClearAlgorithms(e);
      }
    }
    function readableStreamDefaultControllerPullSteps(e, r) {
      const { stream: t, queue: a } = e[Pe];
      if (a.length) {
        const l = ce(e);
        return (
          e[Pe].closeRequested && !a.length
            ? (readableStreamDefaultControllerClearAlgorithms(e),
              readableStreamClose(t))
            : readableStreamDefaultControllerCallPullIfNeeded(e),
          void r[Qe](l)
        );
      }
      readableStreamAddReadRequest(t, r),
        readableStreamDefaultControllerCallPullIfNeeded(e);
    }
    function setupReadableStreamDefaultController(e, r, t, a, l, o, n) {
      Le(void 0 === e[Pe].controller),
        (r[Pe] = {
          cancelAlgorithm: l,
          closeRequested: !1,
          highWaterMark: o,
          pullAgain: !1,
          pullAlgorithm: a,
          pulling: !1,
          queue: [],
          queueTotalSize: 0,
          started: !1,
          sizeAlgorithm: n,
          stream: e,
        }),
        (e[Pe].controller = r),
        (e[le] = b(r.error, r));
      const d = t();
      p(
        B(d),
        () => {
          (r[Pe].started = !0),
            Le(!r[Pe].pulling),
            Le(!r[Pe].pullAgain),
            readableStreamDefaultControllerCallPullIfNeeded(r);
        },
        (e) => readableStreamDefaultControllerError(r, e)
      );
    }
    function setupReadableStreamDefaultControllerFromSource(e, r, t, a) {
      const l = new ReadableStreamDefaultController(xe),
        o = r?.start,
        n = r?.pull,
        d = r?.cancel;
      setupReadableStreamDefaultController(
        e,
        l,
        o ? b(o, r, l) : ve,
        n ? b(n, r, l) : qe,
        d ? b(d, r) : De,
        t,
        a
      );
    }
    function readableByteStreamControllerClose(e) {
      const {
        closeRequested: r,
        pendingPullIntos: t,
        queueTotalSize: a,
        stream: l,
      } = e[Pe];
      if (!r && "readable" === l[Pe].state)
        if (a) e[Pe].closeRequested = !0;
        else {
          if (t.length) {
            if (t[0].bytesFilled > 0) {
              const r = new z.TypeError("Partial read");
              throw (readableByteStreamControllerError(e, r), r);
            }
          }
          readableByteStreamControllerClearAlgorithms(e),
            readableStreamClose(l);
        }
    }
    function readableByteStreamControllerCommitPullIntoDescriptor(e, r) {
      Le("errored" !== e[Pe].state), Le("none" !== r.type);
      let t = !1;
      "closed" === e[Pe].state && ((r.bytesFilled = 0), (t = !0));
      const a = readableByteStreamControllerConvertPullIntoDescriptor(r);
      "default" === r.type
        ? readableStreamFulfillReadRequest(e, a, t)
        : (Le("byob" === r.type),
          readableStreamFulfillReadIntoRequest(e, a, t));
    }
    function readableByteStreamControllerInvalidateBYOBRequest(e) {
      null !== e[Pe].byobRequest &&
        ((e[Pe].byobRequest[Pe].controller = void 0),
        (e[Pe].byobRequest[Pe].view = null),
        (e[Pe].byobRequest = null));
    }
    function readableByteStreamControllerClearAlgorithms(e) {
      (e[Pe].pullAlgorithm = void 0), (e[Pe].cancelAlgorithm = void 0);
    }
    function readableByteStreamControllerClearPendingPullIntos(e) {
      readableByteStreamControllerInvalidateBYOBRequest(e),
        (e[Pe].pendingPullIntos = []);
    }
    function readableByteStreamControllerGetDesiredSize(e) {
      const { stream: r, highWaterMark: t, queueTotalSize: a } = e[Pe];
      switch (r[Pe].state) {
        case "errored":
          return null;
        case "closed":
          return 0;
        default:
          return t - a;
      }
    }
    function readableByteStreamControllerShouldCallPull(e) {
      const { stream: r } = e[Pe];
      if ("readable" !== r[Pe].state || e[Pe].closeRequested || !e[Pe].started)
        return !1;
      if (
        readableStreamHasDefaultReader(r) &&
        readableStreamGetNumReadRequests(r) > 0
      )
        return !0;
      if (
        readableStreamHasBYOBReader(r) &&
        readableStreamGetNumReadIntoRequests(r) > 0
      )
        return !0;
      const t = readableByteStreamControllerGetDesiredSize(e);
      return Le(null !== t), t > 0;
    }
    function readableByteStreamControllerHandleQueueDrain(e) {
      const { closeRequested: r, queueTotalSize: t, stream: a } = e[Pe];
      if ((Le("readable" === a[Pe].state), !t && r))
        return (
          readableByteStreamControllerClearAlgorithms(e),
          void readableStreamClose(a)
        );
      readableByteStreamControllerCallPullIfNeeded(e);
    }
    function readableByteStreamControllerPullInto(e, r, t) {
      const { closeRequested: a, stream: l, pendingPullIntos: o } = e[Pe];
      let n = 1,
        s = m;
      W(r) &&
        !G(r) &&
        ((n = r.constructor.BYTES_PER_ELEMENT), (s = r.constructor));
      const u = ne(r),
        b = se(r),
        c = de(r),
        S = d(u);
      let f;
      try {
        f = ge(u);
      } catch (e) {
        return void t[Ve](e);
      }
      const R = {
        buffer: f,
        bufferByteLength: S,
        byteOffset: b,
        byteLength: c,
        bytesFilled: 0,
        elementSize: n,
        ctor: s,
        type: "byob",
      };
      if (o.length) return i(o, R), void readableStreamAddReadIntoRequest(l, t);
      if ("closed" !== l[Pe].state) {
        if (e[Pe].queueTotalSize) {
          if (
            readableByteStreamControllerFillPullIntoDescriptorFromQueue(e, R)
          ) {
            const r = readableByteStreamControllerConvertPullIntoDescriptor(R);
            return (
              readableByteStreamControllerHandleQueueDrain(e), void t[Qe](r)
            );
          }
          if (a) {
            const r = new z.TypeError("ReadableStream closed");
            return readableByteStreamControllerError(e, r), void t[Ve](r);
          }
        }
        i(o, R),
          readableStreamAddReadIntoRequest(l, t),
          readableByteStreamControllerCallPullIfNeeded(e);
      } else {
        const e = new s(R.buffer, b, 0);
        t[He](e);
      }
    }
    function readableByteStreamControllerRespondInternal(e, r) {
      const { stream: t, pendingPullIntos: a } = e[Pe],
        l = a[0];
      if (
        (readableByteStreamControllerInvalidateBYOBRequest(e),
        "closed" === t[Pe].state)
      ) {
        if (r)
          throw new z.TypeError(
            "Controller is closed but view is not zero-length"
          );
        readableByteStreamControllerRespondInClosedState(e, l);
      } else {
        if ((Le("readable" === t[Pe].state), !r))
          throw new z.TypeError("View cannot be zero-length");
        readableByteStreamControllerRespondInReadableState(e, r, l);
      }
      readableByteStreamControllerCallPullIfNeeded(e);
    }
    function readableByteStreamControllerRespond(e, r) {
      const { pendingPullIntos: t, stream: a } = e[Pe];
      Le(t.length);
      const l = t[0];
      if ("closed" === a[Pe].state) {
        if (0 !== r) throw new O("bytesWritten", r);
      } else {
        if ((Le("readable" === a[Pe].state), !r))
          throw new O("bytesWritten", r);
        if (l.bytesFilled + r > l.byteLength)
          throw new O.RangeError("bytesWritten", r);
      }
      (l.buffer = ge(l.buffer)),
        readableByteStreamControllerRespondInternal(e, r);
    }
    function readableByteStreamControllerRespondInClosedState(e, r) {
      Le(!r.bytesFilled),
        "none" === r.type &&
          readableByteStreamControllerShiftPendingPullInto(e);
      const { stream: t } = e[Pe];
      if (readableStreamHasBYOBReader(t))
        for (; readableStreamGetNumReadIntoRequests(t) > 0; )
          readableByteStreamControllerCommitPullIntoDescriptor(
            t,
            readableByteStreamControllerShiftPendingPullInto(e)
          );
    }
    function readableByteStreamControllerFillHeadPullIntoDescriptor(e, r, t) {
      const { pendingPullIntos: a, byobRequest: l } = e[Pe];
      Le(!a.length || a[0] === t), Le(null === l), (t.bytesFilled += r);
    }
    function readableByteStreamControllerEnqueue(e, r) {
      const {
          closeRequested: t,
          pendingPullIntos: a,
          queue: l,
          stream: o,
        } = e[Pe],
        n = ne(r),
        d = se(r),
        s = de(r);
      if (t || "readable" !== o[Pe].state) return;
      const i = ge(n);
      if (a.length) {
        const r = a[0];
        if (_(r.buffer))
          throw new z.TypeError("Destination ArrayBuffer is detached");
        readableByteStreamControllerInvalidateBYOBRequest(e),
          (r.buffer = ge(r.buffer)),
          "none" === r.type &&
            readableByteStreamControllerEnqueueDetachedPullIntoToQueue(e, r);
      }
      if (readableStreamHasDefaultReader(o))
        if (
          ((function readableByteStreamControllerProcessReadRequestsUsingQueue(
            e
          ) {
            const { stream: r, queueTotalSize: t } = e[Pe],
              { reader: a } = r[Pe];
            Le(rr(a));
            for (; a[Pe].readRequests.length > 0; ) {
              if (0 === t) return;
              readableByteStreamControllerFillReadRequestFromQueue(
                e,
                u(a[Pe].readRequests)
              );
            }
          })(e),
          readableStreamGetNumReadRequests(o))
        ) {
          Le(!l.length),
            a.length &&
              (Le("default" === a[0].type),
              readableByteStreamControllerShiftPendingPullInto(e));
          readableStreamFulfillReadRequest(o, new E(i, d, s), !1);
        } else readableByteStreamControllerEnqueueChunkToQueue(e, i, d, s);
      else
        readableStreamHasBYOBReader(o)
          ? (readableByteStreamControllerEnqueueChunkToQueue(e, i, d, s),
            readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e))
          : (Le(!isReadableStreamLocked(o)),
            readableByteStreamControllerEnqueueChunkToQueue(e, i, d, s));
      readableByteStreamControllerCallPullIfNeeded(e);
    }
    function readableByteStreamControllerEnqueueChunkToQueue(e, r, t, a) {
      i(e[Pe].queue, { buffer: r, byteOffset: t, byteLength: a }),
        (e[Pe].queueTotalSize += a);
    }
    function readableByteStreamControllerEnqueueDetachedPullIntoToQueue(e, r) {
      const { buffer: t, byteOffset: a, bytesFilled: l, type: o } = r;
      Le("none" === o),
        l > 0 &&
          (function readableByteStreamControllerEnqueueClonedChunkToQueue(
            e,
            r,
            t,
            a
          ) {
            let l;
            try {
              l = s(r, t, t + a);
            } catch (r) {
              throw (readableByteStreamControllerError(e, r), r);
            }
            readableByteStreamControllerEnqueueChunkToQueue(e, l, 0, a);
          })(e, t, a, l),
        readableByteStreamControllerShiftPendingPullInto(e);
    }
    function readableByteStreamControllerFillPullIntoDescriptorFromQueue(e, r) {
      const {
          buffer: t,
          byteLength: a,
          byteOffset: l,
          bytesFilled: o,
          elementSize: n,
        } = r,
        s = o - (o % n),
        i = S(e[Pe].queueTotalSize, a - o),
        m = o + i,
        b = m - (m % n);
      let c = i,
        f = !1;
      b > s && ((c = b - o), (f = !0));
      const { queue: R } = e[Pe];
      for (; c; ) {
        const a = R[0],
          o = S(c, a.byteLength),
          n = l + r.bytesFilled,
          s = d(t);
        if (s - n < o)
          throw new z.RangeError("view ArrayBuffer size is invalid");
        Le(s - n >= o),
          me(t, n, a.buffer, a.byteOffset, o),
          a.byteLength === o
            ? u(R)
            : ((a.byteOffset += o), (a.byteLength -= o)),
          (e[Pe].queueTotalSize -= o),
          readableByteStreamControllerFillHeadPullIntoDescriptor(e, o, r),
          (c -= o);
      }
      return (
        f ||
          (Le(!e[Pe].queueTotalSize),
          Le(r.bytesFilled > 0),
          Le(r.bytesFilled < n)),
        f
      );
    }
    function readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
      e
    ) {
      const { closeRequested: r, pendingPullIntos: t, stream: a } = e[Pe];
      for (Le(!r); t.length; ) {
        if (!e[Pe].queueTotalSize) return;
        const r = t[0];
        readableByteStreamControllerFillPullIntoDescriptorFromQueue(e, r) &&
          (readableByteStreamControllerShiftPendingPullInto(e),
          readableByteStreamControllerCommitPullIntoDescriptor(a, r));
      }
    }
    function readableByteStreamControllerRespondInReadableState(e, r, t) {
      const { buffer: a, bytesFilled: l, byteLength: o, type: n } = t;
      if (l + r > o) throw new z.RangeError("The buffer size is invalid");
      if (
        (readableByteStreamControllerFillHeadPullIntoDescriptor(e, r, t),
        "none" === n)
      )
        return (
          readableByteStreamControllerEnqueueDetachedPullIntoToQueue(e, t),
          void readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(
            e
          )
        );
      if (t.bytesFilled < t.elementSize) return;
      readableByteStreamControllerShiftPendingPullInto(e);
      const i = t.bytesFilled % t.elementSize;
      if (i) {
        const r = t.byteOffset + t.bytesFilled,
          l = s(a, r - i, r);
        readableByteStreamControllerEnqueueChunkToQueue(e, l, 0, d(l));
      }
      (t.bytesFilled -= i),
        readableByteStreamControllerCommitPullIntoDescriptor(e[Pe].stream, t),
        readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e);
    }
    function readableByteStreamControllerRespondWithNewView(e, r) {
      const { stream: t, pendingPullIntos: a } = e[Pe];
      Le(a.length);
      const l = a[0];
      Le("errored" !== t[Pe].state);
      const o = de(r),
        n = se(r),
        s = ne(r),
        i = d(s);
      if ("closed" === t[Pe].state) {
        if (0 !== o) throw new z.TypeError("View is not zero-length");
      } else if ((Le("readable" === t[Pe].state), 0 === o))
        throw new z.TypeError("View is zero-length");
      const {
        byteOffset: u,
        byteLength: m,
        bytesFilled: b,
        bufferByteLength: c,
      } = l;
      if (u + b !== n) throw new O.RangeError("view", r);
      if (b + o > m) throw new O.RangeError("view", r);
      if (c !== i) throw new O.RangeError("view", r);
      (l.buffer = ge(s)), readableByteStreamControllerRespondInternal(e, o);
    }
    function readableByteStreamControllerShiftPendingPullInto(e) {
      return Le(null === e[Pe].byobRequest), u(e[Pe].pendingPullIntos);
    }
    function readableByteStreamControllerCallPullIfNeeded(e) {
      readableByteStreamControllerShouldCallPull(e) &&
        (e[Pe].pulling
          ? (e[Pe].pullAgain = !0)
          : (Le(!e[Pe].pullAgain),
            (e[Pe].pulling = !0),
            p(
              Se(e[Pe].pullAlgorithm, e),
              () => {
                (e[Pe].pulling = !1),
                  e[Pe].pullAgain &&
                    ((e[Pe].pullAgain = !1),
                    readableByteStreamControllerCallPullIfNeeded(e));
              },
              (r) => readableByteStreamControllerError(e, r)
            )));
    }
    function readableByteStreamControllerError(e, r) {
      const { stream: t } = e[Pe];
      "readable" === t[Pe].state &&
        (readableByteStreamControllerClearPendingPullIntos(e),
        Be(e),
        readableByteStreamControllerClearAlgorithms(e),
        readableStreamError(t, r));
    }
    function readableByteStreamControllerCancelSteps(e, r) {
      readableByteStreamControllerClearPendingPullIntos(e), Be(e);
      const t = e[Pe].cancelAlgorithm(r);
      return readableByteStreamControllerClearAlgorithms(e), t;
    }
    function readableByteStreamControllerFillReadRequestFromQueue(e, r) {
      const { queue: t, queueTotalSize: a } = e[Pe];
      Le(a > 0);
      const { buffer: l, byteOffset: o, byteLength: n } = u(t);
      (e[Pe].queueTotalSize -= n),
        readableByteStreamControllerHandleQueueDrain(e);
      const d = new E(l, o, n);
      r[Qe](d);
    }
    function readableByteStreamControllerPullSteps(e, r) {
      const { pendingPullIntos: t, queueTotalSize: a, stream: l } = e[Pe];
      if ((Le(readableStreamHasDefaultReader(l)), a))
        return (
          Le(!readableStreamGetNumReadRequests(l)),
          void readableByteStreamControllerFillReadRequestFromQueue(e, r)
        );
      const { autoAllocateChunkSize: o } = e[Pe];
      if (void 0 !== o)
        try {
          const e = new n(o);
          i(t, {
            buffer: e,
            bufferByteLength: o,
            byteOffset: 0,
            byteLength: o,
            bytesFilled: 0,
            elementSize: 1,
            ctor: E,
            type: "default",
          });
        } catch (e) {
          return void r[Ve](e);
        }
      readableStreamAddReadRequest(l, r),
        readableByteStreamControllerCallPullIfNeeded(e);
    }
    function setupReadableByteStreamController(e, r, t, a, l, o, n) {
      Le(void 0 === e[Pe].controller),
        void 0 !== n && (Le(f(n)), Le(n > 0)),
        (r[Pe] = {
          byobRequest: null,
          closeRequested: !1,
          pullAgain: !1,
          pulling: !1,
          started: !1,
          stream: e,
          queue: [],
          queueTotalSize: 0,
          highWaterMark: o,
          pullAlgorithm: a,
          cancelAlgorithm: l,
          autoAllocateChunkSize: n,
          pendingPullIntos: [],
        }),
        (e[Pe].controller = r);
      const d = t();
      p(
        B(d),
        () => {
          (r[Pe].started = !0),
            Le(!r[Pe].pulling),
            Le(!r[Pe].pullAgain),
            readableByteStreamControllerCallPullIfNeeded(r);
        },
        (e) => readableByteStreamControllerError(r, e)
      );
    }
    function setupReadableByteStreamControllerFromSource(e, r, t) {
      const a = new ReadableByteStreamController(xe),
        l = r?.start,
        o = r?.pull,
        n = r?.cancel,
        d = r?.autoAllocateChunkSize,
        s = l ? b(l, r, a) : ve,
        i = o ? b(o, r, a) : qe,
        u = n ? b(n, r) : De;
      if (0 === d) throw new O("source.autoAllocateChunkSize", d);
      setupReadableByteStreamController(e, a, s, i, u, t, d);
    }
    t.exports = {
      ReadableStream: ReadableStream,
      ReadableStreamDefaultReader: ReadableStreamDefaultReader,
      ReadableStreamBYOBReader: ReadableStreamBYOBReader,
      ReadableStreamBYOBRequest: ReadableStreamBYOBRequest,
      ReadableByteStreamController: ReadableByteStreamController,
      ReadableStreamDefaultController: ReadableStreamDefaultController,
      TransferredReadableStream: TransferredReadableStream,
      isReadableStream: Xe,
      isReadableByteStreamController: Ze,
      isReadableStreamBYOBRequest: er,
      isReadableStreamDefaultReader: rr,
      isReadableStreamBYOBReader: tr,
      isWritableStreamDefaultWriter: ke,
      isWritableStreamDefaultController: Oe,
      readableStreamPipeTo: readableStreamPipeTo,
      readableStreamTee: readableStreamTee,
      readableByteStreamControllerConvertPullIntoDescriptor:
        readableByteStreamControllerConvertPullIntoDescriptor,
      isReadableStreamLocked: isReadableStreamLocked,
      readableStreamCancel: readableStreamCancel,
      readableStreamClose: readableStreamClose,
      readableStreamError: readableStreamError,
      readableStreamHasDefaultReader: readableStreamHasDefaultReader,
      readableStreamGetNumReadRequests: readableStreamGetNumReadRequests,
      readableStreamHasBYOBReader: readableStreamHasBYOBReader,
      readableStreamGetNumReadIntoRequests:
        readableStreamGetNumReadIntoRequests,
      readableStreamFulfillReadRequest: readableStreamFulfillReadRequest,
      readableStreamFulfillReadIntoRequest:
        readableStreamFulfillReadIntoRequest,
      readableStreamAddReadRequest: readableStreamAddReadRequest,
      readableStreamAddReadIntoRequest: readableStreamAddReadIntoRequest,
      readableStreamReaderGenericCancel: readableStreamReaderGenericCancel,
      readableStreamReaderGenericInitialize:
        readableStreamReaderGenericInitialize,
      readableStreamReaderGenericRelease: readableStreamReaderGenericRelease,
      readableStreamBYOBReaderRead: readableStreamBYOBReaderRead,
      readableStreamDefaultReaderRead: readableStreamDefaultReaderRead,
      setupReadableStreamBYOBReader: setupReadableStreamBYOBReader,
      setupReadableStreamDefaultReader: setupReadableStreamDefaultReader,
      readableStreamDefaultControllerClose:
        readableStreamDefaultControllerClose,
      readableStreamDefaultControllerEnqueue:
        readableStreamDefaultControllerEnqueue,
      readableStreamDefaultControllerHasBackpressure:
        function readableStreamDefaultControllerHasBackpressure(e) {
          return !readableStreamDefaultControllerShouldCallPull(e);
        },
      readableStreamDefaultControllerCanCloseOrEnqueue:
        readableStreamDefaultControllerCanCloseOrEnqueue,
      readableStreamDefaultControllerGetDesiredSize:
        readableStreamDefaultControllerGetDesiredSize,
      readableStreamDefaultControllerShouldCallPull:
        readableStreamDefaultControllerShouldCallPull,
      readableStreamDefaultControllerCallPullIfNeeded:
        readableStreamDefaultControllerCallPullIfNeeded,
      readableStreamDefaultControllerClearAlgorithms:
        readableStreamDefaultControllerClearAlgorithms,
      readableStreamDefaultControllerError:
        readableStreamDefaultControllerError,
      readableStreamDefaultControllerCancelSteps:
        readableStreamDefaultControllerCancelSteps,
      readableStreamDefaultControllerPullSteps:
        readableStreamDefaultControllerPullSteps,
      setupReadableStreamDefaultController:
        setupReadableStreamDefaultController,
      setupReadableStreamDefaultControllerFromSource:
        setupReadableStreamDefaultControllerFromSource,
      readableByteStreamControllerClose: readableByteStreamControllerClose,
      readableByteStreamControllerCommitPullIntoDescriptor:
        readableByteStreamControllerCommitPullIntoDescriptor,
      readableByteStreamControllerInvalidateBYOBRequest:
        readableByteStreamControllerInvalidateBYOBRequest,
      readableByteStreamControllerClearAlgorithms:
        readableByteStreamControllerClearAlgorithms,
      readableByteStreamControllerClearPendingPullIntos:
        readableByteStreamControllerClearPendingPullIntos,
      readableByteStreamControllerGetDesiredSize:
        readableByteStreamControllerGetDesiredSize,
      readableByteStreamControllerShouldCallPull:
        readableByteStreamControllerShouldCallPull,
      readableByteStreamControllerHandleQueueDrain:
        readableByteStreamControllerHandleQueueDrain,
      readableByteStreamControllerPullInto:
        readableByteStreamControllerPullInto,
      readableByteStreamControllerRespondInternal:
        readableByteStreamControllerRespondInternal,
      readableByteStreamControllerRespond: readableByteStreamControllerRespond,
      readableByteStreamControllerRespondInClosedState:
        readableByteStreamControllerRespondInClosedState,
      readableByteStreamControllerFillHeadPullIntoDescriptor:
        readableByteStreamControllerFillHeadPullIntoDescriptor,
      readableByteStreamControllerEnqueue: readableByteStreamControllerEnqueue,
      readableByteStreamControllerEnqueueChunkToQueue:
        readableByteStreamControllerEnqueueChunkToQueue,
      readableByteStreamControllerFillPullIntoDescriptorFromQueue:
        readableByteStreamControllerFillPullIntoDescriptorFromQueue,
      readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue:
        readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue,
      readableByteStreamControllerRespondInReadableState:
        readableByteStreamControllerRespondInReadableState,
      readableByteStreamControllerRespondWithNewView:
        readableByteStreamControllerRespondWithNewView,
      readableByteStreamControllerShiftPendingPullInto:
        readableByteStreamControllerShiftPendingPullInto,
      readableByteStreamControllerCallPullIfNeeded:
        readableByteStreamControllerCallPullIfNeeded,
      readableByteStreamControllerError: readableByteStreamControllerError,
      readableByteStreamControllerCancelSteps:
        readableByteStreamControllerCancelSteps,
      readableByteStreamControllerPullSteps:
        readableByteStreamControllerPullSteps,
      setupReadableByteStreamController: setupReadableByteStreamController,
      setupReadableByteStreamControllerFromSource:
        setupReadableByteStreamControllerFromSource,
    };
  },
  "internal/webstreams/transfer": function (e, r, s, t, a, o) {
    "use strict";
    const {
        ObjectDefineProperties: n,
        PromiseResolve: l,
        ReflectConstruct: i,
      } = o,
      { kState: c, setPromiseHandled: m } = r("internal/webstreams/util"),
      { DOMException: p } = a("messaging"),
      {
        ReadableStream: b,
        readableStreamDefaultControllerEnqueue: u,
        readableStreamDefaultControllerClose: h,
        readableStreamDefaultControllerError: d,
        readableStreamPipeTo: f,
      } = r("internal/webstreams/readablestream"),
      { WritableStream: C, writableStreamDefaultControllerErrorIfNeeded: g } =
        r("internal/webstreams/writablestream"),
      { createDeferredPromise: w } = r("internal/util"),
      k = r("internal/assert"),
      {
        makeTransferable: D,
        kClone: M,
        kDeserialize: v,
      } = r("internal/worker/js_transferable");
    class CloneableDOMException extends p {
      constructor(e, r) {
        return (
          super(e, r),
          this[v]({ message: this.message, name: this.name, code: this.code }),
          D(this)
        );
      }
      [M]() {
        return {
          data: { message: this.message, name: this.name, code: this.code },
          deserializeInfo:
            "internal/webstreams/transfer:InternalCloneableDOMException",
        };
      }
      [v]({ message: e, name: r, code: s }) {
        n(this, {
          message: {
            __proto__: null,
            configurable: !0,
            enumerable: !0,
            get: () => e,
          },
          name: {
            __proto__: null,
            configurable: !0,
            enumerable: !0,
            get: () => r,
          },
          code: {
            __proto__: null,
            configurable: !0,
            enumerable: !0,
            get: () => s,
          },
        });
      }
    }
    function InternalCloneableDOMException() {
      return D(i(CloneableDOMException, [], p));
    }
    InternalCloneableDOMException[v] = () => {};
    class CrossRealmTransformReadableSource {
      constructor(e) {
        (this[c] = { port: e, controller: void 0 }),
          (e.onmessage = ({ data: r }) => {
            const { controller: s } = this[c],
              { type: t, value: a } = r;
            switch (t) {
              case "chunk":
                u(s, a);
                break;
              case "close":
                h(s), e.close();
                break;
              case "error":
                d(s, a), e.close();
            }
          }),
          (e.onmessageerror = () => {
            const r = new CloneableDOMException(
              "Internal transferred ReadableStream error",
              "DataCloneError"
            );
            e.postMessage({ type: "error", value: r }),
              d(this[c].controller, r),
              e.close();
          });
      }
      start(e) {
        this[c].controller = e;
      }
      async pull() {
        this[c].port.postMessage({ type: "pull" });
      }
      async cancel(e) {
        try {
          this[c].port.postMessage({ type: "error", value: e });
        } catch (e) {
          throw (
            (e instanceof p &&
              (e = new CloneableDOMException(e.message, e.name)),
            this[c].port.postMessage({ type: "error", value: e }),
            e)
          );
        } finally {
          this[c].port.close();
        }
      }
    }
    class CrossRealmTransformWritableSink {
      constructor(e) {
        (this[c] = { port: e, controller: void 0, backpressurePromise: w() }),
          (e.onmessage = ({ data: e }) => {
            k("object" == typeof e);
            const { type: r, value: s } = { ...e };
            switch ((k("string" == typeof r), r)) {
              case "pull":
                void 0 !== this[c].backpressurePromise &&
                  this[c].backpressurePromise.resolve?.(),
                  (this[c].backpressurePromise = void 0);
                break;
              case "error":
                g(this[c].controller, s),
                  void 0 !== this[c].backpressurePromise &&
                    this[c].backpressurePromise.resolve?.(),
                  (this[c].backpressurePromise = void 0);
            }
          }),
          (e.onmessageerror = () => {
            const r = new CloneableDOMException(
              "Internal transferred ReadableStream error",
              "DataCloneError"
            );
            e.postMessage({ type: "error", value: r }),
              g(this[c].controller, r),
              e.close();
          });
      }
      start(e) {
        this[c].controller = e;
      }
      async write(e) {
        void 0 === this[c].backpressurePromise &&
          (this[c].backpressurePromise = {
            promise: l(),
            resolve: void 0,
            reject: void 0,
          }),
          await this[c].backpressurePromise.promise,
          (this[c].backpressurePromise = w());
        try {
          this[c].port.postMessage({ type: "chunk", value: e });
        } catch (e) {
          throw (
            (e instanceof p &&
              (e = new CloneableDOMException(e.message, e.name)),
            this[c].port.postMessage({ type: "error", value: e }),
            this[c].port.close(),
            e)
          );
        }
      }
      close() {
        this[c].port.postMessage({ type: "close" }), this[c].port.close();
      }
      abort(e) {
        try {
          this[c].port.postMessage({ type: "error", value: e });
        } catch (e) {
          throw (
            (e instanceof p &&
              (e = new CloneableDOMException(e.message, e.name)),
            this[c].port.postMessage({ type: "error", value: e }),
            e)
          );
        } finally {
          this[c].port.close();
        }
      }
    }
    s.exports = {
      newCrossRealmReadableStream: function newCrossRealmReadableStream(e, r) {
        const s = new b(new CrossRealmTransformReadableSource(r)),
          t = f(s, e, !1, !1, !1);
        return m(t), { readable: s, promise: t };
      },
      newCrossRealmWritableSink: function newCrossRealmWritableSink(e, r) {
        const s = new C(new CrossRealmTransformWritableSink(r)),
          t = f(e, s, !1, !1, !1);
        return m(t), { writable: s, promise: t };
      },
      CrossRealmTransformWritableSink: CrossRealmTransformWritableSink,
      CrossRealmTransformReadableSource: CrossRealmTransformReadableSource,
      CloneableDOMException: CloneableDOMException,
      InternalCloneableDOMException: InternalCloneableDOMException,
    };
  },
  "internal/webstreams/transformstream": function (r, e, t, a, o, n) {
    "use strict";
    const {
        FunctionPrototypeBind: s,
        FunctionPrototypeCall: l,
        ObjectDefineProperties: m,
        PromisePrototypeThen: i,
        PromiseResolve: f,
        ReflectConstruct: u,
        SymbolToStringTag: c,
        Symbol: S,
      } = n,
      {
        codes: {
          ERR_ILLEGAL_CONSTRUCTOR: b,
          ERR_INVALID_ARG_VALUE: h,
          ERR_INVALID_STATE: d,
          ERR_INVALID_THIS: T,
        },
      } = e("internal/errors"),
      { DOMException: w } = o("messaging"),
      {
        createDeferredPromise: p,
        customInspectSymbol: C,
        kEmptyObject: k,
        kEnumerableProperty: D,
      } = e("internal/util"),
      {
        kDeserialize: g,
        kTransfer: E,
        kTransferList: v,
        makeTransferable: A,
      } = e("internal/worker/js_transferable"),
      {
        customInspect: _,
        ensureIsPromise: y,
        extractHighWaterMark: W,
        extractSizeAlgorithm: R,
        isBrandCheck: I,
        nonOpFlush: P,
        kType: z,
        kState: q,
      } = e("internal/webstreams/util"),
      {
        ReadableStream: B,
        readableStreamDefaultControllerCanCloseOrEnqueue: L,
        readableStreamDefaultControllerClose: U,
        readableStreamDefaultControllerEnqueue: O,
        readableStreamDefaultControllerError: M,
        readableStreamDefaultControllerGetDesiredSize: N,
        readableStreamDefaultControllerHasBackpressure: j,
      } = e("internal/webstreams/readablestream"),
      { WritableStream: F, writableStreamDefaultControllerErrorIfNeeded: x } =
        e("internal/webstreams/writablestream"),
      V = e("internal/assert"),
      G = S("kSkipThrow"),
      getNonWritablePropertyDescriptor = (r) => ({
        __proto__: null,
        configurable: !0,
        value: r,
      });
    class TransformStream {
      [z] = "TransformStream";
      constructor(r = null, e = k, t = k) {
        const a = r?.readableType,
          o = r?.writableType,
          n = r?.start;
        if (void 0 !== a) throw new h.RangeError("transformer.readableType", a);
        if (void 0 !== o) throw new h.RangeError("transformer.writableType", o);
        const m = t?.highWaterMark,
          u = t?.size,
          c = e?.highWaterMark,
          S = e?.size,
          b = W(m, 0),
          d = R(u),
          T = W(c, 1),
          w = R(S),
          C = p();
        return (
          (function initializeTransformStream(r, e, t, a, o, n) {
            const s = new F(
                {
                  __proto__: null,
                  start: () => e.promise,
                  write: (e) =>
                    (function transformStreamDefaultSinkWriteAlgorithm(r, e) {
                      const { writable: t, controller: a } = r[q];
                      if ((V("writable" === t[q].state), r[q].backpressure)) {
                        const t = r[q].backpressureChange.promise;
                        return i(t, () => {
                          const { writable: t } = r[q];
                          if ("erroring" === t[q].state) throw t[q].storedError;
                          return (
                            V("writable" === t[q].state),
                            transformStreamDefaultControllerPerformTransform(
                              a,
                              e
                            )
                          );
                        });
                      }
                      return transformStreamDefaultControllerPerformTransform(
                        a,
                        e
                      );
                    })(r, e),
                  abort: (e) =>
                    (async function transformStreamDefaultSinkAbortAlgorithm(
                      r,
                      e
                    ) {
                      transformStreamError(r, e);
                    })(r, e),
                  close: () =>
                    (function transformStreamDefaultSinkCloseAlgorithm(r) {
                      const { readable: e, controller: t } = r[q],
                        a = y(t[q].flushAlgorithm, t, t);
                      return (
                        transformStreamDefaultControllerClearAlgorithms(t),
                        i(
                          a,
                          () => {
                            if ("errored" === e[q].state)
                              throw e[q].storedError;
                            U(e[q].controller);
                          },
                          (t) => {
                            throw (
                              (transformStreamError(r, t), e[q].storedError)
                            );
                          }
                        )
                      );
                    })(r),
                },
                { highWaterMark: t, size: a }
              ),
              l = new B(
                {
                  __proto__: null,
                  start: () => e.promise,
                  pull: () =>
                    (function transformStreamDefaultSourcePullAlgorithm(r) {
                      return (
                        V(r[q].backpressure),
                        V(void 0 !== r[q].backpressureChange.promise),
                        transformStreamSetBackpressure(r, !1),
                        r[q].backpressureChange.promise
                      );
                    })(r),
                  cancel: (e) => (
                    transformStreamErrorWritableAndUnblockWrite(r, e), f()
                  ),
                },
                { highWaterMark: o, size: n }
              );
            (r[q] = {
              readable: l,
              writable: s,
              controller: void 0,
              backpressure: void 0,
              backpressureChange: {
                promise: void 0,
                resolve: void 0,
                reject: void 0,
              },
            }),
              transformStreamSetBackpressure(r, !0);
          })(this, C, T, w, b, d),
          (function setupTransformStreamDefaultControllerFromTransformer(r, e) {
            const t = new TransformStreamDefaultController(G),
              a = e?.transform || defaultTransformAlgorithm,
              o = e?.flush || P,
              n = s(a, e),
              l = s(o, e);
            !(function setupTransformStreamDefaultController(r, e, t, a) {
              V(H(r)),
                V(void 0 === r[q].controller),
                (e[q] = {
                  stream: r,
                  transformAlgorithm: t,
                  flushAlgorithm: a,
                }),
                (r[q].controller = e);
            })(r, t, n, l);
          })(this, r),
          void 0 !== n ? C.resolve(l(n, r, this[q].controller)) : C.resolve(),
          A(this)
        );
      }
      get readable() {
        if (!H(this)) throw new T("TransformStream");
        return this[q].readable;
      }
      get writable() {
        if (!H(this)) throw new T("TransformStream");
        return this[q].writable;
      }
      [C](r, e) {
        return _(r, e, this[z], {
          readable: this.readable,
          writable: this.writable,
          backpressure: this[q].backpressure,
        });
      }
      [E]() {
        if (!H(this)) throw new T("TransformStream");
        const { readable: r, writable: e } = this[q];
        if (r.locked)
          throw new w(
            "Cannot transfer a locked ReadableStream",
            "DataCloneError"
          );
        if (e.locked)
          throw new w(
            "Cannot transfer a locked WritableStream",
            "DataCloneError"
          );
        return {
          data: { readable: r, writable: e },
          deserializeInfo:
            "internal/webstreams/transformstream:TransferredTransformStream",
        };
      }
      [v]() {
        return [this[q].readable, this[q].writable];
      }
      [g]({ readable: r, writable: e }) {
        (this[q].readable = r), (this[q].writable = e);
      }
    }
    function TransferredTransformStream() {
      return A(
        u(
          function () {
            (this[z] = "TransformStream"),
              (this[q] = {
                readable: void 0,
                writable: void 0,
                backpressure: void 0,
                backpressureChange: {
                  promise: void 0,
                  resolve: void 0,
                  reject: void 0,
                },
                controller: void 0,
              });
          },
          [],
          TransformStream
        )
      );
    }
    m(TransformStream.prototype, {
      readable: D,
      writable: D,
      [c]: getNonWritablePropertyDescriptor(TransformStream.name),
    }),
      (TransferredTransformStream.prototype[g] = () => {});
    class TransformStreamDefaultController {
      [z] = "TransformStreamDefaultController";
      constructor(r = void 0) {
        if (r !== G) throw new b();
      }
      get desiredSize() {
        if (!J(this)) throw new T("TransformStreamDefaultController");
        const { stream: r } = this[q],
          { readable: e } = r[q],
          { controller: t } = e[q];
        return N(t);
      }
      enqueue(r = void 0) {
        if (!J(this)) throw new T("TransformStreamDefaultController");
        transformStreamDefaultControllerEnqueue(this, r);
      }
      error(r = void 0) {
        if (!J(this)) throw new T("TransformStreamDefaultController");
        !(function transformStreamDefaultControllerError(r, e) {
          transformStreamError(r[q].stream, e);
        })(this, r);
      }
      terminate() {
        if (!J(this)) throw new T("TransformStreamDefaultController");
        !(function transformStreamDefaultControllerTerminate(r) {
          const { stream: e } = r[q],
            { readable: t } = e[q];
          V(void 0 !== t);
          const { controller: a } = t[q];
          U(a),
            transformStreamErrorWritableAndUnblockWrite(
              e,
              new d.TypeError("TransformStream has been terminated")
            );
        })(this);
      }
      [C](r, e) {
        return _(r, e, this[z], { stream: this[q].stream });
      }
    }
    m(TransformStreamDefaultController.prototype, {
      desiredSize: D,
      enqueue: D,
      error: D,
      terminate: D,
      [c]: getNonWritablePropertyDescriptor(
        TransformStreamDefaultController.name
      ),
    });
    const H = I("TransformStream"),
      J = I("TransformStreamDefaultController");
    async function defaultTransformAlgorithm(r, e) {
      transformStreamDefaultControllerEnqueue(e, r);
    }
    function transformStreamError(r, e) {
      const { readable: t } = r[q],
        { controller: a } = t[q];
      M(a, e), transformStreamErrorWritableAndUnblockWrite(r, e);
    }
    function transformStreamErrorWritableAndUnblockWrite(r, e) {
      const { controller: t, writable: a } = r[q];
      transformStreamDefaultControllerClearAlgorithms(t),
        x(a[q].controller, e),
        r[q].backpressure && transformStreamSetBackpressure(r, !1);
    }
    function transformStreamSetBackpressure(r, e) {
      V(r[q].backpressure !== e),
        void 0 !== r[q].backpressureChange.promise &&
          r[q].backpressureChange.resolve?.(),
        (r[q].backpressureChange = p()),
        (r[q].backpressure = e);
    }
    function transformStreamDefaultControllerClearAlgorithms(r) {
      (r[q].transformAlgorithm = void 0), (r[q].flushAlgorithm = void 0);
    }
    function transformStreamDefaultControllerEnqueue(r, e) {
      const { stream: t } = r[q],
        { readable: a } = t[q],
        { controller: o } = a[q];
      if (!L(o)) throw new d.TypeError("Unable to enqueue");
      try {
        O(o, e);
      } catch (r) {
        throw (
          (transformStreamErrorWritableAndUnblockWrite(t, r), a[q].storedError)
        );
      }
      const n = j(o);
      n !== t[q].backpressure && (V(n), transformStreamSetBackpressure(t, !0));
    }
    async function transformStreamDefaultControllerPerformTransform(r, e) {
      try {
        return await y(r[q].transformAlgorithm, r, e, r);
      } catch (e) {
        throw (transformStreamError(r[q].stream, e), e);
      }
    }
    t.exports = {
      TransformStream: TransformStream,
      TransformStreamDefaultController: TransformStreamDefaultController,
      TransferredTransformStream: TransferredTransformStream,
      isTransformStream: H,
      isTransformStreamDefaultController: J,
    };
  },
  "internal/webstreams/util": function (e, r, t, n, u, i) {
    "use strict";
    const {
        ArrayBufferPrototypeSlice: o,
        ArrayPrototypePush: a,
        ArrayPrototypeShift: f,
        AsyncIteratorPrototype: s,
        FunctionPrototypeCall: c,
        MathMax: l,
        NumberIsNaN: y,
        ObjectCreate: p,
        PromisePrototypeThen: A,
        PromiseResolve: B,
        PromiseReject: d,
        ReflectGet: h,
        Symbol: w,
        Uint8Array: P,
      } = i,
      {
        codes: { ERR_INVALID_ARG_VALUE: V, ERR_OPERATION_FAILED: g },
      } = r("internal/errors"),
      { copyArrayBuffer: m, detachArrayBuffer: q } = u("buffer"),
      { isPromise: v } = r("internal/util/types"),
      { inspect: S } = r("util"),
      {
        constants: { kPending: z },
        getPromiseDetails: O,
      } = u("util"),
      b = r("internal/assert"),
      { isArrayBufferDetached: G } = r("internal/util"),
      { validateFunction: T } = r("internal/validators"),
      _ = w("kState"),
      k = w("kType"),
      I = p(s, {
        next: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          writable: !0,
        },
        return: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          writable: !0,
        },
      });
    function ArrayBufferViewGetBuffer(e) {
      return h(e.constructor.prototype, "buffer", e);
    }
    function ArrayBufferViewGetByteLength(e) {
      return h(e.constructor.prototype, "byteLength", e);
    }
    function ArrayBufferViewGetByteOffset(e) {
      return h(e.constructor.prototype, "byteOffset", e);
    }
    let R;
    t.exports = {
      ArrayBufferViewGetBuffer: ArrayBufferViewGetBuffer,
      ArrayBufferViewGetByteLength: ArrayBufferViewGetByteLength,
      ArrayBufferViewGetByteOffset: ArrayBufferViewGetByteOffset,
      AsyncIterator: I,
      cloneAsUint8Array: function cloneAsUint8Array(e) {
        const r = ArrayBufferViewGetBuffer(e),
          t = ArrayBufferViewGetByteOffset(e),
          n = ArrayBufferViewGetByteLength(e);
        return new P(o(r, t, t + n));
      },
      copyArrayBuffer: m,
      customInspect: function customInspect(e, r, t, n) {
        if (e < 0) return this;
        const u = { ...r, depth: null == r.depth ? null : r.depth - 1 };
        return `${t} ${S(n, u)}`;
      },
      dequeueValue: function dequeueValue(e) {
        b(void 0 !== e[_].queue),
          b(void 0 !== e[_].queueTotalSize),
          b(e[_].queue.length);
        const { value: r, size: t } = f(e[_].queue);
        return (e[_].queueTotalSize = l(0, e[_].queueTotalSize - t)), r;
      },
      ensureIsPromise: function ensureIsPromise(e, r, ...t) {
        try {
          const n = c(e, r, ...t);
          return v(n) ? n : B(n);
        } catch (e) {
          return d(e);
        }
      },
      enqueueValueWithSize: function enqueueValueWithSize(e, r, t) {
        if (
          (b(void 0 !== e[_].queue),
          b(void 0 !== e[_].queueTotalSize),
          "number" != typeof (t = +t) || t < 0 || y(t) || t === 1 / 0)
        )
          throw new V.RangeError("size", t);
        a(e[_].queue, { value: r, size: t }), (e[_].queueTotalSize += t);
      },
      extractHighWaterMark: function extractHighWaterMark(e, r) {
        if (void 0 === e) return r;
        if ("number" != typeof (e = +e) || y(e) || e < 0)
          throw new V.RangeError("strategy.highWaterMark", e);
        return e;
      },
      extractSizeAlgorithm: function extractSizeAlgorithm(e) {
        return void 0 === e ? () => 1 : (T(e, "strategy.size"), e);
      },
      lazyTransfer: function lazyTransfer() {
        return void 0 === R && (R = r("internal/webstreams/transfer")), R;
      },
      isBrandCheck: function isBrandCheck(e) {
        return (r) => null != r && void 0 !== r[_] && r[k] === e;
      },
      isPromisePending: function isPromisePending(e) {
        if (void 0 === e) return !1;
        const r = O(e);
        return r?.[0] === z;
      },
      isViewedArrayBufferDetached: function isViewedArrayBufferDetached(e) {
        return (
          0 === ArrayBufferViewGetByteLength(e) &&
          G(ArrayBufferViewGetBuffer(e))
        );
      },
      peekQueueValue: function peekQueueValue(e) {
        return (
          b(void 0 !== e[_].queue),
          b(void 0 !== e[_].queueTotalSize),
          b(e[_].queue.length),
          e[_].queue[0].value
        );
      },
      resetQueue: function resetQueue(e) {
        b(void 0 !== e[_].queue),
          b(void 0 !== e[_].queueTotalSize),
          (e[_].queue = []),
          (e[_].queueTotalSize = 0);
      },
      setPromiseHandled: function setPromiseHandled(e) {
        A(
          e,
          () => {},
          () => {}
        );
      },
      transferArrayBuffer: function transferArrayBuffer(e) {
        const r = q(e);
        if (void 0 === r)
          throw new g.TypeError("The ArrayBuffer could not be transferred");
        return r;
      },
      nonOpCancel: async function nonOpCancel() {},
      nonOpFlush: async function nonOpFlush() {},
      nonOpPull: async function nonOpPull() {},
      nonOpStart: function nonOpStart() {},
      nonOpWrite: async function nonOpWrite() {},
      kType: k,
      kState: _,
    };
  },
  "internal/webstreams/writablestream": function (e, r, t, i, o, a) {
    "use strict";
    const {
        ArrayPrototypePush: l,
        ArrayPrototypeShift: s,
        FunctionPrototypeBind: n,
        FunctionPrototypeCall: m,
        ObjectDefineProperties: u,
        PromisePrototypeThen: d,
        PromiseResolve: b,
        PromiseReject: c,
        ReflectConstruct: S,
        Symbol: w,
        SymbolToStringTag: f,
      } = a,
      {
        codes: {
          ERR_ILLEGAL_CONSTRUCTOR: h,
          ERR_INVALID_ARG_VALUE: W,
          ERR_INVALID_ARG_TYPE: v,
          ERR_INVALID_STATE: p,
          ERR_INVALID_THIS: C,
        },
      } = r("internal/errors"),
      { DOMException: g } = o("messaging"),
      {
        createDeferredPromise: D,
        customInspectSymbol: R,
        kEmptyObject: F,
        kEnumerableProperty: E,
        SideEffectFreeRegExpPrototypeSymbolReplace: k,
      } = r("internal/util"),
      { MessageChannel: A } = r("internal/worker/io"),
      {
        kDeserialize: q,
        kTransfer: I,
        kTransferList: y,
        makeTransferable: j,
      } = r("internal/worker/js_transferable"),
      {
        customInspect: P,
        dequeueValue: T,
        ensureIsPromise: z,
        enqueueValueWithSize: N,
        extractHighWaterMark: O,
        extractSizeAlgorithm: G,
        lazyTransfer: Q,
        isBrandCheck: _,
        isPromisePending: M,
        peekQueueValue: L,
        resetQueue: B,
        setPromiseHandled: H,
        nonOpCancel: U,
        nonOpStart: V,
        nonOpWrite: x,
        kType: Y,
        kState: $,
      } = r("internal/webstreams/util"),
      { kIsClosedPromise: J, kControllerErrorFunction: K } = r(
        "internal/streams/utils"
      ),
      { AbortController: X } = r("internal/abort_controller"),
      Z = r("internal/assert"),
      ee = w("kAbort"),
      re = w("kCloseSentinel"),
      te = w("kError"),
      ie = w("kSkipThrow");
    let oe;
    const getNonWritablePropertyDescriptor = (e) => ({
      __proto__: null,
      configurable: !0,
      value: e,
    });
    class WritableStream {
      [Y] = "WritableStream";
      constructor(e = null, r = F) {
        const t = e?.type;
        if (void 0 !== t) throw new W.RangeError("type", t);
        (this[$] = {
          close: D(),
          closeRequest: { promise: void 0, resolve: void 0, reject: void 0 },
          inFlightWriteRequest: {
            promise: void 0,
            resolve: void 0,
            reject: void 0,
          },
          inFlightCloseRequest: {
            promise: void 0,
            resolve: void 0,
            reject: void 0,
          },
          pendingAbortRequest: {
            abort: { promise: void 0, resolve: void 0, reject: void 0 },
            reason: void 0,
            wasAlreadyErroring: !1,
          },
          backpressure: !1,
          controller: void 0,
          state: "writable",
          storedError: void 0,
          writeRequests: [],
          writer: void 0,
          transfer: {
            readable: void 0,
            port1: void 0,
            port2: void 0,
            promise: void 0,
          },
        }),
          (this[J] = D()),
          (this[K] = () => {});
        const i = G(r?.size);
        return (
          setupWritableStreamDefaultControllerFromSink(
            this,
            e,
            O(r?.highWaterMark, 1),
            i
          ),
          j(this)
        );
      }
      get locked() {
        if (!ae(this)) throw new C("WritableStream");
        return isWritableStreamLocked(this);
      }
      abort(e = void 0) {
        return ae(this)
          ? isWritableStreamLocked(this)
            ? c(new p.TypeError("WritableStream is locked"))
            : writableStreamAbort(this, e)
          : c(new C("WritableStream"));
      }
      close() {
        return ae(this)
          ? isWritableStreamLocked(this)
            ? c(new p.TypeError("WritableStream is locked"))
            : writableStreamCloseQueuedOrInFlight(this)
            ? c(new p.TypeError("Failure closing WritableStream"))
            : writableStreamClose(this)
          : c(new C("WritableStream"));
      }
      getWriter() {
        if (!ae(this)) throw new C("WritableStream");
        return new WritableStreamDefaultWriter(this);
      }
      [R](e, r) {
        return P(e, r, this[Y], { locked: this.locked, state: this[$].state });
      }
      [I]() {
        if (!ae(this)) throw new C("WritableStream");
        if (this.locked)
          throw (
            (this[$].transfer.port1?.close(),
            (this[$].transfer.port1 = void 0),
            (this[$].transfer.port2 = void 0),
            new g("Cannot transfer a locked WritableStream", "DataCloneError"))
          );
        const { readable: e, promise: r } = Q().newCrossRealmReadableStream(
          this,
          this[$].transfer.port1
        );
        return (
          (this[$].transfer.readable = e),
          (this[$].transfer.promise = r),
          H(this[$].transfer.promise),
          {
            data: { port: this[$].transfer.port2 },
            deserializeInfo:
              "internal/webstreams/writablestream:TransferredWritableStream",
          }
        );
      }
      [y]() {
        const { port1: e, port2: r } = new A();
        return (this[$].transfer.port1 = e), (this[$].transfer.port2 = r), [r];
      }
      [q]({ port: e }) {
        setupWritableStreamDefaultControllerFromSink(
          this,
          new (Q().CrossRealmTransformWritableSink)(e),
          1,
          () => 1
        );
      }
    }
    function TransferredWritableStream() {
      return j(
        S(
          function () {
            (this[Y] = "WritableStream"),
              (this[$] = {
                close: D(),
                closeRequest: {
                  promise: void 0,
                  resolve: void 0,
                  reject: void 0,
                },
                inFlightWriteRequest: {
                  promise: void 0,
                  resolve: void 0,
                  reject: void 0,
                },
                inFlightCloseRequest: {
                  promise: void 0,
                  resolve: void 0,
                  reject: void 0,
                },
                pendingAbortRequest: {
                  abort: { promise: void 0, resolve: void 0, reject: void 0 },
                  reason: void 0,
                  wasAlreadyErroring: !1,
                },
                backpressure: !1,
                controller: void 0,
                state: "writable",
                storedError: void 0,
                writeRequests: [],
                writer: void 0,
                transfer: {
                  promise: void 0,
                  port1: void 0,
                  port2: void 0,
                  readable: void 0,
                },
              }),
              (this[J] = D()),
              (this[K] = () => {});
          },
          [],
          WritableStream
        )
      );
    }
    u(WritableStream.prototype, {
      locked: E,
      abort: E,
      close: E,
      getWriter: E,
      [f]: getNonWritablePropertyDescriptor(WritableStream.name),
    }),
      (TransferredWritableStream.prototype[q] = () => {});
    class WritableStreamDefaultWriter {
      [Y] = "WritableStreamDefaultWriter";
      constructor(e) {
        if (!ae(e)) throw new v("stream", "WritableStream", e);
        (this[$] = {
          stream: void 0,
          close: { promise: void 0, resolve: void 0, reject: void 0 },
          ready: { promise: void 0, resolve: void 0, reject: void 0 },
        }),
          setupWritableStreamDefaultWriter(this, e);
      }
      get closed() {
        return le(this)
          ? this[$].close.promise
          : c(new C("WritableStreamDefaultWriter"));
      }
      get desiredSize() {
        if (!le(this)) throw new C("WritableStreamDefaultWriter");
        if (void 0 === this[$].stream)
          throw new p.TypeError("Writer is not bound to a WritableStream");
        return writableStreamDefaultWriterGetDesiredSize(this);
      }
      get ready() {
        return le(this)
          ? this[$].ready.promise
          : c(new C("WritableStreamDefaultWriter"));
      }
      abort(e = void 0) {
        return le(this)
          ? void 0 === this[$].stream
            ? c(new p.TypeError("Writer is not bound to a WritableStream"))
            : writableStreamDefaultWriterAbort(this, e)
          : c(new C("WritableStreamDefaultWriter"));
      }
      close() {
        if (!le(this)) return c(new C("WritableStreamDefaultWriter"));
        const { stream: e } = this[$];
        return void 0 === e
          ? c(new p.TypeError("Writer is not bound to a WritableStream"))
          : writableStreamCloseQueuedOrInFlight(e)
          ? c(new p.TypeError("Failure to close WritableStream"))
          : writableStreamDefaultWriterClose(this);
      }
      releaseLock() {
        if (!le(this)) throw new C("WritableStreamDefaultWriter");
        const { stream: e } = this[$];
        void 0 !== e &&
          (Z(void 0 !== e[$].writer), writableStreamDefaultWriterRelease(this));
      }
      write(e = void 0) {
        return le(this)
          ? void 0 === this[$].stream
            ? c(new p.TypeError("Writer is not bound to a WritableStream"))
            : writableStreamDefaultWriterWrite(this, e)
          : c(new C("WritableStreamDefaultWriter"));
      }
      [R](e, r) {
        return P(e, r, this[Y], {
          stream: this[$].stream,
          close: this[$].close.promise,
          ready: this[$].ready.promise,
          desiredSize: this.desiredSize,
        });
      }
    }
    u(WritableStreamDefaultWriter.prototype, {
      closed: E,
      ready: E,
      desiredSize: E,
      abort: E,
      close: E,
      releaseLock: E,
      write: E,
      [f]: getNonWritablePropertyDescriptor(WritableStreamDefaultWriter.name),
    });
    class WritableStreamDefaultController {
      [Y] = "WritableStreamDefaultController";
      constructor(e = void 0) {
        if (e !== ie) throw new h();
      }
      [ee](e) {
        const r = this[$].abortAlgorithm(e);
        return writableStreamDefaultControllerClearAlgorithms(this), r;
      }
      [te]() {
        B(this);
      }
      get signal() {
        if (!se(this)) throw new C("WritableStreamDefaultController");
        return this[$].abortController.signal;
      }
      error(e = void 0) {
        if (!se(this)) throw new C("WritableStreamDefaultController");
        "writable" === this[$].stream[$].state &&
          writableStreamDefaultControllerError(this, e);
      }
      [R](e, r) {
        return P(e, r, this[Y], { stream: this[$].stream });
      }
    }
    u(WritableStreamDefaultController.prototype, {
      signal: E,
      error: E,
      [f]: getNonWritablePropertyDescriptor(
        WritableStreamDefaultController.name
      ),
    });
    const ae = _("WritableStream"),
      le = _("WritableStreamDefaultWriter"),
      se = _("WritableStreamDefaultController");
    function isWritableStreamLocked(e) {
      return void 0 !== e[$].writer;
    }
    function setupWritableStreamDefaultWriter(e, r) {
      if (isWritableStreamLocked(r))
        throw new p.TypeError("WritableStream is locked");
      switch (((e[$].stream = r), (r[$].writer = e), r[$].state)) {
        case "writable":
          !writableStreamCloseQueuedOrInFlight(r) && r[$].backpressure
            ? (e[$].ready = D())
            : (e[$].ready = { promise: b(), resolve: void 0, reject: void 0 }),
            setClosedPromiseToNewPromise();
          break;
        case "erroring":
          (e[$].ready = {
            promise: c(r[$].storedError),
            resolve: void 0,
            reject: void 0,
          }),
            H(e[$].ready.promise),
            setClosedPromiseToNewPromise();
          break;
        case "closed":
          (e[$].ready = { promise: b(), resolve: void 0, reject: void 0 }),
            (e[$].close = { promise: b(), resolve: void 0, reject: void 0 });
          break;
        default:
          (e[$].ready = {
            promise: c(r[$].storedError),
            resolve: void 0,
            reject: void 0,
          }),
            (e[$].close = {
              promise: c(r[$].storedError),
              resolve: void 0,
              reject: void 0,
            }),
            H(e[$].ready.promise),
            H(e[$].close.promise);
      }
      function setClosedPromiseToNewPromise() {
        e[$].close = D();
      }
    }
    function writableStreamAbort(e, r) {
      const { state: t, controller: i } = e[$];
      if ("closed" === t || "errored" === t) return b();
      if (
        (i[$].abortController.abort(r),
        void 0 !== e[$].pendingAbortRequest.abort.promise)
      )
        return e[$].pendingAbortRequest.abort.promise;
      Z("writable" === t || "erroring" === t);
      let o = !1;
      "erroring" === t && ((o = !0), (r = void 0));
      const a = D();
      return (
        (e[$].pendingAbortRequest = {
          abort: a,
          reason: r,
          wasAlreadyErroring: o,
        }),
        o || writableStreamStartErroring(e, r),
        a.promise
      );
    }
    function writableStreamClose(e) {
      const { state: r, writer: t, backpressure: i, controller: o } = e[$];
      if ("closed" === r || "errored" === r)
        return c(new p.TypeError("WritableStream is closed"));
      Z("writable" === r || "erroring" === r),
        Z(!writableStreamCloseQueuedOrInFlight(e)),
        (e[$].closeRequest = D());
      const { promise: a } = e[$].closeRequest;
      return (
        void 0 !== t && i && "writable" === r && t[$].ready.resolve?.(),
        writableStreamDefaultControllerClose(o),
        a
      );
    }
    function writableStreamUpdateBackpressure(e, r) {
      Z("writable" === e[$].state), Z(!writableStreamCloseQueuedOrInFlight(e));
      const { writer: t } = e[$];
      void 0 !== t &&
        e[$].backpressure !== r &&
        (r ? (t[$].ready = D()) : t[$].ready.resolve?.()),
        (e[$].backpressure = r);
    }
    function writableStreamStartErroring(e, r) {
      Z(void 0 === e[$].storedError), Z("writable" === e[$].state);
      const { controller: t, writer: i } = e[$];
      Z(void 0 !== t),
        (e[$].state = "erroring"),
        (e[$].storedError = r),
        void 0 !== i &&
          writableStreamDefaultWriterEnsureReadyPromiseRejected(i, r),
        !writableStreamHasOperationMarkedInFlight(e) &&
          t[$].started &&
          writableStreamFinishErroring(e);
    }
    function writableStreamRejectCloseAndClosedPromiseIfNeeded(e) {
      Z("errored" === e[$].state),
        void 0 !== e[$].closeRequest.promise &&
          (Z(void 0 === e[$].inFlightCloseRequest.promise),
          e[$].closeRequest.reject?.(e[$].storedError),
          (e[$].closeRequest = {
            promise: void 0,
            reject: void 0,
            resolve: void 0,
          })),
        e[J].reject(e[$]?.storedError),
        H(e[J].promise);
      const { writer: r } = e[$];
      void 0 !== r &&
        (r[$].close.reject?.(e[$].storedError), H(r[$].close.promise));
    }
    function writableStreamMarkFirstWriteRequestInFlight(e) {
      Z(void 0 === e[$].inFlightWriteRequest.promise),
        Z(e[$].writeRequests.length);
      const r = s(e[$].writeRequests);
      e[$].inFlightWriteRequest = r;
    }
    function writableStreamMarkCloseRequestInFlight(e) {
      Z(void 0 === e[$].inFlightWriteRequest.promise),
        Z(void 0 !== e[$].closeRequest.promise),
        (e[$].inFlightCloseRequest = e[$].closeRequest),
        (e[$].closeRequest = {
          promise: void 0,
          resolve: void 0,
          reject: void 0,
        });
    }
    function writableStreamHasOperationMarkedInFlight(e) {
      const { inFlightWriteRequest: r, inFlightCloseRequest: t } = e[$];
      return void 0 !== r.promise || void 0 !== t.promise;
    }
    function writableStreamFinishInFlightWriteWithError(e, r) {
      Z(void 0 !== e[$].inFlightWriteRequest.promise),
        e[$].inFlightWriteRequest.reject?.(r),
        (e[$].inFlightWriteRequest = {
          promise: void 0,
          resolve: void 0,
          reject: void 0,
        }),
        Z("writable" === e[$].state || "erroring" === e[$].state),
        writableStreamDealWithRejection(e, r);
    }
    function writableStreamFinishInFlightWrite(e) {
      Z(void 0 !== e[$].inFlightWriteRequest.promise),
        e[$].inFlightWriteRequest.resolve?.(),
        (e[$].inFlightWriteRequest = {
          promise: void 0,
          resolve: void 0,
          reject: void 0,
        });
    }
    function writableStreamFinishInFlightCloseWithError(e, r) {
      Z(void 0 !== e[$].inFlightCloseRequest.promise),
        e[$].inFlightCloseRequest.reject?.(r),
        (e[$].inFlightCloseRequest = {
          promise: void 0,
          resolve: void 0,
          reject: void 0,
        }),
        Z("writable" === e[$].state || "erroring" === e[$].state),
        void 0 !== e[$].pendingAbortRequest.abort.promise &&
          (e[$].pendingAbortRequest.abort.reject?.(r),
          (e[$].pendingAbortRequest = {
            abort: { promise: void 0, resolve: void 0, reject: void 0 },
            reason: void 0,
            wasAlreadyErroring: !1,
          })),
        writableStreamDealWithRejection(e, r);
    }
    function writableStreamFinishInFlightClose(e) {
      Z(void 0 !== e[$].inFlightCloseRequest.promise),
        e[$].inFlightCloseRequest.resolve?.(),
        (e[$].inFlightCloseRequest = {
          promise: void 0,
          resolve: void 0,
          reject: void 0,
        }),
        "erroring" === e[$].state &&
          ((e[$].storedError = void 0),
          void 0 !== e[$].pendingAbortRequest.abort.promise &&
            (e[$].pendingAbortRequest.abort.resolve?.(),
            (e[$].pendingAbortRequest = {
              abort: { promise: void 0, resolve: void 0, reject: void 0 },
              reason: void 0,
              wasAlreadyErroring: !1,
            }))),
        (e[$].state = "closed"),
        void 0 !== e[$].writer && e[$].writer[$].close.resolve?.(),
        e[J].resolve?.(),
        Z(void 0 === e[$].pendingAbortRequest.abort.promise),
        Z(void 0 === e[$].storedError);
    }
    function writableStreamFinishErroring(e) {
      Z("erroring" === e[$].state),
        Z(!writableStreamHasOperationMarkedInFlight(e)),
        (e[$].state = "errored"),
        e[$].controller[te]();
      const r = e[$].storedError;
      for (let t = 0; t < e[$].writeRequests.length; t++)
        e[$].writeRequests[t].reject?.(r);
      if (
        ((e[$].writeRequests = []),
        void 0 === e[$].pendingAbortRequest.abort.promise)
      )
        return void writableStreamRejectCloseAndClosedPromiseIfNeeded(e);
      const t = e[$].pendingAbortRequest;
      if (
        ((e[$].pendingAbortRequest = {
          abort: { promise: void 0, resolve: void 0, reject: void 0 },
          reason: void 0,
          wasAlreadyErroring: !1,
        }),
        t.wasAlreadyErroring)
      )
        return (
          t.abort.reject?.(r),
          void writableStreamRejectCloseAndClosedPromiseIfNeeded(e)
        );
      d(
        z(e[$].controller[ee], e[$].controller, t.reason),
        () => {
          t.abort.resolve?.(),
            writableStreamRejectCloseAndClosedPromiseIfNeeded(e);
        },
        (r) => {
          t.abort.reject?.(r),
            writableStreamRejectCloseAndClosedPromiseIfNeeded(e);
        }
      );
    }
    function writableStreamDealWithRejection(e, r) {
      const { state: t } = e[$];
      "writable" !== t
        ? (Z("erroring" === t), writableStreamFinishErroring(e))
        : writableStreamStartErroring(e, r);
    }
    function writableStreamCloseQueuedOrInFlight(e) {
      return (
        void 0 !== e[$].closeRequest.promise ||
        void 0 !== e[$].inFlightCloseRequest.promise
      );
    }
    function writableStreamAddWriteRequest(e) {
      Z(isWritableStreamLocked(e)), Z("writable" === e[$].state);
      const { promise: r, resolve: t, reject: i } = D();
      return l(e[$].writeRequests, { promise: r, resolve: t, reject: i }), r;
    }
    function writableStreamDefaultWriterWrite(e, r) {
      const { stream: t } = e[$];
      Z(void 0 !== t);
      const { controller: i } = t[$],
        o = writableStreamDefaultControllerGetChunkSize(i, r);
      if (t !== e[$].stream)
        return c(new p.TypeError("Mismatched WritableStreams"));
      const { state: a } = t[$];
      if ("errored" === a) return c(t[$].storedError);
      if (writableStreamCloseQueuedOrInFlight(t) || "closed" === a)
        return c(new p.TypeError("WritableStream is closed"));
      if ("erroring" === a) return c(t[$].storedError);
      Z("writable" === a);
      const l = writableStreamAddWriteRequest(t);
      return writableStreamDefaultControllerWrite(i, r, o), l;
    }
    function writableStreamDefaultWriterRelease(e) {
      const { stream: r } = e[$];
      Z(void 0 !== r), Z(r[$].writer === e);
      const t = (function lazyWritableReleasedError() {
        return (
          oe ||
          ((oe = new p.TypeError("Writer has been released")),
          (oe.stack = k(
            /^ {4}at (?:[^/\\(]+ \()(?!node:(.+):\d+:\d+\)$).*/gm,
            oe.stack,
            ""
          )),
          oe)
        );
      })();
      writableStreamDefaultWriterEnsureReadyPromiseRejected(e, t),
        writableStreamDefaultWriterEnsureClosedPromiseRejected(e, t),
        (r[$].writer = void 0),
        (e[$].stream = void 0);
    }
    function writableStreamDefaultWriterGetDesiredSize(e) {
      const { stream: r } = e[$];
      switch (r[$].state) {
        case "errored":
        case "erroring":
          return null;
        case "closed":
          return 0;
      }
      return writableStreamDefaultControllerGetDesiredSize(r[$].controller);
    }
    function writableStreamDefaultWriterEnsureReadyPromiseRejected(e, r) {
      M(e[$].ready.promise)
        ? e[$].ready.reject?.(r)
        : (e[$].ready = { promise: c(r), resolve: void 0, reject: void 0 }),
        H(e[$].ready.promise);
    }
    function writableStreamDefaultWriterEnsureClosedPromiseRejected(e, r) {
      M(e[$].close.promise)
        ? e[$].close.reject?.(r)
        : (e[$].close = { promise: c(r), resolve: void 0, reject: void 0 }),
        H(e[$].close.promise);
    }
    function writableStreamDefaultWriterClose(e) {
      const { stream: r } = e[$];
      return Z(void 0 !== r), writableStreamClose(r);
    }
    function writableStreamDefaultWriterAbort(e, r) {
      const { stream: t } = e[$];
      return Z(void 0 !== t), writableStreamAbort(t, r);
    }
    function writableStreamDefaultControllerWrite(e, r, t) {
      try {
        N(e, r, t);
      } catch (r) {
        return void writableStreamDefaultControllerErrorIfNeeded(e, r);
      }
      const { stream: i } = e[$];
      writableStreamCloseQueuedOrInFlight(i) ||
        "writable" !== i[$].state ||
        writableStreamUpdateBackpressure(
          i,
          writableStreamDefaultControllerGetBackpressure(e)
        ),
        writableStreamDefaultControllerAdvanceQueueIfNeeded(e);
    }
    function writableStreamDefaultControllerProcessWrite(e, r) {
      const { stream: t, writeAlgorithm: i } = e[$];
      writableStreamMarkFirstWriteRequestInFlight(t),
        d(
          z(i, e, r, e),
          () => {
            writableStreamFinishInFlightWrite(t);
            const { state: r } = t[$];
            Z("writable" === r || "erroring" === r),
              T(e),
              writableStreamCloseQueuedOrInFlight(t) ||
                "writable" !== r ||
                writableStreamUpdateBackpressure(
                  t,
                  writableStreamDefaultControllerGetBackpressure(e)
                ),
              writableStreamDefaultControllerAdvanceQueueIfNeeded(e);
          },
          (r) => {
            "writable" === t[$].state &&
              writableStreamDefaultControllerClearAlgorithms(e),
              writableStreamFinishInFlightWriteWithError(t, r);
          }
        );
    }
    function writableStreamDefaultControllerProcessClose(e) {
      const { closeAlgorithm: r, queue: t, stream: i } = e[$];
      writableStreamMarkCloseRequestInFlight(i), T(e), Z(!t.length);
      const o = z(r, e);
      writableStreamDefaultControllerClearAlgorithms(e),
        d(
          o,
          () => writableStreamFinishInFlightClose(i),
          (e) => writableStreamFinishInFlightCloseWithError(i, e)
        );
    }
    function writableStreamDefaultControllerGetDesiredSize(e) {
      const { highWaterMark: r, queueTotalSize: t } = e[$];
      return r - t;
    }
    function writableStreamDefaultControllerGetChunkSize(e, r) {
      try {
        return m(e[$].sizeAlgorithm, void 0, r);
      } catch (r) {
        return writableStreamDefaultControllerErrorIfNeeded(e, r), 1;
      }
    }
    function writableStreamDefaultControllerErrorIfNeeded(e, r) {
      const { stream: t } = e[$];
      "writable" === t[$].state && writableStreamDefaultControllerError(e, r);
    }
    function writableStreamDefaultControllerError(e, r) {
      const { stream: t } = e[$];
      Z("writable" === t[$].state),
        writableStreamDefaultControllerClearAlgorithms(e),
        writableStreamStartErroring(t, r);
    }
    function writableStreamDefaultControllerClose(e) {
      N(e, re, 0), writableStreamDefaultControllerAdvanceQueueIfNeeded(e);
    }
    function writableStreamDefaultControllerClearAlgorithms(e) {
      (e[$].writeAlgorithm = void 0),
        (e[$].closeAlgorithm = void 0),
        (e[$].abortAlgorithm = void 0),
        (e[$].sizeAlgorithm = void 0);
    }
    function writableStreamDefaultControllerGetBackpressure(e) {
      return writableStreamDefaultControllerGetDesiredSize(e) <= 0;
    }
    function writableStreamDefaultControllerAdvanceQueueIfNeeded(e) {
      const { queue: r, started: t, stream: i } = e[$];
      if (!t || void 0 !== i[$].inFlightWriteRequest.promise) return;
      if ("erroring" === i[$].state)
        return void writableStreamFinishErroring(i);
      if (!r.length) return;
      const o = L(e);
      o === re
        ? writableStreamDefaultControllerProcessClose(e)
        : writableStreamDefaultControllerProcessWrite(e, o);
    }
    function setupWritableStreamDefaultControllerFromSink(e, r, t, i) {
      const o = new WritableStreamDefaultController(ie),
        a = r?.start,
        l = r?.write,
        s = r?.close,
        m = r?.abort;
      setupWritableStreamDefaultController(
        e,
        o,
        a ? n(a, r, o) : V,
        l ? n(l, r) : x,
        s ? n(s, r) : U,
        m ? n(m, r) : U,
        t,
        i
      );
    }
    function setupWritableStreamDefaultController(e, r, t, i, o, a, l, s) {
      Z(ae(e)),
        Z(void 0 === e[$].controller),
        (r[$] = {
          abortAlgorithm: a,
          closeAlgorithm: o,
          highWaterMark: l,
          queue: [],
          queueTotalSize: 0,
          abortController: new X(),
          sizeAlgorithm: s,
          started: !1,
          stream: e,
          writeAlgorithm: i,
        }),
        (e[$].controller = r),
        (e[K] = n(r.error, r)),
        writableStreamUpdateBackpressure(
          e,
          writableStreamDefaultControllerGetBackpressure(r)
        );
      const m = t();
      d(
        b(m),
        () => {
          Z("writable" === e[$].state || "erroring" === e[$].state),
            (r[$].started = !0),
            writableStreamDefaultControllerAdvanceQueueIfNeeded(r);
        },
        (t) => {
          Z("writable" === e[$].state || "erroring" === e[$].state),
            (r[$].started = !0),
            writableStreamDealWithRejection(e, t);
        }
      );
    }
    t.exports = {
      WritableStream: WritableStream,
      WritableStreamDefaultWriter: WritableStreamDefaultWriter,
      WritableStreamDefaultController: WritableStreamDefaultController,
      TransferredWritableStream: TransferredWritableStream,
      isWritableStream: ae,
      isWritableStreamDefaultController: se,
      isWritableStreamDefaultWriter: le,
      isWritableStreamLocked: isWritableStreamLocked,
      setupWritableStreamDefaultWriter: setupWritableStreamDefaultWriter,
      writableStreamAbort: writableStreamAbort,
      writableStreamClose: writableStreamClose,
      writableStreamUpdateBackpressure: writableStreamUpdateBackpressure,
      writableStreamStartErroring: writableStreamStartErroring,
      writableStreamRejectCloseAndClosedPromiseIfNeeded:
        writableStreamRejectCloseAndClosedPromiseIfNeeded,
      writableStreamMarkFirstWriteRequestInFlight:
        writableStreamMarkFirstWriteRequestInFlight,
      writableStreamMarkCloseRequestInFlight:
        writableStreamMarkCloseRequestInFlight,
      writableStreamHasOperationMarkedInFlight:
        writableStreamHasOperationMarkedInFlight,
      writableStreamFinishInFlightWriteWithError:
        writableStreamFinishInFlightWriteWithError,
      writableStreamFinishInFlightWrite: writableStreamFinishInFlightWrite,
      writableStreamFinishInFlightCloseWithError:
        writableStreamFinishInFlightCloseWithError,
      writableStreamFinishInFlightClose: writableStreamFinishInFlightClose,
      writableStreamFinishErroring: writableStreamFinishErroring,
      writableStreamDealWithRejection: writableStreamDealWithRejection,
      writableStreamCloseQueuedOrInFlight: writableStreamCloseQueuedOrInFlight,
      writableStreamAddWriteRequest: writableStreamAddWriteRequest,
      writableStreamDefaultWriterWrite: writableStreamDefaultWriterWrite,
      writableStreamDefaultWriterRelease: writableStreamDefaultWriterRelease,
      writableStreamDefaultWriterGetDesiredSize:
        writableStreamDefaultWriterGetDesiredSize,
      writableStreamDefaultWriterEnsureReadyPromiseRejected:
        writableStreamDefaultWriterEnsureReadyPromiseRejected,
      writableStreamDefaultWriterEnsureClosedPromiseRejected:
        writableStreamDefaultWriterEnsureClosedPromiseRejected,
      writableStreamDefaultWriterCloseWithErrorPropagation:
        function writableStreamDefaultWriterCloseWithErrorPropagation(e) {
          const { stream: r } = e[$];
          Z(void 0 !== r);
          const { state: t } = r[$];
          return writableStreamCloseQueuedOrInFlight(r) || "closed" === t
            ? b()
            : "errored" === t
            ? c(r[$].storedError)
            : (Z("writable" === t || "erroring" === t),
              writableStreamDefaultWriterClose(e));
        },
      writableStreamDefaultWriterClose: writableStreamDefaultWriterClose,
      writableStreamDefaultWriterAbort: writableStreamDefaultWriterAbort,
      writableStreamDefaultControllerWrite:
        writableStreamDefaultControllerWrite,
      writableStreamDefaultControllerProcessWrite:
        writableStreamDefaultControllerProcessWrite,
      writableStreamDefaultControllerProcessClose:
        writableStreamDefaultControllerProcessClose,
      writableStreamDefaultControllerGetDesiredSize:
        writableStreamDefaultControllerGetDesiredSize,
      writableStreamDefaultControllerGetChunkSize:
        writableStreamDefaultControllerGetChunkSize,
      writableStreamDefaultControllerErrorIfNeeded:
        writableStreamDefaultControllerErrorIfNeeded,
      writableStreamDefaultControllerError:
        writableStreamDefaultControllerError,
      writableStreamDefaultControllerClose:
        writableStreamDefaultControllerClose,
      writableStreamDefaultControllerClearAlgorithms:
        writableStreamDefaultControllerClearAlgorithms,
      writableStreamDefaultControllerGetBackpressure:
        writableStreamDefaultControllerGetBackpressure,
      writableStreamDefaultControllerAdvanceQueueIfNeeded:
        writableStreamDefaultControllerAdvanceQueueIfNeeded,
      setupWritableStreamDefaultControllerFromSink:
        setupWritableStreamDefaultControllerFromSink,
      setupWritableStreamDefaultController:
        setupWritableStreamDefaultController,
    };
  },
  "internal/worker": function (e, t, i, r, n, s) {
    "use strict";
    const {
        ArrayPrototypeForEach: o,
        ArrayPrototypeMap: a,
        ArrayPrototypePush: l,
        Float64Array: h,
        FunctionPrototypeBind: u,
        JSONStringify: d,
        MathMax: c,
        ObjectCreate: p,
        ObjectEntries: m,
        Promise: f,
        PromiseResolve: g,
        ReflectApply: v,
        RegExpPrototypeExec: R,
        SafeArrayIterator: k,
        SafeMap: S,
        String: E,
        StringPrototypeTrim: w,
        Symbol: _,
        SymbolFor: y,
        TypedArrayPrototypeFill: A,
        Uint32Array: b,
        globalThis: { Atomics: I, SharedArrayBuffer: L },
      } = s,
      M = t("events"),
      x = t("internal/assert"),
      O = t("path"),
      { now: P } = t("internal/perf/utils"),
      W = t("internal/errors").codes,
      {
        ERR_WORKER_NOT_RUNNING: D,
        ERR_WORKER_PATH: z,
        ERR_WORKER_UNSERIALIZABLE_ERROR: T,
        ERR_WORKER_INVALID_EXEC_ARGV: N,
        ERR_INVALID_ARG_TYPE: $,
        ERR_INVALID_ARG_VALUE: U,
      } = W,
      { getOptionValue: G } = t("internal/options"),
      C = t("internal/worker/io"),
      {
        drainMessagePort: V,
        receiveMessageOnPort: F,
        MessageChannel: H,
        messageTypes: j,
        kPort: Y,
        kIncrementsPortRef: K,
        kWaitingStreams: B,
        kStdioWantsMoreDataCallback: Z,
        setupPortReferencing: J,
        ReadableWorkerStdio: X,
        WritableWorkerStdio: q,
      } = C,
      { deserializeError: Q } = t("internal/error_serdes"),
      { fileURLToPath: ee, isURL: te, pathToFileURL: ie } = t("internal/url"),
      { kEmptyObject: re } = t("internal/util"),
      { validateArray: ne, validateString: se } = t("internal/validators"),
      {
        ownsProcessState: oe,
        isMainThread: ae,
        resourceLimits: le,
        threadId: he,
        Worker: ue,
        kMaxYoungGenerationSizeMb: de,
        kMaxOldGenerationSizeMb: ce,
        kCodeRangeSizeMb: pe,
        kStackSizeMb: me,
        kTotalResourceLimitCount: fe,
      } = n("worker"),
      ge = _("kHandle"),
      ve = _("kPublicPort"),
      Re = _("kDispose"),
      ke = _("kOnExit"),
      Se = _("kOnMessage"),
      Ee = _("kOnCouldNotSerializeErr"),
      we = _("kOnErrorMessage"),
      _e = _("kParentSideStdio"),
      ye = _("kLoopStartTime"),
      Ae = _("kIsInternal"),
      be = _("kIsOnline"),
      Ie = y("nodejs.worker_threads.SHARE_ENV");
    let Le,
      Me = t("internal/util/debuglog").debuglog("worker", (e) => {
        Me = e;
      });
    const xe = new S();
    if (ae && void 0 !== L && void 0 !== I) {
      Le = new b(new L(4));
      const e = r.chdir;
      r.chdir = function (t) {
        I.add(Le, 0, 1), e(t);
      };
    }
    class Worker extends M {
      constructor(e, i = re) {
        super();
        const n = arguments[2] === Ae;
        let s, h, f, g;
        if (
          (Me(`[${he}] create new worker`, e, i, `isInternal: ${n}`),
          i.execArgv && ne(i.execArgv, "options.execArgv"),
          i.argv && (ne(i.argv, "options.argv"), (s = a(i.argv, E))),
          n)
        )
          (f = "internal"), (h = `node:${e}`);
        else if (i.eval) {
          if ("string" != typeof e)
            throw new U(
              "options.eval",
              i.eval,
              "must be false when 'filename' is not a string"
            );
          (h = null), (f = "classic");
        } else if (te(e) && "data:" === e.protocol)
          (h = null), (f = "module"), (e = `import ${d(`${e}`)}`);
        else if (((f = !1), te(e))) (h = e), (e = ee(e));
        else {
          if ("string" != typeof e)
            throw new $("filename", ["string", "URL"], e);
          if (!O.isAbsolute(e) && null === R(/^\.\.?[\\/]/, e)) throw new z(e);
          (e = O.resolve(e)), (h = ie(e));
        }
        if ("object" == typeof i.env && null !== i.env)
          (g = p(null)),
            o(m(i.env), ({ 0: e, 1: t }) => {
              g[e] = `${t}`;
            });
        else if (null == i.env) g = r.env;
        else if (i.env !== Ie)
          throw new $(
            "options.env",
            ["object", "undefined", "null", "worker_threads.SHARE_ENV"],
            i.env
          );
        let v = "";
        if (
          (i.name && (se(i.name, "options.name"), (v = w(i.name))),
          Me("instantiating Worker.", `url: ${h}`, `doEval: ${f}`),
          (this[ge] = new ue(
            h,
            g === r.env ? null : g,
            i.execArgv,
            (function parseResourceLimits(e) {
              const t = Oe;
              if ((A(t, -1), "object" != typeof e || null === e)) return t;
              "number" == typeof e.maxOldGenerationSizeMb &&
                (t[ce] = c(e.maxOldGenerationSizeMb, 2));
              "number" == typeof e.maxYoungGenerationSizeMb &&
                (t[de] = e.maxYoungGenerationSizeMb);
              "number" == typeof e.codeRangeSizeMb &&
                (t[pe] = e.codeRangeSizeMb);
              "number" == typeof e.stackSizeMb && (t[me] = e.stackSizeMb);
              return t;
            })(i.resourceLimits),
            !!(i.trackUnmanagedFds ?? 1),
            n,
            v
          )),
          this[ge].invalidExecArgv)
        )
          throw new N(this[ge].invalidExecArgv);
        if (this[ge].invalidNodeOptions)
          throw new N(
            this[ge].invalidNodeOptions,
            "invalid NODE_OPTIONS env variable"
          );
        (this[ge].onexit = (e, t, i) => {
          this[ke](e, t, i);
        }),
          (this[Y] = this[ge].messagePort),
          this[Y].on("message", (e) => this[Se](e)),
          this[Y].start(),
          this[Y].unref(),
          (this[Y][B] = 0),
          Me(`[${he}] created Worker with ID ${this.threadId}`);
        let S = null;
        i.stdin && (S = new q(this[Y], "stdin"));
        const _ = new X(this[Y], "stdout");
        i.stdout || ((_[K] = !1), pipeWithoutWarning(_, r.stdout));
        const y = new X(this[Y], "stderr");
        i.stderr || ((y[K] = !1), pipeWithoutWarning(y, r.stderr)),
          (this[_e] = { stdin: S, stdout: _, stderr: y });
        const { port1: b, port2: I } = new H(),
          L = [I];
        i.transferList && l(L, ...new k(i.transferList)),
          (this[ve] = b),
          o(["message", "messageerror"], (e) => {
            this[ve].on(e, (t) => this.emit(e, t));
          }),
          J(this[ve], this, "message"),
          this[Y].postMessage(
            {
              argv: s,
              type: j.LOAD_SCRIPT,
              filename: e,
              doEval: f,
              isInternal: n,
              cwdCounter: Le || C.sharedCwdCounter,
              workerData: i.workerData,
              environmentData: xe,
              publicPort: I,
              manifestURL: G("--experimental-policy")
                ? t("internal/process/policy").url
                : null,
              manifestSrc: G("--experimental-policy")
                ? t("internal/process/policy").src
                : null,
              hasStdin: !!i.stdin,
            },
            L
          ),
          (this[ye] = -1),
          (this[be] = !1),
          (this.performance = {
            eventLoopUtilization: u(eventLoopUtilization, this),
          }),
          this[ge].startThread(),
          r.nextTick(() => r.emit("worker", this));
      }
      [ke](e, t, i) {
        Me(`[${he}] hears end event for Worker ${this.threadId}`),
          V(this[ve]),
          V(this[Y]),
          this.removeAllListeners("message"),
          this.removeAllListeners("messageerrors"),
          this[ve].unref(),
          this[Y].unref(),
          this[Re](),
          t &&
            (Me(
              `[${he}] failing with custom error ${t}         and with reason ${i}`
            ),
            this.emit("error", new W[t](i))),
          this.emit("exit", e),
          this.removeAllListeners();
      }
      [Ee]() {
        this.emit("error", new T());
      }
      [we](e) {
        const t = Q(e);
        this.emit("error", t);
      }
      [Se](e) {
        switch (e.type) {
          case j.UP_AND_RUNNING:
            return (this[be] = !0), this.emit("online");
          case j.COULD_NOT_SERIALIZE_ERROR:
            return this[Ee]();
          case j.ERROR_MESSAGE:
            return this[we](e.error);
          case j.STDIO_PAYLOAD: {
            const { stream: t, chunks: i } = e,
              r = this[_e][t];
            return void o(i, ({ chunk: e, encoding: t }) => {
              r.push(e, t);
            });
          }
          case j.STDIO_WANTS_MORE_DATA: {
            const { stream: t } = e;
            return this[_e][t][Z]();
          }
        }
        x.fail(`Unknown worker message type ${e.type}`);
      }
      [Re]() {
        (this[ge].onexit = null),
          (this[ge] = null),
          (this[Y] = null),
          (this[ve] = null);
        const { stdout: e, stderr: t } = this[_e];
        e.readableEnded ||
          (Me(`[${he}] explicitly closes stdout for ${this.threadId}`),
          e.push(null)),
          t.readableEnded ||
            (Me(`[${he}] explicitly closes stderr for ${this.threadId}`),
            t.push(null));
      }
      postMessage(...e) {
        null !== this[ve] && v(this[ve].postMessage, this[ve], e);
      }
      terminate(e) {
        if (
          (Me(`[${he}] terminates Worker with ID ${this.threadId}`),
          this.ref(),
          "function" == typeof e)
        ) {
          if (
            (r.emitWarning(
              "Passing a callback to worker.terminate() is deprecated. It returns a Promise instead.",
              "DeprecationWarning",
              "DEP0132"
            ),
            null === this[ge])
          )
            return g();
          this.once("exit", (t) => e(null, t));
        }
        return null === this[ge]
          ? g()
          : (this[ge].stopThread(),
            new f((e) => {
              this.once("exit", e);
            }));
      }
      ref() {
        null !== this[ge] && (this[ge].ref(), this[ve].ref());
      }
      unref() {
        null !== this[ge] && (this[ge].unref(), this[ve].unref());
      }
      get threadId() {
        return null === this[ge] ? -1 : this[ge].threadId;
      }
      get stdin() {
        return this[_e].stdin;
      }
      get stdout() {
        return this[_e].stdout;
      }
      get stderr() {
        return this[_e].stderr;
      }
      get resourceLimits() {
        return null === this[ge]
          ? {}
          : makeResourceLimits(this[ge].getResourceLimits());
      }
      getHeapSnapshot() {
        const e = this[ge] && this[ge].takeHeapSnapshot();
        return new f((i, r) => {
          if (!e) return r(new D());
          e.ondone = (e) => {
            const { HeapSnapshotStream: r } = t("internal/heap_utils");
            i(new r(e));
          };
        });
      }
    }
    function pipeWithoutWarning(e, t) {
      const i = e._maxListeners,
        r = t._maxListeners;
      e.setMaxListeners(1 / 0),
        t.setMaxListeners(1 / 0),
        e.pipe(t),
        (e._maxListeners = i),
        (t._maxListeners = r);
    }
    const Oe = new h(fe);
    function makeResourceLimits(e) {
      return {
        maxYoungGenerationSizeMb: e[de],
        maxOldGenerationSizeMb: e[ce],
        codeRangeSizeMb: e[pe],
        stackSizeMb: e[me],
      };
    }
    function eventLoopUtilization(e, t) {
      if (!this[be] || !this[ge]) return { idle: 0, active: 0, utilization: 0 };
      if (
        -1 === this[ye] &&
        ((this[ye] = this[ge].loopStartTime()), -1 === this[ye])
      )
        return { idle: 0, active: 0, utilization: 0 };
      if (t) {
        const i = e.idle - t.idle,
          r = e.active - t.active;
        return { idle: i, active: r, utilization: r / (i + r) };
      }
      const i = this[ge].loopIdleTime(),
        r = P() - this[ye] - i;
      if (!e) return { idle: i, active: r, utilization: r / (i + r) };
      const n = i - e.idle,
        s = r - e.active;
      return { idle: n, active: s, utilization: s / (n + s) };
    }
    i.exports = {
      ownsProcessState: oe,
      kIsOnline: be,
      isMainThread: ae,
      SHARE_ENV: Ie,
      resourceLimits: ae ? {} : makeResourceLimits(le),
      setEnvironmentData: function setEnvironmentData(e, t) {
        void 0 === t ? xe.delete(e) : xe.set(e, t);
      },
      getEnvironmentData: function getEnvironmentData(e) {
        return xe.get(e);
      },
      assignEnvironmentData: function assignEnvironmentData(e) {
        void 0 !== e &&
          e.forEach((e, t) => {
            xe.set(t, e);
          });
      },
      threadId: he,
      InternalWorker: class InternalWorker extends Worker {
        constructor(e, t) {
          super(e, t, Ae);
        }
        receiveMessageSync() {
          return F(this[ve]);
        }
      },
      Worker: Worker,
    };
  },
  "internal/worker/io": function (e, t, s, n, r, o) {
    "use strict";
    const {
        ArrayPrototypeForEach: i,
        ArrayPrototypeMap: a,
        ArrayPrototypePush: h,
        FunctionPrototypeBind: l,
        FunctionPrototypeCall: c,
        ObjectAssign: u,
        ObjectCreate: d,
        ObjectDefineProperty: g,
        ObjectDefineProperties: p,
        ObjectGetOwnPropertyDescriptors: f,
        ObjectGetPrototypeOf: v,
        ObjectSetPrototypeOf: _,
        ObjectValues: M,
        ReflectApply: m,
        Symbol: E,
        SymbolFor: w,
      } = o,
      {
        kEmptyObject: b,
        kEnumerableProperty: y,
        setOwnProperty: P,
      } = t("internal/util"),
      { handle_onclose: k, oninit: C, no_message_symbol: R } = r("symbols"),
      {
        MessagePort: S,
        MessageChannel: O,
        broadcastChannel: A,
        drainMessagePort: B,
        moveMessagePortToContext: W,
        receiveMessageOnPort: D,
        stopMessagePort: I,
        checkMessagePort: T,
        DOMException: L,
      } = r("messaging"),
      { getEnvMessagePort: N } = r("worker"),
      { Readable: j, Writable: x } = t("stream"),
      {
        Event: G,
        EventTarget: F,
        NodeEventTarget: $,
        defineEventHandler: Y,
        initNodeEventTarget: H,
        kCreateEvent: U,
        kNewListener: V,
        kRemoveListener: z,
      } = t("internal/event_target"),
      { inspect: Z } = t("internal/util/inspect"),
      {
        codes: {
          ERR_INVALID_ARG_TYPE: q,
          ERR_INVALID_THIS: J,
          ERR_MISSING_ARGS: K,
        },
      } = t("internal/errors"),
      Q = E("kData"),
      X = E("kHandle"),
      ee = E("kIncrementsPortRef"),
      te = E("kLastEventId"),
      se = E("kName"),
      ne = E("kOrigin"),
      re = E("kOnMessage"),
      oe = E("kOnMessageError"),
      ie = E("kPort"),
      ae = E("kPorts"),
      he = E("kWaitingStreams"),
      le = E("kWritableCallbacks"),
      ce = E("kSource"),
      ue = E("kStartedReading"),
      de = E("kStdioWantsMoreDataCallback"),
      ge = w("nodejs.internal.kCurrentlyReceivingPorts"),
      pe = E("kType"),
      fe = {
        UP_AND_RUNNING: "upAndRunning",
        COULD_NOT_SERIALIZE_ERROR: "couldNotSerializeError",
        ERROR_MESSAGE: "errorMessage",
        STDIO_PAYLOAD: "stdioPayload",
        STDIO_WANTS_MORE_DATA: "stdioWantsMoreData",
        LOAD_SCRIPT: "loadScript",
      },
      ve = f(S.prototype),
      _e = M(ve);
    for (let e = 0; e < _e.length; e++) _(_e[e], null);
    const Me = d(v(S.prototype), ve);
    function validateMessagePort(e, t) {
      if (!T(e)) throw new q(t, "MessagePort", e);
    }
    function isMessageEvent(e) {
      return null != e && Q in e;
    }
    _(S, $),
      _(S.prototype, $.prototype),
      (S.prototype.ref = Me.ref),
      (S.prototype.unref = Me.unref),
      (S.prototype.hasRef = function () {
        return !!c(Me.hasRef, this);
      });
    class MessageEvent extends G {
      constructor(
        e,
        {
          data: t = null,
          origin: s = "",
          lastEventId: n = "",
          source: r = null,
          ports: o = [],
        } = b
      ) {
        super(e),
          (this[Q] = t),
          (this[ne] = `${s}`),
          (this[te] = `${n}`),
          (this[ce] = r),
          (this[ae] = [...o]),
          null !== this[ce] && validateMessagePort(this[ce], "init.source");
        for (let e = 0; e < this[ae].length; e++)
          validateMessagePort(this[ae][e], `init.ports[${e}]`);
      }
    }
    p(MessageEvent.prototype, {
      data: {
        __proto__: null,
        get() {
          if (!isMessageEvent(this)) throw new J("MessageEvent");
          return this[Q];
        },
        enumerable: !0,
        configurable: !0,
        set: void 0,
      },
      origin: {
        __proto__: null,
        get() {
          if (!isMessageEvent(this)) throw new J("MessageEvent");
          return this[ne];
        },
        enumerable: !0,
        configurable: !0,
        set: void 0,
      },
      lastEventId: {
        __proto__: null,
        get() {
          if (!isMessageEvent(this)) throw new J("MessageEvent");
          return this[te];
        },
        enumerable: !0,
        configurable: !0,
        set: void 0,
      },
      source: {
        __proto__: null,
        get() {
          if (!isMessageEvent(this)) throw new J("MessageEvent");
          return this[ce];
        },
        enumerable: !0,
        configurable: !0,
        set: void 0,
      },
      ports: {
        __proto__: null,
        get() {
          if (!isMessageEvent(this)) throw new J("MessageEvent");
          return this[ae];
        },
        enumerable: !0,
        configurable: !0,
        set: void 0,
      },
    });
    const me = F.prototype[U];
    g(S.prototype, U, {
      __proto__: null,
      value: function (e, t) {
        if ("message" !== t && "messageerror" !== t)
          return m(me, this, arguments);
        const s = this[ge];
        return (this[ge] = void 0), new MessageEvent(t, { data: e, ports: s });
      },
      configurable: !1,
      writable: !1,
      enumerable: !1,
    }),
      Y(S.prototype, "message"),
      Y(S.prototype, "messageerror"),
      g(S.prototype, C, {
        __proto__: null,
        enumerable: !0,
        writable: !1,
        value: function oninit() {
          H(this),
            setupPortReferencing(this, this, "message"),
            (this[ge] = void 0);
        },
      });
    class MessagePortCloseEvent extends G {
      constructor() {
        super("close");
      }
    }
    function setupPortReferencing(e, t, s) {
      e.unref(),
        t.on("newListener", function (e) {
          e === s && newListener(t.listenerCount(e));
        }),
        t.on("removeListener", function (e) {
          e === s && removeListener(t.listenerCount(e));
        });
      const n = t[V];
      P(t, V, function (e, t, ...r) {
        return t === s && newListener(e - 1), m(n, this, arguments);
      });
      const r = t[z];
      function newListener(t) {
        0 === t && (e.ref(), c(Me.start, e));
      }
      function removeListener(t) {
        0 === t && (I(e), e.unref());
      }
      P(t, z, function (e, t, ...n) {
        return t === s && removeListener(e), m(r, this, arguments);
      });
    }
    g(S.prototype, k, {
      __proto__: null,
      enumerable: !1,
      writable: !1,
      value: function onclose() {
        this.dispatchEvent(new MessagePortCloseEvent());
      },
    }),
      (S.prototype.close = function (e) {
        "function" == typeof e && this.once("close", e), c(Me.close, this);
      }),
      g(S.prototype, Z.custom, {
        __proto__: null,
        enumerable: !1,
        writable: !1,
        value: function inspect2() {
          let e;
          try {
            e = c(Me.hasRef, this);
          } catch {
            return this;
          }
          return u(
            d(S.prototype),
            void 0 === e ? { active: !1 } : { active: !0, refed: e },
            this
          );
        },
      });
    class ReadableWorkerStdio extends j {
      constructor(e, t) {
        super(),
          (this[ie] = e),
          (this[se] = t),
          (this[ee] = !0),
          (this[ue] = !1),
          this.on("end", () => {
            this[ue] && this[ee] && 0 == --this[ie][he] && this[ie].unref();
          });
      }
      _read() {
        !this[ue] &&
          this[ee] &&
          ((this[ue] = !0), 0 == this[ie][he]++ && this[ie].ref()),
          this[ie].postMessage({
            type: fe.STDIO_WANTS_MORE_DATA,
            stream: this[se],
          });
      }
    }
    class WritableWorkerStdio extends x {
      constructor(e, t) {
        super({ decodeStrings: !1 }),
          (this[ie] = e),
          (this[se] = t),
          (this[le] = []);
      }
      _writev(e, t) {
        this[ie].postMessage({
          type: fe.STDIO_PAYLOAD,
          stream: this[se],
          chunks: a(e, ({ chunk: e, encoding: t }) => ({
            chunk: e,
            encoding: t,
          })),
        }),
          h(this[le], t),
          0 == this[ie][he]++ && this[ie].ref();
      }
      _final(e) {
        this[ie].postMessage({
          type: fe.STDIO_PAYLOAD,
          stream: this[se],
          chunks: [{ chunk: null, encoding: "" }],
        }),
          e();
      }
      [de]() {
        const e = this[le];
        (this[le] = []),
          i(e, (e) => e()),
          0 == (this[ie][he] -= e.length) && this[ie].unref();
      }
    }
    function onMessageEvent(e, t) {
      this.dispatchEvent(new MessageEvent(e, { data: t }));
    }
    function isBroadcastChannel(e) {
      return "BroadcastChannel" === e?.[pe];
    }
    class BroadcastChannel extends F {
      constructor(e) {
        if (0 === arguments.length) throw new K("name");
        super(),
          (this[pe] = "BroadcastChannel"),
          (this[se] = `${e}`),
          (this[X] = A(this[se])),
          (this[re] = l(onMessageEvent, this, "message")),
          (this[oe] = l(onMessageEvent, this, "messageerror")),
          this[X].on("message", this[re]),
          this[X].on("messageerror", this[oe]);
      }
      [Z.custom](e, t) {
        if (!isBroadcastChannel(this)) throw new J("BroadcastChannel");
        if (e < 0) return "BroadcastChannel";
        const s = { ...t, depth: null == t.depth ? null : t.depth - 1 };
        return `BroadcastChannel ${Z(
          { name: this[se], active: void 0 !== this[X] },
          s
        )}`;
      }
      get name() {
        if (!isBroadcastChannel(this)) throw new J("BroadcastChannel");
        return this[se];
      }
      close() {
        if (!isBroadcastChannel(this)) throw new J("BroadcastChannel");
        void 0 !== this[X] &&
          (this[X].off("message", this[re]),
          this[X].off("messageerror", this[oe]),
          (this[re] = void 0),
          (this[oe] = void 0),
          this[X].close(),
          (this[X] = void 0));
      }
      postMessage(e) {
        if (!isBroadcastChannel(this)) throw new J("BroadcastChannel");
        if (0 === arguments.length) throw new K("message");
        if (void 0 === this[X]) throw new L("BroadcastChannel is closed.");
        if (void 0 === this[X].postMessage(e))
          throw new L("Message could not be posted.");
      }
      ref() {
        if (!isBroadcastChannel(this)) throw new J("BroadcastChannel");
        return this[X] && this[X].ref(), this;
      }
      unref() {
        if (!isBroadcastChannel(this)) throw new J("BroadcastChannel");
        return this[X] && this[X].unref(), this;
      }
    }
    p(BroadcastChannel.prototype, { name: y, close: y, postMessage: y }),
      Y(BroadcastChannel.prototype, "message"),
      Y(BroadcastChannel.prototype, "messageerror"),
      (s.exports = {
        drainMessagePort: B,
        messageTypes: fe,
        kPort: ie,
        kIncrementsPortRef: ee,
        kWaitingStreams: he,
        kStdioWantsMoreDataCallback: de,
        moveMessagePortToContext: W,
        MessagePort: S,
        MessageChannel: O,
        MessageEvent: MessageEvent,
        receiveMessageOnPort: function receiveMessageOnPort(e) {
          const t = D(e?.[X] ?? e);
          if (t !== R) return { message: t };
        },
        setupPortReferencing: setupPortReferencing,
        ReadableWorkerStdio: ReadableWorkerStdio,
        WritableWorkerStdio: WritableWorkerStdio,
        createWorkerStdio: function createWorkerStdio() {
          const e = N();
          return (
            (e[he] = 0),
            {
              stdin: new ReadableWorkerStdio(e, "stdin"),
              stdout: new WritableWorkerStdio(e, "stdout"),
              stderr: new WritableWorkerStdio(e, "stderr"),
            }
          );
        },
        BroadcastChannel: BroadcastChannel,
      });
  },
  "internal/worker/js_transferable": function (e, t, r, n, s, o) {
    "use strict";
    const {
        Error: i,
        ObjectDefineProperties: a,
        ObjectGetOwnPropertyDescriptors: c,
        ObjectGetPrototypeOf: f,
        ObjectSetPrototypeOf: l,
        ObjectValues: u,
        ReflectConstruct: b,
        StringPrototypeSplit: p,
      } = o,
      {
        messaging_deserialize_symbol: g,
        messaging_transfer_symbol: m,
        messaging_clone_symbol: y,
        messaging_transfer_list_symbol: _,
      } = s("symbols"),
      { JSTransferable: O, setDeserializerCreateObjectFunction: k } =
        s("messaging");
    r.exports = {
      makeTransferable: function makeTransferable(e) {
        if (e instanceof O) return e;
        const t = b(O, [], e.constructor),
          r = c(e),
          n = u(r);
        for (let e = 0; e < n.length; e++) l(n[e], null);
        return a(t, r), l(t, f(e)), t;
      },
      setup: function setup() {
        k((e) => {
          const { 0: r, 1: n } = p(e, ":"),
            s = t(r)[n];
          if ("function" != typeof s || "function" != typeof s.prototype[g])
            throw new i(`Unknown deserialize spec ${e}`);
          return new s();
        });
      },
      JSTransferable: O,
      kClone: y,
      kDeserialize: g,
      kTransfer: m,
      kTransferList: _,
    };
  },
  module: function (e, r, o, a, c, s) {
    "use strict";
    const { findSourceMap: n } = r("internal/source_map/source_map_cache"),
      { Module: u } = r("internal/modules/cjs/loader"),
      { register: t } = r("internal/modules/esm/loader"),
      { SourceMap: i } = r("internal/source_map/source_map");
    (u.findSourceMap = n), (u.register = t), (u.SourceMap = i), (o.exports = u);
  },
  net: function (e, t, n, o, i, r) {
    "use strict";
    const {
        ArrayIsArray: s,
        ArrayPrototypeIndexOf: l,
        ArrayPrototypePush: c,
        Boolean: a,
        FunctionPrototypeBind: h,
        FunctionPrototypeCall: d,
        MathMax: u,
        Number: p,
        NumberIsNaN: f,
        NumberParseInt: _,
        ObjectDefineProperty: m,
        ObjectSetPrototypeOf: y,
        Symbol: g,
        ObjectCreate: k,
        SymbolAsyncDispose: S,
      } = r,
      b = t("events"),
      v = t("stream");
    let A = t("internal/util/debuglog").debuglog("net", (e) => {
      A = e;
    });
    const {
        kReinitializeHandle: w,
        isIP: E,
        isIPv4: D,
        isIPv6: T,
        normalizedArgsSymbol: C,
        makeSyncWrite: N,
      } = t("internal/net"),
      I = t("internal/assert"),
      {
        UV_EADDRINUSE: P,
        UV_EINVAL: R,
        UV_ENOTCONN: O,
        UV_ECANCELED: H,
      } = i("uv"),
      { Buffer: M } = t("buffer"),
      { guessHandleType: L } = i("util"),
      { ShutdownWrap: x } = i("stream_wrap"),
      { TCP: W, TCPConnectWrap: F, constants: V } = i("tcp_wrap"),
      { Pipe: B, PipeConnectWrap: G, constants: j } = i("pipe_wrap"),
      {
        newAsyncId: K,
        defaultTriggerAsyncIdScope: z,
        symbols: { async_id_symbol: U, owner_symbol: Y },
      } = t("internal/async_hooks"),
      {
        writevGeneric: $,
        writeGeneric: q,
        onStreamRead: Q,
        kAfterAsyncWrite: J,
        kHandle: X,
        kUpdateTimer: Z,
        setStreamTimeout: ee,
        kBuffer: te,
        kBufferCb: ne,
        kBufferGen: oe,
      } = t("internal/stream_base_commons"),
      {
        codes: {
          ERR_INVALID_ADDRESS_FAMILY: ie,
          ERR_INVALID_ARG_TYPE: re,
          ERR_INVALID_ARG_VALUE: se,
          ERR_INVALID_FD_TYPE: le,
          ERR_INVALID_IP_ADDRESS: ce,
          ERR_INVALID_HANDLE_TYPE: ae,
          ERR_SERVER_ALREADY_LISTEN: he,
          ERR_SERVER_NOT_RUNNING: de,
          ERR_SOCKET_CLOSED: ue,
          ERR_SOCKET_CLOSED_BEFORE_CONNECTION: pe,
          ERR_MISSING_ARGS: fe,
        },
        aggregateErrors: _e,
        errnoException: me,
        exceptionWithHostPort: ye,
        genericNodeError: ge,
        uvExceptionWithHostPort: ke,
      } = t("internal/errors"),
      { isUint8Array: Se } = t("internal/util/types"),
      { queueMicrotask: be } = t("internal/process/task_queues"),
      { kEmptyObject: ve, promisify: Ae } = t("internal/util"),
      {
        validateAbortSignal: we,
        validateBoolean: Ee,
        validateFunction: De,
        validateInt32: Te,
        validateNumber: Ce,
        validatePort: Ne,
        validateString: Ie,
      } = t("internal/validators"),
      Pe = g("lastWriteQueueSize"),
      { DTRACE_NET_SERVER_CONNECTION: Re, DTRACE_NET_STREAM_END: Oe } =
        t("internal/dtrace"),
      { getOptionValue: He } = t("internal/options");
    let Me,
      Le,
      xe,
      We,
      Fe = He("--enable-network-family-autoselection"),
      Ve = 250;
    const { clearTimeout: Be, setTimeout: Ge } = t("timers"),
      { kTimeout: je } = t("internal/timers"),
      Ke = "0.0.0.0",
      ze = "::",
      Ue = "win32" === o.platform,
      noop = () => {},
      Ye = g("kPerfHooksNetConnectContext");
    let $e, qe;
    function lazyChannels() {
      if (void 0 === $e) {
        const e = t("diagnostics_channel");
        ($e = e.channel("net.client.socket")),
          (qe = e.channel("net.server.socket"));
      }
    }
    const {
        hasObserver: Qe,
        startPerf: Je,
        stopPerf: Xe,
      } = t("internal/perf/observe"),
      { getDefaultHighWaterMark: Ze } = t("internal/streams/state");
    function createHandle(e, t) {
      Te(e, "fd", 0);
      const n = L(e);
      if ("PIPE" === n) return new B(t ? j.SERVER : j.SOCKET);
      if ("TCP" === n) return new W(t ? V.SERVER : V.SOCKET);
      throw new le(n);
    }
    function getNewAsyncId(e) {
      return e && "function" == typeof e.getAsyncId ? e.getAsyncId() : K();
    }
    function isPipeName(e) {
      return "string" == typeof e && !1 === toNumber(e);
    }
    function connect(...e) {
      const t = normalizeArgs(e),
        n = t[0];
      A("createConnection", t);
      const o = new Socket(n);
      return (
        lazyChannels(),
        $e.hasSubscribers && $e.publish({ socket: o }),
        n.timeout && o.setTimeout(n.timeout),
        o.connect(t)
      );
    }
    function normalizeArgs(e) {
      let t;
      if (0 === e.length) return (t = [{}, null]), (t[C] = !0), t;
      const n = e[0];
      let o = {};
      "object" == typeof n && null !== n
        ? (o = n)
        : isPipeName(n)
        ? (o.path = n)
        : ((o.port = n),
          e.length > 1 && "string" == typeof e[1] && (o.host = e[1]));
      const i = e[e.length - 1];
      return (t = "function" != typeof i ? [o, null] : [o, i]), (t[C] = !0), t;
    }
    function initSocketHandle(e) {
      if ((e._undestroy(), (e._sockname = null), e._handle)) {
        (e._handle[Y] = e),
          (e._handle.onread = Q),
          (e[U] = getNewAsyncId(e._handle));
        let t = e[te];
        if (t) {
          const n = e[oe];
          if (null !== n) {
            if (((t = n()), !Se(t))) return;
            e[te] = t;
          }
          e._handle.useUserBuffer(t);
        }
      }
    }
    function closeSocketHandle(e, t, n = !1) {
      e._handle &&
        e._handle.close(() => {
          A("emit close"),
            e.emit("close", t),
            n &&
              ((e._handle.onread = noop),
              (e._handle = null),
              (e._sockname = null));
        });
    }
    const et = g("kBytesRead"),
      tt = g("kBytesWritten"),
      nt = g("kSetNoDelay"),
      ot = g("kSetKeepAlive"),
      it = g("kSetKeepAliveInitialDelay");
    function Socket(e) {
      if (!(this instanceof Socket)) return new Socket(e);
      if (e?.objectMode)
        throw new se("options.objectMode", e.objectMode, "is not supported");
      if (e?.readableObjectMode || e?.writableObjectMode)
        throw new se(
          "options." +
            (e.readableObjectMode
              ? "readableObjectMode"
              : "writableObjectMode"),
          e.readableObjectMode || e.writableObjectMode,
          "is not supported"
        );
      if (
        (void 0 !== e?.keepAliveInitialDelay &&
          (Ce(e?.keepAliveInitialDelay, "options.keepAliveInitialDelay"),
          e.keepAliveInitialDelay < 0 && (e.keepAliveInitialDelay = 0)),
        (this.connecting = !1),
        (this[U] = -1),
        (this._hadError = !1),
        (this[X] = null),
        (this._parent = null),
        (this._host = null),
        (this[Pe] = 0),
        (this[je] = null),
        (this[te] = null),
        (this[ne] = null),
        (this[oe] = null),
        (this._closeAfterHandlingError = !1),
        ((e = "number" == typeof e ? { fd: e } : { ...e }).allowHalfOpen = a(
          e.allowHalfOpen
        )),
        (e.emitClose = !1),
        (e.autoDestroy = !0),
        (e.decodeStrings = !1),
        v.Duplex.call(this, e),
        e.handle)
      )
        (this._handle = e.handle), (this[U] = getNewAsyncId(this._handle));
      else if (void 0 !== e.fd) {
        const { fd: t } = e;
        let n;
        if (
          ((this._handle = createHandle(t, !1)), (n = this._handle.open(t)), n)
        )
          throw me(n, "open");
        if (
          ((this[U] = this._handle.getAsyncId()),
          (1 === t || 2 === t) && this._handle instanceof B && Ue)
        ) {
          if (((n = this._handle.setBlocking(!0)), n))
            throw me(n, "setBlocking");
          (this._writev = null),
            (this._write = N(t)),
            m(this._handle, "bytesWritten", {
              __proto__: null,
              value: 0,
              writable: !0,
            });
        }
      }
      const t = e.onread;
      null === t ||
        "object" != typeof t ||
        (!Se(t.buffer) && "function" != typeof t.buffer) ||
        "function" != typeof t.callback ||
        ("function" == typeof t.buffer
          ? ((this[te] = !0), (this[oe] = t.buffer))
          : (this[te] = t.buffer),
        (this[ne] = t.callback)),
        (this[nt] = a(e.noDelay)),
        (this[ot] = a(e.keepAlive)),
        (this[it] = ~~(e.keepAliveInitialDelay / 1e3)),
        this.on("end", onReadableStreamEnd),
        initSocketHandle(this),
        (this._pendingData = null),
        (this._pendingEncoding = ""),
        this._handle &&
          !1 !== e.readable &&
          (e.pauseOnCreate
            ? ((this._handle.reading = !1),
              this._handle.readStop(),
              (this.readableFlowing = !1))
            : e.manualStart || this.read(0)),
        (this.server = null),
        (this._server = null),
        (this[et] = 0),
        (this[tt] = 0);
    }
    function afterShutdown() {
      const e = this.handle[Y];
      A("afterShutdown destroyed=%j", e.destroyed), this.callback();
    }
    function writeAfterFIN(e, t, n) {
      if (!this.writableEnded)
        return v.Duplex.prototype.write.call(this, e, t, n);
      "function" == typeof t && ((n = t), (t = null));
      const i = ge("This socket has been ended by the other party", {
        code: "EPIPE",
      });
      return (
        "function" == typeof n && z(this[U], o.nextTick, n, i),
        this.destroy(i),
        !1
      );
    }
    function tryReadStart(e) {
      A("Socket._handle.readStart"), (e._handle.reading = !0);
      const t = e._handle.readStart();
      t && e.destroy(me(t, "read"));
    }
    function onReadableStreamEnd() {
      this.allowHalfOpen || (this.write = writeAfterFIN);
    }
    function protoGetter(e, t) {
      m(Socket.prototype, e, {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        get: t,
      });
    }
    function checkBindError(e, t, n) {
      if (0 === e && t > 0 && n.getsockname) {
        const o = {};
        0 === (e = n.getsockname(o)) &&
          t !== o.port &&
          (A(`checkBindError, bound to ${o.port} instead of ${t}`), (e = P));
      }
      return e;
    }
    function internalConnect(e, t, n, o, i, r, s) {
      let l;
      if (
        (I(e.connecting),
        (i || r) &&
          (4 === o
            ? ((i = i || Ke), (l = e._handle.bind(i, r)))
            : ((i = i || ze), (l = e._handle.bind6(i, r, s))),
          A(
            "connect: binding to localAddress: %s and localPort: %d (addressType: %d)",
            i,
            r,
            o
          ),
          (l = checkBindError(l, r, e._handle)),
          l))
      ) {
        const t = ye(l, "bind", i, r);
        e.destroy(t);
      } else {
        if (
          (A(
            "connect: attempting to connect to %s:%d (addressType: %d)",
            t,
            n,
            o
          ),
          6 === o || 4 === o)
        ) {
          const s = new F();
          (s.oncomplete = afterConnect),
            (s.address = t),
            (s.port = n),
            (s.localAddress = i),
            (s.localPort = r),
            (l =
              4 === o
                ? e._handle.connect(s, t, n)
                : e._handle.connect6(s, t, n));
        } else {
          const n = new G();
          (n.address = t),
            (n.oncomplete = afterConnect),
            (l = e._handle.connect(n, t));
        }
        if (l) {
          const o = e._getsockname();
          let i;
          o && (i = o.address + ":" + o.port);
          const r = ye(l, "connect", t, n, i);
          e.destroy(r);
        } else
          (6 !== o && 4 !== o) ||
            !Qe("net") ||
            Je(e, Ye, {
              type: "net",
              name: "connect",
              detail: { host: t, port: n },
            });
      }
    }
    function internalConnectMultiple(e, t) {
      Be(e[je]);
      const n = e.socket;
      if (t || e.current === e.addresses.length)
        return void n.destroy(_e(e.errors));
      I(n.connecting);
      const o = e.current++,
        i = 0 === o ? n._handle : new W(V.SOCKET),
        { localPort: r, port: s, flags: l } = e,
        { address: a, family: d } = e.addresses[o];
      let u, p;
      if (
        r &&
        (4 === d
          ? ((u = Ke), (p = i.bind(u, r)))
          : ((u = ze), (p = i.bind6(u, r, l))),
        A(
          "connect/multiple: binding to localAddress: %s and localPort: %d (addressType: %d)",
          u,
          r,
          d
        ),
        (p = checkBindError(p, r, i)),
        p)
      )
        return (
          c(e.errors, ye(p, "bind", u, r)), void internalConnectMultiple(e)
        );
      A(
        "connect/multiple: attempting to connect to %s:%d (addressType: %d)",
        a,
        s,
        d
      );
      const f = new F();
      if (
        ((f.oncomplete = h(afterConnectMultiple, void 0, e, o)),
        (f.address = a),
        (f.port = s),
        (f.localAddress = u),
        (f.localPort = r),
        c(n.autoSelectFamilyAttemptedAddresses, `${a}:${s}`),
        (p = 4 === d ? i.connect(f, a, s) : i.connect6(f, a, s)),
        p)
      ) {
        const t = n._getsockname();
        let o;
        return (
          t && (o = t.address + ":" + t.port),
          c(e.errors, ye(p, "connect", a, s, o)),
          void internalConnectMultiple(e)
        );
      }
      o < e.addresses.length - 1 &&
        (A("connect/multiple: setting the attempt timeout to %d ms", e.timeout),
        (e[je] = Ge(internalConnectMultipleTimeout, e.timeout, e, f, i)));
    }
    function socketToDnsFamily(e) {
      switch (e) {
        case "IPv4":
          return 4;
        case "IPv6":
          return 6;
      }
      return e;
    }
    function connectErrorNT(e, t) {
      e.destroy(t);
    }
    function afterConnect(e, t, n, o, i) {
      const r = t[Y];
      if (!r.destroyed)
        if (
          (A("afterConnect"),
          I(r.connecting),
          (r.connecting = !1),
          (r._sockname = null),
          0 === e)
        )
          r.readable && !o && (r.push(null), r.read()),
            r.writable && !i && r.end(),
            r._unrefTimer(),
            r[nt] && r._handle.setNoDelay && r._handle.setNoDelay(!0),
            r[ot] &&
              r._handle.setKeepAlive &&
              r._handle.setKeepAlive(!0, r[it]),
            r.emit("connect"),
            r.emit("ready"),
            o && !r.isPaused() && r.read(0),
            r[Ye] && Qe("net") && Xe(r, Ye);
        else {
          let t;
          n.localAddress &&
            n.localPort &&
            (t = n.localAddress + ":" + n.localPort);
          const o = ye(e, "connect", n.address, n.port, t);
          t && ((o.localAddress = n.localAddress), (o.localPort = n.localPort)),
            r.destroy(o);
        }
    }
    function afterConnectMultiple(e, t, n, o, i, r, s) {
      if ((Be(e[je]), 0 === n && t !== e.current - 1))
        return (
          A(
            "connect/multiple: ignoring successful but timedout connection to %s:%s",
            i.address,
            i.port
          ),
          void o.close()
        );
      const l = e.socket;
      if (0 !== n) {
        let t;
        i.localAddress &&
          i.localPort &&
          (t = i.localAddress + ":" + i.localPort);
        const o = ye(n, "connect", i.address, i.port, t);
        return (
          t && ((o.localAddress = i.localAddress), (o.localPort = i.localPort)),
          c(e.errors, o),
          void internalConnectMultiple(e, n === H)
        );
      }
      if (0 === n && t !== e.current - 1)
        return (
          A(
            "connect/multiple: ignoring successful but timedout connection to %s:%s",
            i.address,
            i.port
          ),
          void o.close()
        );
      e.current > 1 && l[w] && (l[w](o), (o = l._handle)),
        Qe("net") &&
          Je(l, Ye, {
            type: "net",
            name: "connect",
            detail: { host: i.address, port: i.port },
          }),
        afterConnect(n, o, i, r, s);
    }
    function internalConnectMultipleTimeout(e, t, n) {
      A("connect/multiple: connection to %s:%s timed out", t.address, t.port),
        (t.oncomplete = void 0),
        n.close(),
        internalConnectMultiple(e);
    }
    function Server(e, t) {
      if (!(this instanceof Server)) return new Server(e, t);
      if ((b.call(this), "function" == typeof e))
        (t = e), (e = ve), this.on("connection", t);
      else {
        if (null != e && "object" != typeof e)
          throw new re("options", "Object", e);
        (e = { ...e }), "function" == typeof t && this.on("connection", t);
      }
      void 0 !== e.keepAliveInitialDelay &&
        (Ce(e.keepAliveInitialDelay, "options.keepAliveInitialDelay"),
        e.keepAliveInitialDelay < 0 && (e.keepAliveInitialDelay = 0)),
        void 0 !== e.highWaterMark &&
          (Ce(e.highWaterMark, "options.highWaterMark"),
          e.highWaterMark < 0 && (e.highWaterMark = Ze())),
        (this._connections = 0),
        (this[U] = -1),
        (this._handle = null),
        (this._usingWorkers = !1),
        (this._workers = []),
        (this._unref = !1),
        (this.allowHalfOpen = e.allowHalfOpen || !1),
        (this.pauseOnConnect = !!e.pauseOnConnect),
        (this.noDelay = a(e.noDelay)),
        (this.keepAlive = a(e.keepAlive)),
        (this.keepAliveInitialDelay = ~~(e.keepAliveInitialDelay / 1e3)),
        (this.highWaterMark = e.highWaterMark ?? Ze());
    }
    function toNumber(e) {
      return (e = p(e)) >= 0 && e;
    }
    function createServerHandle(e, t, n, i, r) {
      let s,
        l = 0,
        c = !1;
      if ("number" == typeof i && i >= 0) {
        try {
          s = createHandle(i, !0);
        } catch (e) {
          return A("listen invalid fd=%d:", i, e.message), R;
        }
        if (((l = s.open(i)), l)) return l;
        I(!e && !t);
      } else if (-1 === t && -1 === n) {
        if (((s = new B(j.SERVER)), Ue)) {
          const e = _(o.env.NODE_PENDING_PIPE_INSTANCES);
          f(e) || s.setPendingInstances(e);
        }
      } else (s = new W(V.SERVER)), (c = !0);
      if (e || t || c)
        if ((A("bind to", e || "any"), e))
          l = 6 === n ? s.bind6(e, t, r) : s.bind(e, t);
        else if (((l = s.bind6(ze, t, r)), l))
          return s.close(), createServerHandle(Ke, t);
      return l ? (s.close(), l) : s;
    }
    function emitErrorNT(e, t) {
      e.emit("error", t);
    }
    function emitListeningNT(e) {
      e._handle && e.emit("listening");
    }
    function listenInCluster(e, n, o, i, r, s, l, c, a) {
      if (((l = !!l), void 0 === Me && (Me = t("cluster")), Me.isPrimary || l))
        return void e._listen2(n, o, i, r, s, c);
      const h = {
        address: n,
        port: o,
        addressType: i,
        fd: s,
        flags: c,
        backlog: r,
        ...a,
      };
      Me._getServer(e, h, function listenOnPrimaryHandle(t, l) {
        if ((t = checkBindError(t, o, l))) {
          const i = ye(t, "bind", n, o);
          return e.emit("error", i);
        }
        (e._handle = l), e._listen2(n, o, i, r, s, c);
      });
    }
    function onconnection(e, t) {
      const n = this[Y];
      if ((A("onconnection"), e)) return void n.emit("error", me(e, "accept"));
      if (n.maxConnections && n._connections >= n.maxConnections) {
        if (t.getsockname || t.getpeername) {
          const e = k(null);
          if (t.getsockname) {
            const n = k(null);
            t.getsockname(n),
              (e.localAddress = n.address),
              (e.localPort = n.port),
              (e.localFamily = n.family);
          }
          if (t.getpeername) {
            const n = k(null);
            t.getpeername(n),
              (e.remoteAddress = n.address),
              (e.remotePort = n.port),
              (e.remoteFamily = n.family);
          }
          n.emit("drop", e);
        } else n.emit("drop");
        return void t.close();
      }
      const o = new Socket({
        handle: t,
        allowHalfOpen: n.allowHalfOpen,
        pauseOnCreate: n.pauseOnConnect,
        readable: !0,
        writable: !0,
        readableHighWaterMark: n.highWaterMark,
        writableHighWaterMark: n.highWaterMark,
      });
      n.noDelay && t.setNoDelay && ((o[nt] = !0), t.setNoDelay(!0)),
        n.keepAlive &&
          t.setKeepAlive &&
          ((o[ot] = !0),
          (o[it] = n.keepAliveInitialDelay),
          t.setKeepAlive(!0, n.keepAliveInitialDelay)),
        n._connections++,
        (o.server = n),
        (o._server = n),
        Re(o),
        n.emit("connection", o),
        lazyChannels(),
        qe.hasSubscribers && qe.publish({ socket: o });
    }
    function emitCloseNT(e) {
      A("SERVER: emit close"), e.emit("close");
    }
    let rt;
    y(Socket.prototype, v.Duplex.prototype),
      y(Socket, v.Duplex),
      (Socket.prototype._unrefTimer = function _unrefTimer() {
        for (let e = this; null !== e; e = e._parent) e[je] && e[je].refresh();
      }),
      (Socket.prototype._final = function (e) {
        if (this.pending)
          return (
            A("_final: not yet connected"),
            this.once("connect", () => this._final(e))
          );
        if (!this._handle) return e();
        A("_final: not ended, call shutdown()");
        const t = new x();
        (t.oncomplete = afterShutdown),
          (t.handle = this._handle),
          (t.callback = e);
        const n = this._handle.shutdown(t);
        return 1 === n || n === O
          ? e()
          : 0 !== n
          ? e(me(n, "shutdown"))
          : void 0;
      }),
      (Socket.prototype.setTimeout = ee),
      (Socket.prototype._onTimeout = function () {
        const e = this._handle,
          t = this[Pe];
        if (t > 0 && e) {
          const { writeQueueSize: n } = e;
          if (t !== n) return (this[Pe] = n), void this._unrefTimer();
        }
        A("_onTimeout"), this.emit("timeout");
      }),
      (Socket.prototype.setNoDelay = function (e) {
        return (
          (e = a(void 0 === e || e)),
          this._handle
            ? (this._handle.setNoDelay &&
                e !== this[nt] &&
                ((this[nt] = e), this._handle.setNoDelay(e)),
              this)
            : ((this[nt] = e), this)
        );
      }),
      (Socket.prototype.setKeepAlive = function (e, t) {
        e = a(e);
        const n = ~~(t / 1e3);
        return this._handle
          ? this._handle.setKeepAlive
            ? ((e !== this[ot] || (e && this[it] !== n)) &&
                ((this[ot] = e),
                (this[it] = n),
                this._handle.setKeepAlive(e, n)),
              this)
            : this
          : ((this[ot] = e), (this[it] = n), this);
      }),
      (Socket.prototype.address = function () {
        return this._getsockname();
      }),
      m(Socket.prototype, "_connecting", {
        __proto__: null,
        get: function () {
          return this.connecting;
        },
      }),
      m(Socket.prototype, "pending", {
        __proto__: null,
        get() {
          return !this._handle || this.connecting;
        },
        configurable: !0,
      }),
      m(Socket.prototype, "readyState", {
        __proto__: null,
        get: function () {
          return this.connecting
            ? "opening"
            : this.readable && this.writable
            ? "open"
            : this.readable && !this.writable
            ? "readOnly"
            : !this.readable && this.writable
            ? "writeOnly"
            : "closed";
        },
      }),
      m(Socket.prototype, "bufferSize", {
        __proto__: null,
        get: function () {
          if (this._handle) return this.writableLength;
        },
      }),
      m(Socket.prototype, Z, {
        __proto__: null,
        get: function () {
          return this._unrefTimer;
        },
      }),
      (Socket.prototype._read = function (e) {
        A(
          "_read - n",
          e,
          "isConnecting?",
          !!this.connecting,
          "hasHandle?",
          !!this._handle
        ),
          this.connecting || !this._handle
            ? (A("_read wait for connection"),
              this.once("connect", () => this._read(e)))
            : this._handle.reading || tryReadStart(this);
      }),
      (Socket.prototype.end = function (e, t, n) {
        return v.Duplex.prototype.end.call(this, e, t, n), Oe(this), this;
      }),
      (Socket.prototype.resetAndDestroy = function () {
        if (this._handle) {
          if (!(this._handle instanceof W)) throw new ae();
          this.connecting
            ? (A("reset wait for connection"),
              this.once("connect", () => this._reset()))
            : this._reset();
        } else this.destroy(new ue());
        return this;
      }),
      (Socket.prototype.pause = function () {
        if (
          this[te] &&
          !this.connecting &&
          this._handle &&
          this._handle.reading &&
          ((this._handle.reading = !1), !this.destroyed)
        ) {
          const e = this._handle.readStop();
          e && this.destroy(me(e, "read"));
        }
        return v.Duplex.prototype.pause.call(this);
      }),
      (Socket.prototype.resume = function () {
        return (
          this[te] &&
            !this.connecting &&
            this._handle &&
            !this._handle.reading &&
            tryReadStart(this),
          v.Duplex.prototype.resume.call(this)
        );
      }),
      (Socket.prototype.read = function (e) {
        return (
          this[te] &&
            !this.connecting &&
            this._handle &&
            !this._handle.reading &&
            tryReadStart(this),
          v.Duplex.prototype.read.call(this, e)
        );
      }),
      (Socket.prototype.destroySoon = function () {
        this.writable && this.end(),
          this.writableFinished
            ? this.destroy()
            : this.once("finish", this.destroy);
      }),
      (Socket.prototype._destroy = function (e, t) {
        A("destroy"), (this.connecting = !1);
        for (let e = this; null !== e; e = e._parent) Be(e[je]);
        if ((A("close"), this._handle)) {
          this !== o.stderr && A("close handle");
          const n = !!e;
          if (
            ((this[et] = this._handle.bytesRead),
            (this[tt] = this._handle.bytesWritten),
            this.resetAndClosing)
          ) {
            this.resetAndClosing = !1;
            const e = this._handle.reset(() => {
              A("emit close"), this.emit("close", n);
            });
            e && this.emit("error", me(e, "reset"));
          } else
            this._closeAfterHandlingError
              ? be(() => closeSocketHandle(this, n, !0))
              : closeSocketHandle(this, n);
          this._closeAfterHandlingError ||
            ((this._handle.onread = noop),
            (this._handle = null),
            (this._sockname = null)),
            t(e);
        } else t(e), o.nextTick(emitCloseNT, this);
        this._server &&
          (A("has server"),
          this._server._connections--,
          this._server._emitCloseIfDrained &&
            this._server._emitCloseIfDrained());
      }),
      (Socket.prototype._reset = function () {
        return (
          A("reset connection"), (this.resetAndClosing = !0), this.destroy()
        );
      }),
      (Socket.prototype._getpeername = function () {
        if (!this._handle || !this._handle.getpeername || this.connecting)
          return this._peername || {};
        if (!this._peername) {
          const e = {};
          if (this._handle.getpeername(e)) return e;
          this._peername = e;
        }
        return this._peername;
      }),
      protoGetter("bytesRead", function bytesRead() {
        return this._handle ? this._handle.bytesRead : this[et];
      }),
      protoGetter("remoteAddress", function remoteAddress() {
        return this._getpeername().address;
      }),
      protoGetter("remoteFamily", function remoteFamily() {
        return this._getpeername().family;
      }),
      protoGetter("remotePort", function remotePort() {
        return this._getpeername().port;
      }),
      (Socket.prototype._getsockname = function () {
        return this._handle && this._handle.getsockname
          ? (this._sockname ||
              ((this._sockname = {}), this._handle.getsockname(this._sockname)),
            this._sockname)
          : {};
      }),
      protoGetter("localAddress", function localAddress() {
        return this._getsockname().address;
      }),
      protoGetter("localPort", function localPort() {
        return this._getsockname().port;
      }),
      protoGetter("localFamily", function localFamily() {
        return this._getsockname().family;
      }),
      (Socket.prototype[J] = function () {
        this[Pe] = 0;
      }),
      (Socket.prototype._writeGeneric = function (e, t, n, o) {
        if (this.connecting) {
          let onClose = function () {
            o(new pe());
          };
          return (
            (this._pendingData = t),
            (this._pendingEncoding = n),
            this.once("connect", function connect2() {
              this.off("close", onClose), this._writeGeneric(e, t, n, o);
            }),
            void this.once("close", onClose)
          );
        }
        if (
          ((this._pendingData = null),
          (this._pendingEncoding = ""),
          !this._handle)
        )
          return o(new ue()), !1;
        let i;
        this._unrefTimer(),
          (i = e ? $(this, t, o) : q(this, t, n, o)),
          i.async && (this[Pe] = i.bytes);
      }),
      (Socket.prototype._writev = function (e, t) {
        this._writeGeneric(!0, e, "", t);
      }),
      (Socket.prototype._write = function (e, t, n) {
        this._writeGeneric(!1, e, t, n);
      }),
      protoGetter("_bytesDispatched", function _bytesDispatched() {
        return this._handle ? this._handle.bytesWritten : this[tt];
      }),
      protoGetter("bytesWritten", function bytesWritten() {
        let e = this._bytesDispatched;
        const t = this._pendingData,
          n = this._pendingEncoding,
          o = this.writableBuffer;
        if (o) {
          for (const t of o)
            e +=
              t.chunk instanceof M
                ? t.chunk.length
                : M.byteLength(t.chunk, t.encoding);
          if (s(t))
            for (let n = 0; n < t.length; n++) {
              const o = t[n];
              t.allBuffers || o instanceof M
                ? (e += o.length)
                : (e += M.byteLength(o.chunk, o.encoding));
            }
          else t && (e += "string" != typeof t ? t.length : M.byteLength(t, n));
          return e;
        }
      }),
      (Socket.prototype.connect = function (...e) {
        let n;
        n = s(e[0]) && e[0][C] ? e[0] : normalizeArgs(e);
        const i = n[0],
          r = n[1];
        if (void 0 === i.port && null == i.path)
          throw new fe(["options", "port", "path"]);
        this.write !== Socket.prototype.write &&
          (this.write = Socket.prototype.write),
          this.destroyed &&
            ((this._handle = null),
            (this._peername = null),
            (this._sockname = null));
        const { path: l } = i,
          a = !!l;
        return (
          A("pipe", a, l),
          this._handle ||
            ((this._handle = a ? new B(j.SOCKET) : new W(V.SOCKET)),
            initSocketHandle(this)),
          null !== r && this.once("connect", r),
          this._unrefTimer(),
          (this.connecting = !0),
          a
            ? (Ie(l, "options.path"), z(this[U], internalConnect, this, l))
            : (function lookupAndConnect(e, n) {
                const { localAddress: i, localPort: r } = n,
                  s = n.host || "localhost";
                let {
                  port: l,
                  autoSelectFamilyAttemptTimeout: a,
                  autoSelectFamily: h,
                } = n;
                if (i && !E(i)) throw new ce(i);
                r && Ce(r, "options.localPort");
                if (void 0 !== l) {
                  if ("number" != typeof l && "string" != typeof l)
                    throw new re("options.port", ["number", "string"], l);
                  Ne(l);
                }
                (l |= 0),
                  null != h ? Ee(h, "options.autoSelectFamily") : (h = Fe);
                null != a
                  ? (Te(a, "options.autoSelectFamilyAttemptTimeout", 1),
                    a < 10 && (a = 10))
                  : (a = Ve);
                const d = E(s);
                if (d)
                  return void z(e[U], o.nextTick, () => {
                    e.connecting && z(e[U], internalConnect, e, s, l, d, i, r);
                  });
                null != n.lookup && De(n.lookup, "options.lookup");
                void 0 === Le && (Le = t("dns"));
                const p = {
                  family: socketToDnsFamily(n.family),
                  hints: n.hints || 0,
                };
                Ue ||
                  4 === p.family ||
                  6 === p.family ||
                  0 !== p.hints ||
                  (p.hints = Le.ADDRCONFIG);
                A("connect: find host", s),
                  A("connect: dns options", p),
                  (e._host = s);
                const f = n.lookup || Le.lookup;
                if (4 !== p.family && 6 !== p.family && !i && h)
                  return (
                    A("connect: autodetecting"),
                    (p.all = !0),
                    void z(e[U], function () {
                      !(function lookupAndConnectMultiple(
                        e,
                        t,
                        n,
                        i,
                        r,
                        s,
                        l,
                        a,
                        h
                      ) {
                        z(e[t], function emitLookup() {
                          n(i, s, function emitLookup2(n, s) {
                            if (!e.connecting) return;
                            if (n)
                              return (
                                e.emit("lookup", n, void 0, void 0, i),
                                void o.nextTick(connectErrorNT, e, n)
                              );
                            const d = [[], []];
                            let p;
                            for (let t = 0, o = s.length; t < o; t++) {
                              const o = s[t],
                                { address: r, family: l } = o;
                              e.emit("lookup", n, r, l, i),
                                !E(r) ||
                                  (4 !== l && 6 !== l) ||
                                  (p ||
                                    (p =
                                      6 === l
                                        ? { 6: 0, 4: 1 }
                                        : { 4: 0, 6: 1 }),
                                  c(d[p[l]], o));
                            }
                            if (!d[0].length && !d[1].length) {
                              const { address: t, family: i } = s[0];
                              return void (E(t)
                                ? 4 !== i &&
                                  6 !== i &&
                                  ((n = new ie(i, r.host, r.port)),
                                  o.nextTick(connectErrorNT, e, n))
                                : ((n = new ce(t)),
                                  o.nextTick(connectErrorNT, e, n)));
                            }
                            const f = [];
                            for (
                              let e = 0, t = u(d[0].length, d[1].length);
                              e < t;
                              e++
                            )
                              e in d[0] && c(f, d[0][e]),
                                e in d[1] && c(f, d[1][e]);
                            e.autoSelectFamilyAttemptedAddresses = [];
                            const _ = {
                              socket: e,
                              addresses: f,
                              current: 0,
                              port: l,
                              localPort: a,
                              timeout: h,
                              [je]: null,
                              errors: [],
                            };
                            e._unrefTimer(),
                              z(e[t], internalConnectMultiple, _);
                          });
                        });
                      })(e, U, f, s, n, p, l, r, a);
                    })
                  );
                z(e[U], function () {
                  f(s, p, function emitLookup(t, c, a) {
                    e.emit("lookup", t, c, a, s),
                      e.connecting &&
                        (t
                          ? o.nextTick(connectErrorNT, e, t)
                          : E(c)
                          ? 4 !== a && 6 !== a
                            ? ((t = new ie(a, n.host, n.port)),
                              o.nextTick(connectErrorNT, e, t))
                            : (e._unrefTimer(),
                              z(e[U], internalConnect, e, c, l, a, i, r))
                          : ((t = new ce(c)),
                            o.nextTick(connectErrorNT, e, t)));
                  });
                });
              })(this, i),
          this
        );
      }),
      (Socket.prototype[w] = function reinitializeHandle(e) {
        this._handle?.close(),
          (this._handle = e),
          (this._handle[Y] = this),
          initSocketHandle(this);
      }),
      (Socket.prototype.ref = function () {
        return this._handle
          ? ("function" == typeof this._handle.ref && this._handle.ref(), this)
          : (this.once("connect", this.ref), this);
      }),
      (Socket.prototype.unref = function () {
        return this._handle
          ? ("function" == typeof this._handle.unref && this._handle.unref(),
            this)
          : (this.once("connect", this.unref), this);
      }),
      y(Server.prototype, b.prototype),
      y(Server, b),
      (Server.prototype._listen2 = function setupListenHandle(
        e,
        t,
        n,
        i,
        r,
        s
      ) {
        if ((A("setupListenHandle", e, t, n, i, r), this._handle))
          A("setupListenHandle: have a handle already");
        else {
          A("setupListenHandle: create a handle");
          let i = null;
          if (
            (e ||
              "number" == typeof r ||
              ((i = createServerHandle(ze, t, 6, r, s)),
              "number" == typeof i
                ? ((i = null), (e = Ke), (n = 4))
                : ((e = ze), (n = 6))),
            null === i && (i = createServerHandle(e, t, n, r, s)),
            "number" == typeof i)
          ) {
            const n = ke(i, "listen", e, t);
            return void o.nextTick(emitErrorNT, this, n);
          }
          this._handle = i;
        }
        (this[U] = getNewAsyncId(this._handle)),
          (this._handle.onconnection = onconnection),
          (this._handle[Y] = this);
        const l = this._handle.listen(i || 511);
        if (l) {
          const n = ke(l, "listen", e, t);
          return (
            this._handle.close(),
            (this._handle = null),
            void z(this[U], o.nextTick, emitErrorNT, this, n)
          );
        }
        (this._connectionKey = n + ":" + e + ":" + t),
          this._unref && this.unref(),
          z(this[U], o.nextTick, emitListeningNT, this);
      }),
      (Server.prototype.listen = function (...e) {
        const n = normalizeArgs(e);
        let i = n[0];
        const r = n[1];
        if (this._handle) throw new he();
        null !== r && this.once("listening", r);
        const s =
          toNumber(e.length > 1 && e[1]) || toNumber(e.length > 2 && e[2]);
        i = i._handle || i.handle || i;
        const l = (function getFlags(e) {
          return !0 === e ? V.UV_TCP_IPV6ONLY : 0;
        })(i.ipv6Only);
        if (i instanceof W)
          return (
            (this._handle = i),
            (this[U] = this._handle.getAsyncId()),
            listenInCluster(this, null, -1, -1, s),
            this
          );
        if (
          ((function addAbortSignalOption(e, t) {
            if (void 0 === t?.signal) return;
            we(t.signal, "options.signal");
            const { signal: n } = t,
              onAborted = () => {
                e.close();
              };
            n.aborted
              ? o.nextTick(onAborted)
              : (n.addEventListener("abort", onAborted),
                e.once("close", () =>
                  n.removeEventListener("abort", onAborted)
                ));
          })(this, i),
          "number" == typeof i.fd && i.fd >= 0)
        )
          return listenInCluster(this, null, null, null, s, i.fd), this;
        let c;
        if (
          ((0 === e.length ||
            "function" == typeof e[0] ||
            (void 0 === i.port && "port" in i) ||
            null === i.port) &&
            (i.port = 0),
          "number" == typeof i.port || "string" == typeof i.port)
        )
          return (
            Ne(i.port, "options.port"),
            (c = i.backlog || s),
            i.host
              ? (function lookupAndListen(e, n, o, i, r, s) {
                  void 0 === Le && (Le = t("dns"));
                  Le.lookup(o, function doListen(t, o, l) {
                    t
                      ? e.emit("error", t)
                      : listenInCluster(
                          e,
                          o,
                          n,
                          (l = o ? l : 4),
                          i,
                          void 0,
                          r,
                          s
                        );
                  });
                })(this, 0 | i.port, i.host, c, i.exclusive, l)
              : listenInCluster(
                  this,
                  null,
                  0 | i.port,
                  4,
                  c,
                  void 0,
                  i.exclusive
                ),
            this
          );
        if (i.path && isPipeName(i.path)) {
          const e = (this._pipeName = i.path);
          if (
            ((c = i.backlog || s),
            listenInCluster(this, e, -1, -1, c, void 0, i.exclusive, void 0, {
              readableAll: i.readableAll,
              writableAll: i.writableAll,
            }),
            !this._handle)
          )
            return this;
          let t = 0;
          if (
            (!0 === i.readableAll && (t |= j.UV_READABLE),
            !0 === i.writableAll && (t |= j.UV_WRITABLE),
            0 !== t)
          ) {
            const e = this._handle.fchmod(t);
            if (e)
              throw (
                (this._handle.close(),
                (this._handle = null),
                me(e, "uv_pipe_chmod"))
              );
          }
          return this;
        }
        if (!("port" in i) && !("path" in i))
          throw new se("options", i, 'must have the property "port" or "path"');
        throw new se("options", i);
      }),
      m(Server.prototype, "listening", {
        __proto__: null,
        get: function () {
          return !!this._handle;
        },
        configurable: !0,
        enumerable: !0,
      }),
      (Server.prototype.address = function () {
        if (this._handle && this._handle.getsockname) {
          const e = {},
            t = this._handle.getsockname(e);
          if (t) throw me(t, "address");
          return e;
        }
        return this._pipeName ? this._pipeName : null;
      }),
      (Server.prototype.getConnections = function (e) {
        const t = this;
        function end(n, i) {
          z(t[U], o.nextTick, e, n, i);
        }
        if (!this._usingWorkers) return end(null, this._connections), this;
        let n = this._workers.length,
          i = this._connections;
        function oncount(e, t) {
          return e
            ? ((n = -1), end(e))
            : ((i += t), 0 == --n ? end(null, i) : void 0);
        }
        for (let e = 0; e < this._workers.length; e++)
          this._workers[e].getConnections(oncount);
        return this;
      }),
      (Server.prototype.close = function (e) {
        if (
          ("function" == typeof e &&
            (this._handle
              ? this.once("close", e)
              : this.once("close", function close() {
                  e(new de());
                })),
          this._handle && (this._handle.close(), (this._handle = null)),
          this._usingWorkers)
        ) {
          let e = this._workers.length;
          const onWorkerClose = () => {
            0 == --e && ((this._connections = 0), this._emitCloseIfDrained());
          };
          this._connections++;
          for (let e = 0; e < this._workers.length; e++)
            this._workers[e].close(onWorkerClose);
        } else this._emitCloseIfDrained();
        return this;
      }),
      (Server.prototype[S] = async function () {
        if (this._handle) return d(Ae(this.close), this);
      }),
      (Server.prototype._emitCloseIfDrained = function () {
        A("SERVER _emitCloseIfDrained"),
          this._handle || this._connections
            ? A(
                "SERVER handle? %j   connections? %d",
                !!this._handle,
                this._connections
              )
            : z(this[U], o.nextTick, emitCloseNT, this);
      }),
      (Server.prototype[b.captureRejectionSymbol] = function (e, t, n) {
        if ("connection" === t) n.destroy(e);
        else this.emit("error", e);
      }),
      m(W.prototype, "owner", {
        __proto__: null,
        get() {
          return this[Y];
        },
        set(e) {
          return (this[Y] = e);
        },
      }),
      m(Socket.prototype, "_handle", {
        __proto__: null,
        get() {
          return this[X];
        },
        set(e) {
          return (this[X] = e);
        },
      }),
      (Server.prototype._setupWorker = function (e) {
        (this._usingWorkers = !0),
          this._workers.push(e),
          e.once("exit", (e) => {
            const t = l(this._workers, e);
            this._workers.splice(t, 1);
          });
      }),
      (Server.prototype.ref = function () {
        return (this._unref = !1), this._handle && this._handle.ref(), this;
      }),
      (Server.prototype.unref = function () {
        return (this._unref = !0), this._handle && this._handle.unref(), this;
      });
    let st = !0;
    if (Ue) {
      let e;
      rt = function (t) {
        st &&
          (o.emitWarning(
            "net._setSimultaneousAccepts() is deprecated and will be removed.",
            "DeprecationWarning",
            "DEP0121"
          ),
          (st = !1)),
          void 0 !== t &&
            (void 0 === e &&
              (e = o.env.NODE_MANY_ACCEPTS && "0" !== o.env.NODE_MANY_ACCEPTS),
            t._simultaneousAccepts !== e &&
              (t.setSimultaneousAccepts(!!e), (t._simultaneousAccepts = e)));
      };
    } else
      rt = function () {
        st &&
          (o.emitWarning(
            "net._setSimultaneousAccepts() is deprecated and will be removed.",
            "DeprecationWarning",
            "DEP0121"
          ),
          (st = !1));
      };
    n.exports = {
      _createServerHandle: createServerHandle,
      _normalizeArgs: normalizeArgs,
      _setSimultaneousAccepts: rt,
      get BlockList() {
        return (xe ??= t("internal/blocklist").BlockList), xe;
      },
      get SocketAddress() {
        return (We ??= t("internal/socketaddress").SocketAddress), We;
      },
      connect: connect,
      createConnection: connect,
      createServer: function createServer(e, t) {
        return new Server(e, t);
      },
      isIP: E,
      isIPv4: D,
      isIPv6: T,
      Server: Server,
      Socket: Socket,
      Stream: Socket,
      getDefaultAutoSelectFamily: function getDefaultAutoSelectFamily() {
        return Fe;
      },
      setDefaultAutoSelectFamily: function setDefaultAutoSelectFamily(e) {
        Ee(e, "value"), (Fe = e);
      },
      getDefaultAutoSelectFamilyAttemptTimeout:
        function getDefaultAutoSelectFamilyAttemptTimeout() {
          return Ve;
        },
      setDefaultAutoSelectFamilyAttemptTimeout:
        function setDefaultAutoSelectFamilyAttemptTimeout(e) {
          Te(e, "value", 1), e < 10 && (e = 10), (Ve = e);
        },
    };
  },
  os: function (e, t, n, r, o, i) {
    "use strict";
    const {
        ArrayPrototypePush: a,
        Float64Array: l,
        NumberParseInt: s,
        ObjectDefineProperties: c,
        StringPrototypeEndsWith: u,
        StringPrototypeSlice: f,
        SymbolToPrimitive: d,
      } = i,
      { safeGetenv: m } = o("credentials"),
      g = o("constants").os,
      p = "win32" === r.platform,
      {
        codes: { ERR_SYSTEM_ERROR: h },
        hideStackFrames: v,
      } = t("internal/errors"),
      { validateInt32: P } = t("internal/validators"),
      {
        getAvailableParallelism: y,
        getCPUs: _,
        getFreeMem: w,
        getHomeDirectory: b,
        getHostname: I,
        getInterfaceAddresses: E,
        getLoadAvg: k,
        getPriority: F,
        getOSInformation: R,
        getTotalMem: S,
        getUserInfo: C,
        getUptime: M,
        isBigEndian: T,
        setPriority: D,
      } = o("os");
    function getCheckedFunction(e) {
      return v(function checkError(...t) {
        const n = {},
          r = e(...t, n);
        if (void 0 === r) throw new h(n);
        return r;
      });
    }
    const { 0: A, 1: O, 2: L, 3: N } = R(),
      U = getCheckedFunction(b),
      j = getCheckedFunction(I),
      x = getCheckedFunction(E),
      B = getCheckedFunction(M),
      getOSRelease = () => L,
      getOSType = () => A,
      getOSVersion = () => O,
      getMachine = () => N;
    (y[d] = () => y()),
      (w[d] = () => w()),
      (j[d] = () => j()),
      (getOSVersion[d] = () => getOSVersion()),
      (getOSType[d] = () => getOSType()),
      (getOSRelease[d] = () => getOSRelease()),
      (getMachine[d] = () => getMachine()),
      (U[d] = () => U()),
      (S[d] = () => S()),
      (B[d] = () => B());
    const H = T ? "BE" : "LE",
      $ = new l(3);
    function arch() {
      return r.arch;
    }
    function platform() {
      return r.platform;
    }
    function tmpdir() {
      let e;
      return (
        p
          ? ((e =
              r.env.TEMP ||
              r.env.TMP ||
              (r.env.SystemRoot || r.env.windir) + "\\temp"),
            e.length > 1 && u(e, "\\") && !u(e, ":\\") && (e = f(e, 0, -1)))
          : ((e = m("TMPDIR") || m("TMP") || m("TEMP") || "/tmp"),
            e.length > 1 && u(e, "/") && (e = f(e, 0, -1))),
        e
      );
    }
    function endianness() {
      return H;
    }
    function getCIDR(e, t, n) {
      let r = 0,
        o = ".",
        i = 10,
        a = 8,
        l = !1,
        c = 0;
      "IPv6" === n && ((o = ":"), (i = 16), (a = 16));
      for (let e = 0; e < t.length; e++) {
        if (t[e] !== o) {
          if (e + 1 < t.length) continue;
          e++;
        }
        const n = f(t, c, e);
        if (((c = e + 1), "" !== n))
          if (l) {
            if ("0" !== n) return null;
          } else {
            const e = s(n, i),
              t =
                ((u = e),
                (16843009 *
                  (((u =
                    (858993459 & (u -= (u >>> 1) & 1431655765)) +
                    ((u >>> 2) & 858993459)) +
                    (u >>> 4)) &
                    252645135)) >>>
                  24);
            if (((r += t), t !== a)) {
              if (0 != (1 & e)) return null;
              l = !0;
            }
          }
      }
      var u;
      return `${e}/${r}`;
    }
    (arch[d] = () => r.arch),
      (platform[d] = () => r.platform),
      (tmpdir[d] = () => tmpdir()),
      (endianness[d] = () => H),
      (n.exports = {
        arch: arch,
        availableParallelism: y,
        cpus: function cpus() {
          const e = _() || [],
            t = [];
          let n = 0;
          for (; n < e.length; )
            a(t, {
              model: e[n++],
              speed: e[n++],
              times: {
                user: e[n++],
                nice: e[n++],
                sys: e[n++],
                idle: e[n++],
                irq: e[n++],
              },
            });
          return t;
        },
        endianness: endianness,
        freemem: w,
        getPriority: function getPriority(e) {
          void 0 === e ? (e = 0) : P(e, "pid");
          const t = {},
            n = F(e, t);
          if (void 0 === n) throw new h(t);
          return n;
        },
        homedir: U,
        hostname: j,
        loadavg: function loadavg() {
          return k($), [$[0], $[1], $[2]];
        },
        networkInterfaces: function networkInterfaces() {
          const e = x(),
            t = {};
          if (void 0 === e) return t;
          for (let n = 0; n < e.length; n += 7) {
            const r = e[n],
              o = {
                address: e[n + 1],
                netmask: e[n + 2],
                family: e[n + 3],
                mac: e[n + 4],
                internal: e[n + 5],
                cidr: getCIDR(e[n + 1], e[n + 2], e[n + 3]),
              },
              i = e[n + 6];
            -1 !== i && (o.scopeid = i);
            const l = t[r];
            void 0 !== l ? a(l, o) : (t[r] = [o]);
          }
          return t;
        },
        platform: platform,
        release: getOSRelease,
        setPriority: function setPriority(e, t) {
          void 0 === t && ((t = e), (e = 0)),
            P(e, "pid"),
            P(t, "priority", -20, 19);
          const n = {};
          if (0 !== D(e, t, n)) throw new h(n);
        },
        tmpdir: tmpdir,
        totalmem: S,
        type: getOSType,
        userInfo: function userInfo(e) {
          "object" != typeof e && (e = null);
          const t = {},
            n = C(e, t);
          if (void 0 === n) throw new h(t);
          return p && ((n.uid |= 0), (n.gid |= 0)), n;
        },
        uptime: B,
        version: getOSVersion,
        machine: getMachine,
      }),
      c(n.exports, {
        constants: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: g,
        },
        EOL: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          writable: !1,
          value: p ? "\r\n" : "\n",
        },
        devNull: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          writable: !1,
          value: p ? "\\\\.\\nul" : "/dev/null",
        },
      });
  },
  path: function (t, e, r, n, i, o) {
    "use strict";
    const {
        FunctionPrototypeBind: a,
        StringPrototypeCharCodeAt: l,
        StringPrototypeIndexOf: s,
        StringPrototypeLastIndexOf: f,
        StringPrototypeReplace: h,
        StringPrototypeSlice: g,
        StringPrototypeToLowerCase: p,
      } = o,
      {
        CHAR_UPPERCASE_A: u,
        CHAR_LOWERCASE_A: c,
        CHAR_UPPERCASE_Z: S,
        CHAR_LOWERCASE_Z: P,
        CHAR_DOT: d,
        CHAR_FORWARD_SLASH: $,
        CHAR_BACKWARD_SLASH: m,
        CHAR_COLON: v,
        CHAR_QUESTION_MARK: b,
      } = e("internal/constants"),
      { validateObject: R, validateString: A } = e("internal/validators"),
      _ = "win32" === n.platform;
    function isPathSeparator(t) {
      return t === $ || t === m;
    }
    function isPosixPathSeparator(t) {
      return t === $;
    }
    function isWindowsDeviceRoot(t) {
      return (t >= u && t <= S) || (t >= c && t <= P);
    }
    function normalizeString(t, e, r, n) {
      let i = "",
        o = 0,
        a = -1,
        s = 0,
        h = 0;
      for (let p = 0; p <= t.length; ++p) {
        if (p < t.length) h = l(t, p);
        else {
          if (n(h)) break;
          h = $;
        }
        if (n(h)) {
          if (a === p - 1 || 1 === s);
          else if (2 === s) {
            if (
              i.length < 2 ||
              2 !== o ||
              l(i, i.length - 1) !== d ||
              l(i, i.length - 2) !== d
            ) {
              if (i.length > 2) {
                const t = f(i, r);
                -1 === t
                  ? ((i = ""), (o = 0))
                  : ((i = g(i, 0, t)), (o = i.length - 1 - f(i, r))),
                  (a = p),
                  (s = 0);
                continue;
              }
              if (0 !== i.length) {
                (i = ""), (o = 0), (a = p), (s = 0);
                continue;
              }
            }
            e && ((i += i.length > 0 ? `${r}..` : ".."), (o = 2));
          } else
            i.length > 0
              ? (i += `${r}${g(t, a + 1, p)}`)
              : (i = g(t, a + 1, p)),
              (o = p - a - 1);
          (a = p), (s = 0);
        } else h === d && -1 !== s ? ++s : (s = -1);
      }
      return i;
    }
    function _format(t, e) {
      R(e, "pathObject");
      const r = e.dir || e.root,
        n = e.base || `${e.name || ""}${e.ext || ""}`;
      return r ? (r === e.root ? `${r}${n}` : `${r}${t}${n}`) : n;
    }
    const x = {
        resolve(...t) {
          let e = "",
            r = "",
            i = !1;
          for (let o = t.length - 1; o >= -1; o--) {
            let a;
            if (o >= 0) {
              if (((a = t[o]), A(a, `paths[${o}]`), 0 === a.length)) continue;
            } else
              0 === e.length
                ? (a = n.cwd())
                : ((a = n.env[`=${e}`] || n.cwd()),
                  (void 0 === a || (p(g(a, 0, 2)) !== p(e) && l(a, 2) === m)) &&
                    (a = `${e}\\`));
            const s = a.length;
            let f = 0,
              h = "",
              u = !1;
            const c = l(a, 0);
            if (1 === s) isPathSeparator(c) && ((f = 1), (u = !0));
            else if (isPathSeparator(c))
              if (((u = !0), isPathSeparator(l(a, 1)))) {
                let t = 2,
                  e = t;
                for (; t < s && !isPathSeparator(l(a, t)); ) t++;
                if (t < s && t !== e) {
                  const r = g(a, e, t);
                  for (e = t; t < s && isPathSeparator(l(a, t)); ) t++;
                  if (t < s && t !== e) {
                    for (e = t; t < s && !isPathSeparator(l(a, t)); ) t++;
                    (t !== s && t === e) ||
                      ((h = `\\\\${r}\\${g(a, e, t)}`), (f = t));
                  }
                }
              } else f = 1;
            else
              isWindowsDeviceRoot(c) &&
                l(a, 1) === v &&
                ((h = g(a, 0, 2)),
                (f = 2),
                s > 2 && isPathSeparator(l(a, 2)) && ((u = !0), (f = 3)));
            if (h.length > 0)
              if (e.length > 0) {
                if (p(h) !== p(e)) continue;
              } else e = h;
            if (i) {
              if (e.length > 0) break;
            } else if (((r = `${g(a, f)}\\${r}`), (i = u), u && e.length > 0))
              break;
          }
          return (
            (r = normalizeString(r, !i, "\\", isPathSeparator)),
            i ? `${e}\\${r}` : `${e}${r}` || "."
          );
        },
        normalize(t) {
          A(t, "path");
          const e = t.length;
          if (0 === e) return ".";
          let r,
            n = 0,
            i = !1;
          const o = l(t, 0);
          if (1 === e) return isPosixPathSeparator(o) ? "\\" : t;
          if (isPathSeparator(o))
            if (((i = !0), isPathSeparator(l(t, 1)))) {
              let i = 2,
                o = i;
              for (; i < e && !isPathSeparator(l(t, i)); ) i++;
              if (i < e && i !== o) {
                const a = g(t, o, i);
                for (o = i; i < e && isPathSeparator(l(t, i)); ) i++;
                if (i < e && i !== o) {
                  for (o = i; i < e && !isPathSeparator(l(t, i)); ) i++;
                  if (i === e) return `\\\\${a}\\${g(t, o)}\\`;
                  i !== o && ((r = `\\\\${a}\\${g(t, o, i)}`), (n = i));
                }
              }
            } else n = 1;
          else
            isWindowsDeviceRoot(o) &&
              l(t, 1) === v &&
              ((r = g(t, 0, 2)),
              (n = 2),
              e > 2 && isPathSeparator(l(t, 2)) && ((i = !0), (n = 3)));
          let a =
            n < e ? normalizeString(g(t, n), !i, "\\", isPathSeparator) : "";
          return (
            0 !== a.length || i || (a = "."),
            a.length > 0 && isPathSeparator(l(t, e - 1)) && (a += "\\"),
            void 0 === r ? (i ? `\\${a}` : a) : i ? `${r}\\${a}` : `${r}${a}`
          );
        },
        isAbsolute(t) {
          A(t, "path");
          const e = t.length;
          if (0 === e) return !1;
          const r = l(t, 0);
          return (
            isPathSeparator(r) ||
            (e > 2 &&
              isWindowsDeviceRoot(r) &&
              l(t, 1) === v &&
              isPathSeparator(l(t, 2)))
          );
        },
        join(...t) {
          if (0 === t.length) return ".";
          let e, r;
          for (let n = 0; n < t.length; ++n) {
            const i = t[n];
            A(i, "path"),
              i.length > 0 && (void 0 === e ? (e = r = i) : (e += `\\${i}`));
          }
          if (void 0 === e) return ".";
          let n = !0,
            i = 0;
          if (isPathSeparator(l(r, 0))) {
            ++i;
            const t = r.length;
            t > 1 &&
              isPathSeparator(l(r, 1)) &&
              (++i, t > 2 && (isPathSeparator(l(r, 2)) ? ++i : (n = !1)));
          }
          if (n) {
            for (; i < e.length && isPathSeparator(l(e, i)); ) i++;
            i >= 2 && (e = `\\${g(e, i)}`);
          }
          return x.normalize(e);
        },
        relative(t, e) {
          if ((A(t, "from"), A(e, "to"), t === e)) return "";
          const r = x.resolve(t),
            n = x.resolve(e);
          if (r === n) return "";
          if ((t = p(r)) === (e = p(n))) return "";
          let i = 0;
          for (; i < t.length && l(t, i) === m; ) i++;
          let o = t.length;
          for (; o - 1 > i && l(t, o - 1) === m; ) o--;
          const a = o - i;
          let s = 0;
          for (; s < e.length && l(e, s) === m; ) s++;
          let f = e.length;
          for (; f - 1 > s && l(e, f - 1) === m; ) f--;
          const h = f - s,
            u = a < h ? a : h;
          let c = -1,
            S = 0;
          for (; S < u; S++) {
            const r = l(t, i + S);
            if (r !== l(e, s + S)) break;
            r === m && (c = S);
          }
          if (S !== u) {
            if (-1 === c) return n;
          } else {
            if (h > u) {
              if (l(e, s + S) === m) return g(n, s + S + 1);
              if (2 === S) return g(n, s + S);
            }
            a > u && (l(t, i + S) === m ? (c = S) : 2 === S && (c = 3)),
              -1 === c && (c = 0);
          }
          let P = "";
          for (S = i + c + 1; S <= o; ++S)
            (S !== o && l(t, S) !== m) || (P += 0 === P.length ? ".." : "\\..");
          return (
            (s += c),
            P.length > 0
              ? `${P}${g(n, s, f)}`
              : (l(n, s) === m && ++s, g(n, s, f))
          );
        },
        toNamespacedPath(t) {
          if ("string" != typeof t || 0 === t.length) return t;
          const e = x.resolve(t);
          if (e.length <= 2) return t;
          if (l(e, 0) === m) {
            if (l(e, 1) === m) {
              const t = l(e, 2);
              if (t !== b && t !== d) return `\\\\?\\UNC\\${g(e, 2)}`;
            }
          } else if (
            isWindowsDeviceRoot(l(e, 0)) &&
            l(e, 1) === v &&
            l(e, 2) === m
          )
            return `\\\\?\\${e}`;
          return t;
        },
        dirname(t) {
          A(t, "path");
          const e = t.length;
          if (0 === e) return ".";
          let r = -1,
            n = 0;
          const i = l(t, 0);
          if (1 === e) return isPathSeparator(i) ? t : ".";
          if (isPathSeparator(i)) {
            if (((r = n = 1), isPathSeparator(l(t, 1)))) {
              let i = 2,
                o = i;
              for (; i < e && !isPathSeparator(l(t, i)); ) i++;
              if (i < e && i !== o) {
                for (o = i; i < e && isPathSeparator(l(t, i)); ) i++;
                if (i < e && i !== o) {
                  for (o = i; i < e && !isPathSeparator(l(t, i)); ) i++;
                  if (i === e) return t;
                  i !== o && (r = n = i + 1);
                }
              }
            }
          } else
            isWindowsDeviceRoot(i) &&
              l(t, 1) === v &&
              ((r = e > 2 && isPathSeparator(l(t, 2)) ? 3 : 2), (n = r));
          let o = -1,
            a = !0;
          for (let r = e - 1; r >= n; --r)
            if (isPathSeparator(l(t, r))) {
              if (!a) {
                o = r;
                break;
              }
            } else a = !1;
          if (-1 === o) {
            if (-1 === r) return ".";
            o = r;
          }
          return g(t, 0, o);
        },
        basename(t, e) {
          void 0 !== e && A(e, "ext"), A(t, "path");
          let r = 0,
            n = -1,
            i = !0;
          if (
            (t.length >= 2 &&
              isWindowsDeviceRoot(l(t, 0)) &&
              l(t, 1) === v &&
              (r = 2),
            void 0 !== e && e.length > 0 && e.length <= t.length)
          ) {
            if (e === t) return "";
            let o = e.length - 1,
              a = -1;
            for (let s = t.length - 1; s >= r; --s) {
              const f = l(t, s);
              if (isPathSeparator(f)) {
                if (!i) {
                  r = s + 1;
                  break;
                }
              } else
                -1 === a && ((i = !1), (a = s + 1)),
                  o >= 0 &&
                    (f === l(e, o)
                      ? -1 == --o && (n = s)
                      : ((o = -1), (n = a)));
            }
            return r === n ? (n = a) : -1 === n && (n = t.length), g(t, r, n);
          }
          for (let e = t.length - 1; e >= r; --e)
            if (isPathSeparator(l(t, e))) {
              if (!i) {
                r = e + 1;
                break;
              }
            } else -1 === n && ((i = !1), (n = e + 1));
          return -1 === n ? "" : g(t, r, n);
        },
        extname(t) {
          A(t, "path");
          let e = 0,
            r = -1,
            n = 0,
            i = -1,
            o = !0,
            a = 0;
          t.length >= 2 &&
            l(t, 1) === v &&
            isWindowsDeviceRoot(l(t, 0)) &&
            (e = n = 2);
          for (let s = t.length - 1; s >= e; --s) {
            const e = l(t, s);
            if (isPathSeparator(e)) {
              if (!o) {
                n = s + 1;
                break;
              }
            } else
              -1 === i && ((o = !1), (i = s + 1)),
                e === d
                  ? -1 === r
                    ? (r = s)
                    : 1 !== a && (a = 1)
                  : -1 !== r && (a = -1);
          }
          return -1 === r ||
            -1 === i ||
            0 === a ||
            (1 === a && r === i - 1 && r === n + 1)
            ? ""
            : g(t, r, i);
        },
        format: a(_format, null, "\\"),
        parse(t) {
          A(t, "path");
          const e = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t.length) return e;
          const r = t.length;
          let n = 0,
            i = l(t, 0);
          if (1 === r)
            return isPathSeparator(i)
              ? ((e.root = e.dir = t), e)
              : ((e.base = e.name = t), e);
          if (isPathSeparator(i)) {
            if (((n = 1), isPathSeparator(l(t, 1)))) {
              let e = 2,
                i = e;
              for (; e < r && !isPathSeparator(l(t, e)); ) e++;
              if (e < r && e !== i) {
                for (i = e; e < r && isPathSeparator(l(t, e)); ) e++;
                if (e < r && e !== i) {
                  for (i = e; e < r && !isPathSeparator(l(t, e)); ) e++;
                  e === r ? (n = e) : e !== i && (n = e + 1);
                }
              }
            }
          } else if (isWindowsDeviceRoot(i) && l(t, 1) === v) {
            if (r <= 2) return (e.root = e.dir = t), e;
            if (((n = 2), isPathSeparator(l(t, 2)))) {
              if (3 === r) return (e.root = e.dir = t), e;
              n = 3;
            }
          }
          n > 0 && (e.root = g(t, 0, n));
          let o = -1,
            a = n,
            s = -1,
            f = !0,
            h = t.length - 1,
            p = 0;
          for (; h >= n; --h)
            if (((i = l(t, h)), isPathSeparator(i))) {
              if (!f) {
                a = h + 1;
                break;
              }
            } else
              -1 === s && ((f = !1), (s = h + 1)),
                i === d
                  ? -1 === o
                    ? (o = h)
                    : 1 !== p && (p = 1)
                  : -1 !== o && (p = -1);
          return (
            -1 !== s &&
              (-1 === o || 0 === p || (1 === p && o === s - 1 && o === a + 1)
                ? (e.base = e.name = g(t, a, s))
                : ((e.name = g(t, a, o)),
                  (e.base = g(t, a, s)),
                  (e.ext = g(t, o, s)))),
            (e.dir = a > 0 && a !== n ? g(t, 0, a - 1) : e.root),
            e
          );
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null,
      },
      w = (() => {
        if (_) {
          const t = /\\/g;
          return () => {
            const e = h(n.cwd(), t, "/");
            return g(e, s(e, "/"));
          };
        }
        return () => n.cwd();
      })(),
      C = {
        resolve(...t) {
          let e = "",
            r = !1;
          for (let n = t.length - 1; n >= -1 && !r; n--) {
            const i = n >= 0 ? t[n] : w();
            A(i, `paths[${n}]`),
              0 !== i.length && ((e = `${i}/${e}`), (r = l(i, 0) === $));
          }
          return (
            (e = normalizeString(e, !r, "/", isPosixPathSeparator)),
            r ? `/${e}` : e.length > 0 ? e : "."
          );
        },
        normalize(t) {
          if ((A(t, "path"), 0 === t.length)) return ".";
          const e = l(t, 0) === $,
            r = l(t, t.length - 1) === $;
          return 0 ===
            (t = normalizeString(t, !e, "/", isPosixPathSeparator)).length
            ? e
              ? "/"
              : r
              ? "./"
              : "."
            : (r && (t += "/"), e ? `/${t}` : t);
        },
        isAbsolute: (t) => (A(t, "path"), t.length > 0 && l(t, 0) === $),
        join(...t) {
          if (0 === t.length) return ".";
          let e;
          for (let r = 0; r < t.length; ++r) {
            const n = t[r];
            A(n, "path"),
              n.length > 0 && (void 0 === e ? (e = n) : (e += `/${n}`));
          }
          return void 0 === e ? "." : C.normalize(e);
        },
        relative(t, e) {
          if ((A(t, "from"), A(e, "to"), t === e)) return "";
          if ((t = C.resolve(t)) === (e = C.resolve(e))) return "";
          const r = t.length,
            n = r - 1,
            i = e.length - 1,
            o = n < i ? n : i;
          let a = -1,
            s = 0;
          for (; s < o; s++) {
            const r = l(t, 1 + s);
            if (r !== l(e, 1 + s)) break;
            r === $ && (a = s);
          }
          if (s === o)
            if (i > o) {
              if (l(e, 1 + s) === $) return g(e, 1 + s + 1);
              if (0 === s) return g(e, 1 + s);
            } else n > o && (l(t, 1 + s) === $ ? (a = s) : 0 === s && (a = 0));
          let f = "";
          for (s = 1 + a + 1; s <= r; ++s)
            (s !== r && l(t, s) !== $) || (f += 0 === f.length ? ".." : "/..");
          return `${f}${g(e, 1 + a)}`;
        },
        toNamespacedPath: (t) => t,
        dirname(t) {
          if ((A(t, "path"), 0 === t.length)) return ".";
          const e = l(t, 0) === $;
          let r = -1,
            n = !0;
          for (let e = t.length - 1; e >= 1; --e)
            if (l(t, e) === $) {
              if (!n) {
                r = e;
                break;
              }
            } else n = !1;
          return -1 === r ? (e ? "/" : ".") : e && 1 === r ? "//" : g(t, 0, r);
        },
        basename(t, e) {
          void 0 !== e && A(e, "ext"), A(t, "path");
          let r = 0,
            n = -1,
            i = !0;
          if (void 0 !== e && e.length > 0 && e.length <= t.length) {
            if (e === t) return "";
            let o = e.length - 1,
              a = -1;
            for (let s = t.length - 1; s >= 0; --s) {
              const f = l(t, s);
              if (f === $) {
                if (!i) {
                  r = s + 1;
                  break;
                }
              } else
                -1 === a && ((i = !1), (a = s + 1)),
                  o >= 0 &&
                    (f === l(e, o)
                      ? -1 == --o && (n = s)
                      : ((o = -1), (n = a)));
            }
            return r === n ? (n = a) : -1 === n && (n = t.length), g(t, r, n);
          }
          for (let e = t.length - 1; e >= 0; --e)
            if (l(t, e) === $) {
              if (!i) {
                r = e + 1;
                break;
              }
            } else -1 === n && ((i = !1), (n = e + 1));
          return -1 === n ? "" : g(t, r, n);
        },
        extname(t) {
          A(t, "path");
          let e = -1,
            r = 0,
            n = -1,
            i = !0,
            o = 0;
          for (let a = t.length - 1; a >= 0; --a) {
            const s = l(t, a);
            if (s !== $)
              -1 === n && ((i = !1), (n = a + 1)),
                s === d
                  ? -1 === e
                    ? (e = a)
                    : 1 !== o && (o = 1)
                  : -1 !== e && (o = -1);
            else if (!i) {
              r = a + 1;
              break;
            }
          }
          return -1 === e ||
            -1 === n ||
            0 === o ||
            (1 === o && e === n - 1 && e === r + 1)
            ? ""
            : g(t, e, n);
        },
        format: a(_format, null, "/"),
        parse(t) {
          A(t, "path");
          const e = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t.length) return e;
          const r = l(t, 0) === $;
          let n;
          r ? ((e.root = "/"), (n = 1)) : (n = 0);
          let i = -1,
            o = 0,
            a = -1,
            s = !0,
            f = t.length - 1,
            h = 0;
          for (; f >= n; --f) {
            const e = l(t, f);
            if (e !== $)
              -1 === a && ((s = !1), (a = f + 1)),
                e === d
                  ? -1 === i
                    ? (i = f)
                    : 1 !== h && (h = 1)
                  : -1 !== i && (h = -1);
            else if (!s) {
              o = f + 1;
              break;
            }
          }
          if (-1 !== a) {
            const n = 0 === o && r ? 1 : o;
            -1 === i || 0 === h || (1 === h && i === a - 1 && i === o + 1)
              ? (e.base = e.name = g(t, n, a))
              : ((e.name = g(t, n, i)),
                (e.base = g(t, n, a)),
                (e.ext = g(t, i, a)));
          }
          return o > 0 ? (e.dir = g(t, 0, o - 1)) : r && (e.dir = "/"), e;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null,
      };
    (C.win32 = x.win32 = x),
      (C.posix = x.posix = C),
      (x._makeLong = x.toNamespacedPath),
      (C._makeLong = C.toNamespacedPath),
      (r.exports = _ ? x : C);
  },
  "path/posix": function (t, s, i, o, p, _) {
    "use strict";
    i.exports = s("path").posix;
  },
  "path/win32": function (t, i, n, s, _, c) {
    "use strict";
    n.exports = i("path").win32;
  },
  perf_hooks: function (e, r, n, a, o, t) {
    "use strict";
    const { ObjectDefineProperty: c } = t,
      { constants: f } = o("performance"),
      { PerformanceEntry: m } = r("internal/perf/performance_entry"),
      { PerformanceResourceTiming: i } = r("internal/perf/resource_timing"),
      { PerformanceObserver: s, PerformanceObserverEntryList: p } = r(
        "internal/perf/observe"
      ),
      { PerformanceMark: l, PerformanceMeasure: P } = r(
        "internal/perf/usertiming"
      ),
      { Performance: u, performance: _ } = r("internal/perf/performance"),
      { createHistogram: b } = r("internal/histogram"),
      g = r("internal/perf/event_loop_delay");
    (n.exports = {
      Performance: u,
      PerformanceEntry: m,
      PerformanceMark: l,
      PerformanceMeasure: P,
      PerformanceObserver: s,
      PerformanceObserverEntryList: p,
      PerformanceResourceTiming: i,
      monitorEventLoopDelay: g,
      createHistogram: b,
      performance: _,
    }),
      c(n.exports, "constants", {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        value: f,
      });
  },
  process: function (t, s, _, c, e, i) {
    "use strict";
    _.exports = c;
  },
  punycode: function (o, n, e, t, r, c) {
    "use strict";
    const { getOptionValue: i } = n("internal/options");
    i("--pending-deprecation") &&
      t.emitWarning(
        "The `punycode` module is deprecated. Please use a userland alternative instead.",
        "DeprecationWarning",
        "DEP0040"
      );
    const s = 2147483647,
      u = 36,
      l = /^xn--/,
      a = /[^\0-\x7F]/,
      f = /[\x2E\u3002\uFF0E\uFF61]/g,
      d = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      },
      p = Math.floor,
      h = String.fromCharCode;
    function error(o) {
      throw new RangeError(d[o]);
    }
    function mapDomain(o, n) {
      const e = o.split("@");
      let t = "";
      e.length > 1 && ((t = e[0] + "@"), (o = e[1]));
      const r = (function map(o, n) {
        const e = [];
        let t = o.length;
        for (; t--; ) e[t] = n(o[t]);
        return e;
      })((o = o.replace(f, ".")).split("."), n).join(".");
      return t + r;
    }
    function ucs2decode(o) {
      const n = [];
      let e = 0;
      const t = o.length;
      for (; e < t; ) {
        const r = o.charCodeAt(e++);
        if (r >= 55296 && r <= 56319 && e < t) {
          const t = o.charCodeAt(e++);
          56320 == (64512 & t)
            ? n.push(((1023 & r) << 10) + (1023 & t) + 65536)
            : (n.push(r), e--);
        } else n.push(r);
      }
      return n;
    }
    const digitToBasic = function (o, n) {
        return o + 22 + 75 * (o < 26) - ((0 != n) << 5);
      },
      adapt = function (o, n, e) {
        let t = 0;
        for (o = e ? p(o / 700) : o >> 1, o += p(o / n); o > 455; t += u)
          o = p(o / 35);
        return p(t + (36 * o) / (o + 38));
      },
      decode = function (o) {
        const n = [],
          e = o.length;
        let t = 0,
          r = 128,
          c = 72,
          i = o.lastIndexOf("-");
        i < 0 && (i = 0);
        for (let e = 0; e < i; ++e)
          o.charCodeAt(e) >= 128 && error("not-basic"), n.push(o.charCodeAt(e));
        for (let a = i > 0 ? i + 1 : 0; a < e; ) {
          const i = t;
          for (let n = 1, r = u; ; r += u) {
            a >= e && error("invalid-input");
            const i =
              (l = o.charCodeAt(a++)) >= 48 && l < 58
                ? l - 48 + 26
                : l >= 65 && l < 91
                ? l - 65
                : l >= 97 && l < 123
                ? l - 97
                : u;
            i >= u && error("invalid-input"),
              i > p((s - t) / n) && error("overflow"),
              (t += i * n);
            const f = r <= c ? 1 : r >= c + 26 ? 26 : r - c;
            if (i < f) break;
            const d = u - f;
            n > p(s / d) && error("overflow"), (n *= d);
          }
          const f = n.length + 1;
          (c = adapt(t - i, f, 0 == i)),
            p(t / f) > s - r && error("overflow"),
            (r += p(t / f)),
            (t %= f),
            n.splice(t++, 0, r);
        }
        var l;
        return String.fromCodePoint(...n);
      },
      encode = function (o) {
        const n = [],
          e = (o = ucs2decode(o)).length;
        let t = 128,
          r = 0,
          c = 72;
        for (const e of o) e < 128 && n.push(h(e));
        const i = n.length;
        let l = i;
        for (i && n.push("-"); l < e; ) {
          let e = s;
          for (const n of o) n >= t && n < e && (e = n);
          const a = l + 1;
          e - t > p((s - r) / a) && error("overflow"),
            (r += (e - t) * a),
            (t = e);
          for (const e of o)
            if ((e < t && ++r > s && error("overflow"), e === t)) {
              let o = r;
              for (let e = u; ; e += u) {
                const t = e <= c ? 1 : e >= c + 26 ? 26 : e - c;
                if (o < t) break;
                const r = o - t,
                  i = u - t;
                n.push(h(digitToBasic(t + (r % i), 0))), (o = p(r / i));
              }
              n.push(h(digitToBasic(o, 0))),
                (c = adapt(r, a, l === i)),
                (r = 0),
                ++l;
            }
          ++r, ++t;
        }
        return n.join("");
      },
      g = {
        version: "2.1.0",
        ucs2: { decode: ucs2decode, encode: (o) => String.fromCodePoint(...o) },
        decode: decode,
        encode: encode,
        toASCII: function (o) {
          return mapDomain(o, function (o) {
            return a.test(o) ? "xn--" + encode(o) : o;
          });
        },
        toUnicode: function (o) {
          return mapDomain(o, function (o) {
            return l.test(o) ? decode(o.slice(4).toLowerCase()) : o;
          });
        },
      };
    e.exports = g;
  },
  querystring: function (e, t, n, o, r, i) {
    "use strict";
    const {
        Array: c,
        ArrayIsArray: f,
        Int8Array: s,
        MathAbs: u,
        NumberIsFinite: l,
        ObjectCreate: a,
        ObjectKeys: p,
        String: g,
        StringPrototypeCharCodeAt: d,
        StringPrototypeSlice: y,
        decodeURIComponent: h,
      } = i,
      { Buffer: b } = t("buffer"),
      { encodeStr: m, hexTable: C, isHexTable: S } = t("internal/querystring"),
      I = (n.exports = {
        unescapeBuffer: function unescapeBuffer(e, t) {
          const n = b.allocUnsafe(e.length);
          let o,
            r,
            i,
            c,
            f = 0,
            s = 0;
          const u = e.length - 2;
          let l = !1;
          for (; f < e.length; )
            if (((o = d(e, f)), 43 === o && t)) (n[s++] = 32), f++;
            else {
              if (37 === o && f < u) {
                if (((o = d(e, ++f)), (i = U[o]), !(i >= 0))) {
                  n[s++] = 37;
                  continue;
                }
                (r = d(e, ++f)),
                  (c = U[r]),
                  c >= 0 ? ((l = !0), (o = 16 * i + c)) : ((n[s++] = 37), f--);
              }
              (n[s++] = o), f++;
            }
          return l ? n.slice(0, s) : n;
        },
        unescape: qsUnescape,
        escape: qsEscape,
        stringify: stringify,
        encode: stringify,
        parse: parse,
        decode: parse,
      }),
      U = new s([
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1,
      ]);
    function qsUnescape(e, t) {
      try {
        return h(e);
      } catch {
        return I.unescapeBuffer(e, t).toString();
      }
    }
    const q = new s([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
      0, 1, 0,
    ]);
    function qsEscape(e) {
      return (
        "string" != typeof e && ("object" == typeof e ? (e = g(e)) : (e += "")),
        m(e, q, C)
      );
    }
    function encodeStringified(e, t) {
      return "string" == typeof e
        ? e.length
          ? t(e)
          : ""
        : "number" == typeof e && l(e)
        ? u(e) < 1e21
          ? "" + e
          : t("" + e)
        : "bigint" == typeof e
        ? "" + e
        : "boolean" == typeof e
        ? e
          ? "true"
          : "false"
        : "";
    }
    function encodeStringifiedCustom(e, t) {
      return t(
        (function stringifyPrimitive(e) {
          return "string" == typeof e
            ? e
            : ("number" == typeof e && l(e)) || "bigint" == typeof e
            ? "" + e
            : "boolean" == typeof e
            ? e
              ? "true"
              : "false"
            : "";
        })(e)
      );
    }
    function stringify(e, t, n, o) {
      (t = t || "&"), (n = n || "=");
      let r = I.escape;
      o &&
        "function" == typeof o.encodeURIComponent &&
        (r = o.encodeURIComponent);
      const i = r === qsEscape ? encodeStringified : encodeStringifiedCustom;
      if (null !== e && "object" == typeof e) {
        const o = p(e),
          c = o.length;
        let s = "";
        for (let u = 0; u < c; ++u) {
          const c = o[u],
            l = e[c];
          let a = i(c, r);
          if (((a += n), f(l))) {
            const e = l.length;
            if (0 === e) continue;
            s && (s += t);
            for (let n = 0; n < e; ++n)
              n && (s += t), (s += a), (s += i(l[n], r));
          } else s && (s += t), (s += a), (s += i(l, r));
        }
        return s;
      }
      return "";
    }
    function charCodes(e) {
      if (0 === e.length) return [];
      if (1 === e.length) return [d(e, 0)];
      const t = new c(e.length);
      for (let n = 0; n < e.length; ++n) t[n] = d(e, n);
      return t;
    }
    const K = [38],
      x = [61];
    function addKeyVal(e, t, n, o, r, i) {
      if (
        (t.length > 0 && o && (t = decodeStr(t, i)),
        n.length > 0 && r && (n = decodeStr(n, i)),
        void 0 === e[t])
      )
        e[t] = n;
      else {
        const o = e[t];
        o.pop ? (o[o.length] = n) : (e[t] = [o, n]);
      }
    }
    function parse(e, t, n, o) {
      const r = a(null);
      if ("string" != typeof e || 0 === e.length) return r;
      const i = t ? charCodes(g(t)) : K,
        c = n ? charCodes(g(n)) : x,
        f = i.length,
        s = c.length;
      let u = 1e3;
      o && "number" == typeof o.maxKeys && (u = o.maxKeys > 0 ? o.maxKeys : -1);
      let l = I.unescape;
      o &&
        "function" == typeof o.decodeURIComponent &&
        (l = o.decodeURIComponent);
      const p = l !== qsUnescape;
      let h = 0,
        b = 0,
        m = 0,
        C = "",
        U = "",
        q = p,
        A = p;
      const R = p ? "%20" : " ";
      let j = 0;
      for (let t = 0; t < e.length; ++t) {
        const n = d(e, t);
        if (n === i[b]) {
          if (++b === f) {
            const n = t - b + 1;
            if (m < s) {
              if (h < n) C += y(e, h, n);
              else if (0 === C.length) {
                if (0 == --u) return r;
                (h = t + 1), (b = m = 0);
                continue;
              }
            } else h < n && (U += y(e, h, n));
            if ((addKeyVal(r, C, U, q, A, l), 0 == --u)) return r;
            (q = A = p), (C = U = ""), (j = 0), (h = t + 1), (b = m = 0);
          }
        } else {
          if (((b = 0), m < s)) {
            if (n === c[m]) {
              if (++m === s) {
                const n = t - m + 1;
                h < n && (C += y(e, h, n)), (j = 0), (h = t + 1);
              }
              continue;
            }
            if (((m = 0), !q)) {
              if (37 === n) {
                j = 1;
                continue;
              }
              if (j > 0) {
                if (1 === S[n]) {
                  3 == ++j && (q = !0);
                  continue;
                }
                j = 0;
              }
            }
            if (43 === n) {
              h < t && (C += y(e, h, t)), (C += R), (h = t + 1);
              continue;
            }
          }
          43 === n
            ? (h < t && (U += y(e, h, t)), (U += R), (h = t + 1))
            : A ||
              (37 === n
                ? (j = 1)
                : j > 0 && (1 === S[n] ? 3 == ++j && (A = !0) : (j = 0)));
        }
      }
      if (h < e.length) m < s ? (C += y(e, h)) : b < f && (U += y(e, h));
      else if (0 === m && 0 === C.length) return r;
      return addKeyVal(r, C, U, q, A, l), r;
    }
    function decodeStr(e, t) {
      try {
        return t(e);
      } catch {
        return I.unescape(e, !0);
      }
    }
  },
  readline: function (t, e, r, o, n, i) {
    "use strict";
    const {
        DateNow: s,
        FunctionPrototypeBind: p,
        FunctionPrototypeCall: _,
        ObjectDefineProperties: l,
        ObjectSetPrototypeOf: u,
        Promise: a,
        PromiseReject: c,
        StringPrototypeSlice: h,
        SymbolDispose: f,
      } = i,
      {
        clearLine: y,
        clearScreenDown: g,
        cursorTo: d,
        moveCursor: I,
      } = e("internal/readline/callbacks"),
      m = e("internal/readline/emitKeypressEvents"),
      k = e("readline/promises"),
      { AbortError: w } = e("internal/errors"),
      { inspect: L } = e("internal/util/inspect"),
      { kEmptyObject: b, promisify: v } = e("internal/util"),
      { validateAbortSignal: P } = e("internal/validators"),
      {
        Interface: R,
        InterfaceConstructor: D,
        kAddHistory: C,
        kDecoder: W,
        kDeleteLeft: S,
        kDeleteLineLeft: T,
        kDeleteLineRight: O,
        kDeleteRight: N,
        kDeleteWordLeft: j,
        kDeleteWordRight: A,
        kGetDisplayPos: q,
        kHistoryNext: K,
        kHistoryPrev: E,
        kInsertString: H,
        kLine: M,
        kLine_buffer: x,
        kMoveCursor: F,
        kNormalWrite: G,
        kOldPrompt: Q,
        kOnLine: B,
        kPreviousKey: $,
        kPrompt: z,
        kQuestionCallback: J,
        kQuestionCancel: U,
        kRefreshLine: V,
        kSawKeyPress: X,
        kSawReturnAt: Y,
        kSetRawMode: Z,
        kTabComplete: tt,
        kTabCompleter: et,
        kTtyWrite: rt,
        kWordLeft: ot,
        kWordRight: nt,
        kWriteToOutput: it,
      } = e("internal/readline/interface");
    let st;
    function Interface(t, e, r, n) {
      if (!(this instanceof Interface)) return new Interface(t, e, r, n);
      if (
        t?.input &&
        "function" == typeof t.completer &&
        2 !== t.completer.length
      ) {
        const { completer: e } = t;
        t.completer = (t, r) => r(null, e(t));
      } else if ("function" == typeof r && 2 !== r.length) {
        const t = r;
        r = (e, r) => r(null, t(e));
      }
      _(D, this, t, e, r, n),
        "dumb" === o.env.TERM && (this._ttyWrite = p(_ttyWriteDumb, this));
    }
    u(Interface.prototype, R.prototype), u(Interface, R);
    const pt = R.prototype.question;
    function _ttyWriteDumb(t, e) {
      if ("escape" !== (e = e || b).name) {
        if ((this[Y] && "enter" !== e.name && (this[Y] = 0), e.ctrl)) {
          if ("c" === e.name)
            return void (this.listenerCount("SIGINT") > 0
              ? this.emit("SIGINT")
              : this.close());
          if ("d" === e.name) return void this.close();
        }
        switch (e.name) {
          case "return":
            (this[Y] = s()), this._line();
            break;
          case "enter":
            (0 === this[Y] || s() - this[Y] > this.crlfDelay) && this._line(),
              (this[Y] = 0);
            break;
          default:
            "string" == typeof t &&
              t &&
              ((this.line += t),
              (this.cursor += t.length),
              this._writeToOutput(t));
        }
      }
    }
    (Interface.prototype.question = function (t, r, o) {
      if (
        ((o = "function" == typeof r ? r : o),
        (null !== r && "object" == typeof r) || (r = b),
        r.signal)
      ) {
        if ((P(r.signal, "options.signal"), r.signal.aborted)) return;
        const onAbort = () => {
          this[U]();
        };
        st ??= e("events").addAbortListener;
        const t = st(r.signal, onAbort),
          n = o;
        o = "function" == typeof o ? (e) => (t[f](), n(e)) : t[f];
      }
      "function" == typeof o && _(pt, this, t, o);
    }),
      (Interface.prototype.question[v.custom] = function question(t, r) {
        return (
          (null !== r && "object" == typeof r) || (r = b),
          r.signal && r.signal.aborted
            ? c(new w(void 0, { cause: r.signal.reason }))
            : new a((o, n) => {
                let i = o;
                if (r.signal) {
                  const onAbort = () => {
                    n(new w(void 0, { cause: r.signal.reason }));
                  };
                  st ??= e("events").addAbortListener;
                  const t = st(r.signal, onAbort);
                  i = (e) => {
                    t[f](), o(e);
                  };
                }
                this.question(t, r, i);
              })
        );
      }),
      l(Interface.prototype, {
        [Z]: {
          __proto__: null,
          get() {
            return this._setRawMode;
          },
        },
        [B]: {
          __proto__: null,
          get() {
            return this._onLine;
          },
        },
        [it]: {
          __proto__: null,
          get() {
            return this._writeToOutput;
          },
        },
        [C]: {
          __proto__: null,
          get() {
            return this._addHistory;
          },
        },
        [V]: {
          __proto__: null,
          get() {
            return this._refreshLine;
          },
        },
        [G]: {
          __proto__: null,
          get() {
            return this._normalWrite;
          },
        },
        [H]: {
          __proto__: null,
          get() {
            return this._insertString;
          },
        },
        [tt]: {
          __proto__: null,
          get() {
            return this._tabComplete;
          },
        },
        [ot]: {
          __proto__: null,
          get() {
            return this._wordLeft;
          },
        },
        [nt]: {
          __proto__: null,
          get() {
            return this._wordRight;
          },
        },
        [S]: {
          __proto__: null,
          get() {
            return this._deleteLeft;
          },
        },
        [N]: {
          __proto__: null,
          get() {
            return this._deleteRight;
          },
        },
        [j]: {
          __proto__: null,
          get() {
            return this._deleteWordLeft;
          },
        },
        [A]: {
          __proto__: null,
          get() {
            return this._deleteWordRight;
          },
        },
        [T]: {
          __proto__: null,
          get() {
            return this._deleteLineLeft;
          },
        },
        [O]: {
          __proto__: null,
          get() {
            return this._deleteLineRight;
          },
        },
        [M]: {
          __proto__: null,
          get() {
            return this._line;
          },
        },
        [K]: {
          __proto__: null,
          get() {
            return this._historyNext;
          },
        },
        [E]: {
          __proto__: null,
          get() {
            return this._historyPrev;
          },
        },
        [q]: {
          __proto__: null,
          get() {
            return this._getDisplayPos;
          },
        },
        [F]: {
          __proto__: null,
          get() {
            return this._moveCursor;
          },
        },
        [rt]: {
          __proto__: null,
          get() {
            return this._ttyWrite;
          },
        },
        _decoder: {
          __proto__: null,
          get() {
            return this[W];
          },
          set(t) {
            this[W] = t;
          },
        },
        _line_buffer: {
          __proto__: null,
          get() {
            return this[x];
          },
          set(t) {
            this[x] = t;
          },
        },
        _oldPrompt: {
          __proto__: null,
          get() {
            return this[Q];
          },
          set(t) {
            this[Q] = t;
          },
        },
        _previousKey: {
          __proto__: null,
          get() {
            return this[$];
          },
          set(t) {
            this[$] = t;
          },
        },
        _prompt: {
          __proto__: null,
          get() {
            return this[z];
          },
          set(t) {
            this[z] = t;
          },
        },
        _questionCallback: {
          __proto__: null,
          get() {
            return this[J];
          },
          set(t) {
            this[J] = t;
          },
        },
        _sawKeyPress: {
          __proto__: null,
          get() {
            return this[X];
          },
          set(t) {
            this[X] = t;
          },
        },
        _sawReturnAt: {
          __proto__: null,
          get() {
            return this[Y];
          },
          set(t) {
            this[Y] = t;
          },
        },
      }),
      (Interface.prototype._setRawMode = R.prototype[Z]),
      (Interface.prototype._onLine = R.prototype[B]),
      (Interface.prototype._writeToOutput = R.prototype[it]),
      (Interface.prototype._addHistory = R.prototype[C]),
      (Interface.prototype._refreshLine = function () {
        const t = [],
          e = { write: (e) => t.push(e) },
          r = this._prompt + this.line,
          o = this._getDisplayPos(r),
          n = o.cols,
          i = o.rows,
          s = this.getCursorPos(),
          p = this.prevRows || 0;
        p > 0 && I(e, 0, -p),
          d(e, 0),
          g(e),
          t.push(r),
          0 === n && t.push(" "),
          d(e, s.cols);
        const _ = i - s.rows;
        _ > 0 && I(e, 0, -_),
          this._writeToOutput(t.join("")),
          (this.prevRows = s.rows);
      }),
      (Interface.prototype._normalWrite = R.prototype[G]),
      (Interface.prototype._insertString = R.prototype[H]),
      (Interface.prototype._tabComplete = function (t) {
        this.pause();
        const e = h(this.line, 0, this.cursor);
        this.completer(e, (e, r) => {
          this.resume(),
            e
              ? this._writeToOutput(`Tab completion error: ${L(e)}`)
              : this[et](t, r);
        });
      }),
      (Interface.prototype._wordLeft = R.prototype[ot]),
      (Interface.prototype._wordRight = R.prototype[nt]),
      (Interface.prototype._deleteLeft = R.prototype[S]),
      (Interface.prototype._deleteRight = R.prototype[N]),
      (Interface.prototype._deleteWordLeft = R.prototype[j]),
      (Interface.prototype._deleteWordRight = R.prototype[A]),
      (Interface.prototype._deleteLineLeft = R.prototype[T]),
      (Interface.prototype._deleteLineRight = R.prototype[O]),
      (Interface.prototype._line = R.prototype[M]),
      (Interface.prototype._historyNext = R.prototype[K]),
      (Interface.prototype._historyPrev = R.prototype[E]),
      (Interface.prototype._getDisplayPos = R.prototype[q]),
      (Interface.prototype._getCursorPos = R.prototype.getCursorPos),
      (Interface.prototype._moveCursor = R.prototype[F]),
      (Interface.prototype._ttyWrite = R.prototype[rt]),
      (r.exports = {
        Interface: Interface,
        clearLine: y,
        clearScreenDown: g,
        createInterface: function createInterface(t, e, r, o) {
          return new Interface(t, e, r, o);
        },
        cursorTo: d,
        emitKeypressEvents: m,
        moveCursor: I,
        promises: k,
      });
  },
  "readline/promises": function (e, n, t, r, a, i) {
    "use strict";
    const { Promise: s, SymbolDispose: o } = i,
      { Readline: l } = n("internal/readline/promises"),
      { Interface: c, kQuestionCancel: u } = n("internal/readline/interface"),
      { AbortError: d } = n("internal/errors"),
      { validateAbortSignal: f } = n("internal/validators"),
      { kEmptyObject: g } = n("internal/util");
    let I;
    class Interface extends c {
      constructor(e, n, t, r) {
        super(e, n, t, r);
      }
      question(e, t = g) {
        return new s((r, a) => {
          let i = r;
          if (t?.signal) {
            if ((f(t.signal, "options.signal"), t.signal.aborted))
              return a(new d(void 0, { cause: t.signal.reason }));
            const onAbort = () => {
              this[u](), a(new d(void 0, { cause: t.signal.reason }));
            };
            I ??= n("events").addAbortListener;
            const e = I(t.signal, onAbort);
            i = (n) => {
              e[o](), r(n);
            };
          }
          super.question(e, i);
        });
      }
    }
    t.exports = {
      Interface: Interface,
      Readline: l,
      createInterface: function createInterface(e, n, t, r) {
        return new Interface(e, n, t, r);
      },
    };
  },
  repl: function (e, t, n, o, r, i) {
    "use strict";
    const {
        ArrayPrototypeFilter: s,
        ArrayPrototypeFindIndex: l,
        ArrayPrototypeForEach: a,
        ArrayPrototypeIncludes: c,
        ArrayPrototypeJoin: u,
        ArrayPrototypeMap: p,
        ArrayPrototypePop: d,
        ArrayPrototypePush: m,
        ArrayPrototypePushApply: f,
        ArrayPrototypeReverse: h,
        ArrayPrototypeShift: y,
        ArrayPrototypeSlice: g,
        ArrayPrototypeSome: P,
        ArrayPrototypeSort: _,
        ArrayPrototypeSplice: E,
        ArrayPrototypeUnshift: v,
        Boolean: S,
        Error: w,
        FunctionPrototypeBind: b,
        JSONStringify: R,
        MathMaxApply: x,
        NumberIsNaN: C,
        NumberParseFloat: L,
        ObjectAssign: $,
        ObjectCreate: O,
        ObjectDefineProperty: k,
        ObjectGetOwnPropertyDescriptor: M,
        ObjectGetOwnPropertyNames: T,
        ObjectGetPrototypeOf: I,
        ObjectKeys: A,
        ObjectSetPrototypeOf: N,
        Promise: D,
        ReflectApply: F,
        RegExp: j,
        RegExpPrototypeExec: G,
        SafePromiseRace: B,
        SafeSet: U,
        SafeWeakSet: W,
        StringPrototypeCharAt: z,
        StringPrototypeCodePointAt: K,
        StringPrototypeEndsWith: V,
        StringPrototypeIncludes: Y,
        StringPrototypeRepeat: q,
        StringPrototypeSlice: H,
        StringPrototypeSplit: J,
        StringPrototypeStartsWith: Z,
        StringPrototypeTrim: X,
        StringPrototypeTrimLeft: Q,
        StringPrototypeToLocaleLowerCase: ee,
        Symbol: te,
        SyntaxError: ne,
        SyntaxErrorPrototype: oe,
        globalThis: re,
      } = i,
      { BuiltinModule: ie } = t("internal/bootstrap/realm"),
      { makeRequireFunction: se, addBuiltinLibsToObject: le } = t(
        "internal/modules/helpers"
      ),
      {
        isIdentifierStart: ae,
        isIdentifierChar: ce,
        parse: ue,
      } = t("internal/deps/acorn/acorn/dist/acorn"),
      pe = t("internal/deps/acorn/acorn-walk/dist/walk"),
      {
        decorateErrorStack: de,
        isError: me,
        deprecate: fe,
        SideEffectFreeRegExpPrototypeSymbolReplace: he,
        SideEffectFreeRegExpPrototypeSymbolSplit: ye,
      } = t("internal/util"),
      { inspect: ge } = t("internal/util/inspect"),
      Pe = t("vm"),
      { runInThisContext: _e, runInContext: Ee } = Pe.Script.prototype,
      ve = t("path"),
      Se = t("fs"),
      { Interface: we } = t("readline"),
      { commonPrefix: be } = t("internal/readline/utils"),
      { Console: Re } = t("console"),
      { shouldColorize: xe } = t("internal/util/colors"),
      Ce = t("internal/modules/cjs/loader").Module;
    let Le = s(Ce.builtinModules, (e) => !Z(e, "_"));
    const $e = p(Le, (e) => `node:${e}`);
    a(ie.getSchemeOnlyModuleNames(), (e) => m($e, `node:${e}`));
    const Oe = t("domain");
    let ke = t("internal/util/debuglog").debuglog("repl", (e) => {
      ke = e;
    });
    const {
        codes: {
          ERR_CANNOT_WATCH_SIGINT: Me,
          ERR_INVALID_REPL_EVAL_CONFIG: Te,
          ERR_INVALID_REPL_INPUT: Ie,
          ERR_SCRIPT_EXECUTION_INTERRUPTED: Ae,
        },
        isErrorStackTraceLimitWritable: Ne,
        overrideStackTrace: De,
      } = t("internal/errors"),
      { sendInspectorCommand: Fe } = t("internal/util/inspector"),
      { getOptionValue: je } = t("internal/options"),
      { validateFunction: Ge, validateObject: Be } = t("internal/validators"),
      Ue = je("--experimental-repl-await"),
      We = je("--pending-deprecation"),
      {
        REPL_MODE_SLOPPY: ze,
        REPL_MODE_STRICT: Ke,
        isRecoverableError: Ve,
        kStandaloneREPL: Ye,
        setupPreview: qe,
        setupReverseSearch: He,
      } = t("internal/repl/utils"),
      {
        constants: { ALL_PROPERTIES: Je, SKIP_SYMBOLS: Ze },
        getOwnNonIndexProperties: Xe,
      } = r("util"),
      { startSigintWatchdog: Qe, stopSigintWatchdog: et } = r("contextify"),
      tt = t("internal/repl/history"),
      { extensionFormatMap: nt, legacyExtensionFormatMap: ot } = t(
        "internal/modules/esm/formats"
      ),
      { makeContextifyScript: rt } = t("internal/vm");
    let it,
      st = 1;
    function getREPLResourceName() {
      return "REPL" + st++;
    }
    const lt = new U(
        Pe.runInNewContext("Object.getOwnPropertyNames(globalThis)")
      ),
      at = n,
      ct = new W(),
      ut = te("bufferedCommand"),
      pt = te("contextId");
    let dt = !1;
    try {
      n.filename = ve.resolve("repl");
    } catch {
      const e = ve.dirname(o.execPath);
      n.filename = ve.resolve(e, "repl");
    }
    n.paths = Ce._nodeModulePaths(n.filename);
    const writer = (e) => ge(e, writer.options);
    writer.options = { ...ge.defaultOptions, showProxy: !0 };
    const toDynamicImport = (e) => {
      let t = "";
      const n = ue(e, {
        __proto__: null,
        sourceType: "module",
        ecmaVersion: "latest",
      });
      return (
        pe.ancestor(n, {
          ImportDeclaration(e) {
            const n = `await import(${R(e.source.value)});`;
            if (0 === e.specifiers.length) t += n;
            else if (
              1 === e.specifiers.length &&
              "ImportNamespaceSpecifier" === e.specifiers[0].type
            )
              t += `const ${e.specifiers[0].local.name} = ${n}`;
            else {
              const o = u(
                p(e.specifiers, ({ local: e, imported: t }) =>
                  e.name === t?.name
                    ? e.name
                    : `${t?.name ?? "default"}: ${e.name}`
                ),
                ", "
              );
              t += `const { ${o} } = ${n}`;
            }
          },
        }),
        t
      );
    };
    function REPLServer(e, r, i, s, c, d) {
      if (!(this instanceof REPLServer))
        return new REPLServer(e, r, i, s, c, d);
      let f;
      null !== e && "object" == typeof e
        ? ((f = { ...e }),
          (r = f.stream || f.socket),
          (i = f.eval),
          (s = f.useGlobal),
          (c = f.ignoreUndefined),
          (e = f.prompt),
          (d = f.replMode))
        : (f = {}),
        f.input ||
          f.output ||
          (r || (r = o), (f.input = r.stdin || r), (f.output = r.stdout || r)),
        void 0 === f.terminal && (f.terminal = f.output.isTTY),
        (f.terminal = !!f.terminal),
        f.terminal &&
          void 0 === f.useColors &&
          (f.useColors = xe(f.output) || void 0 === o.env.NODE_DISABLE_COLORS);
      const g = f.terminal && (void 0 !== f.preview ? !!f.preview : !i);
      if (
        (k(this, "inputStream", {
          __proto__: null,
          get: We
            ? fe(
                () => this.input,
                "repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead",
                "DEP0141"
              )
            : () => this.input,
          set: We
            ? fe(
                (e) => (this.input = e),
                "repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead",
                "DEP0141"
              )
            : (e) => (this.input = e),
          enumerable: !1,
          configurable: !0,
        }),
        k(this, "outputStream", {
          __proto__: null,
          get: We
            ? fe(
                () => this.output,
                "repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead",
                "DEP0141"
              )
            : () => this.output,
          set: We
            ? fe(
                (e) => (this.output = e),
                "repl.inputStream and repl.outputStream are deprecated. Use repl.input and repl.output instead",
                "DEP0141"
              )
            : (e) => (this.output = e),
          enumerable: !1,
          configurable: !0,
        }),
        (this.allowBlockingCompletions = !!f.allowBlockingCompletions),
        (this.useColors = !!f.useColors),
        (this._domain = f.domain || Oe.create()),
        (this.useGlobal = !!s),
        (this.ignoreUndefined = !!c),
        (this.replMode = d || n.exports.REPL_MODE_SLOPPY),
        (this.underscoreAssigned = !1),
        (this.last = void 0),
        (this.underscoreErrAssigned = !1),
        (this.lastError = void 0),
        (this.breakEvalOnSigint = !!f.breakEvalOnSigint),
        (this.editorMode = !1),
        (this[pt] = void 0),
        this.breakEvalOnSigint && i)
      )
        throw new Te();
      f[Ye]
        ? (n.exports.repl = this)
        : dt ||
          (o.prependListener("newListener", (e, t) => {
            if (
              "uncaughtException" === e &&
              o.domain &&
              "domainUncaughtExceptionClear" !== t.name &&
              ct.has(o.domain)
            )
              throw new Ie(
                "Listeners for `uncaughtException` cannot be used in the REPL"
              );
          }),
          (dt = !0)),
        ct.add(this._domain);
      const P = ["", "", "", "", "", "", "", "", "", ""],
        v = "\0\0\0",
        S = new j(
          `^${v}(.*)${v}(.*)${v}(.*)${v}(.*)${v}(.*)${v}(.*)${v}(.*)${v}(.*)${v}(.*)$`
        );
      i =
        i ||
        function defaultEval(e, r, i, s) {
          let l,
            a,
            c,
            p = null,
            d = !1,
            m = !1;
          const f = e;
          null !== G(/^\s*{/, e) &&
            null === G(/;\s*$/, e) &&
            ((e = `(${X(e)})\n`), (d = !0));
          const h = te(`eval:${i}`);
          let g;
          try {
            const { pathToFileURL: e } = t("internal/url");
            g = e(ve.join(o.cwd(), "repl")).href;
          } catch {}
          async function importModuleDynamically(e, n, o) {
            return t("internal/process/esm_loader").esmLoader.import(e, g, o);
          }
          if (Ue && Y(e, "await")) {
            void 0 === it &&
              ({ processTopLevelAwait: it } = t("internal/repl/await"));
            try {
              const t = it(e);
              null !== t && ((e = t), (d = !0), (m = !0));
            } catch (t) {
              let n = !1;
              if ("SyntaxError" === t.name) {
                const o = he(/\bawait\b/g, e, "");
                try {
                  rt(
                    o,
                    i,
                    0,
                    0,
                    void 0,
                    !1,
                    void 0,
                    h,
                    importModuleDynamically
                  );
                } catch (e) {
                  Ve(e, o) && ((n = !0), (p = new Recoverable(t)));
                }
              }
              n || (de(t), (p = t));
            }
          }
          if ("\n" === e) return s(null);
          if (null === p)
            for (;;) {
              try {
                R.replMode === n.exports.REPL_MODE_STRICT &&
                  null === G(/^\s*$/, e) &&
                  (e = `'use strict'; void 0;\n${e}`),
                  (a = rt(
                    e,
                    i,
                    0,
                    0,
                    void 0,
                    !1,
                    void 0,
                    h,
                    importModuleDynamically
                  ));
              } catch (t) {
                if ((ke("parse error %j", e, t), d)) {
                  (d = !1), (m = !1), (e = f), (c = t);
                  continue;
                }
                const n = c || t;
                p = Ve(n, e) ? new Recoverable(n) : n;
              }
              break;
            }
          G(S, u(P, v));
          let _ = !1;
          function finishExecution(e, t) {
            if (!_) {
              _ = !0;
              for (let e = 1; e < P.length; e += 1) P[e] = j[`$${e}`];
              s(e, t);
            }
          }
          if (!p) {
            let e;
            if (R.breakEvalOnSigint) {
              if (!Qe()) throw new Me();
              e = R._setRawMode(!1);
            }
            try {
              try {
                const e = {
                  displayErrors: !1,
                  breakOnSigint: R.breakEvalOnSigint,
                };
                l = R.useGlobal ? F(_e, a, [e]) : F(Ee, a, [r, e]);
              } finally {
                R.breakEvalOnSigint &&
                  (R._setRawMode(e), et() && R.emit("SIGINT"));
              }
            } catch (e) {
              if (((p = e), o.domain))
                return (
                  ke("not recoverable, send to domain"),
                  o.domain.emit("error", p),
                  void o.domain.exit()
                );
            }
            if (m && !p) {
              let e;
              !(function pause() {
                T = !0;
              })();
              let t = l;
              if (R.breakEvalOnSigint) {
                const n = new D((t, n) => {
                  (e = () => {
                    const e = w.stackTraceLimit;
                    Ne() && (w.stackTraceLimit = 0);
                    const t = new Ae();
                    Ne() && (w.stackTraceLimit = e), n(t);
                  }),
                    W.add(e);
                });
                t = B([t, n]);
              }
              (async () => {
                try {
                  const e = (await t)?.value;
                  finishExecution(null, e);
                } catch (e) {
                  if (e && o.domain)
                    return (
                      ke("not recoverable, send to domain"),
                      o.domain.emit("error", e),
                      void o.domain.exit()
                    );
                  finishExecution(e);
                } finally {
                  W.delete(e),
                    (function unpause() {
                      if (!T) return;
                      let e;
                      T = !1;
                      const t = R.isCompletionEnabled;
                      for (; void 0 !== (e = y(M)); ) {
                        const { 0: t, 1: n, 2: o } = e;
                        switch (t) {
                          case "key": {
                            const { 0: e, 1: t } = n;
                            (R.isCompletionEnabled = o), R._ttyWrite(e, t);
                            break;
                          }
                          case "close":
                            R.emit("exit");
                        }
                        if (T) break;
                      }
                      R.isCompletionEnabled = t;
                    })();
                }
              })();
            }
          }
          (m && !p) || finishExecution(p, l);
        };
      const R = this,
        M = [];
      let T = !1;
      function _parseREPLKeyword(e, t) {
        const n = this.commands[e];
        return !!n && (F(n.action, this, [t]), !0);
      }
      (R.eval = R._domain.bind(i)),
        R._domain.on("error", function debugDomainError(e) {
          ke("domain error");
          let t = "";
          if (
            "object" == typeof e &&
            null !== e &&
            (De.set(e, (e, t) => {
              let n;
              if ("object" == typeof t) {
                const e = l(h(t), (e) => null === e.getFunctionName());
                n = E(t, e + 1);
              } else n = t;
              return "function" == typeof w.prepareStackTrace
                ? w.prepareStackTrace(e, n)
                : (m(n, e), u(h(n), "\n    at "));
            }),
            de(e),
            e.domainThrown && (delete e.domain, delete e.domainThrown),
            me(e))
          ) {
            if (e.stack)
              if ("SyntaxError" === e.name) {
                e.stack = he(
                  /^\s+at\s.*\n?/gm,
                  he(/^REPL\d+:\d+\r?\n/, e.stack, ""),
                  ""
                );
                const t = "Cannot use import statement outside a module";
                Y(e.message, t) &&
                  ((e.message =
                    "Cannot use import statement inside the Node.js REPL, alternatively use dynamic import: " +
                    toDynamicImport(R.lines.at(-1))),
                  (e.stack = he(
                    /SyntaxError:.*\n/,
                    e.stack,
                    `SyntaxError: ${e.message}\n`
                  )));
              } else
                R.replMode === n.exports.REPL_MODE_STRICT &&
                  (e.stack = he(
                    /(\s+at\s+REPL\d+:)(\d+)/,
                    e.stack,
                    (e, t, n) => t + (n - 1)
                  ));
            (t = R.writer(e)),
              "[" === t[0] && "]" === t[t.length - 1] && (t = H(t, 1, -1));
          }
          if (
            (R.underscoreErrAssigned || (R.lastError = e),
            f[Ye] && 0 !== o.listenerCount("uncaughtException"))
          )
            o.nextTick(() => {
              o.emit("uncaughtException", e),
                R.clearBufferedCommand(),
                (R.lines.level = []),
                R.displayPrompt();
            });
          else {
            "" === t && (t = R.writer(e));
            const n = ye(/(?<=\n)/, t);
            let o = !1;
            if (
              ((t = ""),
              a(n, (e) => {
                o || null === G(/^\[?([A-Z][a-z0-9_]*)*Error/, e)
                  ? (t += e)
                  : ((t +=
                      writer.options.breakLength >= e.length
                        ? `Uncaught ${e}`
                        : `Uncaught:\n${e}`),
                    (o = !0));
              }),
              !o)
            ) {
              const e = 1 === n.length ? " " : ":\n";
              t = `Uncaught${e}${t}`;
            }
            (t += V(t, "\n") ? "" : "\n"),
              R.output.write(t),
              R.clearBufferedCommand(),
              (R.lines.level = []),
              R.displayPrompt();
          }
        }),
        R.clearBufferedCommand(),
        F(we, this, [
          {
            input: f.input,
            output: f.output,
            completer:
              f.completer ||
              function completer(e, t) {
                F(complete, R, [
                  e,
                  R.editorMode ? R.completeOnEditorMode(t) : t,
                ]);
              },
            terminal: f.terminal,
            historySize: f.historySize,
            prompt: e,
          },
        ]),
        R.resetContext(),
        (this.commands = O(null)),
        (function defineDefaultCommands(e) {
          let t;
          e.defineCommand("break", {
            help: "Sometimes you get stuck, this gets you out",
            action: function () {
              this.clearBufferedCommand(), this.displayPrompt();
            },
          }),
            (t = e.useGlobal
              ? "Alias for .break"
              : "Break, and also clear the local context");
          e.defineCommand("clear", {
            help: t,
            action: function () {
              this.clearBufferedCommand(),
                this.useGlobal ||
                  (this.output.write("Clearing context...\n"),
                  this.resetContext()),
                this.displayPrompt();
            },
          }),
            e.defineCommand("exit", {
              help: "Exit the REPL",
              action: function () {
                this.close();
              },
            }),
            e.defineCommand("help", {
              help: "Print this help message",
              action: function () {
                const e = _(A(this.commands)),
                  t = x(p(e, (e) => e.length));
                a(e, (e) => {
                  const n = this.commands[e],
                    o = q(" ", t - e.length + 3),
                    r = `.${e}${n.help ? o + n.help : ""}\n`;
                  this.output.write(r);
                }),
                  this.output.write(
                    "\nPress Ctrl+C to abort current expression, Ctrl+D to exit the REPL\n"
                  ),
                  this.displayPrompt();
              },
            }),
            e.defineCommand("save", {
              help: "Save all evaluated commands in this REPL session to a file",
              action: function (e) {
                try {
                  Se.writeFileSync(e, u(this.lines, "\n")),
                    this.output.write(`Session saved to: ${e}\n`);
                } catch {
                  this.output.write(`Failed to save: ${e}\n`);
                }
                this.displayPrompt();
              },
            }),
            e.defineCommand("load", {
              help: "Load JS from a file into the REPL session",
              action: function (e) {
                try {
                  const t = Se.statSync(e);
                  if (t && t.isFile()) {
                    _turnOnEditorMode(this);
                    const t = Se.readFileSync(e, "utf8");
                    this.write(t), _turnOffEditorMode(this), this.write("\n");
                  } else
                    this.output.write(
                      `Failed to load: ${e} is not a valid file\n`
                    );
                } catch {
                  this.output.write(`Failed to load: ${e}\n`);
                }
                this.displayPrompt();
              },
            }),
            e.terminal &&
              e.defineCommand("editor", {
                help: "Enter editor mode",
                action() {
                  _turnOnEditorMode(this),
                    this.output.write(
                      "// Entering editor mode (Ctrl+D to finish, Ctrl+C to cancel)\n"
                    );
                },
              });
        })(this),
        (R.writer = f.writer || n.exports.writer),
        R.writer === writer &&
          ((writer.options.colors = R.useColors),
          f[Ye] &&
            k(ge, "replDefaults", {
              __proto__: null,
              get: () => writer.options,
              set: (e) => (Be(e, "options"), $(writer.options, e)),
              enumerable: !0,
              configurable: !0,
            })),
        R.on("close", function emitExit() {
          T ? m(M, ["close"]) : R.emit("exit");
        });
      let I = !1,
        N = !1;
      const W = new U();
      R.on("SIGINT", function onSigInt() {
        if (W.size > 0) {
          for (const e of W) e();
          return;
        }
        const e = 0 === R.line.length;
        R.clearLine(), _turnOffEditorMode(R);
        const t = R[ut];
        if ((t && t.length > 0) || !e) I = !1;
        else {
          if (I) return R.close(), void (I = !1);
          R.output.write(
            "(To exit, press Ctrl+C again or Ctrl+D or type .exit)\n"
          ),
            (I = !0);
        }
        R.clearBufferedCommand(), (R.lines.level = []), R.displayPrompt();
      }),
        R.on("line", function onLine(e) {
          if ((ke("line %j", e), (e = e || ""), (I = !1), R.editorMode)) {
            R[ut] += e + "\n";
            const t = R._sawKeyPress ? G(/^\s+/, e) : null;
            if (t) {
              const e = t[0];
              R.write(e), (R.line = e), (R.cursor = e.length);
            }
            return void F(_memory, R, [e]);
          }
          const t = X(e);
          if (t && "." === z(t, 0) && "." !== z(t, 1) && C(L(t))) {
            const e = G(/^\.([^\s]+)\s*(.*)$/, t),
              n = e && e[1],
              o = e && e[2];
            if (!0 === F(_parseREPLKeyword, R, [n, o])) return;
            if (!R[ut])
              return (
                R.output.write("Invalid REPL keyword\n"), void finish(null)
              );
          }
          const n = R[ut] + e + "\n";
          function finish(t, n) {
            if (
              (ke("finish", t, n),
              F(_memory, R, [e]),
              t && !R[ut] && Z(X(e), "npm "))
            )
              return (
                R.output.write(
                  "npm should be run outside of the Node.js REPL, in your normal shell.\n(Press Ctrl+D to exit.)\n"
                ),
                void R.displayPrompt()
              );
            if (t) {
              if (t instanceof Recoverable && !N)
                return (R[ut] += e + "\n"), void R.displayPrompt();
              R._domain.emit("error", t.err || t);
            }
            R.clearBufferedCommand(),
              (N = !1),
              t ||
                2 !== arguments.length ||
                (R.ignoreUndefined && void 0 === n) ||
                (R.underscoreAssigned || (R.last = n),
                R.output.write(R.writer(n) + "\n")),
              t || R.displayPrompt();
          }
          ke("eval %j", n), R.eval(n, R.context, getREPLResourceName(), finish);
        }),
        R.on("SIGCONT", function onSigCont() {
          R.editorMode
            ? (R.output.write(`${R._initialPrompt}.editor\n`),
              R.output.write(
                "// Entering editor mode (Ctrl+D to finish, Ctrl+C to cancel)\n"
              ),
              R.output.write(`${R[ut]}\n`),
              R.prompt(!0))
            : R.displayPrompt(!0);
        });
      const { reverseSearch: K } = He(this),
        { clearPreview: J, showPreview: Q } = qe(this, pt, ut, g),
        ee = b(R._ttyWrite, R);
      (R._ttyWrite = (e, t) => {
        if (
          ((t = t || {}),
          !T || (R.breakEvalOnSigint && t.ctrl && "c" === t.name))
        ) {
          if (R.editorMode && R.terminal)
            if (t.ctrl && !t.shift)
              switch (t.name) {
                case "d":
                  _turnOffEditorMode(R), (N = !0), ee(e, { name: "return" });
                  break;
                case "n":
                case "p":
                  break;
                default:
                  ee(e, t);
              }
            else
              switch (t.name) {
                case "up":
                case "down":
                  break;
                case "tab":
                  (R._previousKey = null), ee(e, t);
                  break;
                default:
                  ee(e, t);
              }
          else if (
            (t.ctrl &&
              "d" === t.name &&
              0 === R.cursor &&
              0 === R.line.length &&
              R.clearLine(),
            J(t),
            !K(e, t))
          ) {
            ee(e, t);
            const n = "escape" !== t.name;
            Q(n);
          }
        } else m(M, ["key", [e, t], R.isCompletionEnabled]);
      }),
        R.displayPrompt();
    }
    N(REPLServer.prototype, we.prototype),
      N(REPLServer, we),
      (REPLServer.prototype.setupHistory = function setupHistory(e, t) {
        tt(this, e, t);
      }),
      (REPLServer.prototype.clearBufferedCommand =
        function clearBufferedCommand() {
          this[ut] = "";
        }),
      (REPLServer.prototype.close = function close() {
        if (this.terminal && this._flushing && !this._closingOnFlush)
          return (
            (this._closingOnFlush = !0),
            void this.once("flushHistory", () =>
              F(we.prototype.close, this, [])
            )
          );
        o.nextTick(() => F(we.prototype.close, this, []));
      }),
      (REPLServer.prototype.createContext = function () {
        let e;
        if (this.useGlobal) e = re;
        else {
          Fe(
            (t) => {
              t.post("Runtime.enable"),
                t.once("Runtime.executionContextCreated", ({ params: e }) => {
                  this[pt] = e.context.id;
                }),
                (e = Pe.createContext()),
                t.post("Runtime.disable");
            },
            () => {
              e = Pe.createContext();
            }
          ),
            a(T(re), (t) => {
              lt.has(t) || k(e, t, { __proto__: null, ...M(re, t) });
            }),
            (e.global = e);
          const t = new Re(this.output);
          k(e, "console", {
            __proto__: null,
            configurable: !0,
            writable: !0,
            value: t,
          });
        }
        const t = new Ce("<repl>");
        return (
          (t.paths = Ce._resolveLookupPaths("<repl>", at)),
          k(e, "module", {
            __proto__: null,
            configurable: !0,
            writable: !0,
            value: t,
          }),
          k(e, "require", {
            __proto__: null,
            configurable: !0,
            writable: !0,
            value: se(t),
          }),
          le(e, "<REPL>"),
          e
        );
      }),
      (REPLServer.prototype.resetContext = function () {
        (this.context = this.createContext()),
          (this.underscoreAssigned = !1),
          (this.underscoreErrAssigned = !1),
          (this.lines = []),
          (this.lines.level = []),
          k(this.context, "_", {
            __proto__: null,
            configurable: !0,
            get: () => this.last,
            set: (e) => {
              (this.last = e),
                this.underscoreAssigned ||
                  ((this.underscoreAssigned = !0),
                  this.output.write(
                    "Expression assignment to _ now disabled.\n"
                  ));
            },
          }),
          k(this.context, "_error", {
            __proto__: null,
            configurable: !0,
            get: () => this.lastError,
            set: (e) => {
              (this.lastError = e),
                this.underscoreErrAssigned ||
                  ((this.underscoreErrAssigned = !0),
                  this.output.write(
                    "Expression assignment to _error now disabled.\n"
                  ));
            },
          }),
          this.emit("reset", this.context);
      }),
      (REPLServer.prototype.displayPrompt = function (e) {
        let t = this._initialPrompt;
        if (this[ut].length) {
          t = "...";
          const e = this.lines.level.length ? this.lines.level.length - 1 : 0;
          t += q("..", e) + " ";
        }
        F(we.prototype.setPrompt, this, [t]), this.prompt(e);
      }),
      (REPLServer.prototype.setPrompt = function setPrompt(e) {
        (this._initialPrompt = e), F(we.prototype.setPrompt, this, [e]);
      });
    const mt =
        /\bimport\s*\(\s*['"`](([\w@./:-]+\/)?(?:[\w@./:-]*))(?![^'"`])$/,
      ft = /\brequire\s*\(\s*['"`](([\w@./:-]+\/)?(?:[\w@./:-]*))(?![^'"`])$/,
      ht = /fs(?:\.promises)?\.\s*[a-z][a-zA-Z]+\(\s*["'](.*)/,
      yt =
        /(?:[\w$'"`[{(](?:\w|\$|['"`\]})])*\??\.)*[a-zA-Z_$](?:\w|\$)*\??\.?$/,
      gt = /-\d+\.\d+/;
    function isIdentifier(e) {
      if ("" === e) return !1;
      const t = K(e, 0);
      if (!ae(t)) return !1;
      for (let n = t > 65535 ? 2 : 1; n < e.length; n += 1) {
        const t = K(e, n);
        if (!ce(t)) return !1;
        t > 65535 && (n += 1);
      }
      return !0;
    }
    function isNotLegacyObjectPrototypeMethod(e) {
      return (
        isIdentifier(e) &&
        "__defineGetter__" !== e &&
        "__defineSetter__" !== e &&
        "__lookupGetter__" !== e &&
        "__lookupSetter__" !== e
      );
    }
    function filteredOwnPropertyNames(e) {
      if (!e) return [];
      let t = !1;
      if (null === I(e)) {
        const n = M(e, "constructor");
        if (n && n.value) {
          const o = I(n.value);
          t = o && I(o) === e;
        }
      }
      return s(
        Xe(e, Je | Ze),
        t ? isNotLegacyObjectPrototypeMethod : isIdentifier
      );
    }
    function gracefulReaddir(...e) {
      try {
        return F(Se.readdirSync, null, e);
      } catch {}
    }
    function complete(e, t) {
      let r,
        i,
        l = [];
      e = Q(e);
      let h,
        E = "";
      if (null !== (h = G(/^\s*\.(\w*)$/, e)))
        m(l, A(this.commands)), (r = h[1]), r.length && (E = r);
      else if (null !== (h = G(ft, e))) {
        if (((r = h[1]), (E = r), this.allowBlockingCompletions)) {
          const e = h[2] || "",
            t = A(this.context.require.extensions),
            s = p(t, (e) => `index${e}`);
          m(s, "package.json", "index"), (i = []);
          let u = [];
          "." === r
            ? (i = ["./", "../"])
            : ".." === r
            ? (i = ["../"])
            : null !== G(/^\.\.?\//, r)
            ? (u = [o.cwd()])
            : ((u = []), f(u, n.paths), f(u, Ce.globalPaths)),
            a(u, (n) => {
              const o =
                gracefulReaddir((n = ve.resolve(n, e)), {
                  withFileTypes: !0,
                }) || [];
              a(o, (o) => {
                if (null !== G(gt, o.name) || ".npm" === o.name) return;
                const r = ve.extname(o.name),
                  l = H(o.name, 0, -r.length);
                if (!o.isDirectory())
                  return void (
                    !Y(t, r) ||
                    (e && "index" === l) ||
                    m(i, `${e}${l}`)
                  );
                m(i, `${e}${o.name}/`);
                const a = ve.resolve(n, o.name);
                P(gracefulReaddir(a) || [], (e) => c(s, e)) &&
                  m(i, `${e}${o.name}`);
              });
            }),
            i.length && m(l, i);
        }
        m(l, Le, $e);
      } else if (null !== (h = G(mt, e))) {
        if (((r = h[1]), (E = r), this.allowBlockingCompletions)) {
          const e = h[2] || "",
            t = A(
              "node" === je("--experimental-specifier-resolution") ? ot : nt
            ),
            s = p(t, (e) => `index${e}`);
          m(s, "package.json"), (i = []);
          let u = [];
          "." === r
            ? (i = ["./", "../"])
            : ".." === r
            ? (i = ["../"])
            : (u = null !== G(/^\.\.?\//, r) ? [o.cwd()] : g(n.paths)),
            a(u, (n) => {
              n = ve.resolve(n, e);
              const o = "node_modules" === ve.basename(n),
                r = gracefulReaddir(n, { withFileTypes: !0 }) || [];
              a(r, (r) => {
                const { name: l } = r;
                if (null === G(gt, l) && ".npm" !== l)
                  if (r.isDirectory()) {
                    if ((m(i, `${e}${l}/`), !e && o)) {
                      const t = gracefulReaddir(ve.resolve(n, l)) || [];
                      P(t, (e) => c(s, e)) && m(i, `${e}${l}`);
                    }
                  } else {
                    const n = ve.extname(l);
                    Y(t, n) && m(i, `${e}${l}`);
                  }
              });
            }),
            i.length && m(l, i);
        }
        m(l, Le, $e);
      } else if (null !== (h = G(ht, e)) && this.allowBlockingCompletions)
        ({ 0: l, 1: r } = (function completeFSFunctions(e) {
          let t = "",
            n = e[1],
            o = gracefulReaddir(n, { withFileTypes: !0 });
          return (
            o ||
              ((t = ve.basename(n)),
              (n = ve.dirname(n)),
              (o = gracefulReaddir(n, { withFileTypes: !0 }) || [])),
            [
              [
                p(
                  s(o, (e) => Z(e.name, t)),
                  (e) => e.name
                ),
              ],
              t,
            ]
          );
        })(h));
      else if (0 === e.length || null !== G(/\w|\.|\$/, e[e.length - 1])) {
        const { 0: t } = G(yt, e) || [""];
        if (0 !== e.length && !t) return void completionGroupsLoaded();
        let n = "";
        if (((r = t), V(e, "."))) n = H(t, 0, -1);
        else if (0 !== e.length) {
          const e = J(t, ".");
          (E = d(e)), (n = u(e, "."));
        }
        if (!n) {
          m(
            l,
            (function getGlobalLexicalScopeNames(e) {
              return Fe(
                (t) => {
                  let n = [];
                  return (
                    t.post(
                      "Runtime.globalLexicalScopeNames",
                      { executionContextId: e },
                      (e, t) => {
                        e || (n = t.names);
                      }
                    ),
                    n
                  );
                },
                () => []
              );
            })(this[pt])
          );
          let e = this.context;
          for (; null !== (e = I(e)); ) m(l, filteredOwnPropertyNames(e));
          const t = filteredOwnPropertyNames(this.context);
          return (
            this.useGlobal || m(t, ...lt),
            m(l, t),
            "" !== E &&
              (function addCommonWords(e) {
                m(e, [
                  "async",
                  "await",
                  "break",
                  "case",
                  "catch",
                  "const",
                  "continue",
                  "debugger",
                  "default",
                  "delete",
                  "do",
                  "else",
                  "export",
                  "false",
                  "finally",
                  "for",
                  "function",
                  "if",
                  "import",
                  "in",
                  "instanceof",
                  "let",
                  "new",
                  "null",
                  "return",
                  "switch",
                  "this",
                  "throw",
                  "true",
                  "try",
                  "typeof",
                  "var",
                  "void",
                  "while",
                  "with",
                  "yield",
                ]);
              })(l),
            void completionGroupsLoaded()
          );
        }
        let o = ".";
        V(n, "?") && ((n = H(n, 0, -1)), (o = "?."));
        const i = [],
          s = `try { ${n} } catch {}`;
        return void this.eval(
          s,
          this.context,
          getREPLResourceName(),
          (e, t) => {
            try {
              let e;
              ("object" == typeof t && null !== t) || "function" == typeof t
                ? (i.push(filteredOwnPropertyNames(t)), (e = I(t)))
                : (e = t.constructor ? t.constructor.prototype : null);
              let n = 5;
              for (; null !== e && 0 != n--; )
                i.push(filteredOwnPropertyNames(e)), (e = I(e));
            } catch {}
            i.length &&
              ((n += o),
              a(i, (e) => {
                m(
                  l,
                  p(e, (e) => `${n}${e}`)
                );
              }),
              E && (E = `${n}${E}`)),
              completionGroupsLoaded();
          }
        );
      }
      return completionGroupsLoaded();
      function completionGroupsLoaded() {
        if (l.length && E) {
          const e = [],
            t = ee(E);
          a(l, (n) => {
            const o = s(n, (e) => Z(ee(e), t));
            o.length && m(e, o);
          }),
            (l = e);
        }
        const e = [],
          n = new U();
        n.add(""),
          a(l, (t) => {
            _(t, (e, t) => (t > e ? 1 : -1));
            const o = n.size;
            a(t, (t) => {
              n.has(t) || (v(e, t), n.add(t));
            }),
              n.size !== o && v(e, "");
          }),
          "" === e[0] && y(e),
          t(null, [e, r]);
      }
    }
    function _memory(e) {
      const t = this;
      if (
        ((t.lines = t.lines || []), (t.lines.level = t.lines.level || []), e)
      ) {
        const n = t.lines.level.length ? t.lines.level.length - 1 : 0;
        m(t.lines, q("  ", n) + e);
      } else m(t.lines, "");
      if (!e) return void (t.lines.level = []);
      const countMatches = (e, t) => {
          let n = 0;
          for (; null !== G(e, t); ) n++;
          return n;
        },
        n = countMatches(/[{(]/g, e),
        o = countMatches(/[})]/g, e);
      let r = n.length - o.length;
      r &&
        (function workIt() {
          if (r > 0) m(t.lines.level, { line: t.lines.length - 1, depth: r });
          else if (r < 0) {
            const e = d(t.lines.level);
            if (e) {
              const n = e.depth + r;
              n < 0
                ? ((r += e.depth), workIt())
                : n > 0 && ((e.depth += r), m(t.lines.level, e));
            }
          }
        })();
    }
    function _turnOnEditorMode(e) {
      (e.editorMode = !0), F(we.prototype.setPrompt, e, [""]);
    }
    function _turnOffEditorMode(e) {
      (e.editorMode = !1), e.setPrompt(e._initialPrompt);
    }
    function Recoverable(e) {
      this.err = e;
    }
    (REPLServer.prototype.complete = function () {
      F(this.completer, this, arguments);
    }),
      (REPLServer.prototype.completeOnEditorMode = (e) => (t, n) => {
        if (t) return e(t);
        const { 0: o, 1: r = "" } = n;
        let i = s(o, S);
        r && 0 !== i.length && (i = [be(i)]), e(null, [i, r]);
      }),
      (REPLServer.prototype.defineCommand = function (e, t) {
        "function" == typeof t
          ? (t = { action: t })
          : Ge(t.action, "cmd.action"),
          (this.commands[e] = t);
      }),
      N(Recoverable.prototype, oe),
      N(Recoverable, ne),
      (n.exports = {
        start: function start(e, t, n, o, r, i) {
          return new REPLServer(e, t, n, o, r, i);
        },
        writer: writer,
        REPLServer: REPLServer,
        REPL_MODE_SLOPPY: ze,
        REPL_MODE_STRICT: Ke,
        Recoverable: Recoverable,
      }),
      k(n.exports, "builtinModules", {
        __proto__: null,
        get: () => Le,
        set: (e) => (Le = e),
        enumerable: !0,
        configurable: !0,
      }),
      k(n.exports, "_builtinLibs", {
        __proto__: null,
        get: We
          ? fe(
              () => Le,
              "repl._builtinLibs is deprecated. Check module.builtinModules instead",
              "DEP0142"
            )
          : () => Le,
        set: We
          ? fe(
              (e) => (Le = e),
              "repl._builtinLibs is deprecated. Check module.builtinModules instead",
              "DEP0142"
            )
          : (e) => (Le = e),
        enumerable: !1,
        configurable: !0,
      });
  },
  stream: function (e, r, t, a, n, s) {
    "use strict";
    const { ObjectDefineProperty: l, ObjectKeys: i, ReflectApply: o } = s,
      {
        promisify: { custom: u },
      } = r("internal/util"),
      { streamReturningOperators: _, promiseReturningOperators: f } = r(
        "internal/streams/operators"
      ),
      {
        codes: { ERR_ILLEGAL_CONSTRUCTOR: m },
      } = r("internal/errors"),
      p = r("internal/streams/compose"),
      { setDefaultHighWaterMark: b, getDefaultHighWaterMark: d } = r(
        "internal/streams/state"
      ),
      { pipeline: g } = r("internal/streams/pipeline"),
      { destroyer: c } = r("internal/streams/destroy"),
      h = r("internal/streams/end-of-stream"),
      y = r("internal/buffer"),
      R = r("stream/promises"),
      D = r("internal/streams/utils"),
      w = (t.exports = r("internal/streams/legacy").Stream);
    (w.isDestroyed = D.isDestroyed),
      (w.isDisturbed = D.isDisturbed),
      (w.isErrored = D.isErrored),
      (w.isReadable = D.isReadable),
      (w.isWritable = D.isWritable),
      (w.Readable = r("internal/streams/readable"));
    for (const e of i(_)) {
      let fn = function (...e) {
        if (new.target) throw m();
        return w.Readable.from(o(r, this, e));
      };
      const r = _[e];
      l(fn, "name", { __proto__: null, value: r.name }),
        l(fn, "length", { __proto__: null, value: r.length }),
        l(w.Readable.prototype, e, {
          __proto__: null,
          value: fn,
          enumerable: !1,
          configurable: !0,
          writable: !0,
        });
    }
    for (const e of i(f)) {
      let fn = function (...e) {
        if (new.target) throw m();
        return o(r, this, e);
      };
      const r = f[e];
      l(fn, "name", { __proto__: null, value: r.name }),
        l(fn, "length", { __proto__: null, value: r.length }),
        l(w.Readable.prototype, e, {
          __proto__: null,
          value: fn,
          enumerable: !1,
          configurable: !0,
          writable: !0,
        });
    }
    (w.Writable = r("internal/streams/writable")),
      (w.Duplex = r("internal/streams/duplex")),
      (w.Transform = r("internal/streams/transform")),
      (w.PassThrough = r("internal/streams/passthrough")),
      (w.pipeline = g);
    const { addAbortSignal: A } = r("internal/streams/add-abort-signal");
    (w.addAbortSignal = A),
      (w.finished = h),
      (w.destroy = c),
      (w.compose = p),
      (w.setDefaultHighWaterMark = b),
      (w.getDefaultHighWaterMark = d),
      l(w, "promises", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: () => R,
      }),
      l(g, u, { __proto__: null, enumerable: !0, get: () => R.pipeline }),
      l(h, u, { __proto__: null, enumerable: !0, get: () => R.finished }),
      (w.Stream = w),
      (w._isUint8Array = r("internal/util/types").isUint8Array),
      (w._uint8ArrayToBuffer = function _uint8ArrayToBuffer(e) {
        return new y.FastBuffer(e.buffer, e.byteOffset, e.byteLength);
      });
  },
  "stream/consumers": function (r, t, n, e, o, a) {
    "use strict";
    const { JSONParse: f } = a,
      { TextDecoder: c } = t("internal/encoding"),
      { Blob: u } = t("internal/blob"),
      { Buffer: s } = t("buffer");
    async function blob(r) {
      const t = [];
      for await (const n of r) t.push(n);
      return new u(t);
    }
    async function arrayBuffer(r) {
      return (await blob(r)).arrayBuffer();
    }
    async function text(r) {
      const t = new c();
      let n = "";
      for await (const e of r)
        n += "string" == typeof e ? e : t.decode(e, { stream: !0 });
      return (n += t.decode(void 0, { stream: !1 })), n;
    }
    n.exports = {
      arrayBuffer: arrayBuffer,
      blob: blob,
      buffer: async function buffer(r) {
        return s.from(await arrayBuffer(r));
      },
      text: text,
      json: async function json(r) {
        const t = await text(r);
        return f(t);
      },
    };
  },
  "stream/promises": function (e, n, t, i, s, r) {
    "use strict";
    const { ArrayPrototypePop: a, Promise: l } = r,
      {
        isIterable: o,
        isNodeStream: p,
        isWebStream: m,
      } = n("internal/streams/utils"),
      { pipelineImpl: c } = n("internal/streams/pipeline"),
      { finished: f } = n("internal/streams/end-of-stream");
    n("stream"),
      (t.exports = {
        finished: f,
        pipeline: function pipeline(...e) {
          return new l((n, t) => {
            let i, s;
            const r = e[e.length - 1];
            if (r && "object" == typeof r && !p(r) && !o(r) && !m(r)) {
              const n = a(e);
              (i = n.signal), (s = n.end);
            }
            c(
              e,
              (e, i) => {
                e ? t(e) : n(i);
              },
              { signal: i, end: s }
            );
          });
        },
      });
  },
  "stream/web": function (e, r, a, t, l, m) {
    "use strict";
    const { TransformStream: n, TransformStreamDefaultController: o } = r(
        "internal/webstreams/transformstream"
      ),
      {
        WritableStream: s,
        WritableStreamDefaultController: S,
        WritableStreamDefaultWriter: i,
      } = r("internal/webstreams/writablestream"),
      {
        ReadableStream: b,
        ReadableStreamDefaultReader: u,
        ReadableStreamBYOBReader: d,
        ReadableStreamBYOBRequest: R,
        ReadableByteStreamController: f,
        ReadableStreamDefaultController: D,
      } = r("internal/webstreams/readablestream"),
      { ByteLengthQueuingStrategy: g, CountQueuingStrategy: B } = r(
        "internal/webstreams/queuingstrategies"
      ),
      { TextEncoderStream: C, TextDecoderStream: c } = r(
        "internal/webstreams/encoding"
      ),
      { CompressionStream: y, DecompressionStream: T } = r(
        "internal/webstreams/compression"
      );
    a.exports = {
      ReadableStream: b,
      ReadableStreamDefaultReader: u,
      ReadableStreamBYOBReader: d,
      ReadableStreamBYOBRequest: R,
      ReadableByteStreamController: f,
      ReadableStreamDefaultController: D,
      TransformStream: n,
      TransformStreamDefaultController: o,
      WritableStream: s,
      WritableStreamDefaultWriter: i,
      WritableStreamDefaultController: S,
      ByteLengthQueuingStrategy: g,
      CountQueuingStrategy: B,
      TextEncoderStream: C,
      TextDecoderStream: c,
      CompressionStream: y,
      DecompressionStream: T,
    };
  },
  string_decoder: function (e, t, r, n, i, o) {
    "use strict";
    const {
        ArrayBufferIsView: s,
        ObjectDefineProperties: c,
        Symbol: u,
        TypedArrayPrototypeSubarray: d,
      } = o,
      { Buffer: l } = t("buffer"),
      {
        kIncompleteCharactersStart: a,
        kIncompleteCharactersEnd: f,
        kMissingBytes: g,
        kBufferedBytes: h,
        kEncodingField: _,
        kSize: p,
        decode: y,
        flush: D,
        encodings: S,
      } = i("string_decoder"),
      b = t("internal/util"),
      {
        ERR_INVALID_ARG_TYPE: w,
        ERR_INVALID_THIS: E,
        ERR_UNKNOWN_ENCODING: I,
      } = t("internal/errors").codes,
      N = l[b.kIsEncodingSymbol],
      m = u("kNativeDecoder");
    const k = {};
    for (let e = 0; e < S.length; ++e) k[S[e]] = e;
    function StringDecoder(e) {
      (this.encoding = (function normalizeEncoding(e) {
        const t = b.normalizeEncoding(e);
        if (void 0 === t) {
          if (l.isEncoding === N || !l.isEncoding(e)) throw new I(e);
          return e;
        }
        return t;
      })(e)),
        (this[m] = l.alloc(p)),
        (this[m][_] = k[this.encoding]);
    }
    (StringDecoder.prototype.write = function write(e) {
      if ("string" == typeof e) return e;
      if (!s(e)) throw new w("buf", ["Buffer", "TypedArray", "DataView"], e);
      if (!this[m]) throw new E("StringDecoder");
      return y(this[m], e);
    }),
      (StringDecoder.prototype.end = function end(e) {
        let t = "";
        return (
          void 0 !== e && (t = this.write(e)),
          this[m][h] > 0 && (t += D(this[m])),
          t
        );
      }),
      (StringDecoder.prototype.text = function text(e, t) {
        return (this[m][g] = 0), (this[m][h] = 0), this.write(e.slice(t));
      }),
      c(StringDecoder.prototype, {
        lastChar: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get() {
            return d(this[m], a, f);
          },
        },
        lastNeed: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get() {
            return this[m][g];
          },
        },
        lastTotal: {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get() {
            return this[m][h] + this[m][g];
          },
        },
      }),
      (e.StringDecoder = StringDecoder);
  },
  sys: function (e, i, t, n, s, r) {
    "use strict";
    (t.exports = i("util")),
      n.emitWarning(
        "sys is deprecated. Use util instead.",
        "DeprecationWarning",
        "DEP0025"
      );
  },
  test: function (e, r, t, n, o, c) {
    "use strict";
    const { ObjectAssign: s, ObjectDefineProperty: a } = c,
      {
        test: i,
        describe: f,
        it: u,
        before: b,
        after: _,
        beforeEach: l,
        afterEach: h,
      } = r("internal/test_runner/harness"),
      { run: k } = r("internal/test_runner/runner");
    let p;
    (t.exports = i),
      s(t.exports, {
        after: _,
        afterEach: h,
        before: b,
        beforeEach: l,
        describe: f,
        it: u,
        run: k,
        test: i,
      }),
      a(t.exports, "mock", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get() {
          if (void 0 === p) {
            const { MockTracker: e } = r("internal/test_runner/mock/mock");
            p = new e();
          }
          return p;
        },
      });
  },
  "test/reporters": function (e, r, t, n, _, l) {
    "use strict";
    const { ObjectDefineProperties: o, ReflectConstruct: u } = l;
    let a, i, p, c;
    o(t.exports, {
      __proto__: null,
      dot: {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: () => ((a ??= r("internal/test_runner/reporter/dot")), a),
      },
      junit: {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: () => ((i ??= r("internal/test_runner/reporter/junit")), i),
      },
      spec: {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        value: function value() {
          return (
            (p ??= r("internal/test_runner/reporter/spec")), u(p, arguments)
          );
        },
      },
      tap: {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: () => ((c ??= r("internal/test_runner/reporter/tap")), c),
      },
    });
  },
  timers: function (e, t, i, n, o, r) {
    "use strict";
    const {
        MathTrunc: l,
        ObjectCreate: s,
        ObjectDefineProperty: a,
        SymbolDispose: u,
        SymbolToPrimitive: m,
      } = r,
      { immediateInfo: c, toggleImmediateRef: d } = o("timers"),
      f = t("internal/linkedlist"),
      {
        async_id_symbol: _,
        Timeout: p,
        Immediate: T,
        decRefCount: b,
        immediateInfoFields: { kCount: v, kRefCount: y },
        kRefed: h,
        kHasPrimitive: k,
        getTimerDuration: I,
        timerListMap: g,
        timerListQueue: P,
        immediateQueue: D,
        active: w,
        unrefActive: E,
        insert: A,
      } = t("internal/timers"),
      {
        promisify: { custom: C },
        deprecate: R,
      } = t("internal/util");
    let x = t("internal/util/debuglog").debuglog("timer", (e) => {
      x = e;
    });
    const { validateFunction: F } = t("internal/validators");
    let Q;
    const { destroyHooksExist: j, emitDestroy: H } = t("internal/async_hooks"),
      L = s(null);
    function unenroll(e) {
      if (!e._destroyed) {
        if (
          ((e._destroyed = !0),
          e[k] && delete L[e[_]],
          j() && void 0 !== e[_] && H(e[_]),
          f.remove(e),
          e[h])
        ) {
          const t = l(e._idleTimeout),
            i = g[t];
          void 0 !== i &&
            f.isEmpty(i) &&
            (x("unenroll: list empty"),
            P.removeAt(i.priorityQueuePosition),
            delete g[i.msecs]),
            b();
        }
        e._idleTimeout = -1;
      }
    }
    function setTimeout(e, t, i, n, o) {
      let r, l;
      switch ((F(e, "callback"), arguments.length)) {
        case 1:
        case 2:
          break;
        case 3:
          l = [i];
          break;
        case 4:
          l = [i, n];
          break;
        default:
          for (l = [i, n, o], r = 5; r < arguments.length; r++)
            l[r - 2] = arguments[r];
      }
      const s = new p(e, t, l, !1, !0);
      return A(s, s._idleTimeout), s;
    }
    function clearTimeout(e) {
      if (e && e._onTimeout) return (e._onTimeout = null), void unenroll(e);
      if ("number" == typeof e || "string" == typeof e) {
        const t = L[e];
        void 0 !== t && ((t._onTimeout = null), unenroll(t));
      }
    }
    function setImmediate(e, t, i, n) {
      let o, r;
      switch ((F(e, "callback"), arguments.length)) {
        case 1:
          break;
        case 2:
          r = [t];
          break;
        case 3:
          r = [t, i];
          break;
        default:
          for (r = [t, i, n], o = 4; o < arguments.length; o++)
            r[o - 1] = arguments[o];
      }
      return new T(e, r);
    }
    function clearImmediate(e) {
      e &&
        !e._destroyed &&
        (c[v]--,
        (e._destroyed = !0),
        e[h] && 0 == --c[y] && d(!1),
        (e[h] = null),
        j() && void 0 !== e[_] && H(e[_]),
        (e._onImmediate = null),
        D.remove(e));
    }
    a(setTimeout, C, {
      __proto__: null,
      enumerable: !0,
      get: () => (Q || (Q = t("timers/promises")), Q.setTimeout),
    }),
      (p.prototype.close = function () {
        return clearTimeout(this), this;
      }),
      (p.prototype[u] = function () {
        clearTimeout(this);
      }),
      (p.prototype[m] = function () {
        const e = this[_];
        return this[k] || ((this[k] = !0), (L[e] = this)), e;
      }),
      a(setImmediate, C, {
        __proto__: null,
        enumerable: !0,
        get: () => (Q || (Q = t("timers/promises")), Q.setImmediate),
      }),
      (T.prototype[u] = function () {
        clearImmediate(this);
      }),
      (i.exports = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setImmediate: setImmediate,
        clearImmediate: clearImmediate,
        setInterval: function setInterval(e, t, i, n, o) {
          let r, l;
          switch ((F(e, "callback"), arguments.length)) {
            case 1:
            case 2:
              break;
            case 3:
              l = [i];
              break;
            case 4:
              l = [i, n];
              break;
            default:
              for (l = [i, n, o], r = 5; r < arguments.length; r++)
                l[r - 2] = arguments[r];
          }
          const s = new p(e, t, l, !0, !0);
          return A(s, s._idleTimeout), s;
        },
        clearInterval: function clearInterval(e) {
          clearTimeout(e);
        },
        _unrefActive: R(
          E,
          "timers._unrefActive() is deprecated. Please use timeout.refresh() instead.",
          "DEP0127"
        ),
        active: R(
          w,
          "timers.active() is deprecated. Please use timeout.refresh() instead.",
          "DEP0126"
        ),
        unenroll: R(
          unenroll,
          "timers.unenroll() is deprecated. Please use clearTimeout instead.",
          "DEP0096"
        ),
        enroll: R(
          function enroll(e, t) {
            (t = I(t, "msecs")),
              e._idleNext && unenroll(e),
              f.init(e),
              (e._idleTimeout = t);
          },
          "timers.enroll() is deprecated. Please use setTimeout instead.",
          "DEP0095"
        ),
      });
  },
  "timers/promises": function (e, t, n, o, r, i) {
    "use strict";
    const {
        FunctionPrototypeBind: a,
        Promise: s,
        PromiseReject: l,
        ReflectConstruct: c,
        SafePromisePrototypeFinally: d,
        Symbol: u,
      } = i,
      { Timeout: v, Immediate: f, insert: m } = t("internal/timers"),
      { clearImmediate: _, clearInterval: p, clearTimeout: w } = t("timers"),
      {
        AbortError: b,
        codes: {
          ERR_ILLEGAL_CONSTRUCTOR: h,
          ERR_INVALID_ARG_TYPE: y,
          ERR_INVALID_THIS: I,
        },
      } = t("internal/errors"),
      {
        validateAbortSignal: g,
        validateBoolean: L,
        validateObject: R,
      } = t("internal/validators"),
      { kEmptyObject: E } = t("internal/util"),
      S = u("kScheduler");
    let T;
    function cancelListenerHandler(e, t, n) {
      this._destroyed || (e(this), t(new b(void 0, { cause: n?.reason })));
    }
    function setTimeout(e, n, o = E) {
      const r = void 0 !== n ? [n] : n;
      if (null == o || "object" != typeof o)
        return l(new y("options", "Object", o));
      const { signal: i, ref: c = !0 } = o;
      try {
        g(i, "options.signal");
      } catch (e) {
        return l(e);
      }
      if ("boolean" != typeof c) return l(new y("options.ref", "boolean", c));
      if (i?.aborted) return l(new b(void 0, { cause: i.reason }));
      let u;
      const f = new s((n, o) => {
        const s = new v(n, e, r, !1, c);
        m(s, s._idleTimeout),
          i &&
            ((u = a(cancelListenerHandler, s, w, o, i)),
            (T ??= t("internal/event_target").kResistStopPropagation),
            i.addEventListener("abort", u, { __proto__: null, [T]: !0 }));
      });
      return void 0 !== u ? d(f, () => i.removeEventListener("abort", u)) : f;
    }
    function setImmediate(e, n = E) {
      if (null == n || "object" != typeof n)
        return l(new y("options", "Object", n));
      const { signal: o, ref: r = !0 } = n;
      try {
        g(o, "options.signal");
      } catch (e) {
        return l(e);
      }
      if ("boolean" != typeof r) return l(new y("options.ref", "boolean", r));
      if (o?.aborted) return l(new b(void 0, { cause: o.reason }));
      let i;
      const c = new s((n, s) => {
        const l = new f(n, [e]);
        r || l.unref(),
          o &&
            ((i = a(cancelListenerHandler, l, _, s, o)),
            (T ??= t("internal/event_target").kResistStopPropagation),
            o.addEventListener("abort", i, { __proto__: null, [T]: !0 }));
      });
      return void 0 !== i ? d(c, () => o.removeEventListener("abort", i)) : c;
    }
    n.exports = {
      setTimeout: setTimeout,
      setImmediate: setImmediate,
      setInterval: async function* setInterval(e, n, o = E) {
        R(o, "options");
        const { signal: r, ref: i = !0 } = o;
        if ((g(r, "options.signal"), L(i, "options.ref"), r?.aborted))
          throw new b(void 0, { cause: r?.reason });
        let a, c;
        try {
          let o,
            d = 0;
          for (
            c = new v(
              () => {
                d++, o && (o(), (o = void 0));
              },
              e,
              void 0,
              !0,
              i
            ),
              m(c, c._idleTimeout),
              r &&
                ((a = () => {
                  p(c),
                    o &&
                      (o(l(new b(void 0, { cause: r.reason }))), (o = void 0));
                }),
                (T ??= t("internal/event_target").kResistStopPropagation),
                r.addEventListener("abort", a, {
                  __proto__: null,
                  once: !0,
                  [T]: !0,
                }));
            !r?.aborted;

          )
            for (0 === d && (await new s((e) => (o = e))); d > 0; d--) yield n;
          throw new b(void 0, { cause: r?.reason });
        } finally {
          p(c), r?.removeEventListener("abort", a);
        }
      },
      scheduler: c(
        function () {
          this[S] = !0;
        },
        [],
        class Scheduler {
          constructor() {
            throw new h();
          }
          yield() {
            if (!this[S]) throw new I("Scheduler");
            return setImmediate();
          }
          wait(e, t) {
            if (!this[S]) throw new I("Scheduler");
            return setTimeout(e, void 0, { signal: t?.signal });
          }
        }
      ),
    };
  },
  tls: function (t, e, r, n, o, s) {
    "use strict";
    const {
        Array: c,
        ArrayIsArray: i,
        ArrayPrototypeForEach: l,
        ArrayPrototypeIncludes: a,
        ArrayPrototypeJoin: u,
        ArrayPrototypePush: f,
        ArrayPrototypeReduce: S,
        ArrayPrototypeSome: _,
        JSONParse: p,
        ObjectDefineProperty: E,
        ObjectFreeze: h,
        RegExpPrototypeExec: A,
        RegExpPrototypeSymbolReplace: g,
        StringFromCharCode: P,
        StringPrototypeCharCodeAt: y,
        StringPrototypeEndsWith: L,
        StringPrototypeIncludes: N,
        StringPrototypeIndexOf: T,
        StringPrototypeSlice: I,
        StringPrototypeSplit: R,
        StringPrototypeStartsWith: C,
        StringPrototypeSubstring: d,
      } = s,
      {
        ERR_TLS_CERT_ALTNAME_FORMAT: v,
        ERR_TLS_CERT_ALTNAME_INVALID: m,
        ERR_OUT_OF_RANGE: D,
      } = e("internal/errors").codes,
      O = e("internal/util");
    O.assertCrypto();
    const { isArrayBufferView: F, isUint8Array: b } = e("internal/util/types"),
      U = e("net"),
      { getOptionValue: x } = e("internal/options"),
      { getRootCertificates: w, getSSLCiphers: M } = o("crypto"),
      { Buffer: V } = e("buffer"),
      { canonicalizeIP: k } = o("cares_wrap"),
      H = e("_tls_common"),
      $ = e("_tls_wrap"),
      { createSecurePair: j } = e("internal/tls/secure-pair");
    let W;
    function unfqdn(t) {
      return g(/[.]$/, t, "");
    }
    function toLowerCase(t) {
      return P(32 + y(t, 0));
    }
    function splitHost(t) {
      return R(g(/[A-Z]/g, unfqdn(t), toLowerCase), ".");
    }
    (t.CLIENT_RENEG_LIMIT = 3),
      (t.CLIENT_RENEG_WINDOW = 600),
      (t.DEFAULT_CIPHERS = x("--tls-cipher-list")),
      (t.DEFAULT_ECDH_CURVE = "auto"),
      x("--tls-min-v1.0")
        ? (t.DEFAULT_MIN_VERSION = "TLSv1")
        : x("--tls-min-v1.1")
        ? (t.DEFAULT_MIN_VERSION = "TLSv1.1")
        : x("--tls-min-v1.2")
        ? (t.DEFAULT_MIN_VERSION = "TLSv1.2")
        : x("--tls-min-v1.3")
        ? (t.DEFAULT_MIN_VERSION = "TLSv1.3")
        : (t.DEFAULT_MIN_VERSION = "TLSv1.2"),
      x("--tls-max-v1.3")
        ? (t.DEFAULT_MAX_VERSION = "TLSv1.3")
        : x("--tls-max-v1.2")
        ? (t.DEFAULT_MAX_VERSION = "TLSv1.2")
        : (t.DEFAULT_MAX_VERSION = "TLSv1.3"),
      (t.getCiphers = O.cachedResult(() => O.filterDuplicateStrings(M(), !0))),
      E(t, "rootCertificates", {
        __proto__: null,
        configurable: !1,
        enumerable: !0,
        get: () => (
          W ||
            (function cacheRootCertificates() {
              W = h(w());
            })(),
          W
        ),
      }),
      (t.convertALPNProtocols = function convertALPNProtocols(t, e) {
        i(t)
          ? (e.ALPNProtocols = (function convertProtocols(t) {
              const e = new c(t.length),
                r = V.allocUnsafe(
                  S(
                    t,
                    (t, r, n) => {
                      const o = V.byteLength(r);
                      if (o > 255)
                        throw new D(
                          `The byte length of the protocol at index ${n} exceeds the maximum length.`,
                          "<= 255",
                          o,
                          !0
                        );
                      return (e[n] = o), t + 1 + o;
                    },
                    0
                  )
                );
              let n = 0;
              for (let o = 0, s = t.length; o < s; o++)
                (r[n++] = e[o]), r.write(t[o], n), (n += e[o]);
              return r;
            })(t))
          : b(t)
          ? (e.ALPNProtocols = V.from(t))
          : F(t) &&
            (e.ALPNProtocols = V.from(
              t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
            ));
      });
    const q = /^"(?:[^"\\\u0000-\u001f]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4}))*"/;
    (t.checkServerIdentity = function checkServerIdentity(t, e) {
      const r = e.subject,
        n = e.subjectaltname,
        o = [],
        s = [];
      if (((t = "" + t), n)) {
        const t = N(n, '"')
          ? (function splitEscapedAltNames(t) {
              const e = [];
              let r = "",
                n = 0;
              for (; n !== t.length; ) {
                const o = T(t, ", ", n),
                  s = T(t, '"', n);
                if (-1 !== s && (-1 === o || s < o)) {
                  r += d(t, n, s);
                  const e = A(q, d(t, s));
                  if (!e) throw new v();
                  (r += p(e[0])), (n = s + e[0].length);
                } else
                  -1 !== o
                    ? ((r += d(t, n, o)), f(e, r), (r = ""), (n = o + 2))
                    : ((r += d(t, n)), (n = t.length));
              }
              return f(e, r), e;
            })(n)
          : R(n, ", ");
        l(t, (t) => {
          C(t, "DNS:")
            ? f(o, I(t, 4))
            : C(t, "IP Address:") && f(s, k(I(t, 11)));
        });
      }
      let c = !1,
        S = "Unknown reason";
      if (((t = unfqdn(t)), U.isIP(t)))
        (c = a(s, k(t))),
          c || (S = `IP: ${t} is not in the cert's list: ` + u(s, ", "));
      else if (o.length > 0 || r?.CN) {
        const e = splitHost(t),
          wildcard = (t) =>
            (function check(t, e, r) {
              if (!e) return !1;
              const n = splitHost(e);
              if (t.length !== n.length) return !1;
              if (a(n, "")) return !1;
              if (_(n, (t) => null !== A(/[^\u0021-\u007F]/u, t))) return !1;
              for (let e = t.length - 1; e > 0; e -= 1)
                if (t[e] !== n[e]) return !1;
              const o = t[0],
                s = n[0],
                c = R(s, "*");
              if (1 === c.length || N(s, "xn--")) return o === s;
              if (!r) return !1;
              if (c.length > 2) return !1;
              if (n.length <= 2) return !1;
              const { 0: i, 1: l } = c;
              return !(i.length + l.length > o.length || !C(o, i) || !L(o, l));
            })(e, t, !0);
        if (o.length > 0)
          (c = _(o, wildcard)),
            c || (S = `Host: ${t}. is not in the cert's altnames: ${n}`);
        else {
          const e = r.CN;
          i(e) ? (c = _(e, wildcard)) : e && (c = wildcard(e)),
            c || (S = `Host: ${t}. is not cert's CN: ${e}`);
        }
      } else S = "Cert does not contain a DNS name";
      if (!c) return new m(S, t, e);
    }),
      (t.createSecureContext = H.createSecureContext),
      (t.SecureContext = H.SecureContext),
      (t.TLSSocket = $.TLSSocket),
      (t.Server = $.Server),
      (t.createServer = $.createServer),
      (t.connect = $.connect),
      (t.createSecurePair = O.deprecate(
        j,
        "tls.createSecurePair() is deprecated. Please use tls.TLSSocket instead.",
        "DEP0064"
      ));
  },
  trace_events: function (e, t, r, i, n, a) {
    "use strict";
    const { ArrayPrototypeJoin: s, SafeSet: o, Symbol: c } = a,
      { hasTracing: l } = n("config"),
      g = c("handle"),
      h = c("enabled"),
      d = c("categories"),
      {
        ERR_TRACE_EVENTS_CATEGORY_REQUIRED: b,
        ERR_TRACE_EVENTS_UNAVAILABLE: E,
      } = t("internal/errors").codes,
      { ownsProcessState: u } = t("internal/worker");
    if (!l || !u) throw new E();
    const { CategorySet: T, getEnabledCategories: _ } = n("trace_events"),
      { customInspectSymbol: f } = t("internal/util"),
      { format: m } = t("internal/util/inspect"),
      { validateObject: w, validateStringArray: R } = t("internal/validators"),
      S = new o();
    class Tracing {
      constructor(e) {
        (this[g] = new T(e)), (this[d] = e), (this[h] = !1);
      }
      enable() {
        this[h] ||
          ((this[h] = !0),
          this[g].enable(),
          S.add(this),
          S.size > 10 &&
            i.emitWarning(
              "Possible trace_events memory leak detected. There are more than 10 enabled Tracing objects."
            ));
      }
      disable() {
        this[h] && ((this[h] = !1), this[g].disable(), S.delete(this));
      }
      get enabled() {
        return this[h];
      }
      get categories() {
        return s(this[d], ",");
      }
      [f](e, t) {
        if ("number" == typeof e && e < 0) return this;
        const r = { enabled: this.enabled, categories: this.categories };
        return `Tracing ${m(r)}`;
      }
    }
    r.exports = {
      createTracing: function createTracing(e) {
        if (
          (w(e, "options"),
          R(e.categories, "options.categories"),
          e.categories.length <= 0)
        )
          throw new b();
        return new Tracing(e.categories);
      },
      getEnabledCategories: _,
    };
  },
  tty: function (t, e, r, o, i, n) {
    "use strict";
    const { Array: a, NumberIsInteger: s, ObjectSetPrototypeOf: c } = n,
      h = e("net"),
      { TTY: S, isTTY: d } = i("tty_wrap"),
      m = e("internal/errors"),
      { ERR_INVALID_FD: p, ERR_TTY_INIT_FAILED: l } = m.codes,
      { getColorDepth: u, hasColors: w } = e("internal/tty");
    let f;
    function ReadStream(t, e) {
      if (!(this instanceof ReadStream)) return new ReadStream(t, e);
      if (t >> 0 !== t || t < 0) throw new p(t);
      const r = {},
        o = new S(t, r);
      if (void 0 !== r.code) throw new l(r);
      h.Socket.call(this, {
        readableHighWaterMark: 0,
        handle: o,
        manualStart: !0,
        ...e,
      }),
        (this.isRaw = !1),
        (this.isTTY = !0);
    }
    function WriteStream(t) {
      if (!(this instanceof WriteStream)) return new WriteStream(t);
      if (t >> 0 !== t || t < 0) throw new p(t);
      const e = {},
        r = new S(t, e);
      if (void 0 !== e.code) throw new l(e);
      h.Socket.call(this, {
        readableHighWaterMark: 0,
        handle: r,
        manualStart: !0,
      }),
        this._handle.setBlocking(!0);
      const o = new a(2);
      this._handle.getWindowSize(o) ||
        ((this.columns = o[0]), (this.rows = o[1]));
    }
    c(ReadStream.prototype, h.Socket.prototype),
      c(ReadStream, h.Socket),
      (ReadStream.prototype.setRawMode = function (t) {
        t = !!t;
        const e = this._handle?.setRawMode(t);
        return e
          ? (this.emit("error", m.errnoException(e, "setRawMode")), this)
          : ((this.isRaw = t), this);
      }),
      c(WriteStream.prototype, h.Socket.prototype),
      c(WriteStream, h.Socket),
      (WriteStream.prototype.isTTY = !0),
      (WriteStream.prototype.getColorDepth = u),
      (WriteStream.prototype.hasColors = w),
      (WriteStream.prototype._refreshSize = function () {
        const t = this.columns,
          e = this.rows,
          r = new a(2),
          o = this._handle.getWindowSize(r);
        if (o)
          return void this.emit("error", m.errnoException(o, "getWindowSize"));
        const { 0: i, 1: n } = r;
        (t === i && e === n) ||
          ((this.columns = i), (this.rows = n), this.emit("resize"));
      }),
      (WriteStream.prototype.cursorTo = function (t, r, o) {
        return void 0 === f && (f = e("readline")), f.cursorTo(this, t, r, o);
      }),
      (WriteStream.prototype.moveCursor = function (t, r, o) {
        return void 0 === f && (f = e("readline")), f.moveCursor(this, t, r, o);
      }),
      (WriteStream.prototype.clearLine = function (t, r) {
        return void 0 === f && (f = e("readline")), f.clearLine(this, t, r);
      }),
      (WriteStream.prototype.clearScreenDown = function (t) {
        return void 0 === f && (f = e("readline")), f.clearScreenDown(this, t);
      }),
      (WriteStream.prototype.getWindowSize = function () {
        return [this.columns, this.rows];
      }),
      (r.exports = {
        isatty: function isatty(t) {
          return s(t) && t >= 0 && t <= 2147483647 && d(t);
        },
        ReadStream: ReadStream,
        WriteStream: WriteStream,
      });
  },
  url: function (t, e, s, h, a, o) {
    "use strict";
    const {
        Boolean: n,
        Int8Array: r,
        ObjectCreate: l,
        ObjectKeys: i,
        StringPrototypeCharCodeAt: c,
        decodeURIComponent: u,
      } = o,
      { toASCII: p } = e("internal/idna"),
      { encodeStr: f, hexTable: m } = e("internal/querystring"),
      A = e("querystring"),
      { ERR_INVALID_ARG_TYPE: C, ERR_INVALID_URL: R } =
        e("internal/errors").codes,
      { validateString: _, validateObject: d } = e("internal/validators"),
      { spliceOne: g } = e("internal/util"),
      {
        URL: E,
        URLSearchParams: H,
        domainToASCII: U,
        domainToUnicode: y,
        fileURLToPath: T,
        pathToFileURL: L,
        urlToHttpOptions: I,
        unsafeProtocol: O,
        hostlessProtocol: b,
        slashedProtocol: S,
      } = e("internal/url"),
      q = a("url"),
      { getOptionValue: v } = e("internal/options");
    function Url() {
      (this.protocol = null),
        (this.slashes = null),
        (this.auth = null),
        (this.host = null),
        (this.port = null),
        (this.hostname = null),
        (this.hash = null),
        (this.search = null),
        (this.query = null),
        (this.pathname = null),
        (this.path = null),
        (this.href = null);
    }
    const P = /^[a-z0-9.+-]+:/i,
      N = /:[0-9]*$/,
      j = /^\/\/[^@/]+@[^@/]+/,
      w = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
      {
        CHAR_SPACE: B,
        CHAR_TAB: D,
        CHAR_CARRIAGE_RETURN: F,
        CHAR_LINE_FEED: K,
        CHAR_NO_BREAK_SPACE: G,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: k,
        CHAR_HASH: x,
        CHAR_FORWARD_SLASH: W,
        CHAR_LEFT_SQUARE_BRACKET: V,
        CHAR_RIGHT_SQUARE_BRACKET: Q,
        CHAR_LEFT_ANGLE_BRACKET: $,
        CHAR_RIGHT_ANGLE_BRACKET: M,
        CHAR_LEFT_CURLY_BRACKET: Y,
        CHAR_RIGHT_CURLY_BRACKET: z,
        CHAR_QUESTION_MARK: X,
        CHAR_DOUBLE_QUOTE: Z,
        CHAR_SINGLE_QUOTE: J,
        CHAR_PERCENT: tt,
        CHAR_SEMICOLON: et,
        CHAR_BACKWARD_SLASH: st,
        CHAR_CIRCUMFLEX_ACCENT: ht,
        CHAR_GRAVE_ACCENT: at,
        CHAR_VERTICAL_LINE: ot,
        CHAR_AT: nt,
        CHAR_COLON: rt,
      } = e("internal/constants");
    let lt = !1;
    function urlParse(t, e, s) {
      if (
        (!lt &&
          v("--pending-deprecation") &&
          ((lt = !0),
          h.emitWarning(
            "`url.parse()` behavior is not standardized and prone to errors that have security implications. Use the WHATWG URL API instead. CVEs are not issued for `url.parse()` vulnerabilities.",
            "DeprecationWarning",
            "DEP0169"
          )),
        t instanceof Url)
      )
        return t;
      const a = new Url();
      return a.parse(t, e, s), a;
    }
    function isIpv6Hostname(t) {
      return c(t, 0) === V && c(t, t.length - 1) === Q;
    }
    const it = /[\0\t\n\r #%/:<>?@[\\\]^|]/,
      ct = /[\0\t\n\r #%/<>?@\\^|]/;
    Url.prototype.parse = function parse(t, e, s) {
      _(t, "url");
      let h = !1,
        a = !1,
        o = -1,
        n = -1,
        r = "",
        i = 0;
      for (let e = 0, s = !1, l = !1; e < t.length; ++e) {
        const c = t.charCodeAt(e),
          u = c < 33 || c === G || c === k;
        if (-1 === o) {
          if (u) continue;
          i = o = e;
        } else s ? u || ((n = -1), (s = !1)) : u && ((n = e), (s = !0));
        if (l) h || c !== x || (h = !0);
        else
          switch (c) {
            case nt:
              a = !0;
              break;
            case x:
              h = !0;
            case X:
              l = !0;
              break;
            case st:
              e - i > 0 && (r += t.slice(i, e)), (r += "/"), (i = e + 1);
          }
      }
      if (
        (-1 !== o &&
          (i === o
            ? (r = -1 === n ? (0 === o ? t : t.slice(o)) : t.slice(o, n))
            : -1 === n && i < t.length
            ? (r += t.slice(i))
            : -1 !== n && i < n && (r += t.slice(i, n))),
        !s && !h && !a)
      ) {
        const t = w.exec(r);
        if (t)
          return (
            (this.path = r),
            (this.href = r),
            (this.pathname = t[1]),
            t[2]
              ? ((this.search = t[2]),
                (this.query = e
                  ? A.parse(this.search.slice(1))
                  : this.search.slice(1)))
              : e && ((this.search = null), (this.query = l(null))),
            this
          );
      }
      let c,
        f,
        m = P.exec(r);
      if (
        (m &&
          ((m = m[0]),
          (c = m.toLowerCase()),
          (this.protocol = c),
          (r = r.slice(m.length))),
        (s || m || j.test(r)) &&
          ((f = r.charCodeAt(0) === W && r.charCodeAt(1) === W),
          !f || (m && b.has(c)) || ((r = r.slice(2)), (this.slashes = !0))),
        !b.has(c) && (f || (m && !S.has(m))))
      ) {
        let e = -1,
          s = -1,
          h = -1;
        for (let t = 0; t < r.length; ++t) {
          switch (r.charCodeAt(t)) {
            case D:
            case K:
            case F:
              (r = r.slice(0, t) + r.slice(t + 1)), (t -= 1);
              break;
            case B:
            case Z:
            case tt:
            case J:
            case et:
            case $:
            case M:
            case st:
            case ht:
            case at:
            case Y:
            case ot:
            case z:
              -1 === h && (h = t);
              break;
            case x:
            case W:
            case X:
              -1 === h && (h = t), (e = t);
              break;
            case nt:
              (s = t), (h = -1);
          }
          if (-1 !== e) break;
        }
        (o = 0),
          -1 !== s && ((this.auth = u(r.slice(0, s))), (o = s + 1)),
          -1 === h
            ? ((this.host = r.slice(o)), (r = ""))
            : ((this.host = r.slice(o, h)), (r = r.slice(h))),
          this.parseHost(),
          "string" != typeof this.hostname && (this.hostname = "");
        const a = this.hostname,
          n = isIpv6Hostname(a);
        if (
          (n ||
            (r = (function getHostname(t, e, s) {
              for (let h = 0; h < s.length; ++h) {
                const a = s.charCodeAt(h);
                if (!(a !== W && a !== st && a !== x && a !== X && a !== rt))
                  return (t.hostname = s.slice(0, h)), `/${s.slice(h)}${e}`;
              }
              return e;
            })(this, r, a)),
          this.hostname.length > 255
            ? (this.hostname = "")
            : (this.hostname = this.hostname.toLowerCase()),
          "" !== this.hostname)
        )
          if (n) {
            if (ct.test(this.hostname)) throw new R(t);
          } else if (
            ((this.hostname = p(this.hostname)),
            "" === this.hostname || it.test(this.hostname))
          )
            throw new R(t);
        const l = this.port ? ":" + this.port : "",
          i = this.hostname || "";
        (this.host = i + l),
          n &&
            ((this.hostname = this.hostname.slice(1, -1)),
            "/" !== r[0] && (r = "/" + r));
      }
      O.has(c) ||
        (r = (function autoEscapeStr(t) {
          let e = "",
            s = 0;
          for (let h = 0; h < t.length; ++h) {
            const a = ut[t.charCodeAt(h)];
            a && (h > s && (e += t.slice(s, h)), (e += a), (s = h + 1));
          }
          if (0 === s) return t;
          s < t.length && (e += t.slice(s));
          return e;
        })(r));
      let C = -1,
        d = -1;
      for (let t = 0; t < r.length; ++t) {
        const e = r.charCodeAt(t);
        if (e === x) {
          (this.hash = r.slice(t)), (d = t);
          break;
        }
        e === X && -1 === C && (C = t);
      }
      -1 !== C
        ? (-1 === d
            ? ((this.search = r.slice(C)), (this.query = r.slice(C + 1)))
            : ((this.search = r.slice(C, d)), (this.query = r.slice(C + 1, d))),
          e && (this.query = A.parse(this.query)))
        : e && ((this.search = null), (this.query = l(null)));
      const g = -1 !== C && (-1 === d || C < d) ? C : d;
      if (
        (-1 === g
          ? r.length > 0 && (this.pathname = r)
          : g > 0 && (this.pathname = r.slice(0, g)),
        S.has(c) && this.hostname && !this.pathname && (this.pathname = "/"),
        this.pathname || this.search)
      ) {
        const t = this.pathname || "",
          e = this.search || "";
        this.path = t + e;
      }
      return (this.href = this.format()), this;
    };
    const ut = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%09",
      "%0A",
      "",
      "",
      "%0D",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%20",
      "",
      "%22",
      "",
      "",
      "",
      "",
      "%27",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%3C",
      "",
      "%3E",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%5C",
      "",
      "%5E",
      "",
      "%60",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "%7B",
      "%7C",
      "%7D",
    ];
    const pt = new r([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
      0, 1, 0,
    ]);
    (Url.prototype.format = function format() {
      let t = this.auth || "";
      t && ((t = f(t, pt, m)), (t += "@"));
      let e = this.protocol || "",
        s = this.pathname || "",
        h = this.hash || "",
        a = "",
        o = "";
      this.host
        ? (a = t + this.host)
        : this.hostname &&
          ((a =
            t +
            (this.hostname.includes(":") && !isIpv6Hostname(this.hostname)
              ? "[" + this.hostname + "]"
              : this.hostname)),
          this.port && (a += ":" + this.port)),
        null !== this.query &&
          "object" == typeof this.query &&
          (o = A.stringify(this.query));
      let n = this.search || (o && "?" + o) || "";
      e && 58 !== e.charCodeAt(e.length - 1) && (e += ":");
      let r = "",
        l = 0;
      for (let t = 0; t < s.length; ++t)
        switch (s.charCodeAt(t)) {
          case x:
            t - l > 0 && (r += s.slice(l, t)), (r += "%23"), (l = t + 1);
            break;
          case X:
            t - l > 0 && (r += s.slice(l, t)), (r += "%3F"), (l = t + 1);
        }
      return (
        l > 0 && (s = l !== s.length ? r + s.slice(l) : r),
        (this.slashes || S.has(e)) &&
          (this.slashes || a
            ? (s && s.charCodeAt(0) !== W && (s = "/" + s), (a = "//" + a))
            : e.length >= 4 &&
              102 === e.charCodeAt(0) &&
              105 === e.charCodeAt(1) &&
              108 === e.charCodeAt(2) &&
              101 === e.charCodeAt(3) &&
              (a = "//")),
        (n = n.replace(/#/g, "%23")),
        h && h.charCodeAt(0) !== x && (h = "#" + h),
        n && n.charCodeAt(0) !== X && (n = "?" + n),
        e + a + s + n + h
      );
    }),
      (Url.prototype.resolve = function resolve(t) {
        return this.resolveObject(urlParse(t, !1, !0)).format();
      }),
      (Url.prototype.resolveObject = function resolveObject(t) {
        if ("string" == typeof t) {
          const e = new Url();
          e.parse(t, !1, !0), (t = e);
        }
        const e = new Url(),
          s = i(this);
        for (let t = 0; t < s.length; t++) {
          const h = s[t];
          e[h] = this[h];
        }
        if (((e.hash = t.hash), "" === t.href)) return (e.href = e.format()), e;
        if (t.slashes && !t.protocol) {
          const s = i(t);
          for (let h = 0; h < s.length; h++) {
            const a = s[h];
            "protocol" !== a && (e[a] = t[a]);
          }
          return (
            S.has(e.protocol) &&
              e.hostname &&
              !e.pathname &&
              (e.path = e.pathname = "/"),
            (e.href = e.format()),
            e
          );
        }
        if (t.protocol && t.protocol !== e.protocol) {
          if (!S.has(t.protocol)) {
            const s = i(t);
            for (let h = 0; h < s.length; h++) {
              const a = s[h];
              e[a] = t[a];
            }
            return (e.href = e.format()), e;
          }
          if (
            ((e.protocol = t.protocol),
            t.host || /^file:?$/.test(t.protocol) || b.has(t.protocol))
          )
            e.pathname = t.pathname;
          else {
            const s = (t.pathname || "").split("/");
            for (; s.length && !(t.host = s.shift()); );
            t.host || (t.host = ""),
              t.hostname || (t.hostname = ""),
              "" !== s[0] && s.unshift(""),
              s.length < 2 && s.unshift(""),
              (e.pathname = s.join("/"));
          }
          if (
            ((e.search = t.search),
            (e.query = t.query),
            (e.host = t.host || ""),
            (e.auth = t.auth),
            (e.hostname = t.hostname || t.host),
            (e.port = t.port),
            e.pathname || e.search)
          ) {
            const t = e.pathname || "",
              s = e.search || "";
            e.path = t + s;
          }
          return (e.slashes = e.slashes || t.slashes), (e.href = e.format()), e;
        }
        const h = e.pathname && "/" === e.pathname.charAt(0),
          a = t.host || (t.pathname && "/" === t.pathname.charAt(0));
        let o = a || h || (e.host && t.pathname);
        const n = o;
        let r = (e.pathname && e.pathname.split("/")) || [];
        const l = (t.pathname && t.pathname.split("/")) || [],
          c = e.protocol && !S.has(e.protocol);
        if (
          (c &&
            ((e.hostname = ""),
            (e.port = null),
            e.host && ("" === r[0] ? (r[0] = e.host) : r.unshift(e.host)),
            (e.host = ""),
            t.protocol &&
              ((t.hostname = null),
              (t.port = null),
              (e.auth = null),
              t.host && ("" === l[0] ? (l[0] = t.host) : l.unshift(t.host)),
              (t.host = null)),
            (o = o && ("" === l[0] || "" === r[0]))),
          a)
        )
          (t.host || "" === t.host) &&
            (e.host !== t.host && (e.auth = null),
            (e.host = t.host),
            (e.port = t.port)),
            (t.hostname || "" === t.hostname) &&
              (e.hostname !== t.hostname && (e.auth = null),
              (e.hostname = t.hostname)),
            (e.search = t.search),
            (e.query = t.query),
            (r = l);
        else if (l.length)
          r || (r = []),
            r.pop(),
            (r = r.concat(l)),
            (e.search = t.search),
            (e.query = t.query);
        else if (null !== t.search && void 0 !== t.search) {
          if (c) {
            e.hostname = e.host = r.shift();
            const t = e.host && e.host.indexOf("@") > 0 && e.host.split("@");
            t && ((e.auth = t.shift()), (e.host = e.hostname = t.shift()));
          }
          return (
            (e.search = t.search),
            (e.query = t.query),
            (null === e.pathname && null === e.search) ||
              (e.path =
                (e.pathname ? e.pathname : "") + (e.search ? e.search : "")),
            (e.href = e.format()),
            e
          );
        }
        if (!r.length)
          return (
            (e.pathname = null),
            e.search ? (e.path = "/" + e.search) : (e.path = null),
            (e.href = e.format()),
            e
          );
        let u = r.slice(-1)[0];
        const p =
          ((e.host || t.host || r.length > 1) && ("." === u || ".." === u)) ||
          "" === u;
        let f = 0;
        for (let t = r.length - 1; t >= 0; t--)
          (u = r[t]),
            "." === u
              ? g(r, t)
              : ".." === u
              ? (g(r, t), f++)
              : f && (g(r, t), f--);
        if (!o && !n) for (; f--; ) r.unshift("..");
        !o || "" === r[0] || (r[0] && "/" === r[0].charAt(0)) || r.unshift(""),
          p && "/" !== r.join("/").substr(-1) && r.push("");
        const m = "" === r[0] || (r[0] && "/" === r[0].charAt(0));
        if (c) {
          e.hostname = e.host = m ? "" : r.length ? r.shift() : "";
          const t = !!(e.host && e.host.indexOf("@") > 0) && e.host.split("@");
          t && ((e.auth = t.shift()), (e.host = e.hostname = t.shift()));
        }
        return (
          (o = o || (e.host && r.length)),
          o && !m && r.unshift(""),
          r.length
            ? (e.pathname = r.join("/"))
            : ((e.pathname = null), (e.path = null)),
          (null === e.pathname && null === e.search) ||
            (e.path =
              (e.pathname ? e.pathname : "") + (e.search ? e.search : "")),
          (e.auth = t.auth || e.auth),
          (e.slashes = e.slashes || t.slashes),
          (e.href = e.format()),
          e
        );
      }),
      (Url.prototype.parseHost = function parseHost() {
        let t = this.host,
          e = N.exec(t);
        e &&
          ((e = e[0]),
          ":" !== e && (this.port = e.slice(1)),
          (t = t.slice(0, t.length - e.length))),
          t && (this.hostname = t);
      }),
      (s.exports = {
        Url: Url,
        parse: urlParse,
        resolve: function urlResolve(t, e) {
          return urlParse(t, !1, !0).resolve(e);
        },
        resolveObject: function urlResolveObject(t, e) {
          return t ? urlParse(t, !1, !0).resolveObject(e) : e;
        },
        format: function urlFormat(t, e) {
          if ("string" == typeof t) t = urlParse(t);
          else {
            if ("object" != typeof t || null === t)
              throw new C("urlObject", ["Object", "string"], t);
            if (t instanceof E) {
              let s = !0,
                h = !1,
                a = !0,
                o = !0;
              return (
                e &&
                  (d(e, "options"),
                  null != e.fragment && (s = n(e.fragment)),
                  null != e.unicode && (h = n(e.unicode)),
                  null != e.search && (a = n(e.search)),
                  null != e.auth && (o = n(e.auth))),
                q.format(t.href, s, h, a, o)
              );
            }
          }
          return Url.prototype.format.call(t);
        },
        URL: E,
        URLSearchParams: H,
        domainToASCII: U,
        domainToUnicode: y,
        pathToFileURL: function pathToFileURL(t) {
          return _(t, "path"), L(t);
        },
        fileURLToPath: T,
        urlToHttpOptions: I,
      });
  },
  util: function (t, e, r, n, o, i) {
    "use strict";
    const {
        ArrayIsArray: l,
        ArrayPrototypeJoin: a,
        ArrayPrototypePop: s,
        Date: u,
        DatePrototypeGetDate: c,
        DatePrototypeGetHours: p,
        DatePrototypeGetMinutes: f,
        DatePrototypeGetMonth: y,
        DatePrototypeGetSeconds: b,
        Error: g,
        FunctionPrototypeBind: d,
        NumberIsSafeInteger: m,
        ObjectDefineProperties: S,
        ObjectDefineProperty: E,
        ObjectGetOwnPropertyDescriptors: _,
        ObjectKeys: P,
        ObjectPrototypeToString: A,
        ObjectSetPrototypeOf: h,
        ObjectValues: O,
        ReflectApply: D,
        StringPrototypePadStart: x,
      } = i,
      {
        codes: {
          ERR_FALSY_VALUE_REJECTION: N,
          ERR_INVALID_ARG_TYPE: v,
          ERR_OUT_OF_RANGE: j,
        },
        errnoException: C,
        exceptionWithHostPort: w,
        hideStackFrames: R,
      } = e("internal/errors"),
      {
        format: F,
        formatWithOptions: T,
        inspect: M,
        stripVTControlCharacters: k,
      } = e("internal/util/inspect"),
      { debuglog: I } = e("internal/util/debuglog"),
      { validateFunction: G, validateNumber: U } = e("internal/validators"),
      { isBuffer: V } = e("buffer").Buffer,
      B = e("internal/util/types"),
      {
        deprecate: z,
        getSystemErrorMap: J,
        getSystemErrorName: L,
        promisify: W,
        toUSVString: H,
        defineLazyProperties: $,
      } = e("internal/util");
    let q, Y;
    function lazyAbortController() {
      return (q ??= e("internal/abort_controller")), q;
    }
    function pad(t) {
      return x(t.toString(), 2, "0");
    }
    const K = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    let Q;
    const X = R((t, e) => (t || (t = new N(t)), e(t)));
    (r.exports = {
      _errnoException: C,
      _exceptionWithHostPort: w,
      _extend: function _extend(t, e) {
        if (null === e || "object" != typeof e) return t;
        const r = P(e);
        let n = r.length;
        for (; n--; ) t[r[n]] = e[r[n]];
        return t;
      },
      callbackify: function callbackify(t) {
        function callbackified(...e) {
          const r = s(e);
          G(r, "last argument");
          const o = d(r, this);
          D(t, this, e).then(
            (t) => n.nextTick(o, null, t),
            (t) => n.nextTick(X, t, o)
          );
        }
        G(t, "original");
        const e = _(t);
        "number" == typeof e.length.value && e.length.value++,
          "string" == typeof e.name.value && (e.name.value += "Callbackified");
        const r = O(e);
        for (let t = 0; t < r.length; t++) h(r[t], null);
        return S(callbackified, e), callbackified;
      },
      debug: I,
      debuglog: I,
      deprecate: z,
      format: F,
      formatWithOptions: T,
      getSystemErrorMap: J,
      getSystemErrorName: function getSystemErrorName(t) {
        if ((U(t, "err"), t >= 0 || !m(t)))
          throw new j("err", "a negative integer", t);
        return L(t);
      },
      inherits: function inherits(t, e) {
        if (null == t) throw new v("ctor", "Function", t);
        if (null == e) throw new v("superCtor", "Function", e);
        if (void 0 === e.prototype)
          throw new v("superCtor.prototype", "Object", e.prototype);
        E(t, "super_", {
          __proto__: null,
          value: e,
          writable: !0,
          configurable: !0,
        }),
          h(t.prototype, e.prototype);
      },
      inspect: M,
      isArray: l,
      isBoolean: function isBoolean(t) {
        return "boolean" == typeof t;
      },
      isBuffer: V,
      isDeepStrictEqual: (t, r) => (
        void 0 === Y && (Y = e("internal/util/comparisons").isDeepStrictEqual),
        Y(t, r)
      ),
      isNull: function isNull(t) {
        return null === t;
      },
      isNullOrUndefined: function isNullOrUndefined(t) {
        return null == t;
      },
      isNumber: function isNumber(t) {
        return "number" == typeof t;
      },
      isString: function isString(t) {
        return "string" == typeof t;
      },
      isSymbol: function isSymbol(t) {
        return "symbol" == typeof t;
      },
      isUndefined: function isUndefined(t) {
        return void 0 === t;
      },
      isRegExp: B.isRegExp,
      isObject: function isObject(t) {
        return null !== t && "object" == typeof t;
      },
      isDate: B.isDate,
      isError: function isError(t) {
        return "[object Error]" === A(t) || t instanceof g;
      },
      isFunction: function isFunction(t) {
        return "function" == typeof t;
      },
      isPrimitive: function isPrimitive(t) {
        return null === t || ("object" != typeof t && "function" != typeof t);
      },
      log: function log(...t) {
        Q || (Q = e("internal/console/global")),
          Q.log(
            "%s - %s",
            (function timestamp() {
              const t = new u(),
                e = a([pad(p(t)), pad(f(t)), pad(b(t))], ":");
              return `${c(t)} ${K[y(t)]} ${e}`;
            })(),
            F(...t)
          );
      },
      promisify: W,
      stripVTControlCharacters: k,
      toUSVString: H,
      get transferableAbortSignal() {
        return lazyAbortController().transferableAbortSignal;
      },
      get transferableAbortController() {
        return lazyAbortController().transferableAbortController;
      },
      get aborted() {
        return lazyAbortController().aborted;
      },
      types: B,
    }),
      $(r.exports, "internal/util/parse_args/parse_args", ["parseArgs"]),
      $(r.exports, "internal/encoding", ["TextDecoder", "TextEncoder"]),
      $(r.exports, "internal/mime", ["MIMEType", "MIMEParams"]);
  },
  "util/types": function (t, e, i, n, s, r) {
    "use strict";
    i.exports = e("internal/util/types");
  },
  v8: function (e, t, a, r, i, s) {
    "use strict";
    const {
        Array: n,
        BigInt64Array: o,
        BigUint64Array: l,
        DataView: c,
        Error: p,
        Float32Array: f,
        Float64Array: d,
        Int16Array: u,
        Int32Array: _,
        Int8Array: S,
        ObjectPrototypeToString: h,
        Uint16Array: y,
        Uint32Array: b,
        Uint8Array: z,
        Uint8ClampedArray: g,
      } = s,
      { Buffer: m } = t("buffer"),
      { validateString: x, validateUint32: H } = t("internal/validators"),
      { Serializer: I, Deserializer: k } = i("serdes"),
      { namespace: w } = t("internal/v8/startup_snapshot");
    let A = {};
    i("config").hasInspector && (A = i("profiler"));
    const D = t("internal/assert"),
      { copy: B } = i("buffer"),
      { inspect: U } = t("internal/util/inspect"),
      { FastBuffer: C } = t("internal/buffer"),
      { getValidatedPath: j } = t("internal/fs/utils"),
      { toNamespacedPath: v } = t("path"),
      { createHeapSnapshotStream: T, triggerHeapSnapshot: P } = i("heap_utils"),
      { HeapSnapshotStream: F } = t("internal/heap_utils"),
      O = t("internal/promise_hooks"),
      { getOptionValue: E } = t("internal/options"),
      { JSONParse: V } = s;
    const N = i("v8"),
      {
        cachedDataVersionTag: M,
        setFlagsFromString: L,
        updateHeapStatisticsBuffer: G,
        updateHeapSpaceStatisticsBuffer: R,
        updateHeapCodeStatisticsBuffer: J,
        setHeapSnapshotNearHeapLimit: Y,
        kTotalHeapSizeIndex: Z,
        kTotalHeapSizeExecutableIndex: $,
        kTotalPhysicalSizeIndex: q,
        kTotalAvailableSize: K,
        kUsedHeapSizeIndex: Q,
        kHeapSizeLimitIndex: W,
        kDoesZapGarbageIndex: X,
        kMallocedMemoryIndex: ee,
        kPeakMallocedMemoryIndex: te,
        kNumberOfNativeContextsIndex: ae,
        kNumberOfDetachedContextsIndex: re,
        kTotalGlobalHandlesSizeIndex: ie,
        kUsedGlobalHandlesSizeIndex: se,
        kExternalMemoryIndex: ne,
        kHeapSpaces: oe,
        kSpaceSizeIndex: le,
        kSpaceUsedSizeIndex: ce,
        kSpaceAvailableSizeIndex: pe,
        kPhysicalSpaceSizeIndex: fe,
        kCodeAndMetadataSizeIndex: de,
        kBytecodeAndMetadataSizeIndex: ue,
        kExternalScriptSourceSizeIndex: _e,
        kCPUProfilerMetaDataSizeIndex: Se,
      } = N,
      he = oe.length;
    let ye = !1;
    (I.prototype._getDataCloneError = p),
      (k.prototype.readRawBytes = function readRawBytes(e) {
        const t = this._readRawBytes(e);
        return new C(this.buffer.buffer, this.buffer.byteOffset + t, e);
      });
    class DefaultSerializer extends I {
      constructor() {
        super(), this._setTreatArrayBufferViewsAsHostObjects(!0);
      }
      _writeHostObject(e) {
        let t = 10;
        if (
          e.constructor !== m &&
          ((t = (function arrayBufferViewTypeToIndex(e) {
            const t = h(e);
            return "[object Int8Array]" === t
              ? 0
              : "[object Uint8Array]" === t
              ? 1
              : "[object Uint8ClampedArray]" === t
              ? 2
              : "[object Int16Array]" === t
              ? 3
              : "[object Uint16Array]" === t
              ? 4
              : "[object Int32Array]" === t
              ? 5
              : "[object Uint32Array]" === t
              ? 6
              : "[object Float32Array]" === t
              ? 7
              : "[object Float64Array]" === t
              ? 8
              : "[object DataView]" === t
              ? 9
              : "[object BigInt64Array]" === t
              ? 11
              : "[object BigUint64Array]" === t
              ? 12
              : -1;
          })(e)),
          -1 === t)
        )
          throw new this._getDataCloneError(
            `Unserializable host object: ${U(e)}`
          );
        this.writeUint32(t),
          this.writeUint32(e.byteLength),
          this.writeRawBytes(new z(e.buffer, e.byteOffset, e.byteLength));
      }
    }
    class DefaultDeserializer extends k {
      _readHostObject() {
        const e = (function arrayBufferViewIndexToType(e) {
            return 0 === e
              ? S
              : 1 === e
              ? z
              : 2 === e
              ? g
              : 3 === e
              ? u
              : 4 === e
              ? y
              : 5 === e
              ? _
              : 6 === e
              ? b
              : 7 === e
              ? f
              : 8 === e
              ? d
              : 9 === e
              ? c
              : 10 === e
              ? C
              : 11 === e
              ? o
              : 12 === e
              ? l
              : void 0;
          })(this.readUint32()),
          t = this.readUint32(),
          a = this._readRawBytes(t),
          r = e.BYTES_PER_ELEMENT || 1,
          i = this.buffer.byteOffset + a;
        if (i % r == 0) return new e(this.buffer.buffer, i, t / r);
        const s = m.allocUnsafe(t);
        return (
          B(this.buffer, s, 0, a, a + t), new e(s.buffer, s.byteOffset, t / r)
        );
      }
    }
    a.exports = {
      cachedDataVersionTag: M,
      getHeapSnapshot: function getHeapSnapshot() {
        const e = T();
        return D(e), new F(e);
      },
      getHeapStatistics: function getHeapStatistics() {
        const e = N.heapStatisticsBuffer;
        return (
          G(),
          {
            total_heap_size: e[Z],
            total_heap_size_executable: e[$],
            total_physical_size: e[q],
            total_available_size: e[K],
            used_heap_size: e[Q],
            heap_size_limit: e[W],
            malloced_memory: e[ee],
            peak_malloced_memory: e[te],
            does_zap_garbage: e[X],
            number_of_native_contexts: e[ae],
            number_of_detached_contexts: e[re],
            total_global_handles_size: e[ie],
            used_global_handles_size: e[se],
            external_memory: e[ne],
          }
        );
      },
      getHeapSpaceStatistics: function getHeapSpaceStatistics() {
        const e = new n(he),
          t = N.heapSpaceStatisticsBuffer;
        for (let a = 0; a < he; a++)
          R(a),
            (e[a] = {
              space_name: oe[a],
              space_size: t[le],
              space_used_size: t[ce],
              space_available_size: t[pe],
              physical_space_size: t[fe],
            });
        return e;
      },
      getHeapCodeStatistics: function getHeapCodeStatistics() {
        const e = N.heapCodeStatisticsBuffer;
        return (
          J(),
          {
            code_and_metadata_size: e[de],
            bytecode_and_metadata_size: e[ue],
            external_script_source_size: e[_e],
            cpu_profiler_metadata_size: e[Se],
          }
        );
      },
      setFlagsFromString: function setFlagsFromString(e) {
        x(e, "flags"), L(e);
      },
      Serializer: I,
      Deserializer: k,
      DefaultSerializer: DefaultSerializer,
      DefaultDeserializer: DefaultDeserializer,
      deserialize: function deserialize(e) {
        const t = new DefaultDeserializer(e);
        return t.readHeader(), t.readValue();
      },
      takeCoverage: A.takeCoverage,
      stopCoverage: A.stopCoverage,
      serialize: function serialize(e) {
        const t = new DefaultSerializer();
        return t.writeHeader(), t.writeValue(e), t.releaseBuffer();
      },
      writeHeapSnapshot: function writeHeapSnapshot(e) {
        return void 0 !== e && ((e = j(e)), (e = v(e))), P(e);
      },
      promiseHooks: O,
      startupSnapshot: w,
      setHeapSnapshotNearHeapLimit: function setHeapSnapshotNearHeapLimit(e) {
        H(e, "limit", 1),
          ye || E("--heapsnapshot-near-heap-limit") > 0 || ((ye = !0), Y(e));
      },
      GCProfiler: class GCProfiler {
        #e = null;
        start() {
          this.#e || ((this.#e = new N.GCProfiler()), this.#e.start());
        }
        stop() {
          if (this.#e) {
            const e = this.#e.stop();
            return (this.#e = null), V(e);
          }
        }
      },
    };
  },
  vm: function (t, e, n, o, i, r) {
    "use strict";
    const {
        ArrayPrototypeForEach: a,
        Symbol: s,
        PromiseReject: c,
        ReflectApply: u,
      } = r,
      {
        ContextifyScript: d,
        MicrotaskQueue: l,
        makeContext: p,
        constants: m,
        measureMemory: x,
      } = i("contextify"),
      { ERR_CONTEXT_NOT_INITIALIZED: f, ERR_INVALID_ARG_TYPE: C } =
        e("internal/errors").codes,
      {
        validateArray: g,
        validateBoolean: I,
        validateBuffer: v,
        validateInt32: y,
        validateOneOf: O,
        validateObject: S,
        validateString: h,
        validateStringArray: M,
        validateUint32: E,
      } = e("internal/validators"),
      {
        emitExperimentalWarning: G,
        kEmptyObject: w,
        kVmBreakFirstLineSymbol: D,
      } = e("internal/util"),
      {
        getHostDefinedOptionId: k,
        internalCompileFunction: N,
        isContext: T,
        registerImportModuleDynamically: A,
      } = e("internal/vm"),
      _ = s("script parsing context");
    class Script extends d {
      constructor(t, e = w) {
        (t = `${t}`),
          "string" == typeof e ? (e = { filename: e }) : S(e, "options");
        const {
          filename: n = "evalmachine.<anonymous>",
          lineOffset: o = 0,
          columnOffset: i = 0,
          cachedData: r,
          produceCachedData: a = !1,
          importModuleDynamically: s,
          [_]: c,
        } = e;
        h(n, "options.filename"),
          y(o, "options.lineOffset"),
          y(i, "options.columnOffset"),
          void 0 !== r && v(r, "options.cachedData"),
          I(a, "options.produceCachedData");
        const u = k(s, n);
        try {
          super(t, n, o, i, r, a, c, u);
        } catch (t) {
          throw t;
        }
        void 0 !== s && A(this, s);
      }
      runInThisContext(t) {
        const { breakOnSigint: e, args: n } = getRunInContextArgs(null, t);
        return e && o.listenerCount("SIGINT") > 0
          ? sigintHandlersWrap(super.runInContext, this, n)
          : u(super.runInContext, this, n);
      }
      runInContext(t, e) {
        validateContext(t);
        const { breakOnSigint: n, args: i } = getRunInContextArgs(t, e);
        return n && o.listenerCount("SIGINT") > 0
          ? sigintHandlersWrap(super.runInContext, this, i)
          : u(super.runInContext, this, i);
      }
      runInNewContext(t, e) {
        const n = createContext(t, getContextOptions(e));
        return this.runInContext(n, e);
      }
    }
    function validateContext(t) {
      if (!T(t)) throw new C("contextifiedObject", "vm.Context", t);
    }
    function getRunInContextArgs(t, e = w) {
      S(e, "options");
      let n = e.timeout;
      void 0 === n ? (n = -1) : E(n, "options.timeout", !0);
      const { displayErrors: o = !0, breakOnSigint: i = !1, [D]: r = !1 } = e;
      return (
        I(o, "options.displayErrors"),
        I(i, "options.breakOnSigint"),
        { breakOnSigint: i, args: [t, n, o, i, r] }
      );
    }
    function getContextOptions(t) {
      if (!t) return {};
      const e = {
        name: t.contextName,
        origin: t.contextOrigin,
        codeGeneration: void 0,
        microtaskMode: t.microtaskMode,
      };
      if (
        (void 0 !== e.name && h(e.name, "options.contextName"),
        void 0 !== e.origin && h(e.origin, "options.contextOrigin"),
        void 0 !== t.contextCodeGeneration)
      ) {
        S(t.contextCodeGeneration, "options.contextCodeGeneration");
        const { strings: n, wasm: o } = t.contextCodeGeneration;
        void 0 !== n && I(n, "options.contextCodeGeneration.strings"),
          void 0 !== o && I(o, "options.contextCodeGeneration.wasm"),
          (e.codeGeneration = { strings: n, wasm: o });
      }
      return (
        void 0 !== t.microtaskMode &&
          h(t.microtaskMode, "options.microtaskMode"),
        e
      );
    }
    let b = 1;
    function createContext(t = {}, e = w) {
      if (T(t)) return t;
      S(e, "options");
      const {
        name: n = "VM Context " + b++,
        origin: o,
        codeGeneration: i,
        microtaskMode: r,
      } = e;
      h(n, "options.name"),
        void 0 !== o && h(o, "options.origin"),
        void 0 !== i && S(i, "options.codeGeneration");
      let a = !0,
        s = !0;
      void 0 !== i &&
        (({ strings: a = !0, wasm: s = !0 } = i),
        I(a, "options.codeGeneration.strings"),
        I(s, "options.codeGeneration.wasm")),
        O(r, "options.microtaskMode", ["afterEvaluate", void 0]);
      const c = "afterEvaluate" === r ? new l() : null;
      return p(t, n, o, a, s, c), t;
    }
    function createScript(t, e) {
      return new Script(t, e);
    }
    function sigintHandlersWrap(t, e, n) {
      const i = o.rawListeners("SIGINT");
      o.removeAllListeners("SIGINT");
      try {
        return u(t, e, n);
      } finally {
        a(i, (t) => {
          o.addListener("SIGINT", t);
        });
      }
    }
    const R = {
        summary: m.measureMemory.mode.SUMMARY,
        detailed: m.measureMemory.mode.DETAILED,
      },
      L = {
        default: m.measureMemory.execution.DEFAULT,
        eager: m.measureMemory.execution.EAGER,
      };
    n.exports = {
      Script: Script,
      createContext: createContext,
      createScript: createScript,
      runInContext: function runInContext(t, e, n) {
        return (
          validateContext(e),
          createScript(
            t,
            (n =
              "string" == typeof n ? { filename: n, [_]: e } : { ...n, [_]: e })
          ).runInContext(e, n)
        );
      },
      runInNewContext: function runInNewContext(t, e, n) {
        return (
          "string" == typeof n && (n = { filename: n }),
          (e = createContext(e, getContextOptions(n))),
          createScript(t, (n = { ...n, [_]: e })).runInNewContext(e, n)
        );
      },
      runInThisContext: function runInThisContext(t, e) {
        return (
          "string" == typeof e && (e = { filename: e }),
          createScript(t, e).runInThisContext(e)
        );
      },
      isContext: T,
      compileFunction: function compileFunction(t, e, n = w) {
        h(t, "code"), void 0 !== e && M(e, "params");
        const {
          filename: o = "",
          columnOffset: i = 0,
          lineOffset: r = 0,
          cachedData: s,
          produceCachedData: c = !1,
          parsingContext: u,
          contextExtensions: d = [],
          importModuleDynamically: l,
        } = n;
        if (
          (h(o, "options.filename"),
          y(i, "options.columnOffset"),
          y(r, "options.lineOffset"),
          void 0 !== s && v(s, "options.cachedData"),
          I(c, "options.produceCachedData"),
          void 0 !== u && ("object" != typeof u || null === u || !T(u)))
        )
          throw new C("options.parsingContext", "Context", u);
        g(d, "options.contextExtensions"),
          a(d, (t, e) => {
            S(t, `options.contextExtensions[${e}]`, {
              __proto__: null,
              nullable: !0,
            });
          });
        const p = k(l, o);
        return N(t, o, r, i, s, c, u, d, e, p, l).function;
      },
      measureMemory: function measureMemory(t = w) {
        G("vm.measureMemory"), S(t, "options");
        const { mode: e = "summary", execution: n = "default" } = t;
        O(e, "options.mode", ["summary", "detailed"]),
          O(n, "options.execution", ["default", "eager"]);
        const o = x(R[e], L[n]);
        return void 0 === o ? c(new f()) : o;
      },
    };
  },
  wasi: function (t, i, n, e, s, o) {
    "use strict";
    const {
        ArrayPrototypeForEach: r,
        ArrayPrototypeMap: a,
        ArrayPrototypePush: p,
        FunctionPrototypeBind: c,
        ObjectEntries: d,
        String: h,
        Symbol: l,
      } = o,
      { ERR_WASI_ALREADY_STARTED: u } = i("internal/errors").codes,
      { emitExperimentalWarning: x, kEmptyObject: v } = i("internal/util"),
      {
        validateArray: _,
        validateBoolean: y,
        validateFunction: E,
        validateInt32: A,
        validateObject: I,
        validateUndefined: w,
      } = i("internal/validators"),
      { WASI: m } = s("wasi"),
      S = l("kExitCode"),
      O = l("kSetMemory"),
      f = l("kStarted"),
      P = l("kInstance");
    function setupInstance(t, i) {
      I(i, "instance"),
        I(i.exports, "instance.exports"),
        (t[P] = i),
        t[O](i.exports.memory);
    }
    x("WASI");
    function wasiReturnOnProcExit(t) {
      throw ((this[S] = t), S);
    }
    n.exports = {
      WASI: class WASI {
        constructor(t = v) {
          I(t, "options"), void 0 !== t.args && _(t.args, "options.args");
          const i = a(t.args || [], h),
            n = [];
          void 0 !== t.env &&
            (I(t.env, "options.env"),
            r(d(t.env), ({ 0: t, 1: i }) => {
              void 0 !== i && p(n, `${t}=${i}`);
            }));
          const e = [];
          void 0 !== t.preopens &&
            (I(t.preopens, "options.preopens"),
            r(d(t.preopens), ({ 0: t, 1: i }) => p(e, h(t), h(i))));
          const { stdin: s = 0, stdout: o = 1, stderr: l = 2 } = t;
          A(s, "options.stdin", 0),
            A(o, "options.stdout", 0),
            A(l, "options.stderr", 0);
          const u = new m(i, n, e, [s, o, l]);
          for (const t in u) u[t] = c(u[t], u);
          void 0 !== t.returnOnExit &&
            (y(t.returnOnExit, "options.returnOnExit"),
            t.returnOnExit && (u.proc_exit = c(wasiReturnOnProcExit, this))),
            (this[O] = u._setMemory),
            delete u._setMemory,
            (this.wasiImport = u),
            (this[f] = !1),
            (this[S] = 0),
            (this[P] = void 0);
        }
        start(t) {
          if (this[f]) throw new u();
          (this[f] = !0), setupInstance(this, t);
          const { _start: i, _initialize: n } = this[P].exports;
          E(i, "instance.exports._start"), w(n, "instance.exports._initialize");
          try {
            i();
          } catch (t) {
            if (t !== S) throw t;
          }
          return this[S];
        }
        initialize(t) {
          if (this[f]) throw new u();
          (this[f] = !0), setupInstance(this, t);
          const { _start: i, _initialize: n } = this[P].exports;
          w(i, "instance.exports._start"),
            void 0 !== n && (E(n, "instance.exports._initialize"), n());
        }
      },
    };
  },
  worker_threads: function (e, r, a, n, t, s) {
    "use strict";
    const {
        isMainThread: o,
        SHARE_ENV: i,
        resourceLimits: l,
        setEnvironmentData: g,
        getEnvironmentData: m,
        threadId: M,
        Worker: c,
      } = r("internal/worker"),
      {
        MessagePort: d,
        MessageChannel: h,
        moveMessagePortToContext: v,
        receiveMessageOnPort: E,
        BroadcastChannel: k,
      } = r("internal/worker/io"),
      { markAsUntransferable: u } = r("internal/buffer");
    a.exports = {
      isMainThread: o,
      MessagePort: d,
      MessageChannel: h,
      markAsUntransferable: u,
      moveMessagePortToContext: v,
      receiveMessageOnPort: E,
      resourceLimits: l,
      threadId: M,
      SHARE_ENV: i,
      Worker: c,
      parentPort: null,
      workerData: null,
      BroadcastChannel: k,
      setEnvironmentData: g,
      getEnvironmentData: m,
    };
  },
  zlib: function (e, t, n, i, r, o) {
    "use strict";
    const {
        ArrayBuffer: s,
        ArrayPrototypeForEach: l,
        ArrayPrototypeMap: a,
        ArrayPrototypePush: f,
        FunctionPrototypeBind: u,
        MathMaxApply: c,
        NumberIsFinite: h,
        NumberIsNaN: p,
        ObjectDefineProperties: _,
        ObjectDefineProperty: b,
        ObjectFreeze: y,
        ObjectKeys: d,
        ObjectSetPrototypeOf: B,
        ReflectApply: w,
        StringPrototypeStartsWith: R,
        Symbol: O,
        TypedArrayPrototypeFill: E,
        Uint32Array: Z,
      } = o,
      {
        codes: {
          ERR_BROTLI_INVALID_PARAM: I,
          ERR_BUFFER_TOO_LARGE: m,
          ERR_INVALID_ARG_TYPE: D,
          ERR_OUT_OF_RANGE: z,
          ERR_ZLIB_INITIALIZATION_FAILED: F,
        },
        genericNodeError: A,
        hideStackFrames: L,
      } = t("internal/errors"),
      { Transform: g, finished: S } = t("stream"),
      { deprecate: C } = t("internal/util"),
      {
        isArrayBufferView: v,
        isAnyArrayBuffer: M,
        isUint8Array: T,
      } = t("internal/util/types"),
      N = r("zlib"),
      U = t("internal/assert"),
      { Buffer: k, kMaxLength: P } = t("buffer"),
      { owner_symbol: G } = t("internal/async_hooks").symbols,
      { validateFunction: W, validateNumber: x } = t("internal/validators"),
      V = O("kFlushFlag"),
      j = O("kError"),
      H = r("constants").zlib,
      {
        Z_NO_FLUSH: K,
        Z_BLOCK: X,
        Z_PARTIAL_FLUSH: Y,
        Z_SYNC_FLUSH: $,
        Z_FULL_FLUSH: q,
        Z_FINISH: J,
        Z_MIN_CHUNK: Q,
        Z_MIN_WINDOWBITS: ee,
        Z_MAX_WINDOWBITS: te,
        Z_MIN_LEVEL: ne,
        Z_MAX_LEVEL: ie,
        Z_MIN_MEMLEVEL: re,
        Z_MAX_MEMLEVEL: oe,
        Z_DEFAULT_CHUNK: se,
        Z_DEFAULT_COMPRESSION: le,
        Z_DEFAULT_STRATEGY: ae,
        Z_DEFAULT_WINDOWBITS: fe,
        Z_DEFAULT_MEMLEVEL: ue,
        Z_FIXED: ce,
        DEFLATE: he,
        DEFLATERAW: pe,
        INFLATE: _e,
        INFLATERAW: be,
        GZIP: ye,
        GUNZIP: de,
        UNZIP: Be,
        BROTLI_DECODE: we,
        BROTLI_ENCODE: Re,
        BROTLI_OPERATION_PROCESS: Oe,
        BROTLI_OPERATION_FLUSH: Ee,
        BROTLI_OPERATION_FINISH: Ze,
        BROTLI_OPERATION_EMIT_METADATA: Ie,
      } = H,
      me = {
        Z_OK: H.Z_OK,
        Z_STREAM_END: H.Z_STREAM_END,
        Z_NEED_DICT: H.Z_NEED_DICT,
        Z_ERRNO: H.Z_ERRNO,
        Z_STREAM_ERROR: H.Z_STREAM_ERROR,
        Z_DATA_ERROR: H.Z_DATA_ERROR,
        Z_MEM_ERROR: H.Z_MEM_ERROR,
        Z_BUF_ERROR: H.Z_BUF_ERROR,
        Z_VERSION_ERROR: H.Z_VERSION_ERROR,
      };
    for (const e of d(me)) me[me[e]] = e;
    function zlibBufferOnData(e) {
      this.buffers ? f(this.buffers, e) : (this.buffers = [e]),
        (this.nread += e.length),
        this.nread > this._maxOutputLength &&
          (this.close(),
          this.removeAllListeners("end"),
          this.cb(new m(this._maxOutputLength)));
    }
    function zlibBufferOnError(e) {
      this.removeAllListeners("end"), this.cb(e);
    }
    function zlibBufferOnEnd() {
      let e;
      if (0 === this.nread) e = k.alloc(0);
      else {
        const t = this.buffers;
        e = 1 === t.length ? t[0] : k.concat(t, this.nread);
      }
      this.close(),
        this._info
          ? this.cb(null, { buffer: e, engine: this })
          : this.cb(null, e);
    }
    function zlibOnError(e, t, n) {
      const i = this[G],
        r = A(e, { errno: t, code: n });
      (r.errno = t), (r.code = n), i.destroy(r), (i[j] = r);
    }
    const De = L((e, t) => {
        if (void 0 === e) return !1;
        if (h(e)) return !0;
        if (p(e)) return !1;
        throw (x(e, t), new z(t, "a finite number", e));
      }),
      ze = L((e, t, n, i, r) => {
        if (!De(e, t)) return r;
        if (e < n || e > i) throw new z(t, `>= ${n} and <= ${i}`, e);
        return e;
      }),
      Fe = [
        [K, X],
        [Oe, Ie],
      ],
      Ae = 0,
      Le = 1;
    function ZlibBase(e, t, n, { flush: i, finishFlush: r, fullFlush: o }) {
      let s,
        l = se,
        a = P;
      if (
        (U("number" == typeof t),
        U(t >= he && t <= Re),
        (s = t !== Re && t !== we ? Ae : Le),
        e)
      ) {
        if (((l = e.chunkSize), De(l, "options.chunkSize"))) {
          if (l < Q) throw new z("options.chunkSize", `>= ${Q}`, l);
        } else l = se;
        (i = ze(e.flush, "options.flush", Fe[s][0], Fe[s][1], i)),
          (r = ze(e.finishFlush, "options.finishFlush", Fe[s][0], Fe[s][1], r)),
          (a = ze(e.maxOutputLength, "options.maxOutputLength", 1, P, P)),
          (e.encoding || e.objectMode || e.writableObjectMode) &&
            (((e = { ...e }).encoding = null),
            (e.objectMode = !1),
            (e.writableObjectMode = !1));
      }
      w(g, this, [{ autoDestroy: !0, ...e }]),
        (this[j] = null),
        (this.bytesWritten = 0),
        (this._handle = n),
        (n[G] = this),
        (n.onerror = zlibOnError),
        (this._outBuffer = k.allocUnsafe(l)),
        (this._outOffset = 0),
        (this._chunkSize = l),
        (this._defaultFlushFlag = i),
        (this._finishFlushFlag = r),
        (this._defaultFullFlushFlag = o),
        (this._info = e && e.info),
        (this._maxOutputLength = a);
    }
    B(ZlibBase.prototype, g.prototype),
      B(ZlibBase, g),
      b(ZlibBase.prototype, "_closed", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get() {
          return !this._handle;
        },
      }),
      b(ZlibBase.prototype, "bytesRead", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get: C(
          function () {
            return this.bytesWritten;
          },
          "zlib.bytesRead is deprecated and will change its meaning in the future. Use zlib.bytesWritten instead.",
          "DEP0108"
        ),
        set: C(
          function (e) {
            this.bytesWritten = e;
          },
          "Setting zlib.bytesRead is deprecated. This feature will be removed in the future.",
          "DEP0108"
        ),
      }),
      (ZlibBase.prototype.reset = function () {
        return (
          this._handle || U(!1, "zlib binding closed"), this._handle.reset()
        );
      }),
      (ZlibBase.prototype._flush = function (e) {
        this._transform(k.alloc(0), "", e);
      }),
      (ZlibBase.prototype._final = function (e) {
        e();
      });
    const ge = [];
    let Se = 0;
    const Ce = [K, X, Y, $, q, J];
    for (const e of Ce) ge[e] = Se++;
    const ve = [];
    {
      const e = new s();
      for (const t of Ce) (ve[t] = k.from(e)), (ve[t][V] = t);
    }
    function processChunkSync(e, t, n) {
      let i,
        r,
        o = t.byteLength,
        s = e._chunkSize - e._outOffset,
        l = 0,
        a = null,
        u = 0,
        c = 0;
      const h = e._writeState,
        p = e._handle;
      let _ = e._outBuffer,
        b = e._outOffset;
      const y = e._chunkSize;
      let d;
      for (
        e.on("error", function onError(e) {
          d = e;
        });
        ;

      ) {
        if ((p.writeSync(n, t, l, o, _, b, s), d)) throw d;
        if (e[j]) throw e[j];
        (i = h[0]), (r = h[1]);
        const B = o - r;
        c += B;
        const w = s - i;
        if (w > 0) {
          const t = _.slice(b, b + w);
          if (
            ((b += w),
            a ? f(a, t) : (a = [t]),
            (u += t.byteLength),
            u > e._maxOutputLength)
          )
            throw (_close(e), new m(e._maxOutputLength));
        } else U(0 === w, "have should not go down");
        if (
          ((0 === i || b >= y) && ((s = y), (b = 0), (_ = k.allocUnsafe(y))),
          0 !== i)
        )
          break;
        (l += B), (o = r);
      }
      return (
        (e.bytesWritten = c),
        _close(e),
        0 === u ? k.alloc(0) : 1 === a.length ? a[0] : k.concat(a, u)
      );
    }
    function processChunk(e, t, n, r) {
      const o = e._handle;
      if (!o) return i.nextTick(r);
      (o.buffer = t),
        (o.cb = r),
        (o.availOutBefore = e._chunkSize - e._outOffset),
        (o.availInBefore = t.byteLength),
        (o.inOff = 0),
        (o.flushFlag = n),
        o.write(
          n,
          t,
          0,
          o.availInBefore,
          e._outBuffer,
          e._outOffset,
          o.availOutBefore
        );
    }
    function processCallback() {
      const e = this,
        t = this[G],
        n = t._writeState;
      if (t.destroyed) return (this.buffer = null), void this.cb();
      const i = n[0],
        r = n[1],
        o = e.availInBefore - r;
      t.bytesWritten += o;
      const s = e.availOutBefore - i;
      let l = !1;
      if (s > 0) {
        const e = t._outBuffer.slice(t._outOffset, t._outOffset + s);
        (t._outOffset += s), (l = !t.push(e));
      } else U(0 === s, "have should not go down");
      if (t.destroyed) this.cb();
      else if (
        ((0 === i || t._outOffset >= t._chunkSize) &&
          ((e.availOutBefore = t._chunkSize),
          (t._outOffset = 0),
          (t._outBuffer = k.allocUnsafe(t._chunkSize))),
        0 !== i)
      )
        r > 0 && t.push(null), (this.buffer = null), this.cb();
      else if (((e.inOff += o), (e.availInBefore = r), l)) {
        const n = t._read;
        t._read = (i) => {
          (t._read = n),
            this.write(
              e.flushFlag,
              this.buffer,
              e.inOff,
              e.availInBefore,
              t._outBuffer,
              t._outOffset,
              t._chunkSize
            ),
            t._read(i);
        };
      } else
        this.write(
          e.flushFlag,
          this.buffer,
          e.inOff,
          e.availInBefore,
          t._outBuffer,
          t._outOffset,
          t._chunkSize
        );
    }
    function _close(e) {
      e._handle && (e._handle.close(), (e._handle = null));
    }
    (ZlibBase.prototype.flush = function (e, t) {
      ("function" == typeof e || (void 0 === e && !t)) &&
        ((t = e), (e = this._defaultFullFlushFlag)),
        this.writableFinished
          ? t && i.nextTick(t)
          : this.writableEnded
          ? t && this.once("end", t)
          : this.write(ve[e], "", t);
    }),
      (ZlibBase.prototype.close = function (e) {
        e && S(this, e), this.destroy();
      }),
      (ZlibBase.prototype._destroy = function (e, t) {
        _close(this), t(e);
      }),
      (ZlibBase.prototype._transform = function (e, t, n) {
        let i = this._defaultFlushFlag;
        "number" == typeof e[V] && (i = e[V]),
          this.writableEnded &&
            this.writableLength === e.byteLength &&
            (i = (function maxFlush(e, t) {
              return ge[e] > ge[t] ? e : t;
            })(i, this._finishFlushFlag)),
          processChunk(this, e, i, n);
      }),
      (ZlibBase.prototype._processChunk = function (e, t, n) {
        if ("function" != typeof n) return processChunkSync(this, e, t);
        processChunk(this, e, t, n);
      });
    const Me = { flush: K, finishFlush: J, fullFlush: q };
    function Zlib(e, t) {
      let n,
        i = fe,
        r = le,
        o = ue,
        s = ae;
      if (e) {
        if (
          (null != e.windowBits && 0 !== e.windowBits) ||
          (t !== _e && t !== de && t !== Be)
        ) {
          const n = ee + (t === ye ? 1 : 0);
          i = ze(e.windowBits, "options.windowBits", n, te, fe);
        } else i = 0;
        if (
          ((r = ze(e.level, "options.level", ne, ie, le)),
          (o = ze(e.memLevel, "options.memLevel", re, oe, ue)),
          (s = ze(e.strategy, "options.strategy", ae, ce, ae)),
          (n = e.dictionary),
          void 0 !== n && !v(n))
        ) {
          if (!M(n))
            throw new D(
              "options.dictionary",
              ["Buffer", "TypedArray", "DataView", "ArrayBuffer"],
              n
            );
          n = k.from(n);
        }
      }
      const l = new N.Zlib(t);
      (this._writeState = new Z(2)),
        l.init(i, r, o, s, this._writeState, processCallback, n),
        w(ZlibBase, this, [e, t, l, Me]),
        (this._level = r),
        (this._strategy = s);
    }
    function paramsAfterFlushCallback(e, t, n) {
      U(this._handle, "zlib binding closed"),
        this._handle.params(e, t),
        this.destroyed || ((this._level = e), (this._strategy = t), n && n());
    }
    function Deflate(e) {
      if (!(this instanceof Deflate)) return new Deflate(e);
      w(Zlib, this, [e, he]);
    }
    function Inflate(e) {
      if (!(this instanceof Inflate)) return new Inflate(e);
      w(Zlib, this, [e, _e]);
    }
    function Gzip(e) {
      if (!(this instanceof Gzip)) return new Gzip(e);
      w(Zlib, this, [e, ye]);
    }
    function Gunzip(e) {
      if (!(this instanceof Gunzip)) return new Gunzip(e);
      w(Zlib, this, [e, de]);
    }
    function DeflateRaw(e) {
      if (
        (e && 8 === e.windowBits && (e.windowBits = 9),
        !(this instanceof DeflateRaw))
      )
        return new DeflateRaw(e);
      w(Zlib, this, [e, pe]);
    }
    function InflateRaw(e) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(e);
      w(Zlib, this, [e, be]);
    }
    function Unzip(e) {
      if (!(this instanceof Unzip)) return new Unzip(e);
      w(Zlib, this, [e, Be]);
    }
    function createConvenienceMethod(e, t) {
      return t
        ? function syncBufferWrapper(t, n) {
            return (function zlibBufferSync(e, t) {
              if ("string" == typeof t) t = k.from(t);
              else if (!v(t)) {
                if (!M(t))
                  throw new D(
                    "buffer",
                    [
                      "string",
                      "Buffer",
                      "TypedArray",
                      "DataView",
                      "ArrayBuffer",
                    ],
                    t
                  );
                t = k.from(t);
              }
              return (
                (t = processChunkSync(e, t, e._finishFlushFlag)),
                e._info ? { buffer: t, engine: e } : t
              );
            })(new e(n), t);
          }
        : function asyncBufferWrapper(t, n, i) {
            return (
              "function" == typeof n && ((i = n), (n = {})),
              (function zlibBuffer(e, t, n) {
                W(n, "callback"),
                  v(t) && !T(t)
                    ? (t = k.from(t.buffer, t.byteOffset, t.byteLength))
                    : M(t) && (t = k.from(t)),
                  (e.buffers = null),
                  (e.nread = 0),
                  (e.cb = n),
                  e.on("data", zlibBufferOnData),
                  e.on("error", zlibBufferOnError),
                  e.on("end", zlibBufferOnEnd),
                  e.end(t);
              })(new e(n), t, i)
            );
          };
    }
    B(Zlib.prototype, ZlibBase.prototype),
      B(Zlib, ZlibBase),
      (Zlib.prototype.params = function params(e, t, n) {
        ze(e, "level", ne, ie),
          ze(t, "strategy", ae, ce),
          this._level !== e || this._strategy !== t
            ? this.flush($, u(paramsAfterFlushCallback, this, e, t, n))
            : i.nextTick(n);
      }),
      B(Deflate.prototype, Zlib.prototype),
      B(Deflate, Zlib),
      B(Inflate.prototype, Zlib.prototype),
      B(Inflate, Zlib),
      B(Gzip.prototype, Zlib.prototype),
      B(Gzip, Zlib),
      B(Gunzip.prototype, Zlib.prototype),
      B(Gunzip, Zlib),
      B(DeflateRaw.prototype, Zlib.prototype),
      B(DeflateRaw, Zlib),
      B(InflateRaw.prototype, Zlib.prototype),
      B(InflateRaw, Zlib),
      B(Unzip.prototype, Zlib.prototype),
      B(Unzip, Zlib);
    const Te = c(a(d(H), (e) => (R(e, "BROTLI_PARAM_") ? H[e] : 0))),
      Ne = new Z(Te + 1),
      Ue = { flush: Oe, finishFlush: Ze, fullFlush: Ee };
    function Brotli(e, t) {
      U(t === we || t === Re),
        E(Ne, -1),
        e?.params &&
          l(d(e.params), (t) => {
            const n = +t;
            if (p(n) || n < 0 || n > Te || -1 != (0 | Ne[n])) throw new I(t);
            const i = e.params[t];
            if ("number" != typeof i && "boolean" != typeof i)
              throw new D("options.params[key]", "number", e.params[t]);
            Ne[n] = i;
          });
      const n = t === we ? new N.BrotliDecoder(t) : new N.BrotliEncoder(t);
      if (
        ((this._writeState = new Z(2)),
        !n.init(Ne, this._writeState, processCallback))
      )
        throw new F();
      w(ZlibBase, this, [e, t, n, Ue]);
    }
    function BrotliCompress(e) {
      if (!(this instanceof BrotliCompress)) return new BrotliCompress(e);
      w(Brotli, this, [e, Re]);
    }
    function BrotliDecompress(e) {
      if (!(this instanceof BrotliDecompress)) return new BrotliDecompress(e);
      w(Brotli, this, [e, we]);
    }
    function createProperty(e) {
      return {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        value: function (t) {
          return new e(t);
        },
      };
    }
    B(Brotli.prototype, Zlib.prototype),
      B(Brotli, Zlib),
      B(BrotliCompress.prototype, Brotli.prototype),
      B(BrotliCompress, Brotli),
      B(BrotliDecompress.prototype, Brotli.prototype),
      B(BrotliDecompress, Brotli),
      b(N.Zlib.prototype, "jsref", {
        __proto__: null,
        get() {
          return this[G];
        },
        set(e) {
          return (this[G] = e);
        },
      }),
      (n.exports = {
        Deflate: Deflate,
        Inflate: Inflate,
        Gzip: Gzip,
        Gunzip: Gunzip,
        DeflateRaw: DeflateRaw,
        InflateRaw: InflateRaw,
        Unzip: Unzip,
        BrotliCompress: BrotliCompress,
        BrotliDecompress: BrotliDecompress,
        deflate: createConvenienceMethod(Deflate, !1),
        deflateSync: createConvenienceMethod(Deflate, !0),
        gzip: createConvenienceMethod(Gzip, !1),
        gzipSync: createConvenienceMethod(Gzip, !0),
        deflateRaw: createConvenienceMethod(DeflateRaw, !1),
        deflateRawSync: createConvenienceMethod(DeflateRaw, !0),
        unzip: createConvenienceMethod(Unzip, !1),
        unzipSync: createConvenienceMethod(Unzip, !0),
        inflate: createConvenienceMethod(Inflate, !1),
        inflateSync: createConvenienceMethod(Inflate, !0),
        gunzip: createConvenienceMethod(Gunzip, !1),
        gunzipSync: createConvenienceMethod(Gunzip, !0),
        inflateRaw: createConvenienceMethod(InflateRaw, !1),
        inflateRawSync: createConvenienceMethod(InflateRaw, !0),
        brotliCompress: createConvenienceMethod(BrotliCompress, !1),
        brotliCompressSync: createConvenienceMethod(BrotliCompress, !0),
        brotliDecompress: createConvenienceMethod(BrotliDecompress, !1),
        brotliDecompressSync: createConvenienceMethod(BrotliDecompress, !0),
      }),
      _(n.exports, {
        createDeflate: createProperty(Deflate),
        createInflate: createProperty(Inflate),
        createDeflateRaw: createProperty(DeflateRaw),
        createInflateRaw: createProperty(InflateRaw),
        createGzip: createProperty(Gzip),
        createGunzip: createProperty(Gunzip),
        createUnzip: createProperty(Unzip),
        createBrotliCompress: createProperty(BrotliCompress),
        createBrotliDecompress: createProperty(BrotliDecompress),
        constants: {
          __proto__: null,
          configurable: !1,
          enumerable: !0,
          value: H,
        },
        codes: { __proto__: null, enumerable: !0, writable: !1, value: y(me) },
      });
    for (const e of d(H))
      R(e, "BROTLI") ||
        b(n.exports, e, {
          __proto__: null,
          enumerable: !1,
          value: H[e],
          writable: !1,
        });
  },
};
exports.locationData = [
  "_http_agent",
  1,
  15,
  1,
  7223,
  "_http_client",
  2,
  16,
  2,
  12659,
  "_http_common",
  3,
  16,
  3,
  2764,
  "_http_incoming",
  4,
  18,
  4,
  6233,
  "_http_outgoing",
  5,
  18,
  5,
  15529,
  "_http_server",
  6,
  16,
  6,
  17562,
  "_stream_duplex",
  7,
  18,
  7,
  90,
  "_stream_passthrough",
  8,
  23,
  8,
  100,
  "_stream_readable",
  9,
  20,
  9,
  94,
  "_stream_transform",
  10,
  21,
  10,
  96,
  "_stream_wrap",
  11,
  16,
  11,
  187,
  "_stream_writable",
  12,
  20,
  12,
  94,
  "_tls_common",
  13,
  15,
  13,
  1726,
  "_tls_wrap",
  14,
  13,
  14,
  25414,
  "assert",
  15,
  10,
  15,
  11596,
  "assert/strict",
  16,
  17,
  16,
  89,
  "async_hooks",
  17,
  15,
  17,
  4297,
  "buffer",
  18,
  10,
  18,
  16436,
  "child_process",
  19,
  17,
  19,
  10372,
  "cluster",
  20,
  11,
  20,
  178,
  "console",
  21,
  11,
  21,
  93,
  "constants",
  22,
  13,
  22,
  186,
  "crypto",
  23,
  10,
  23,
  4820,
  "dgram",
  24,
  9,
  24,
  12605,
  "diagnostics_channel",
  25,
  23,
  25,
  4830,
  "dns",
  26,
  7,
  26,
  4160,
  "dns/promises",
  27,
  16,
  27,
  96,
  "domain",
  28,
  10,
  28,
  5705,
  "events",
  29,
  10,
  29,
  13917,
  "fs",
  30,
  6,
  30,
  26812,
  "fs/promises",
  31,
  15,
  31,
  102,
  "http",
  32,
  8,
  32,
  1212,
  "http2",
  33,
  9,
  33,
  462,
  "https",
  34,
  9,
  34,
  4247,
  "inspector",
  35,
  13,
  35,
  1994,
  "internal/abort_controller",
  36,
  29,
  36,
  5564,
  "internal/assert",
  37,
  19,
  37,
  283,
  "internal/assert/assertion_error",
  38,
  35,
  38,
  5792,
  "internal/assert/calltracker",
  39,
  31,
  39,
  1726,
  "internal/async_hooks",
  40,
  24,
  40,
  6464,
  "internal/blob",
  41,
  17,
  41,
  4109,
  "internal/blocklist",
  42,
  22,
  42,
  1944,
  "internal/bootstrap/browser",
  43,
  30,
  43,
  2249,
  "internal/bootstrap/node",
  44,
  27,
  44,
  4557,
  "internal/bootstrap/realm",
  45,
  28,
  45,
  4501,
  "internal/bootstrap/switches/does_not_own_process_state",
  46,
  58,
  46,
  684,
  "internal/bootstrap/switches/does_own_process_state",
  47,
  54,
  47,
  1567,
  "internal/bootstrap/switches/is_main_thread",
  48,
  46,
  48,
  3379,
  "internal/bootstrap/switches/is_not_main_thread",
  49,
  50,
  49,
  745,
  "internal/buffer",
  50,
  19,
  50,
  15407,
  "internal/child_process",
  51,
  26,
  51,
  13003,
  "internal/child_process/serialization",
  52,
  40,
  52,
  1940,
  "internal/cli_table",
  53,
  22,
  53,
  855,
  "internal/cluster/child",
  54,
  26,
  54,
  3289,
  "internal/cluster/primary",
  55,
  28,
  55,
  4496,
  "internal/cluster/round_robin_handle",
  56,
  39,
  56,
  1952,
  "internal/cluster/shared_handle",
  57,
  34,
  57,
  734,
  "internal/cluster/utils",
  58,
  26,
  58,
  499,
  "internal/cluster/worker",
  59,
  27,
  59,
  899,
  "internal/console/constructor",
  60,
  32,
  60,
  8499,
  "internal/console/global",
  61,
  27,
  61,
  482,
  "internal/constants",
  62,
  22,
  62,
  994,
  "internal/crypto/aes",
  63,
  23,
  63,
  4460,
  "internal/crypto/certificate",
  64,
  31,
  64,
  747,
  "internal/crypto/cfrg",
  65,
  24,
  65,
  4446,
  "internal/crypto/cipher",
  66,
  26,
  66,
  5021,
  "internal/crypto/diffiehellman",
  67,
  33,
  67,
  5666,
  "internal/crypto/ec",
  68,
  22,
  68,
  3889,
  "internal/crypto/hash",
  69,
  24,
  69,
  2431,
  "internal/crypto/hashnames",
  70,
  29,
  70,
  916,
  "internal/crypto/hkdf",
  71,
  24,
  71,
  1843,
  "internal/crypto/keygen",
  72,
  26,
  72,
  5026,
  "internal/crypto/keys",
  73,
  24,
  73,
  9660,
  "internal/crypto/mac",
  74,
  23,
  74,
  2351,
  "internal/crypto/pbkdf2",
  75,
  26,
  75,
  1721,
  "internal/crypto/random",
  76,
  26,
  76,
  6425,
  "internal/crypto/rsa",
  77,
  23,
  77,
  4252,
  "internal/crypto/scrypt",
  78,
  26,
  78,
  1734,
  "internal/crypto/sig",
  79,
  23,
  79,
  3303,
  "internal/crypto/util",
  80,
  24,
  80,
  7754,
  "internal/crypto/webcrypto",
  81,
  29,
  81,
  16511,
  "internal/crypto/webidl",
  82,
  26,
  82,
  9339,
  "internal/crypto/x509",
  83,
  24,
  83,
  5198,
  "internal/debugger/inspect",
  84,
  29,
  84,
  5045,
  "internal/debugger/inspect_client",
  85,
  36,
  85,
  4374,
  "internal/debugger/inspect_repl",
  86,
  34,
  86,
  17971,
  "internal/deps/acorn/acorn-walk/dist/walk",
  87,
  44,
  87,
  7576,
  "internal/deps/acorn/acorn/dist/acorn",
  88,
  40,
  88,
  110761,
  "internal/deps/cjs-module-lexer/dist/lexer",
  89,
  45,
  89,
  33672,
  "internal/deps/cjs-module-lexer/lexer",
  90,
  40,
  90,
  22459,
  "internal/deps/minimatch/index",
  91,
  33,
  91,
  26289,
  "internal/deps/undici/undici",
  92,
  31,
  92,
  355574,
  "internal/dgram",
  93,
  18,
  93,
  924,
  "internal/dns/callback_resolver",
  94,
  34,
  94,
  1376,
  "internal/dns/promises",
  95,
  25,
  95,
  4496,
  "internal/dns/utils",
  96,
  22,
  96,
  4988,
  "internal/dtrace",
  97,
  19,
  97,
  523,
  "internal/encoding",
  98,
  21,
  98,
  10200,
  "internal/error_serdes",
  99,
  25,
  99,
  2685,
  "internal/errors",
  100,
  19,
  100,
  37315,
  "internal/event_target",
  101,
  25,
  101,
  12580,
  "internal/file",
  102,
  17,
  102,
  932,
  "internal/fixed_queue",
  103,
  24,
  103,
  781,
  "internal/freelist",
  104,
  21,
  104,
  325,
  "internal/freeze_intrinsics",
  105,
  30,
  105,
  4273,
  "internal/fs/cp/cp",
  106,
  21,
  106,
  5222,
  "internal/fs/cp/cp-sync",
  107,
  26,
  107,
  4637,
  "internal/fs/dir",
  108,
  19,
  108,
  3507,
  "internal/fs/promises",
  109,
  24,
  109,
  12847,
  "internal/fs/read_file_context",
  110,
  33,
  110,
  1529,
  "internal/fs/recursive_watch",
  111,
  31,
  111,
  3397,
  "internal/fs/rimraf",
  112,
  22,
  112,
  2845,
  "internal/fs/streams",
  113,
  23,
  113,
  6713,
  "internal/fs/sync_write_stream",
  114,
  33,
  114,
  753,
  "internal/fs/utils",
  115,
  21,
  115,
  12110,
  "internal/fs/watchers",
  116,
  24,
  116,
  4559,
  "internal/heap_utils",
  117,
  23,
  117,
  467,
  "internal/histogram",
  118,
  22,
  118,
  4372,
  "internal/http",
  119,
  17,
  119,
  773,
  "internal/http2/compat",
  120,
  25,
  120,
  10446,
  "internal/http2/core",
  121,
  23,
  121,
  39743,
  "internal/http2/util",
  122,
  23,
  122,
  7576,
  "internal/idna",
  123,
  17,
  123,
  132,
  "internal/inspector_async_hook",
  124,
  33,
  124,
  855,
  "internal/js_stream_socket",
  125,
  29,
  125,
  2728,
  "internal/legacy/processbinding",
  126,
  34,
  126,
  492,
  "internal/linkedlist",
  127,
  23,
  127,
  561,
  "internal/main/check_syntax",
  128,
  30,
  128,
  1360,
  "internal/main/environment",
  129,
  29,
  129,
  172,
  "internal/main/eval_stdin",
  130,
  28,
  130,
  501,
  "internal/main/eval_string",
  131,
  29,
  131,
  608,
  "internal/main/inspect",
  132,
  25,
  132,
  227,
  "internal/main/mksnapshot",
  133,
  28,
  133,
  1780,
  "internal/main/print_help",
  134,
  28,
  134,
  4690,
  "internal/main/prof_process",
  135,
  30,
  135,
  205,
  "internal/main/repl",
  136,
  22,
  136,
  872,
  "internal/main/run_main_module",
  137,
  33,
  137,
  408,
  "internal/main/single_executable_application",
  138,
  47,
  138,
  745,
  "internal/main/test_runner",
  139,
  29,
  139,
  1141,
  "internal/main/watch_mode",
  140,
  28,
  140,
  2280,
  "internal/main/worker_thread",
  141,
  31,
  141,
  3135,
  "internal/mime",
  142,
  17,
  142,
  3481,
  "internal/modules/cjs/loader",
  143,
  31,
  143,
  16604,
  "internal/modules/esm/assert",
  144,
  31,
  144,
  987,
  "internal/modules/esm/create_dynamic_module",
  145,
  46,
  145,
  1146,
  "internal/modules/esm/fetch_module",
  146,
  37,
  146,
  2859,
  "internal/modules/esm/formats",
  147,
  32,
  147,
  1037,
  "internal/modules/esm/get_format",
  148,
  35,
  148,
  2131,
  "internal/modules/esm/handle_process_exit",
  149,
  44,
  149,
  163,
  "internal/modules/esm/hooks",
  150,
  30,
  150,
  9013,
  "internal/modules/esm/initialize_import_meta",
  151,
  47,
  151,
  579,
  "internal/modules/esm/load",
  152,
  29,
  152,
  2015,
  "internal/modules/esm/loader",
  153,
  31,
  153,
  5375,
  "internal/modules/esm/module_job",
  154,
  35,
  154,
  3190,
  "internal/modules/esm/module_map",
  155,
  35,
  155,
  1236,
  "internal/modules/esm/package_config",
  156,
  39,
  156,
  639,
  "internal/modules/esm/resolve",
  157,
  32,
  157,
  13767,
  "internal/modules/esm/shared_constants",
  158,
  41,
  158,
  161,
  "internal/modules/esm/translators",
  159,
  36,
  159,
  5232,
  "internal/modules/esm/utils",
  160,
  30,
  160,
  2223,
  "internal/modules/esm/worker",
  161,
  31,
  161,
  2598,
  "internal/modules/helpers",
  162,
  28,
  162,
  3350,
  "internal/modules/package_json_reader",
  163,
  40,
  163,
  1657,
  "internal/modules/run_main",
  164,
  29,
  164,
  1696,
  "internal/net",
  165,
  16,
  165,
  1162,
  "internal/options",
  166,
  20,
  166,
  957,
  "internal/per_context/domexception",
  167,
  37,
  167,
  2846,
  "internal/per_context/messageport",
  168,
  36,
  168,
  574,
  "internal/per_context/primordials",
  169,
  36,
  169,
  7788,
  "internal/perf/event_loop_delay",
  170,
  34,
  170,
  931,
  "internal/perf/event_loop_utilization",
  171,
  40,
  171,
  511,
  "internal/perf/nodetiming",
  172,
  28,
  172,
  1898,
  "internal/perf/observe",
  173,
  25,
  173,
  6387,
  "internal/perf/performance",
  174,
  29,
  174,
  3182,
  "internal/perf/performance_entry",
  175,
  35,
  175,
  1170,
  "internal/perf/resource_timing",
  176,
  33,
  176,
  2939,
  "internal/perf/timerify",
  177,
  26,
  177,
  1237,
  "internal/perf/usertiming",
  178,
  28,
  178,
  2504,
  "internal/perf/utils",
  179,
  23,
  179,
  359,
  "internal/policy/manifest",
  180,
  28,
  180,
  6336,
  "internal/policy/sri",
  181,
  23,
  181,
  838,
  "internal/priority_queue",
  182,
  27,
  182,
  937,
  "internal/process/esm_loader",
  183,
  31,
  183,
  646,
  "internal/process/execution",
  184,
  30,
  184,
  2848,
  "internal/process/per_thread",
  185,
  31,
  185,
  4564,
  "internal/process/policy",
  186,
  27,
  186,
  757,
  "internal/process/pre_execution",
  187,
  34,
  187,
  9025,
  "internal/process/promises",
  188,
  29,
  188,
  4246,
  "internal/process/report",
  189,
  27,
  189,
  1634,
  "internal/process/signal",
  190,
  27,
  190,
  661,
  "internal/process/task_queues",
  191,
  32,
  191,
  2080,
  "internal/process/warning",
  192,
  28,
  192,
  2563,
  "internal/process/worker_thread_only",
  193,
  39,
  193,
  307,
  "internal/promise_hooks",
  194,
  26,
  194,
  1475,
  "internal/querystring",
  195,
  24,
  195,
  1393,
  "internal/readline/callbacks",
  196,
  31,
  196,
  1273,
  "internal/readline/emitKeypressEvents",
  197,
  40,
  197,
  1142,
  "internal/readline/interface",
  198,
  31,
  198,
  15249,
  "internal/readline/promises",
  199,
  30,
  199,
  1287,
  "internal/readline/utils",
  200,
  27,
  200,
  4199,
  "internal/repl",
  201,
  17,
  201,
  759,
  "internal/repl/await",
  202,
  23,
  202,
  3589,
  "internal/repl/history",
  203,
  25,
  203,
  2119,
  "internal/repl/utils",
  204,
  23,
  204,
  3943,
  "internal/socket_list",
  205,
  24,
  205,
  1629,
  "internal/socketaddress",
  206,
  26,
  206,
  2049,
  "internal/source_map/prepare_stack_trace",
  207,
  43,
  207,
  2496,
  "internal/source_map/source_map",
  208,
  34,
  208,
  2570,
  "internal/source_map/source_map_cache",
  209,
  40,
  209,
  3892,
  "internal/stream_base_commons",
  210,
  32,
  210,
  3236,
  "internal/streams/add-abort-signal",
  211,
  37,
  211,
  879,
  "internal/streams/buffer_list",
  212,
  32,
  212,
  1890,
  "internal/streams/compose",
  213,
  28,
  213,
  2202,
  "internal/streams/destroy",
  214,
  28,
  214,
  3285,
  "internal/streams/duplex",
  215,
  27,
  215,
  2136,
  "internal/streams/duplexify",
  216,
  30,
  216,
  3891,
  "internal/streams/end-of-stream",
  217,
  34,
  217,
  3465,
  "internal/streams/from",
  218,
  25,
  218,
  1115,
  "internal/streams/lazy_transform",
  219,
  35,
  219,
  989,
  "internal/streams/legacy",
  220,
  27,
  220,
  1431,
  "internal/streams/operators",
  221,
  30,
  221,
  5224,
  "internal/streams/passthrough",
  222,
  32,
  222,
  382,
  "internal/streams/pipeline",
  223,
  29,
  223,
  4723,
  "internal/streams/readable",
  224,
  29,
  224,
  16727,
  "internal/streams/state",
  225,
  26,
  225,
  720,
  "internal/streams/transform",
  226,
  30,
  226,
  1462,
  "internal/streams/utils",
  227,
  26,
  227,
  5291,
  "internal/streams/writable",
  228,
  29,
  228,
  10401,
  "internal/structured_clone",
  229,
  29,
  229,
  413,
  "internal/test/binding",
  230,
  25,
  230,
  288,
  "internal/test/transfer",
  231,
  26,
  231,
  460,
  "internal/test_runner/coverage",
  232,
  33,
  232,
  5624,
  "internal/test_runner/harness",
  233,
  32,
  233,
  3580,
  "internal/test_runner/mock/mock",
  234,
  34,
  234,
  3910,
  "internal/test_runner/mock/mock_timers",
  235,
  41,
  235,
  4914,
  "internal/test_runner/reporter/dot",
  236,
  37,
  236,
  388,
  "internal/test_runner/reporter/junit",
  237,
  39,
  237,
  2881,
  "internal/test_runner/reporter/spec",
  238,
  38,
  238,
  2866,
  "internal/test_runner/reporter/tap",
  239,
  37,
  239,
  3581,
  "internal/test_runner/reporter/v8-serializer",
  240,
  47,
  240,
  621,
  "internal/test_runner/runner",
  241,
  31,
  241,
  8286,
  "internal/test_runner/test",
  242,
  29,
  242,
  13130,
  "internal/test_runner/tests_stream",
  243,
  37,
  243,
  1480,
  "internal/test_runner/utils",
  244,
  30,
  244,
  6054,
  "internal/timers",
  245,
  19,
  245,
  5756,
  "internal/tls/secure-context",
  246,
  31,
  246,
  3498,
  "internal/tls/secure-pair",
  247,
  28,
  247,
  1129,
  "internal/trace_events_async_hooks",
  248,
  37,
  248,
  828,
  "internal/tty",
  249,
  16,
  249,
  2096,
  "internal/url",
  250,
  16,
  250,
  16793,
  "internal/util",
  251,
  17,
  251,
  10693,
  "internal/util/colors",
  252,
  24,
  252,
  653,
  "internal/util/comparisons",
  253,
  29,
  253,
  6097,
  "internal/util/debuglog",
  254,
  26,
  254,
  1601,
  "internal/util/inspect",
  255,
  25,
  255,
  30877,
  "internal/util/inspector",
  256,
  27,
  256,
  1689,
  "internal/util/iterable_weak_map",
  257,
  35,
  257,
  937,
  "internal/util/parse_args/parse_args",
  258,
  39,
  258,
  4178,
  "internal/util/parse_args/utils",
  259,
  34,
  259,
  1550,
  "internal/util/types",
  260,
  23,
  260,
  1351,
  "internal/v8/startup_snapshot",
  261,
  32,
  261,
  1464,
  "internal/v8_prof_polyfill",
  262,
  29,
  262,
  2037,
  "internal/v8_prof_processor",
  263,
  30,
  263,
  872,
  "internal/validators",
  264,
  23,
  264,
  4989,
  "internal/vm",
  265,
  15,
  265,
  1569,
  "internal/vm/module",
  266,
  22,
  266,
  5968,
  "internal/wasm_web_api",
  267,
  25,
  267,
  801,
  "internal/watch_mode/files_watcher",
  268,
  37,
  268,
  2180,
  "internal/watchdog",
  269,
  21,
  269,
  816,
  "internal/webidl",
  270,
  19,
  270,
  1129,
  "internal/webstreams/adapters",
  271,
  32,
  271,
  8028,
  "internal/webstreams/compression",
  272,
  35,
  272,
  2069,
  "internal/webstreams/encoding",
  273,
  32,
  273,
  2894,
  "internal/webstreams/queuingstrategies",
  274,
  41,
  274,
  1861,
  "internal/webstreams/readablestream",
  275,
  38,
  275,
  46793,
  "internal/webstreams/transfer",
  276,
  32,
  276,
  4126,
  "internal/webstreams/transformstream",
  277,
  39,
  277,
  7504,
  "internal/webstreams/util",
  278,
  28,
  278,
  3644,
  "internal/webstreams/writablestream",
  279,
  38,
  279,
  22439,
  "internal/worker",
  280,
  19,
  280,
  8218,
  "internal/worker/io",
  281,
  22,
  281,
  7706,
  "internal/worker/js_transferable",
  282,
  35,
  282,
  911,
  "module",
  283,
  10,
  283,
  315,
  "net",
  284,
  7,
  284,
  28964,
  "os",
  285,
  6,
  285,
  3455,
  "path",
  286,
  8,
  286,
  10062,
  "path/posix",
  287,
  14,
  287,
  83,
  "path/win32",
  288,
  14,
  288,
  83,
  "perf_hooks",
  289,
  14,
  289,
  840,
  "process",
  290,
  11,
  290,
  66,
  "punycode",
  291,
  12,
  291,
  2729,
  "querystring",
  292,
  15,
  292,
  4368,
  "readline",
  293,
  12,
  293,
  6287,
  "readline/promises",
  294,
  21,
  294,
  854,
  "repl",
  295,
  8,
  295,
  23029,
  "stream",
  296,
  10,
  296,
  2151,
  "stream/consumers",
  297,
  20,
  297,
  669,
  "stream/promises",
  298,
  19,
  298,
  518,
  "stream/web",
  299,
  14,
  299,
  1189,
  "string_decoder",
  300,
  18,
  300,
  1542,
  "sys",
  301,
  7,
  301,
  155,
  "test",
  302,
  8,
  302,
  507,
  "test/reporters",
  303,
  18,
  303,
  620,
  "timers",
  304,
  10,
  304,
  3209,
  "timers/promises",
  305,
  19,
  305,
  2752,
  "tls",
  306,
  7,
  306,
  4139,
  "trace_events",
  307,
  16,
  307,
  1270,
  "tty",
  308,
  7,
  308,
  2239,
  "url",
  309,
  7,
  309,
  10868,
  "util",
  310,
  8,
  310,
  3943,
  "util/types",
  311,
  14,
  311,
  92,
  "v8",
  312,
  6,
  312,
  5103,
  "vm",
  313,
  6,
  313,
  5037,
  "wasi",
  314,
  8,
  314,
  1857,
  "worker_threads",
  315,
  18,
  315,
  640,
  "zlib",
  316,
  8,
  316,
  12714,
];
//# sourceMappingURL=builtins.1003299b.js.map
